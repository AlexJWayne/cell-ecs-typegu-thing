{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import type * as acorn from 'acorn';\nimport defu from 'defu';\nimport { type Node, walk } from 'estree-walker';\nimport { generateTransform, MagicStringAST } from 'magic-string-ast';\nimport { FORMAT_VERSION } from 'tinyest';\nimport { transpileFn } from 'tinyest-for-wgsl';\nimport { createUnplugin, type UnpluginInstance } from 'unplugin';\nimport babel from './babel.ts';\nimport {\n  type Context,\n  defaultOptions,\n  embedJSON,\n  gatherTgpuAliases,\n  isShellImplementationCall,\n  kernelDirective,\n  type Options,\n  performExpressionNaming,\n} from './common.ts';\n\ntype FunctionNode =\n  | acorn.FunctionDeclaration\n  | acorn.AnonymousFunctionDeclaration\n  | acorn.FunctionExpression\n  | acorn.ArrowFunctionExpression;\n\nfunction containsKernelDirective(node: FunctionNode): boolean {\n  if (node.body.type === 'BlockStatement') {\n    for (const statement of node.body.body) {\n      if (\n        statement.type === 'ExpressionStatement' &&\n        statement.directive === kernelDirective\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nfunction removeKernelDirective(node: FunctionNode) {\n  const cloned = structuredClone(node);\n\n  if (cloned.body.type === 'BlockStatement') {\n    cloned.body.body = cloned.body.body.filter(\n      (statement) =>\n        !(\n          statement.type === 'ExpressionStatement' &&\n          statement.directive === kernelDirective\n        ),\n    );\n  }\n\n  return cloned;\n}\n\nfunction assignMetadata(\n  magicString: MagicStringAST,\n  node: acorn.AnyNode,\n  metadata: string,\n) {\n  magicString.prependLeft(\n    node.start,\n    '(($ => (globalThis.__TYPEGPU_META__ ??= new WeakMap()).set($.f = (',\n  ).appendRight(\n    node.end,\n    `), ${metadata}) && $.f)({}))`,\n  );\n}\n\nfunction wrapInAutoName(\n  magicString: MagicStringAST,\n  node: acorn.Node,\n  name: string,\n) {\n  magicString\n    .prependLeft(\n      node.start,\n      '((globalThis.__TYPEGPU_AUTONAME__ ?? (a => a))(',\n    )\n    .appendRight(node.end, `, \"${name}\"))`);\n}\n\nconst typegpu: UnpluginInstance<Options, false> = createUnplugin(\n  (rawOptions) => {\n    const options = defu(rawOptions, defaultOptions);\n\n    return {\n      name: 'unplugin-typegpu' as const,\n      enforce: options.enforce,\n      transform: {\n        filter: {\n          id: options,\n        },\n        handler(code, id) {\n          const ctx: Context = {\n            tgpuAliases: new Set<string>(\n              options.forceTgpuAlias ? [options.forceTgpuAlias] : [],\n            ),\n            fileId: id,\n            autoNamingEnabled: options.autoNamingEnabled,\n          };\n\n          const ast = this.parse(code, {\n            allowReturnOutsideFunction: true,\n          }) as Node;\n\n          const tgslFunctionDefs: {\n            def: FunctionNode;\n            name?: string | undefined;\n          }[] = [];\n\n          const magicString = new MagicStringAST(code);\n\n          walk(ast, {\n            enter(_node, _parent, prop, index) {\n              const node = _node as acorn.AnyNode;\n\n              performExpressionNaming(ctx, node, (node, name) => {\n                wrapInAutoName(magicString, node, name);\n              });\n\n              if (node.type === 'ImportDeclaration') {\n                gatherTgpuAliases(node, ctx);\n              }\n\n              if (node.type === 'CallExpression') {\n                if (isShellImplementationCall(node, ctx)) {\n                  const implementation = node.arguments[0];\n\n                  if (\n                    implementation &&\n                    (implementation.type === 'FunctionExpression' ||\n                      implementation.type === 'ArrowFunctionExpression')\n                  ) {\n                    tgslFunctionDefs.push({\n                      def: removeKernelDirective(implementation),\n                    });\n                    this.skip();\n                  }\n                }\n              }\n\n              if (\n                node.type === 'ArrowFunctionExpression' ||\n                node.type === 'FunctionExpression' ||\n                node.type === 'FunctionDeclaration'\n              ) {\n                if (containsKernelDirective(node)) {\n                  tgslFunctionDefs.push({\n                    def: removeKernelDirective(node),\n                    name: node.type === 'FunctionDeclaration' ||\n                        node.type === 'FunctionExpression'\n                      ? node.id?.name\n                      : _parent?.type === 'VariableDeclarator'\n                      ? _parent.id.type === 'Identifier'\n                        ? _parent.id.name\n                        : undefined\n                      : undefined,\n                  });\n                  this.skip();\n                }\n              }\n            },\n          });\n\n          for (\n            const {\n              def,\n              name,\n            } of tgslFunctionDefs\n          ) {\n            const { params, body, externalNames } = transpileFn(def);\n            const isFunctionStatement = def.type === 'FunctionDeclaration';\n\n            if (\n              isFunctionStatement &&\n              name &&\n              code\n                  .slice(0, def.start)\n                  .search(new RegExp(`(?<![\\\\w_.])${name}(?![\\\\w_])`)) !== -1\n            ) {\n              console.warn(\n                `File ${id}: function \"${name}\" might have been referenced before its usage. Function statements are no longer hoisted after being transformed by the plugin.`,\n              );\n            }\n\n            const metadata = `{\n              v: ${FORMAT_VERSION},\n              ast: ${embedJSON({ params, body, externalNames })},\n              externals: {${externalNames.join(', ')}},\n            }`;\n\n            assignMetadata(magicString, def, metadata);\n\n            if (isFunctionStatement && name) {\n              magicString.prependLeft(def.start, `const ${name} = `);\n            }\n          }\n\n          return generateTransform(magicString, id);\n        },\n      },\n    };\n  },\n);\n\nexport type { Options } from './common.ts';\n\nexport default typegpu;\n\nexport const vitePlugin = typegpu.vite;\nexport const rollupPlugin = typegpu.rollup;\nexport const rolldownPlugin = typegpu.rolldown;\nexport const webpackPlugin = typegpu.webpack;\nexport const rspackPlugin = typegpu.rspack;\nexport const esbuildPlugin = typegpu.esbuild;\nexport const farmPlugin = typegpu.farm;\nexport const babelPlugin = babel;\n"],"mappings":"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","names":["defu","walk","generateTransform","MagicStringAST","FORMAT_VERSION","transpileFn","createUnplugin","containsKernelDirective","node","statement","kernelDirective","removeKernelDirective","cloned","assignMetadata","magicString","metadata","wrapInAutoName","name","typegpu","createUnplugin","rawOptions","options","defu","defaultOptions","code","id","ctx","ast","tgslFunctionDefs","MagicStringAST","walk","_node","_parent","prop","index","_a","performExpressionNaming","gatherTgpuAliases","isShellImplementationCall","implementation","def","params","body","externalNames","transpileFn","isFunctionStatement","FORMAT_VERSION","embedJSON","generateTransform","index_default","vitePlugin","rollupPlugin","rolldownPlugin","webpackPlugin","rspackPlugin","esbuildPlugin","farmPlugin","babelPlugin","babel_default"]}