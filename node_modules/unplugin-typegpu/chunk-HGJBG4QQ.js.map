{"version":3,"sources":["../src/babel.ts","../src/common.ts","../src/filter.ts"],"sourcesContent":["import * as Babel from '@babel/standalone';\nimport type TemplateGenerator from '@babel/template';\nimport type { TraverseOptions } from '@babel/traverse';\nimport type * as babel from '@babel/types';\nimport { FORMAT_VERSION } from 'tinyest';\nimport { transpileFn } from 'tinyest-for-wgsl';\nimport {\n  type Context,\n  embedJSON,\n  gatherTgpuAliases,\n  isShellImplementationCall,\n  kernelDirective,\n  type Options,\n  performExpressionNaming,\n} from './common.ts';\nimport { createFilterForId } from './filter.ts';\n\n// NOTE: @babel/standalone does expose internal packages, as specified in the docs, but the\n// typing for @babel/standalone does not expose them.\nconst template = (\n  Babel as unknown as { packages: { template: typeof TemplateGenerator } }\n).packages.template;\nconst types = (Babel as unknown as { packages: { types: typeof babel } })\n  .packages.types;\n\nfunction containsKernelDirective(\n  node:\n    | babel.FunctionDeclaration\n    | babel.FunctionExpression\n    | babel.ArrowFunctionExpression,\n): boolean {\n  return ((\n    'directives' in node.body ? (node.body?.directives ?? []) : []\n  )\n    .map((directive) => directive.value.value))\n    .includes(kernelDirective);\n}\n\nfunction i(identifier: string): babel.Identifier {\n  return types.identifier(identifier);\n}\n\nfunction functionToTranspiled(\n  node: babel.ArrowFunctionExpression | babel.FunctionExpression,\n): babel.CallExpression {\n  const { params, body, externalNames } = transpileFn(node);\n\n  const metadata = `{\n    v: ${FORMAT_VERSION},\n    ast: ${embedJSON({ params, body, externalNames })},\n    externals: {${externalNames.join(', ')}},\n  }`;\n\n  return types.callExpression(\n    types.arrowFunctionExpression(\n      [i('$')],\n      types.logicalExpression(\n        '&&',\n        types.callExpression(\n          types.memberExpression(\n            types.assignmentExpression(\n              '??=',\n              types.memberExpression(i('globalThis'), i('__TYPEGPU_META__')),\n              types.newExpression(i('WeakMap'), []),\n            ),\n            i('set'),\n          ),\n          [\n            types.assignmentExpression(\n              '=',\n              types.memberExpression(i('$'), i('f')),\n              node,\n            ),\n            template.expression`${metadata}`(),\n          ],\n        ),\n        types.memberExpression(i('$'), i('f')),\n      ),\n    ),\n    [types.objectExpression([])],\n  );\n}\n\nfunction wrapInAutoName(\n  node: babel.Expression,\n  name: string,\n) {\n  return types.callExpression(\n    template.expression('globalThis.__TYPEGPU_AUTONAME__ ?? (a => a)', {\n      placeholderPattern: false,\n    })(),\n    [node, types.stringLiteral(name)],\n  );\n}\n\nfunction functionVisitor(ctx: Context): TraverseOptions {\n  return {\n    VariableDeclarator(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('init').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    AssignmentExpression(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('right').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    ObjectProperty(path) {\n      performExpressionNaming(ctx, path.node, (node, name) => {\n        path.get('value').replaceWith(wrapInAutoName(node, name));\n      });\n    },\n\n    ImportDeclaration(path) {\n      gatherTgpuAliases(path.node, ctx);\n    },\n\n    ArrowFunctionExpression(path) {\n      if (containsKernelDirective(path.node)) {\n        path.replaceWith(functionToTranspiled(path.node));\n        path.skip();\n      }\n    },\n\n    FunctionExpression(path) {\n      if (containsKernelDirective(path.node)) {\n        path.replaceWith(functionToTranspiled(path.node));\n        path.skip();\n      }\n    },\n\n    FunctionDeclaration(path) {\n      const node = path.node;\n      const expression = types.functionExpression(\n        node.id,\n        node.params,\n        node.body,\n      );\n\n      if (containsKernelDirective(path.node) && node.id) {\n        const transpiled = functionToTranspiled(expression);\n        path.replaceWith(\n          types.variableDeclaration('const', [\n            types.variableDeclarator(node.id, transpiled),\n          ]),\n        );\n        path.skip();\n      }\n    },\n\n    CallExpression(path) {\n      const node = path.node;\n\n      if (isShellImplementationCall(node, ctx)) {\n        const implementation = node.arguments[0];\n\n        if (\n          implementation &&\n          (implementation.type === 'FunctionExpression' ||\n            implementation.type === 'ArrowFunctionExpression')\n        ) {\n          const transpiled = functionToTranspiled(\n            implementation,\n          ) as babel.CallExpression;\n\n          path.replaceWith(\n            types.callExpression(node.callee, [\n              transpiled,\n            ]),\n          );\n\n          path.skip();\n        }\n      }\n    },\n  };\n}\n\nexport default function () {\n  return {\n    visitor: {\n      Program(path, state) {\n        // biome-ignore lint/suspicious/noExplicitAny: <oh babel babel...>\n        const code: string | undefined = (state as any).file?.code;\n        // biome-ignore lint/suspicious/noExplicitAny: <oh babel babel...>\n        const options: Options | undefined = (state as any).opts;\n        // biome-ignore lint/suspicious/noExplicitAny: <oh babel babel...>\n        const id: string | undefined = (state as any).filename;\n\n        const filter = createFilterForId(options);\n        if (id && filter && !filter?.(id)) {\n          return;\n        }\n\n        const ctx: Context = {\n          tgpuAliases: new Set<string>(\n            options?.forceTgpuAlias ? [options.forceTgpuAlias] : [],\n          ),\n          fileId: id,\n          autoNamingEnabled: options?.autoNamingEnabled ?? true,\n        };\n\n        path.traverse(functionVisitor(ctx));\n      },\n    } satisfies TraverseOptions,\n  };\n}\n","import type * as babel from '@babel/types';\nimport type * as acorn from 'acorn';\nimport type { FilterPattern } from 'unplugin';\n\nexport type Context = {\n  /**\n   * How the `tgpu` object is used in code. Since it can be aliased, we\n   * need to catch that and act accordingly.\n   */\n  tgpuAliases: Set<string>;\n  fileId?: string | undefined;\n  autoNamingEnabled: boolean;\n};\n\nexport interface Options {\n  include?: FilterPattern;\n  exclude?: FilterPattern;\n  enforce?: 'post' | 'pre' | undefined;\n  forceTgpuAlias?: string;\n  autoNamingEnabled?: boolean;\n}\n\nexport const defaultOptions = {\n  include: [/\\.m?[jt]sx?$/],\n  autoNamingEnabled: true,\n};\n\nexport function embedJSON(jsValue: unknown) {\n  return JSON.stringify(jsValue)\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029');\n}\n\n/**\n * Checks if `node` is an alias for the 'tgpu' object, traditionally\n * available via `import tgpu from 'typegpu'`.\n */\nfunction isTgpu(ctx: Context, node: babel.Node | acorn.AnyNode): boolean {\n  let path = '';\n\n  let tail = node;\n  while (true) {\n    if (tail.type === 'MemberExpression') {\n      if (\n        (tail.property.type === 'Literal' ||\n          tail.property.type === 'StringLiteral') &&\n        tail.property.value === '~unstable'\n      ) {\n        // Bypassing the '~unstable' property.\n        tail = tail.object;\n        continue;\n      }\n\n      if (tail.property.type !== 'Identifier') {\n        // Not handling computed expressions.\n        break;\n      }\n\n      path = path ? `${tail.property.name}.${path}` : tail.property.name;\n      tail = tail.object;\n    } else if (tail.type === 'Identifier') {\n      path = path ? `${tail.name}.${path}` : tail.name;\n      break;\n    } else {\n      break;\n    }\n  }\n\n  return ctx.tgpuAliases.has(path);\n}\n\nexport function gatherTgpuAliases(\n  node: acorn.ImportDeclaration | babel.ImportDeclaration,\n  ctx: Context,\n) {\n  if (node.source.value === 'typegpu') {\n    for (const spec of node.specifiers) {\n      if (\n        // The default export of 'typegpu' is the `tgpu` object.\n        spec.type === 'ImportDefaultSpecifier' ||\n        // Aliasing 'tgpu' while importing, e.g. import { tgpu as t } from 'typegpu';\n        (spec.type === 'ImportSpecifier' &&\n          spec.imported.type === 'Identifier' &&\n          spec.imported.name === 'tgpu')\n      ) {\n        ctx.tgpuAliases.add(spec.local.name);\n      } else if (spec.type === 'ImportNamespaceSpecifier') {\n        // Importing everything, e.g. import * as t from 'typegpu';\n        ctx.tgpuAliases.add(`${spec.local.name}.tgpu`);\n      }\n    }\n  }\n}\n\nconst fnShellFunctionNames = ['fn', 'vertexFn', 'fragmentFn', 'computeFn'];\n\nexport function isShellImplementationCall(\n  node: acorn.CallExpression | babel.CallExpression,\n  ctx: Context,\n) {\n  return (\n    node.callee.type === 'CallExpression' &&\n    node.callee.callee.type === 'MemberExpression' &&\n    node.callee.callee.property.type === 'Identifier' &&\n    fnShellFunctionNames.includes(node.callee.callee.property.name) &&\n    node.arguments.length === 1 && isTgpu(ctx, node.callee.callee.object)\n  );\n}\n\nconst resourceConstructors: string[] = [\n  // tgpu\n  'bindGroupLayout',\n  'vertexLayout',\n  // tgpu['~unstable']\n  'slot',\n  'accessor',\n  'privateVar',\n  'workgroupVar',\n  'const',\n  ...fnShellFunctionNames,\n  // d\n  'struct',\n  'unstruct',\n  // root\n  'createBuffer',\n  'createMutable',\n  'createReadonly',\n  'createUniform',\n  'createQuerySet',\n  // root['~unstable']\n  'createPipeline',\n  'createTexture',\n  'sampler',\n  'comparisonSampler',\n];\n\n/**\n * Checks if `node` should be wrapped in an autoname function.\n * Since it is mostly for debugging and clean WGSL generation,\n * some false positives and false negatives are admissible.\n */\nfunction containsResourceConstructorCall(\n  node: acorn.AnyNode | babel.Node,\n  ctx: Context,\n) {\n  if (node.type === 'CallExpression') {\n    if (isShellImplementationCall(node, ctx)) {\n      return true;\n    }\n    // struct({...})\n    if (\n      node.callee.type === 'Identifier' &&\n      resourceConstructors.includes(node.callee.name)\n    ) {\n      return true;\n    }\n    if (node.callee.type === 'MemberExpression') {\n      if (node.callee.property.type === 'Identifier') {\n        // root.createBuffer({...})\n        if (resourceConstructors.includes(node.callee.property.name)) {\n          return true;\n        }\n        if (node.callee.property.name === '$name') {\n          return false;\n        }\n      }\n      // root.createBuffer(d.f32).$usage('storage')\n      return containsResourceConstructorCall(node.callee.object, ctx);\n    }\n  }\n  if (node.type === 'TaggedTemplateExpression') {\n    return containsResourceConstructorCall(node.tag, ctx);\n  }\n  return false;\n}\n\ntype ExpressionFor<T extends acorn.AnyNode | babel.Node> = T extends\n  acorn.AnyNode ? acorn.Expression : babel.Expression;\n\n/**\n * Checks if `node` contains a label and a tgpu expression that could be named.\n * If so, it calls the provided callback. Nodes selected for naming include:\n *\n * `let name = tgpu.bindGroupLayout({});` (VariableDeclarator)\n *\n * `name = tgpu.bindGroupLayout({});` (AssignmentExpression)\n *\n * `property: tgpu.bindGroupLayout({})` (Property/ObjectProperty)\n *\n * Since it is mostly for debugging and clean WGSL generation,\n * some false positives and false negatives are admissible.\n *\n * @privateRemarks\n * When adding new checks, you need to call this method in the corresponding node in Babel.\n */\nexport function performExpressionNaming<T extends acorn.AnyNode | babel.Node>(\n  ctx: Context,\n  node: T,\n  namingCallback: (node: ExpressionFor<T>, name: string) => void,\n) {\n  if (!ctx.autoNamingEnabled) {\n    return;\n  }\n\n  if (\n    node.type === 'VariableDeclarator' &&\n    node.id.type === 'Identifier' &&\n    node.init &&\n    containsResourceConstructorCall(node.init, ctx)\n  ) {\n    namingCallback(node.init as ExpressionFor<T>, node.id.name);\n  } else if (\n    node.type === 'AssignmentExpression' &&\n    node.left.type === 'Identifier' &&\n    containsResourceConstructorCall(node.right, ctx)\n  ) {\n    namingCallback(node.right as ExpressionFor<T>, node.left.name);\n  } else if (\n    (node.type === 'Property' || node.type === 'ObjectProperty') &&\n    node.key.type === 'Identifier' &&\n    containsResourceConstructorCall(node.value, ctx)\n  ) {\n    namingCallback(node.value as ExpressionFor<T>, node.key.name);\n  }\n}\n\nexport const kernelDirective = 'kernel';\n","// Copied from https://github.com/unjs/unplugin/blob/f514bf8e2d751b48b3a5acb1077eb1292d9711b3/src/utils/filter.ts#L2\n// Used only in the babel version of the plugin, since others can rely on native unplugin functionality.\n\nimport { resolve } from 'node:path';\nimport picomatch from 'picomatch';\nimport type {\n  Arrayable,\n  Nullable,\n  StringFilter,\n  StringOrRegExp,\n} from 'unplugin';\n\nfunction toArray<T>(array?: Nullable<Arrayable<T>>): Array<T> {\n  const result = array || [];\n  if (Array.isArray(result)) return result;\n  return [result];\n}\n\nconst BACKSLASH_REGEX = /\\\\/g;\nfunction normalize(path: string): string {\n  return path.replace(BACKSLASH_REGEX, '/');\n}\n\nconst ABSOLUTE_PATH_REGEX = /^(?:\\/|(?:[A-Z]:)?[/\\\\|])/i;\nfunction isAbsolute(path: string): boolean {\n  return ABSOLUTE_PATH_REGEX.test(path);\n}\n\nexport type PluginFilter = (input: string) => boolean;\nexport type TransformHookFilter = (id: string, code: string) => boolean;\n\ninterface NormalizedStringFilter {\n  include?: StringOrRegExp[] | undefined;\n  exclude?: StringOrRegExp[] | undefined;\n}\n\nfunction getMatcherString(glob: string, cwd: string) {\n  if (glob.startsWith('**') || isAbsolute(glob)) {\n    return normalize(glob);\n  }\n\n  const resolved = resolve(cwd, glob);\n  return normalize(resolved);\n}\n\nfunction patternToIdFilter(pattern: StringOrRegExp): PluginFilter {\n  if (pattern instanceof RegExp) {\n    return (id: string) => {\n      const normalizedId = normalize(id);\n      const result = pattern.test(normalizedId);\n      pattern.lastIndex = 0;\n      return result;\n    };\n  }\n  const cwd = process.cwd();\n  const glob = getMatcherString(pattern, cwd);\n  const matcher = picomatch(glob, { dot: true });\n  return (id: string) => {\n    const normalizedId = normalize(id);\n    return matcher(normalizedId);\n  };\n}\n\nfunction patternToCodeFilter(pattern: StringOrRegExp): PluginFilter {\n  if (pattern instanceof RegExp) {\n    return (code: string) => {\n      const result = pattern.test(code);\n      pattern.lastIndex = 0;\n      return result;\n    };\n  }\n  return (code: string) => code.includes(pattern);\n}\n\nfunction createFilter(\n  exclude: PluginFilter[] | undefined,\n  include: PluginFilter[] | undefined,\n): PluginFilter | undefined {\n  if (!exclude && !include) {\n    return;\n  }\n\n  return (input) => {\n    if (exclude?.some((filter) => filter(input))) {\n      return false;\n    }\n    if (include?.some((filter) => filter(input))) {\n      return true;\n    }\n    return !(include && include.length > 0);\n  };\n}\n\nfunction normalizeFilter(filter: StringFilter): NormalizedStringFilter {\n  if (typeof filter === 'string' || filter instanceof RegExp) {\n    return {\n      include: [filter],\n    };\n  }\n  if (Array.isArray(filter)) {\n    return {\n      include: filter,\n    };\n  }\n  return {\n    exclude: filter.exclude ? toArray(filter.exclude) : undefined,\n    include: filter.include ? toArray(filter.include) : undefined,\n  };\n}\n\nfunction createIdFilter(\n  filter: StringFilter | undefined,\n): PluginFilter | undefined {\n  if (!filter) return;\n  const { exclude, include } = normalizeFilter(filter);\n  const excludeFilter = exclude?.map(patternToIdFilter);\n  const includeFilter = include?.map(patternToIdFilter);\n  return createFilter(excludeFilter, includeFilter);\n}\n\nfunction createCodeFilter(\n  filter: StringFilter | undefined,\n): PluginFilter | undefined {\n  if (!filter) return;\n  const { exclude, include } = normalizeFilter(filter);\n  const excludeFilter = exclude?.map(patternToCodeFilter);\n  const includeFilter = include?.map(patternToCodeFilter);\n  return createFilter(excludeFilter, includeFilter);\n}\n\nexport function createFilterForId(\n  filter: StringFilter | undefined,\n): PluginFilter | undefined {\n  const filterFunction = createIdFilter(filter);\n  return filterFunction ? (id) => !!filterFunction(id) : undefined;\n}\n\nfunction createFilterForTransform(\n  idFilter: StringFilter | undefined,\n  codeFilter: StringFilter | undefined,\n): TransformHookFilter | undefined {\n  if (!idFilter && !codeFilter) return;\n  const idFilterFunction = createIdFilter(idFilter);\n  const codeFilterFunction = createCodeFilter(codeFilter);\n  return (id, code) => {\n    let fallback = true;\n    if (idFilterFunction) {\n      fallback &&= idFilterFunction(id);\n    }\n    if (!fallback) {\n      return false;\n    }\n\n    if (codeFilterFunction) {\n      fallback &&= codeFilterFunction(code);\n    }\n    return fallback;\n  };\n}\n"],"mappings":"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","names":["Babel","FORMAT_VERSION","transpileFn","defaultOptions","embedJSON","jsValue","isTgpu","ctx","node","path","tail","gatherTgpuAliases","spec","fnShellFunctionNames","isShellImplementationCall","resourceConstructors","containsResourceConstructorCall","performExpressionNaming","namingCallback","kernelDirective","resolve","picomatch","toArray","array","result","BACKSLASH_REGEX","normalize","path","ABSOLUTE_PATH_REGEX","isAbsolute","getMatcherString","glob","cwd","resolved","patternToIdFilter","pattern","id","normalizedId","matcher","createFilter","exclude","include","input","filter","normalizeFilter","toArray","createIdFilter","excludeFilter","patternToIdFilter","includeFilter","createFilterForId","filter","filterFunction","createIdFilter","id","template","types","containsKernelDirective","node","_a","_b","directive","kernelDirective","i","identifier","functionToTranspiled","params","body","externalNames","transpileFn","metadata","FORMAT_VERSION","embedJSON","wrapInAutoName","name","functionVisitor","ctx","path","performExpressionNaming","gatherTgpuAliases","expression","transpiled","isShellImplementationCall","implementation","babel_default","state","code","options","id","filter","createFilterForId"]}