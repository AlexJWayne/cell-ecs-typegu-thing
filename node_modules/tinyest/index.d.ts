declare const NodeTypeCatalog: {
    readonly block: 0;
    readonly binaryExpr: 1;
    readonly assignmentExpr: 2;
    readonly logicalExpr: 3;
    readonly unaryExpr: 4;
    readonly numericLiteral: 5;
    readonly call: 6;
    readonly memberAccess: 7;
    readonly indexAccess: 8;
    readonly return: 10;
    readonly if: 11;
    readonly let: 12;
    readonly const: 13;
    readonly for: 14;
    readonly while: 15;
    readonly continue: 16;
    readonly break: 17;
    readonly arrayExpr: 100;
    readonly preUpdate: 101;
    readonly postUpdate: 102;
    readonly stringLiteral: 103;
    readonly objectExpr: 104;
};
type NodeTypeCatalog = typeof NodeTypeCatalog;
/**
 * Represents a return statement
 */
type Return = readonly [type: NodeTypeCatalog['return'], expr: Expression] | readonly [type: NodeTypeCatalog['return']];
/**
 * Represents an if statement
 */
type If = readonly [type: NodeTypeCatalog['if'], cond: Expression, then: Statement] | readonly [
    type: NodeTypeCatalog['if'],
    cond: Expression,
    then: Statement,
    alt: Statement
];
/**
 * Represents a block of statements
 */
type Block = readonly [type: NodeTypeCatalog['block'], Statement[]];
/**
 * Represents a let statement
 */
type Let = readonly [type: NodeTypeCatalog['let'], identifier: string] | readonly [
    type: NodeTypeCatalog['let'],
    identifier: string,
    value: Expression
];
/**
 * Represents a const statement
 */
type Const = readonly [
    type: NodeTypeCatalog['const'],
    identifier: string,
    value: Expression
];
type For = readonly [
    type: NodeTypeCatalog['for'],
    init: Statement | null,
    condition: Expression | null,
    update: Statement | null,
    body: Statement
];
type While = readonly [
    type: NodeTypeCatalog['while'],
    condition: Expression,
    body: Statement
];
type Continue = readonly [type: NodeTypeCatalog['continue']];
type Break = readonly [type: NodeTypeCatalog['break']];
/**
 * A union type of all statements
 */
type Statement = Return | If | Block | Let | Const | Expression | For | While | Continue | Break;
type BinaryOperator = '==' | '!=' | '<' | '<=' | '>' | '>=' | '<<' | '>>' | '+' | '-' | '*' | '/' | '%' | '|' | '^' | '&';
type BinaryExpression = readonly [
    type: NodeTypeCatalog['binaryExpr'],
    lhs: Expression,
    op: BinaryOperator,
    rhs: Expression
];
type AssignmentOperator = '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '|=' | '^=' | '&=' | '**=' | '||=' | '&&=';
type AssignmentExpression = readonly [
    type: NodeTypeCatalog['assignmentExpr'],
    lhs: Expression,
    op: AssignmentOperator,
    rhs: Expression
];
type LogicalOperator = '&&' | '||';
type LogicalExpression = readonly [
    type: NodeTypeCatalog['logicalExpr'],
    lhs: Expression,
    op: LogicalOperator,
    rhs: Expression
];
type UnaryOperator = '-' | '+' | '!' | '~' | 'typeof' | 'void' | 'delete';
type UnaryExpression = readonly [
    type: NodeTypeCatalog['unaryExpr'],
    op: UnaryOperator,
    inner: Expression
];
type ObjectExpression = readonly [
    type: NodeTypeCatalog['objectExpr'],
    Record<string, Expression>
];
type ArrayExpression = readonly [
    type: NodeTypeCatalog['arrayExpr'],
    values: Expression[]
];
type MemberAccess = readonly [
    type: NodeTypeCatalog['memberAccess'],
    object: Expression,
    member: string
];
type IndexAccess = readonly [
    type: NodeTypeCatalog['indexAccess'],
    object: Expression,
    property: Expression
];
type Call = readonly [
    type: NodeTypeCatalog['call'],
    identifier: Expression,
    args: Expression[]
];
type PostUpdate = readonly [
    type: NodeTypeCatalog['postUpdate'],
    operator: '++' | '--',
    argument: Expression
];
type PreUpdate = readonly [
    type: NodeTypeCatalog['preUpdate'],
    operator: '++' | '--',
    argument: Expression
];
/** A numeric literal */
type Num = readonly [type: NodeTypeCatalog['numericLiteral'], string];
/** A string literal */
type Str = readonly [type: NodeTypeCatalog['stringLiteral'], string];
type Literal = Num | Str | boolean;
/** Identifiers are just strings, since string literals are rare in WGSL, and identifiers are everywhere. */
type Expression = string | BinaryExpression | AssignmentExpression | LogicalExpression | UnaryExpression | ObjectExpression | MemberAccess | IndexAccess | ArrayExpression | PreUpdate | PostUpdate | Call | Literal;
type AnyNode = Statement | Expression;
declare const FuncParameterType: {
    readonly identifier: "i";
    readonly destructuredObject: "d";
};
type FuncParameter = {
    type: typeof FuncParameterType.identifier;
    name: string;
} | {
    type: typeof FuncParameterType.destructuredObject;
    props: {
        name: string;
        alias: string;
    }[];
};

/**
 * Each breaking change to the format requires a bump to this number.
 * It's used at runtime by `typegpu` to determine how to interpret
 * a function's AST. It gets embedded by `unplugin-typegpu` into
 * the source code at build time.
 */
declare const FORMAT_VERSION = 1;

export { type AnyNode, type ArrayExpression, type AssignmentExpression, type AssignmentOperator, type BinaryExpression, type BinaryOperator, type Block, type Break, type Call, type Const, type Continue, type Expression, FORMAT_VERSION, type For, type FuncParameter, FuncParameterType, type If, type IndexAccess, type Let, type Literal, type LogicalExpression, type LogicalOperator, type MemberAccess, NodeTypeCatalog, type Num, type ObjectExpression, type PostUpdate, type PreUpdate, type Return, type Statement, type Str, type UnaryExpression, type UnaryOperator, type While };
