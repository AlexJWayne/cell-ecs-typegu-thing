{
  "version": 3,
  "sources": ["../../src/std/discard.ts", "../../src/std/matrix.ts", "../../src/std/boolean.ts", "../../src/std/atomic.ts", "../../src/std/array.ts", "../../src/std/packing.ts", "../../src/std/texture.ts"],
  "sourcesContent": ["import { snip } from '../data/dataTypes.ts';\nimport { Void } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\n\nexport const discard = createDualImpl(\n  // CPU\n  (): never => {\n    throw new Error('discard() can only be used on the GPU.');\n  },\n  // GPU\n  () => snip('discard;', Void),\n  'discard',\n);\n", "import type { Snippet } from '../data/dataTypes.ts';\nimport { mat4x4f } from '../data/matrix.ts';\nimport type { m4x4f, v3f } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\nimport { mul } from './numeric.ts';\n\n/**\n * Translates the given 4-by-4 matrix by the given vector.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {v3f} vector - The vector by which to translate the matrix.\n * @returns {m4x4f} The translated matrix.\n */\nexport const translate4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, vector: v3f) => {\n    return mul(mat4x4f.translation(vector), matrix);\n  },\n  // GPU implementation\n  (matrix, vector) => ({\n    value: `(${\n      (mat4x4f.translation(vector as unknown as v3f) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'translate4',\n);\n\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount given by the corresponding entry in the given vector.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {v3f} vector - A vector of three entries specifying the factor by which to scale in each dimension.\n * @returns {m4x4f} The scaled matrix.\n */\nexport const scale4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, vector: v3f) => {\n    return mul(mat4x4f.scaling(vector), matrix);\n  },\n  // GPU implementation\n  (matrix, vector) => ({\n    value: `(${\n      (mat4x4f.scaling(vector as unknown as v3f) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'scale4',\n);\n\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateX4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, angle: number) => {\n    return mul(mat4x4f.rotationX(angle), matrix);\n  },\n  // GPU implementation\n  (matrix, angle) => ({\n    value: `(${\n      (mat4x4f.rotationX(angle as unknown as number) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'rotateX4',\n);\n\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateY4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, angle: number) => {\n    return mul(mat4x4f.rotationY(angle), matrix);\n  },\n  // GPU implementation\n  (matrix, angle) => ({\n    value: `(${\n      (mat4x4f.rotationY(angle as unknown as number) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'rotateY4',\n);\n\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateZ4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, angle: number) => {\n    return mul(mat4x4f.rotationZ(angle), matrix);\n  },\n  // GPU implementation\n  (matrix, angle) => ({\n    value: `(${\n      (mat4x4f.rotationZ(angle as unknown as number) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'rotateZ4',\n);\n", "import { snip, type Snippet } from '../data/dataTypes.ts';\nimport { bool, f32 } from '../data/numeric.ts';\nimport { vec2b, vec3b, vec4b } from '../data/vector.ts';\nimport { VectorOps } from '../data/vectorOps.ts';\nimport {\n  type AnyBooleanVecInstance,\n  type AnyFloatVecInstance,\n  type AnyNumericVecInstance,\n  type AnyVec2Instance,\n  type AnyVec3Instance,\n  type AnyVecInstance,\n  isVecInstance,\n  type v2b,\n  type v3b,\n  type v4b,\n} from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\nimport { isSnippetNumeric, sub } from './numeric.ts';\n\nfunction correspondingBooleanVectorSchema(value: Snippet) {\n  if (value.dataType.type.includes('2')) {\n    return vec2b;\n  }\n  if (value.dataType.type.includes('3')) {\n    return vec3b;\n  }\n  return vec4b;\n}\n\n// comparison\n\n/**\n * Checks whether `lhs == rhs` on all components.\n * Equivalent to `all(eq(lhs, rhs))`.\n * @example\n * allEq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns false\n * allEq(vec3u(0, 1, 2), vec3u(0, 1, 2)) // returns true\n */\nexport const allEq = createDualImpl(\n  // CPU implementation\n  <T extends AnyVecInstance>(lhs: T, rhs: T) => all(eq(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) => snip(`all(${lhs.value} == ${rhs.value})`, bool),\n  'allEq',\n);\n\n/**\n * Checks **component-wise** whether `lhs == rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`, or use `allEq`.\n * @example\n * eq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(true, false)\n * eq(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, false)\n * all(eq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1))) // returns true\n * allEq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1)) // returns true\n */\nexport const eq = createDualImpl(\n  // CPU implementation\n  <T extends AnyVecInstance>(lhs: T, rhs: T) =>\n    VectorOps.eq[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} == ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'eq',\n);\n\n/**\n * Checks **component-wise** whether `lhs != rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `any`.\n * @example\n * ne(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(false, true)\n * ne(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, true)\n * any(ne(vec4i(4, 3, 2, 1), vec4i(4, 2, 2, 1))) // returns true\n */\nexport const ne = createDualImpl(\n  // CPU implementation\n  <T extends AnyVecInstance>(lhs: T, rhs: T) => not(eq(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} != ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'ne',\n);\n\n/**\n * Checks **component-wise** whether `lhs < rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * lt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, true)\n * lt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, false)\n * all(lt(vec4i(1, 2, 3, 4), vec4i(2, 3, 4, 5))) // returns true\n */\nexport const lt = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    VectorOps.lt[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} < ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'lt',\n);\n\n/**\n * Checks **component-wise** whether `lhs <= rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * le(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, true)\n * le(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, true, false)\n * all(le(vec4i(1, 2, 3, 4), vec4i(2, 3, 3, 5))) // returns true\n */\nexport const le = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    or(lt(lhs, rhs), eq(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} <= ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'le',\n);\n\n/**\n * Checks **component-wise** whether `lhs > rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * gt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, false)\n * gt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, false, true)\n * all(gt(vec4i(2, 3, 4, 5), vec4i(1, 2, 3, 4))) // returns true\n */\nexport const gt = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    and(not(lt(lhs, rhs)), not(eq(lhs, rhs))),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} > ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'gt',\n);\n\n/**\n * Checks **component-wise** whether `lhs >= rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * ge(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, false)\n * ge(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, true)\n * all(ge(vec4i(2, 2, 4, 5), vec4i(1, 2, 3, 4))) // returns true\n */\nexport const ge = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) => not(lt(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} >= ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'ge',\n);\n\n// logical ops\n\n/**\n * Returns **component-wise** `!value`.\n * @example\n * not(vec2b(false, true)) // returns vec2b(true, false)\n * not(vec3b(true, true, false)) // returns vec3b(false, false, true)\n */\nexport const not = createDualImpl(\n  // CPU implementation\n  <T extends AnyBooleanVecInstance>(value: T): T =>\n    VectorOps.neg[value.kind](value),\n  // GPU implementation\n  (value) => snip(`!(${value.value})`, value.dataType),\n  'not',\n);\n\n/**\n * Returns **component-wise** logical `or` result.\n * @example\n * or(vec2b(false, true), vec2b(false, false)) // returns vec2b(false, true)\n * or(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(true, true, false)\n */\nexport const or = createDualImpl(\n  // CPU implementation\n  <T extends AnyBooleanVecInstance>(lhs: T, rhs: T) =>\n    VectorOps.or[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) => snip(`(${lhs.value} | ${rhs.value})`, lhs.dataType),\n  'or',\n);\n\n/**\n * Returns **component-wise** logical `and` result.\n * @example\n * and(vec2b(false, true), vec2b(true, true)) // returns vec2b(false, true)\n * and(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(false, true, false)\n */\nexport const and = createDualImpl(\n  // CPU implementation\n  <T extends AnyBooleanVecInstance>(lhs: T, rhs: T) =>\n    not(or(not(lhs), not(rhs))),\n  // GPU implementation\n  (lhs, rhs) => snip(`(${lhs.value} & ${rhs.value})`, lhs.dataType),\n  'and',\n);\n\n// logical aggregation\n\n/**\n * Returns `true` if each component of `value` is true.\n * @example\n * all(vec2b(false, true)) // returns false\n * all(vec3b(true, true, true)) // returns true\n */\nexport const all = createDualImpl(\n  // CPU implementation\n  (value: AnyBooleanVecInstance) => VectorOps.all[value.kind](value),\n  // GPU implementation\n  (value) => snip(`all(${value.value})`, bool),\n  'all',\n);\n\n/**\n * Returns `true` if any component of `value` is true.\n * @example\n * any(vec2b(false, true)) // returns true\n * any(vec3b(false, false, false)) // returns false\n */\nexport const any = createDualImpl(\n  // CPU implementation\n  (value: AnyBooleanVecInstance) => !all(not(value)),\n  // GPU implementation\n  (value) => snip(`any(${value.value})`, bool),\n  'any',\n);\n\n// other\n\n/**\n * Checks whether the given elements differ by at most the `precision` value.\n * Checks all elements of `lhs` and `rhs` if arguments are vectors.\n * @example\n * isCloseTo(0, 0.1) // returns false\n * isCloseTo(vec3f(0, 0, 0), vec3f(0.002, -0.009, 0)) // returns true\n *\n * @param {number} precision argument that specifies the maximum allowed difference, 0.01 by default.\n */\nexport const isCloseTo = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(\n    lhs: T,\n    rhs: T,\n    precision = 0.01,\n  ) => {\n    if (typeof lhs === 'number' && typeof rhs === 'number') {\n      return Math.abs(lhs - rhs) < precision;\n    }\n    if (isVecInstance(lhs) && isVecInstance(rhs)) {\n      return VectorOps.isCloseToZero[lhs.kind](\n        sub(lhs, rhs),\n        precision,\n      );\n    }\n    return false;\n  },\n  // GPU implementation\n  (lhs, rhs, precision = snip(0.01, f32)) => {\n    if (isSnippetNumeric(lhs) && isSnippetNumeric(rhs)) {\n      return snip(\n        `(abs(f32(${lhs.value}) - f32(${rhs.value})) <= ${precision.value})`,\n        bool,\n      );\n    }\n    if (!isSnippetNumeric(lhs) && !isSnippetNumeric(rhs)) {\n      return snip(\n        // https://www.w3.org/TR/WGSL/#vector-multi-component:~:text=Binary%20arithmetic%20expressions%20with%20mixed%20scalar%20and%20vector%20operands\n        // (a-a)+prec creates a vector of a.length elements, all equal to prec\n        `all(abs(${lhs.value} - ${rhs.value}) <= (${lhs.value} - ${lhs.value}) + ${precision.value})`,\n        bool,\n      );\n    }\n    return snip('false', bool);\n  },\n  'isCloseTo',\n);\n\nexport type SelectOverload = {\n  <T extends number | boolean | AnyVecInstance>(f: T, t: T, cond: boolean): T;\n  <T extends AnyVecInstance>(\n    f: T,\n    t: T,\n    cond: T extends AnyVec2Instance ? v2b\n      : T extends AnyVec3Instance ? v3b\n      : v4b,\n  ): T;\n};\n\n/**\n * Returns `t` if `cond` is `true`, and `f` otherwise.\n * Component-wise if `cond` is a vector.\n * @example\n * select(1, 2, false) // returns 1\n * select(1, 2, true) // returns 2\n * select(vec2i(1, 2), vec2i(3, 4), true) // returns vec2i(3, 4)\n * select(vec2i(1, 2), vec2i(3, 4), vec2b(false, true)) // returns vec2i(1, 4)\n */\nexport const select: SelectOverload = createDualImpl(\n  // CPU implementation\n  <T extends number | boolean | AnyVecInstance>(\n    f: T,\n    t: T,\n    cond: AnyBooleanVecInstance | boolean,\n  ) => {\n    if (typeof cond === 'boolean') {\n      return cond ? t : f;\n    }\n    return VectorOps.select[(f as AnyVecInstance).kind](\n      f as AnyVecInstance,\n      t as AnyVecInstance,\n      cond,\n    );\n  },\n  // GPU implementation\n  (f, t, cond) =>\n    snip(`select(${f.value}, ${t.value}, ${cond.value})`, f.dataType),\n  'select',\n);\n", "import { snip, type Snippet } from '../data/dataTypes.ts';\nimport { i32, u32 } from '../data/numeric.ts';\nimport {\n  type AnyWgslData,\n  type atomicI32,\n  type atomicU32,\n  isWgslData,\n  Void,\n} from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\ntype AnyAtomic = atomicI32 | atomicU32;\n\nexport const workgroupBarrier = createDualImpl(\n  // CPU implementation\n  () => console.warn('workgroupBarrier is a no-op outside of GPU mode.'),\n  // GPU implementation\n  () => snip('workgroupBarrier()', Void),\n  'workgroupBarrier',\n);\n\nexport const storageBarrier = createDualImpl(\n  // CPU implementation\n  () => console.warn('storageBarrier is a no-op outside of GPU mode.'),\n  // GPU implementation\n  () => snip('storageBarrier()', Void),\n  'storageBarrier',\n);\n\nexport const textureBarrier = createDualImpl(\n  // CPU implementation\n  () => console.warn('textureBarrier is a no-op outside of GPU mode.'),\n  // GPU implementation\n  () => snip('textureBarrier()', Void),\n  'textureBarrier',\n);\n\nexport const atomicLoad = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicLoad(&${a.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicLoad',\n);\n\nexport const atomicStore = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): void => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (!isWgslData(a.dataType) || a.dataType.type !== 'atomic') {\n      throw new Error(\n        `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n      );\n    }\n    return snip(`atomicStore(&${a.value}, ${value.value})`, Void);\n  },\n  'atomicStore',\n);\n\nconst atomicTypeFn = (a: Snippet, _value: Snippet): AnyWgslData[] => {\n  if (a.dataType.type === 'atomic' && a.dataType.inner.type === 'i32') {\n    return [a.dataType, i32];\n  }\n  return [a.dataType as AnyWgslData, u32];\n};\n\nexport const atomicAdd = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicAdd(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicAdd',\n  atomicTypeFn,\n);\n\nexport const atomicSub = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicSub(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicSub',\n  atomicTypeFn,\n);\n\nexport const atomicMax = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicMax(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicMax',\n  atomicTypeFn,\n);\n\nexport const atomicMin = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicMin(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicMin',\n  atomicTypeFn,\n);\n\nexport const atomicAnd = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicAnd(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicAnd',\n  atomicTypeFn,\n);\n\nexport const atomicOr = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicOr(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicOr',\n  atomicTypeFn,\n);\n\nexport const atomicXor = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicXor(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicXor',\n  atomicTypeFn,\n);\n", "import { snip } from '../data/dataTypes.ts';\nimport { abstractInt, u32 } from '../data/numeric.ts';\nimport { ptrFn } from '../data/ptr.ts';\nimport type { AnyWgslData } from '../data/wgslTypes.ts';\nimport { isPtr, isWgslArray } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\n\nexport const arrayLength = createDualImpl(\n  // CPU implementation\n  (a: unknown[]) => a.length,\n  // GPU implementation\n  (a) => {\n    if (\n      isPtr(a.dataType) && isWgslArray(a.dataType.inner) &&\n      a.dataType.inner.elementCount > 0\n    ) {\n      return snip(String(a.dataType.inner.elementCount), abstractInt);\n    }\n    return snip(`arrayLength(${a.value})`, u32);\n  },\n  'arrayLength',\n  (a) => [ptrFn(a.dataType as AnyWgslData)],\n);\n", "import * as TB from 'typed-binary';\nimport { u32 } from '../data/numeric.ts';\nimport { vec2f, vec4f } from '../data/vector.ts';\nimport type { v2f, v4f } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\nimport { snip } from '../data/dataTypes.ts';\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#unpack2x16float-builtin\n */\nexport const unpack2x16float = createDualImpl(\n  // CPU implementation\n  (e: number): v2f => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeUint32(e);\n    const reader = new TB.BufferReader(buffer);\n    return vec2f(reader.readFloat16(), reader.readFloat16());\n  },\n  // GPU implementation\n  (e) => snip(`unpack2x16float(${e.value})`, vec2f),\n  'unpack2x16float',\n);\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#pack2x16float-builtin\n */\nexport const pack2x16float = createDualImpl(\n  // CPU implementation\n  (e: v2f): number => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeFloat16(e.x);\n    writer.writeFloat16(e.y);\n    const reader = new TB.BufferReader(buffer);\n    return u32(reader.readUint32());\n  },\n  // GPU implementation\n  (e) => snip(`pack2x16float(${e.value})`, u32),\n  'pack2x16float',\n);\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#unpack4x8unorm-builtin\n */\nexport const unpack4x8unorm = createDualImpl(\n  // CPU implementation\n  (e: number): v4f => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeUint32(e);\n    const reader = new TB.BufferReader(buffer);\n    return vec4f(\n      reader.readUint8() / 255,\n      reader.readUint8() / 255,\n      reader.readUint8() / 255,\n      reader.readUint8() / 255,\n    );\n  },\n  // GPU implementation\n  (e) => snip(`unpack4x8unorm(${e.value})`, vec4f),\n  'unpack4x8unorm',\n);\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#pack4x8unorm-builtin\n */\nexport const pack4x8unorm = createDualImpl(\n  // CPU implementation\n  (e: v4f): number => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeUint8(e.x * 255);\n    writer.writeUint8(e.y * 255);\n    writer.writeUint8(e.z * 255);\n    writer.writeUint8(e.w * 255);\n    const reader = new TB.BufferReader(buffer);\n    return u32(reader.readUint32());\n  },\n  // GPU implementation\n  (e) => snip(`pack4x8unorm(${e.value})`, u32),\n  'pack4x8unorm',\n);\n", "import type { TgpuSampler } from '../core/sampler/sampler.ts';\nimport type {\n  TgpuSampledTexture,\n  TgpuStorageTexture,\n} from '../core/texture/texture.ts';\nimport type { ChannelData, TexelData } from '../core/texture/texture.ts';\nimport { snip } from '../data/dataTypes.ts';\nimport { u32 } from '../data/numeric.ts';\nimport { vec2u, vec3u, vec4f, vec4i, vec4u } from '../data/vector.ts';\nimport {\n  type v2f,\n  type v2i,\n  type v2u,\n  type v3f,\n  type v3i,\n  type v3u,\n  type v4f,\n  type v4i,\n  type v4u,\n  Void,\n} from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\n\ntype TextureSampleOverload = {\n  <T extends TgpuSampledTexture<'1d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: number,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    offset: v2i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    arrayIndex: number,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    arrayIndex: number,\n    offset: v2i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'3d' | 'cube'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n  ): v4f;\n  <T extends TgpuSampledTexture<'3d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n    offset: v3i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'cube-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n    arrayIndex: number,\n  ): v4f;\n  // TODO: Support this\n  // <T extends TgpuSampledTexture<'depth-2d'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v2f,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-2d'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v2f,\n  //   offset: v2i,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-2d-array'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v2f,\n  //   arrayIndex: number,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-2d-array'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v2f,\n  //   arrayIndex: number,\n  //   offset: v2i,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-cube'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v3i,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-cube-array'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v3i,\n  //   arrayIndex: number,\n  // ): number;\n};\n\nexport const textureSample: TextureSampleOverload = createDualImpl(\n  // CPU implementation\n  (\n    _texture: TgpuSampledTexture,\n    _sampler: TgpuSampler,\n    _coords: number | v2f | v3f,\n    _offsetOrArrayIndex?: v2i | v3i | number,\n    _maybeOffset?: v2i | v3i,\n  ) => {\n    throw new Error('Texture sampling is not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (texture, sampler, coords, offsetOrArrayIndex, maybeOffset) => {\n    const args = [texture, sampler, coords];\n\n    if (offsetOrArrayIndex !== undefined) {\n      args.push(offsetOrArrayIndex);\n    }\n\n    if (maybeOffset !== undefined) {\n      args.push(maybeOffset);\n    }\n\n    return snip(`textureSample(${args.map((v) => v.value).join(', ')})`, vec4f);\n  },\n  'textureSample',\n);\n\ntype TextureSampleLevelOverload = {\n  <T extends TgpuSampledTexture<'2d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    level: number,\n    offset?: v2i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    arrayIndex: number,\n    level: number,\n    offset?: v2i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'3d' | 'cube'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n    level: number,\n    offset?: v3i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'cube-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n    arrayIndex: number,\n    level: number,\n  ): v4f;\n};\n\nexport const textureSampleLevel: TextureSampleLevelOverload = createDualImpl(\n  // CPU implementation\n  (\n    _texture: TgpuSampledTexture,\n    _sampler: TgpuSampler,\n    _coords: number | v2f | v3f,\n    _level: number,\n    _offsetOrArrayIndex?: v2i | v3i | number,\n  ) => {\n    throw new Error('Texture sampling is not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (texture, sampler, coords, level, offsetOrArrayIndex) => {\n    const args = [texture, sampler, coords, level];\n\n    if (offsetOrArrayIndex !== undefined) {\n      args.push(offsetOrArrayIndex);\n    }\n\n    return snip(\n      `textureSampleLevel(${args.map((v) => v.value).join(', ')})`,\n      vec4f,\n    );\n  },\n  'textureSampleLevel',\n);\n\ntype TexelDataToInstance<TF extends TexelData> = {\n  vec4f: v4f;\n  vec4i: v4i;\n  vec4u: v4u;\n}[TF['type']];\n\ntype SampleTypeToInstance<TF extends ChannelData> = {\n  u32: v4u;\n  i32: v4i;\n  f32: v4f;\n}[TF['type']];\n\nconst channelDataToInstance = {\n  u32: vec4u,\n  i32: vec4i,\n  f32: vec4f,\n};\n\ntype TextureLoadOverload = {\n  <T extends TgpuStorageTexture<'1d'>>(\n    texture: T,\n    coords: number,\n  ): TexelDataToInstance<T['texelDataType']>;\n  <T extends TgpuStorageTexture<'2d'>>(\n    texture: T,\n    coords: v2i | v2u,\n  ): TexelDataToInstance<T['texelDataType']>;\n  <T extends TgpuStorageTexture<'2d-array'>>(\n    texture: T,\n    coords: v2i | v2u,\n    arrayIndex: number,\n  ): TexelDataToInstance<T['texelDataType']>;\n  <T extends TgpuStorageTexture<'3d'>>(\n    texture: T,\n    coords: v3i | v3u,\n  ): TexelDataToInstance<T['texelDataType']>;\n\n  <T extends TgpuSampledTexture<'1d'>>(\n    texture: T,\n    coords: number,\n    level: number,\n  ): SampleTypeToInstance<T['channelDataType']>;\n  <T extends TgpuSampledTexture<'2d'>>(\n    texture: T,\n    coords: v2i | v2u,\n    level: number,\n  ): SampleTypeToInstance<T['channelDataType']>;\n  <T extends TgpuSampledTexture<'2d-array'>>(\n    texture: T,\n    coords: v2i | v2u,\n    arrayIndex: number,\n    level: number,\n  ): SampleTypeToInstance<T['channelDataType']>;\n  <T extends TgpuSampledTexture<'3d'>>(\n    texture: T,\n    coords: v3i | v3u,\n    level: number,\n  ): SampleTypeToInstance<T['channelDataType']>;\n  // TODO: Support multisampled textures and depth textures\n};\n\nexport const textureLoad: TextureLoadOverload = createDualImpl(\n  // CPU implementation\n  (\n    _texture: TgpuStorageTexture | TgpuSampledTexture,\n    _coords: number | v2i | v2u | v3i | v3u,\n    _levelOrArrayIndex?: number,\n  ) => {\n    throw new Error('Texture loading is not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (texture, coords, levelOrArrayIndex) => {\n    const args = [texture, coords];\n\n    if (levelOrArrayIndex !== undefined) {\n      args.push(levelOrArrayIndex);\n    }\n\n    const textureInfo = texture.dataType as unknown as\n      | TgpuStorageTexture\n      | TgpuSampledTexture;\n\n    return snip(\n      `textureLoad(${args.map((v) => v.value).join(', ')})`,\n      'texelDataType' in textureInfo\n        ? textureInfo.texelDataType\n        : channelDataToInstance[textureInfo.channelDataType.type],\n    );\n  },\n  'textureLoad',\n);\n\ntype TextureStoreOverload = {\n  <T extends TgpuStorageTexture<'1d'>>(\n    texture: T,\n    coords: number,\n    value: TexelDataToInstance<T['texelDataType']>,\n  ): void;\n  <T extends TgpuStorageTexture<'2d'>>(\n    texture: T,\n    coords: v2i | v2u,\n    value: TexelDataToInstance<T['texelDataType']>,\n  ): void;\n  <T extends TgpuStorageTexture<'2d-array'>>(\n    texture: T,\n    coords: v2i | v2u,\n    arrayIndex: number,\n    value: TexelDataToInstance<T['texelDataType']>,\n  ): void;\n  <T extends TgpuStorageTexture<'3d'>>(\n    texture: T,\n    coords: v3i | v3u,\n    value: TexelDataToInstance<T['texelDataType']>,\n  ): void;\n};\n\nexport const textureStore: TextureStoreOverload = createDualImpl(\n  // CPU implementation\n  (\n    _texture: TgpuStorageTexture,\n    _coords: number | v2i | v2u | v3i | v3u,\n    _arrayIndexOrValue?: number | TexelData,\n    _maybeValue?: TexelData,\n  ) => {\n    throw new Error('Texture storing is not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (texture, coords, arrayIndexOrValue, maybeValue) =>\n    snip(\n      `textureStore(${\n        [texture, coords, arrayIndexOrValue, maybeValue].filter(\n          (arg) => arg !== undefined,\n        ).map((v) => v.value).join(', ')\n      })`,\n      Void,\n    ),\n  'textureStore',\n);\n\ntype TextureDimensionsOverload = {\n  <T extends TgpuSampledTexture<'1d'> | TgpuStorageTexture<'1d'>>(\n    texture: T,\n  ): number;\n  <T extends TgpuSampledTexture<'1d'>>(texture: T, level: number): number;\n\n  <\n    T extends\n      | TgpuSampledTexture<'2d'>\n      | TgpuSampledTexture<'2d-array'>\n      | TgpuSampledTexture<'cube'>\n      | TgpuSampledTexture<'cube-array'>\n      | TgpuStorageTexture<'2d'>\n      | TgpuStorageTexture<'2d-array'>,\n  >(\n    texture: T,\n  ): v2u;\n  <\n    T extends\n      | TgpuSampledTexture<'2d'>\n      | TgpuSampledTexture<'2d-array'>\n      | TgpuSampledTexture<'cube'>\n      | TgpuSampledTexture<'cube-array'>,\n  >(\n    texture: T,\n    level: number,\n  ): v2u;\n\n  <T extends TgpuSampledTexture<'3d'> | TgpuStorageTexture<'3d'>>(\n    texture: T,\n  ): v3u;\n  <T extends TgpuSampledTexture<'3d'>>(texture: T, level: number): v3u;\n};\n\nexport const textureDimensions: TextureDimensionsOverload = createDualImpl(\n  // CPU implementation\n  (_texture: TgpuSampledTexture | TgpuStorageTexture, _level?: number) => {\n    throw new Error(\n      'Texture dimensions are not supported outside of GPU mode.',\n    );\n  },\n  // GPU implementation\n  (texture, level) => {\n    const dim =\n      (texture.dataType as unknown as TgpuSampledTexture | TgpuStorageTexture)\n        .dimension;\n    return snip(\n      `textureDimensions(${texture.value}${\n        level !== undefined ? `, ${level.value}` : ''\n      })`,\n      dim === '1d' ? u32 : dim === '3d' ? vec3u : vec2u,\n    );\n  },\n  'textureDimensions',\n);\n"],
  "mappings": "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",
  "names": ["discard", "createDualImpl", "snip", "Void", "translate4", "matrix", "vector", "mul", "mat4x4f", "scale4", "rotateX4", "angle", "rotateY4", "rotateZ4", "correspondingBooleanVectorSchema", "value", "vec2b", "vec3b", "vec4b", "allEq", "lhs", "rhs", "all", "eq", "bool", "VectorOps", "ne", "not", "lt", "le", "or", "gt", "and", "ge", "any", "isCloseTo", "precision", "isVecInstance", "sub", "f32", "isSnippetNumeric", "select", "f", "cond", "workgroupBarrier", "storageBarrier", "textureBarrier", "atomicLoad", "a", "isWgslData", "atomicStore", "atomicTypeFn", "_value", "i32", "u32", "atomicAdd", "atomicSub", "atomicMax", "atomicMin", "atomicAnd", "atomicOr", "atomicXor", "arrayLength", "isPtr", "isWgslArray", "abstractInt", "ptrFn", "unpack2x16float", "buffer", "reader", "vec2f", "pack2x16float", "writer", "unpack4x8unorm", "vec4f", "pack4x8unorm", "textureSample", "_texture", "_sampler", "_coords", "_offsetOrArrayIndex", "_maybeOffset", "texture", "sampler", "coords", "offsetOrArrayIndex", "maybeOffset", "args", "v", "textureSampleLevel", "_level", "level", "channelDataToInstance", "vec4u", "vec4i", "textureLoad", "_levelOrArrayIndex", "levelOrArrayIndex", "textureInfo", "textureStore", "_arrayIndexOrValue", "_maybeValue", "arrayIndexOrValue", "maybeValue", "arg", "textureDimensions", "dim", "vec3u", "vec2u"]
}
