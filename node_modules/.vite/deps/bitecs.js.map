{
  "version": 3,
  "sources": ["../../bitecs/src/core/utils/defineHiddenProperty.ts", "../../bitecs/src/core/EntityIndex.ts", "../../bitecs/src/core/World.ts", "../../bitecs/src/core/utils/SparseSet.ts", "../../bitecs/src/core/utils/Observer.ts", "../../bitecs/src/core/Query.ts", "../../bitecs/src/core/Relation.ts", "../../bitecs/src/core/Component.ts", "../../bitecs/src/core/Entity.ts", "../../bitecs/src/core/utils/pipe.ts"],
  "sourcesContent": ["export const defineHiddenProperty = (obj:any,key:any,value:any) => Object.defineProperty(obj, key, {\n    value,\n    enumerable: false,\n    writable: true,\n    configurable: true,\n})\n\nexport const defineHiddenProperties = (obj:any,kv:any) => {\n    const descriptors = {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n    }\n    Object.defineProperties(obj, Reflect.ownKeys(kv).reduce((a,k) => Object.assign(a, {[k]: {value: kv[k], ...descriptors}}), {}))\n}", "/**\n * Represents the structure for managing entity IDs.\n */\nexport type EntityIndex = {\n    /** The number of currently alive entities. */\n    aliveCount: number\n    /** Array of entity IDs, densely packed. */\n    dense: number[]\n    /** Sparse array mapping entity IDs to their index in the dense array. */\n    sparse: number[]\n    /** The highest entity ID that has been assigned. */\n    maxId: number\n    /** Flag indicating if versioning is enabled. */\n    versioning: boolean\n    /** Number of bits used for versioning. */\n    versionBits: number\n    /** Bit mask for entity ID. */\n    entityMask: number\n    /** Bit shift for version. */\n    versionShift: number\n    /** Bit mask for version. */\n    versionMask: number\n}\n\n/**\n * Extracts the entity ID from a versioned entity ID by stripping off the version.\n * @param {EntityIndex} index - The EntityIndex containing the masks.\n * @param {number} id - The versioned entity ID.\n * @returns {number} The entity ID without the version.\n */\nexport const getId = (index: EntityIndex, id: number): number => id & index.entityMask;\n\n/**\n * Extracts the version from an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The version.\n */\nexport const getVersion = (index: EntityIndex, id: number): number => \n    (id >>> index.versionShift) & ((1 << index.versionBits) - 1);\n\n/**\n * Increments the version of an entity ID.\n * @param {EntityIndex} index - The EntityIndex containing the masks and shifts.\n * @param {number} id - The entity ID.\n * @returns {number} The new entity ID with incremented version.\n */\nexport const incrementVersion = (index: EntityIndex, id: number): number => {\n    const currentVersion = getVersion(index, id);\n    const newVersion = (currentVersion + 1) & ((1 << index.versionBits) - 1);\n    return (id & index.entityMask) | (newVersion << index.versionShift);\n}\n\n/**\n * Creates configuration options for entity ID recycling with versioning.\n * @param {number} [versionBits] - Optional number of bits to use for version numbers. Defaults to 8 if not specified.\n * @returns {object} Configuration object with versioning enabled and specified version bits.\n */\nexport const withVersioning = (versionBits?: number) => ({\n    versioning: true,\n    versionBits\n})\n\n/**\n * Creates and initializes a new EntityIndex.\n * @param {object|function} [options] - Optional configuration object from withVersioning() or withVersioning function.\n * @param {boolean} options.versioning - Flag to enable versioning for recycled IDs.\n * @param {number} options.versionBits - Number of bits to use for versioning (default: 8).\n * @returns {EntityIndex} A new EntityIndex object.\n */\nexport const createEntityIndex = (options?: ReturnType<typeof withVersioning> | typeof withVersioning): EntityIndex => {\n    const config = options \n        ? typeof options === 'function' \n            ? options()\n            : options\n        : { versioning: false, versionBits: 8 }\n\n    const versionBits = config.versionBits ?? 8\n    const versioning = config.versioning ?? false\n    \n    const entityBits = 32 - versionBits\n    const entityMask = (1 << entityBits) - 1\n    const versionShift = entityBits\n    const versionMask = ((1 << versionBits) - 1) << versionShift\n\n    return {\n        aliveCount: 0,\n        dense: [],\n        sparse: [],\n        maxId: 0,\n        versioning,\n        versionBits,\n        entityMask,\n        versionShift,\n        versionMask\n    }\n}\n\n/**\n * Adds a new entity ID to the index or recycles an existing one.\n * @param {EntityIndex} index - The EntityIndex to add to.\n * @returns {number} The new or recycled entity ID.\n */\nexport const addEntityId = (index: EntityIndex): number => {\n    if (index.aliveCount < index.dense.length) {\n        // Recycle id\n        const recycledId = index.dense[index.aliveCount];\n        const entityId = recycledId;\n        index.sparse[entityId] = index.aliveCount;\n        index.aliveCount++;\n        return recycledId;\n    }\n\n    // Create new id\n    const id = ++index.maxId;\n    index.dense.push(id);\n    index.sparse[id] = index.aliveCount;\n    index.aliveCount++;\n\n    return id;\n}\n\n/**\n * Removes an entity ID from the index.\n * @param {EntityIndex} index - The EntityIndex to remove from.\n * @param {number} id - The entity ID to remove.\n */\nexport const removeEntityId = (index: EntityIndex, id: number): void => {\n    const denseIndex = index.sparse[id];\n    if (denseIndex === undefined || denseIndex >= index.aliveCount) {\n        // Entity is not alive or doesn't exist, nothing to be done\n        return;\n    }\n\n    const lastIndex = index.aliveCount - 1;\n    const lastId = index.dense[lastIndex];\n\n    // Swap with the last element\n    index.sparse[lastId] = denseIndex;\n    index.dense[denseIndex] = lastId;\n\n    // Update the removed entity's record\n    index.sparse[id] = lastIndex; // Set to lastIndex instead of undefined\n    index.dense[lastIndex] = id; // Keep the original id, don't strip version\n\n    // Version the ID if enabled\n    if (index.versioning) {\n        const newId = incrementVersion(index, id);\n        index.dense[lastIndex] = newId;\n    }\n\n    index.aliveCount--;\n}\n\n/**\n * Checks if an entity ID is currently alive in the index.\n * @param {EntityIndex} index - The EntityIndex to check.\n * @param {number} id - The entity ID to check.\n * @returns {boolean} True if the entity ID is alive, false otherwise.\n */\nexport const isEntityIdAlive = (index: EntityIndex, id: number): boolean => {\n    const entityId = getId(index, id);\n    const denseIndex = index.sparse[entityId];\n    return denseIndex !== undefined && denseIndex < index.aliveCount && index.dense[denseIndex] === id;\n}\n", "import { defineHiddenProperty } from './utils/defineHiddenProperty'\nimport { createEntityIndex, EntityIndex } from './EntityIndex'\nimport { ComponentRef, ComponentData } from './Component'\nimport { Query } from './Query'\nimport { EntityId } from './Entity'\n\nexport const $internal = Symbol.for('bitecs_internal')\n\nexport type WorldContext = {\n    entityIndex: EntityIndex\n    entityMasks: number[][]\n    entityComponents: Map<EntityId, Set<ComponentRef>>\n    bitflag: number\n    componentMap: Map<ComponentRef, ComponentData>\n    componentCount: number\n    queries: Set<Query>\n    queriesHashMap: Map<string, Query>\n    notQueries: Set<any>\n    dirtyQueries: Set<any>\n    entitiesWithRelations: Set<EntityId>\n}\n\nexport type InternalWorld = {\n    [$internal]: WorldContext\n}\n\nexport type World<T extends object = {}> = { [K in keyof T]: T[K] }\n\nconst createBaseWorld = <T extends object>(context?: T, entityIndex?: EntityIndex): World<T> => \n    defineHiddenProperty(context || {} as T, $internal, {\n        entityIndex: entityIndex || createEntityIndex(),\n        entityMasks: [[]],\n        entityComponents: new Map(),\n        bitflag: 1,\n        componentMap: new Map(),\n        componentCount: 0,\n        queries: new Set(),\n        queriesHashMap: new Map(),\n        notQueries: new Set(),\n        dirtyQueries: new Set(),\n        entitiesWithRelations: new Set(),\n}) as World<T>\n\n/**\n * Creates a new world with various configurations.\n * @template T\n * @param {...Array<EntityIndex | object>} args - EntityIndex, context object, or both.\n * @returns {World<T>} The created world.\n */\n\n// TODO: middleware\n\nexport function createWorld<T extends object = {}>(\n    ...args: Array<EntityIndex | T>\n): World<T> {\n    let entityIndex: EntityIndex | undefined\n    let context: T | undefined\n\n    args.forEach(arg => {\n        if (typeof arg === 'object' && 'add' in arg && 'remove' in arg) {\n            entityIndex = arg as EntityIndex\n        } else if (typeof arg === 'object') {\n            context = arg as T\n        }\n    })\n\n    return createBaseWorld<T>(context, entityIndex)\n}\n\n/**\n * Resets a world.\n *\n * @param {World} world\n * @returns {object}\n */\nexport const resetWorld = (world: World) => {\n    const ctx = (world as InternalWorld)[$internal]\n    ctx.entityIndex = createEntityIndex()\n    ctx.entityMasks = [[]]\n    ctx.entityComponents = new Map()\n    ctx.bitflag = 1\n    ctx.componentMap = new Map()\n    ctx.componentCount = 0\n    ctx.queries = new Set()\n    ctx.queriesHashMap = new Map()\n    ctx.notQueries = new Set()\n    ctx.dirtyQueries = new Set()\n    ctx.entitiesWithRelations = new Set()\n    return world\n}\n\n/**\n * Deletes a world by removing its internal data.\n *\n * @param {World} world - The world to be deleted.\n */\nexport const deleteWorld = (world: World) => {\n    delete (world as any)[$internal];\n}\n\n/**\n * Returns all components registered to a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getWorldComponents = (world: World) =>\n    Object.keys((world as InternalWorld)[$internal].componentMap)\n\n/**\n * Returns all existing entities in a world\n *\n * @param {World} world\n * @returns Array\n */\nexport const getAllEntities = (world: World): readonly EntityId[] => Array.from((world as InternalWorld)[$internal].entityComponents.keys())\n", "export type SparseSet = {\n    add: (val: number) => void\n    remove: (val: number) => void\n    has: (val: number) => boolean\n    sparse: number[]\n    dense: number[] | Uint32Array\n    reset: () => void\n}\n\nexport const createSparseSet = (): SparseSet => {\n\tconst dense: number[] = []\n\tconst sparse: number[] = []\n\n\tconst has = (val: number) => dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tsparse[val] = dense.push(val) - 1\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense.pop()!\n\t\tif (swapped !== val) {\n\t\t\tdense[index] = swapped\n\t\t\tsparse[swapped] = index\n\t\t}\n\t}\n\n\tconst reset = () => {\n\t\tdense.length = 0\n\t\tsparse.length = 0\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tdense,\n\t\treset,\n\t}\n}\n\nconst SharedArrayBufferOrArrayBuffer = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : ArrayBuffer\n\nexport const createUint32SparseSet = (initialCapacity: number = 1000): SparseSet => {\n\tconst sparse: number[] = []\n\tlet length = 0\n\tlet dense: Uint32Array = new Uint32Array(new SharedArrayBufferOrArrayBuffer(initialCapacity * 4))\n\n\tconst has = (val: number) => val < sparse.length && sparse[val] < length && dense[sparse[val]] === val\n\n\tconst add = (val: number) => {\n\t\tif (has(val)) return\n\t\tif (length >= dense.length) {\n\t\t\tconst newDense = new Uint32Array(new SharedArrayBufferOrArrayBuffer(dense.length * 2 * 4))\n\t\t\tnewDense.set(dense)\n\t\t\tdense = newDense\n\t\t}\n\t\tdense[length] = val\n\t\tsparse[val] = length\n\t\tlength++\n\t}\n\n\tconst remove = (val: number) => {\n\t\tif (!has(val)) return\n\t\tlength--\n\t\tconst index = sparse[val]\n\t\tconst swapped = dense[length]\n\t\tdense[index] = swapped\n\t\tsparse[swapped] = index\n\t}\n\n\tconst reset = () => {\n\t\tlength = 0\n\t\tsparse.length = 0\n\t}\n\n\treturn {\n\t\tadd,\n\t\tremove,\n\t\thas,\n\t\tsparse,\n\t\tget dense() {\n\t\t\treturn new Uint32Array(dense.buffer, 0, length)\n\t\t},\n\t\treset,\n\t}\n}", "import { EntityId } from \"../Entity\"\n\nexport type Observer = (entity: EntityId, ...args: any[]) => void | object\n\nexport interface Observable {\n  subscribe: (observer: Observer) => () => void\n  notify: (entity: EntityId, ...args: any[])  => void | object\n}\n\nexport const createObservable = (): Observable => {\n  const observers = new Set<Observer>()\n\n  const subscribe = (observer: Observer) => {\n    observers.add(observer)\n    return () => {\n      observers.delete(observer)\n    }\n  }\n  const notify = (entity: EntityId, ...args: any[]) => {\n    return Array.from(observers).reduce((acc, listener) => {\n      const result = listener(entity, ...args)\n      return result && typeof result === 'object' ? { ...acc, ...result } : acc\n    }, {})\n  }\n\n  return {\n    subscribe,\n    notify\n  }\n}\n", "import { createSparseSet, createUint32SparseSet, type SparseSet } from './utils/SparseSet'\nimport { hasComponent, registerComponent } from './Component'\nimport { ComponentRef, ComponentData } from './Component'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { $internal } from './World'\nimport { createObservable } from './utils/Observer'\nimport { EntityId, Prefab } from './Entity'\n\n/**\n * @typedef {Uint32Array | readonly number[]} QueryResult\n * @description The result of a query, either as a Uint32Array or a readonly array of numbers.\n */\nexport type QueryResult = Uint32Array | readonly EntityId[]\n\n/**\n * @typedef {Object} Query\n * @description Represents a query in the ECS.\n * @property {ComponentRef[]} allComponents - All components in the query.\n * @property {ComponentRef[]} orComponents - Components in an OR relationship.\n * @property {ComponentRef[]} notComponents - Components that should not be present.\n * @property {Object.<number, number>} masks - Bitmasks for each component generation.\n * @property {Object.<number, number>} orMasks - OR bitmasks for each component generation.\n * @property {Object.<number, number>} notMasks - NOT bitmasks for each component generation.\n * @property {Object.<number, number>} hasMasks - HAS bitmasks for each component generation.\n * @property {number[]} generations - Component generations.\n * @property {SparseSet} toRemove - Set of entities to be removed.\n * @property {ReturnType<typeof createObservable>} addObservable - Observable for entity additions.\n * @property {ReturnType<typeof createObservable>} removeObservable - Observable for entity removals.\n */\nexport type Query = SparseSet & {\n\tallComponents: ComponentRef[]\n\torComponents: ComponentRef[]\n\tnotComponents: ComponentRef[]\n\tmasks: Record<number, number>\n\torMasks: Record<number, number>\n\tnotMasks: Record<number, number>\n\thasMasks: Record<number, number>\n\tgenerations: number[]\n\ttoRemove: SparseSet\n\taddObservable: ReturnType<typeof createObservable>\n\tremoveObservable: ReturnType<typeof createObservable>\n\tqueues: Record<any, any>\n}\n\n/**\n * @typedef {'Or' | 'And' | 'Not'} QueryOperatorType\n * @description Types of query operators.\n */\nexport type QueryOperatorType = 'Or' | 'And' | 'Not'\n/**\n * Symbol for query operator type.\n * @type {Symbol}\n */\nexport const $opType = Symbol.for('bitecs-opType')\n\n/**\n * Symbol for query operator terms.\n * @type {Symbol}\n */\nexport const $opTerms = Symbol.for('bitecs-opTerms')\n\n/**\n * @typedef {Object} OpReturnType\n * @property {symbol} [$opType] - The type of the operator.\n * @property {symbol} [$opTerms] - The components involved in the operation.\n */\nexport type OpReturnType = {\n\t[$opType]: string\n\t[$opTerms]: ComponentRef[]\n}\n\n/**\n * @typedef {Function} QueryOperator\n * @description A function that creates a query operator.\n * @param {...ComponentRef} components - The components to apply the operator to.\n * @returns {OpReturnType} The result of the operator.\n */\nexport type QueryOperator = (...components: ComponentRef[]) => OpReturnType\n\n/**\n * @typedef {ComponentRef | QueryOperator} QueryTerm\n * @description A term in a query, either a component reference or a query operator.\n */\nexport type QueryTerm = ComponentRef | QueryOperator\n\n\n// Aliases\nexport type OrOp = QueryOperator\nexport type AndOp = QueryOperator\nexport type NotOp = QueryOperator\nexport type AnyOp = OrOp\nexport type AllOp = AndOp\nexport type NoneOp = NotOp\n\n/**\n * @function Or\n * @description Creates an 'Or' query operator.\n * @param {...ComponentRef} components - The components to apply the 'Or' operator to.\n * @returns {OpReturnType} The 'Or' operator configuration.\n */\nexport const Or: OrOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'Or',\n\t[$opTerms]: components\n})\n\n/**\n * @function And\n * @description Creates an 'And' query operator.\n * @param {...ComponentRef} components - The components to apply the 'And' operator to.\n * @returns {OpReturnType} The 'And' operator configuration.\n */\nexport const And: AndOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'And',\n\t[$opTerms]: components\n})\n\n/**\n * @function Not\n * @description Creates a 'Not' query operator.\n * @param {...ComponentRef} components - The components to apply the 'Not' operator to.\n * @returns {OpReturnType} The 'Not' operator configuration.\n */\nexport const Not: NotOp = (...components: ComponentRef[]) => ({\n\t[$opType]: 'Not',\n\t[$opTerms]: components\n})\n\nexport const Any: AnyOp = Or\nexport const All: AllOp = And\nexport const None: NoneOp = Not\n\n/**\n * @typedef {Function} ObservableHook\n * @description A function that creates an observable hook for queries.\n * @param {...QueryTerm} terms - The query terms to observe.\n * @returns {{type: 'add' | 'remove' | 'set', terms: QueryTerm[]}} The observable hook configuration.\n */\nexport type ObservableHookDef = (...terms: QueryTerm[]) => {\n\t[$opType]: 'add' | 'remove' | 'set' | 'get'\n\t[$opTerms]: QueryTerm[]\n}\n\nexport type ObservableHook = ReturnType<ObservableHookDef>\n\n/**\n * @function onAdd\n * @description Creates an 'add' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for addition.\n * @returns {OpReturnType} The 'add' observable hook configuration.\n */\nexport const onAdd: ObservableHookDef = (...terms: QueryTerm[]) => ({\n\t[$opType]: 'add',\n\t[$opTerms]: terms\n})\n\n/**\n * @function onRemove\n * @description Creates a 'remove' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for removal.\n * @returns {OpReturnType} The 'remove' observable hook configuration.\n */\nexport const onRemove: ObservableHookDef = (...terms: QueryTerm[]) => ({\n\t[$opType]: 'remove',\n\t[$opTerms]: terms\n})\n\n/**\n * @function onSet\n * @description Creates a 'set' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for setting.\n * @returns {OpReturnType} The 'set' observable hook configuration.\n */\nexport const onSet: ObservableHookDef = (component: ComponentRef) => ({\n\t[$opType]: 'set',\n\t[$opTerms]: [component]\n})\n\n/**\n * @function onGet\n * @description Creates a 'get' observable hook.\n * @param {...QueryTerm} terms - The query terms to observe for getting.\n * @returns {OpReturnType} The 'get' observable hook configuration.\n */\nexport const onGet: ObservableHookDef = (component: ComponentRef) => ({\n\t[$opType]: 'get',\n\t[$opTerms]: [component]\n})\n\n/**\n * @function observe\n * @description Observes changes in entities based on specified components.\n * @param {World} world - The world object.\n * @param {ObservableHook} hook - The observable hook.\n * @param {function(number): any} callback - The callback function to execute when changes occur.\n * @returns {function(): void} A function to unsubscribe from the observation.\n */\nexport function observe(world: World, hook: ObservableHook, callback: (eid: EntityId, ...args: any[]) => any): () => void {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { [$opType]: type, [$opTerms]: components } = hook\n\n\tif (type === 'add' || type === 'remove') {\n\t\tconst hash = queryHash(world, components)\n\t\tlet queryData = ctx.queriesHashMap.get(hash)!\n\n\t\tif (!queryData) {\n\t\t\tqueryData = registerQuery(world, components)\n\t\t}\n\n\t\tconst observableKey = type === 'add' ? 'addObservable' : 'removeObservable'\n\t\treturn queryData[observableKey].subscribe(callback)\n\t} else if (type === 'set' || type === 'get') {\n\t\tif (components.length !== 1) {\n\t\t\tthrow new Error('Set and Get hooks can only observe a single component')\n\t\t}\n\t\tconst component = components[0]\n\t\tlet componentData = ctx.componentMap.get(component)\n\t\tif (!componentData) {\n\t\t\tcomponentData = registerComponent(world, component)\n\t\t}\n\t\tconst observableKey = type === 'set' ? 'setObservable' : 'getObservable'\n\t\treturn componentData[observableKey].subscribe(callback)\n\t}\n\n\tthrow new Error(`Invalid hook type: ${type}`)\n}\n\n/**\n * @function queryHash\n * @description Generates a hash for a query based on its terms.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {string} The generated hash.\n */\nexport const queryHash = (world: World, terms: QueryTerm[]): string => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\n\tconst getComponentId = (component: ComponentRef): number => {\n\t\tif (!ctx.componentMap.has(component)) {\n\t\t\tregisterComponent(world, component)\n\t\t}\n\t\treturn ctx.componentMap.get(component)!.id\n\t}\n\tconst termToString = (term: QueryTerm): string => {\n\t\tif ($opType in term) {\n\t\t\tconst componentIds = term[$opTerms].map(getComponentId)\n\t\t\tconst sortedComponentIds = componentIds.sort((a, b) => a - b)\n\t\t\tconst sortedType = term[$opType].toLowerCase()\n\t\t\treturn `${sortedType}(${sortedComponentIds.join(',')})`\n\t\t} else {\n\t\t\treturn getComponentId(term).toString()\n\t\t}\n\t}\n\n\treturn terms\n\t\t.map(termToString)\n\t\t.sort()\n\t\t.join('-')\n}\n\n/**\n * @function registerQuery\n * @description Registers a new query in the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {Query} The registered query.\n */\nexport const registerQuery = (world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): Query => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\t// if (ctx.queriesHashMap.has(hash)) {\n\t// \treturn ctx.queriesHashMap.get(hash)!\n\t// }\n\tconst components: ComponentRef[] = []\n\tconst notComponents: ComponentRef[] = []\n\tconst orComponents: ComponentRef[] = []\n\n\tconst processComponents = (comps: ComponentRef[], targetArray: ComponentRef[]) => {\n\t\tcomps.forEach((comp: ComponentRef) => {\n\t\t\tif (!ctx.componentMap.has(comp)) registerComponent(world, comp)\n\t\t\ttargetArray.push(comp)\n\t\t})\n\t}\n\n\tterms.forEach((term: QueryTerm) => {\n\t\tif ($opType in term) {\n\t\t\tif (term[$opType] === 'Not') {\n\t\t\t\tprocessComponents(term[$opTerms], notComponents)\n\t\t\t} else if (term[$opType] === 'Or') {\n\t\t\t\tprocessComponents(term[$opTerms], orComponents)\n\t\t\t}\n\t\t} else {\n\t\t\tif (!ctx.componentMap.has(term)) registerComponent(world, term)\n\t\t\tcomponents.push(term)\n\t\t}\n\t})\n\n\tconst mapComponents = (c: ComponentRef) => ctx.componentMap.get(c)!\n\tconst allComponents = components.concat(notComponents.flat()).concat(orComponents.flat()).map(mapComponents)\n\n\tconst sparseSet = options.buffered ? createUint32SparseSet() : createSparseSet()\n\n\tconst toRemove = createSparseSet()\n\n\tconst generations = allComponents\n\t\t.map((c) => c.generationId)\n\t\t.reduce((a, v) => {\n\t\t\tif (a.includes(v)) return a\n\t\t\ta.push(v)\n\t\t\treturn a\n\t\t}, [] as number[])\n\n\tconst reduceBitflags = (a: { [key: number]: number }, c: ComponentData) => {\n\t\tif (!a[c.generationId]) a[c.generationId] = 0\n\t\ta[c.generationId] |= c.bitflag\n\t\treturn a\n\t}\n\n\tconst masks = components.map(mapComponents).reduce(reduceBitflags, {})\n\tconst notMasks = notComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst orMasks = orComponents.map(mapComponents).reduce(reduceBitflags, {})\n\tconst hasMasks = allComponents.reduce(reduceBitflags, {})\n\n\tconst addObservable = createObservable()\n\tconst removeObservable = createObservable()\n\n\tconst query = Object.assign(sparseSet, {\n\t\tcomponents,\n\t\tnotComponents,\n\t\torComponents,\n\t\tallComponents,\n\t\tmasks,\n\t\tnotMasks,\n\t\torMasks,\n\t\thasMasks,\n\t\tgenerations,\n\t\ttoRemove,\n\t\taddObservable,\n\t\tremoveObservable,\n\t\tqueues: {},\n\t}) as Query\n\n\tctx.queries.add(query)\n\n\tctx.queriesHashMap.set(hash, query)\n\n\tallComponents.forEach((c) => {\n\t\tc.queries.add(query)\n\t})\n\n\tif (notComponents.length) ctx.notQueries.add(query)\n\n\tconst entityIndex = ctx.entityIndex\n\tfor (let i = 0; i < entityIndex.aliveCount; i++) {\n\t\tconst eid = entityIndex.dense[i]\n\t\tif (hasComponent(world, eid, Prefab)) continue\n\t\tconst match = queryCheckEntity(world, query, eid)\n\t\tif (match) {\n\t\t\tqueryAddEntity(query, eid)\n\t\t}\n\t}\n\n\treturn query\n}\n\n/**\n * @function innerQuery\n * @description Performs an internal query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @param {Object} [options] - Additional options.\n * @param {boolean} [options.buffered] - Whether the query should be buffered.\n * @returns {QueryResult} The result of the query.\n */\nexport function innerQuery(world: World, terms: QueryTerm[], options: { buffered?: boolean } = {}): QueryResult {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tlet queryData = ctx.queriesHashMap.get(hash)\n\tif (!queryData) {\n\t\tqueryData = registerQuery(world, terms, options)\n\t} else if (options.buffered && !('buffer' in queryData.dense)) {\n\t\tqueryData = registerQuery(world, terms, { buffered: true })\n\t}\n\treturn queryData.dense\n}\n\n/**\n * @function query\n * @description Performs a query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {readonly EntityId[]} The result of the query as a readonly array of entity IDs.\n */\nexport function query(world: World, terms: QueryTerm[]): readonly EntityId[] {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms) as EntityId[]\n}\n\n/**\n * @function bufferQuery\n * @description Performs a buffered query operation.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms.\n * @returns {Uint32Array} The result of the query as a Uint32Array.\n */\nexport function bufferQuery(world: World, terms: QueryTerm[]): Uint32Array {\n\tcommitRemovals(world)\n\treturn innerQuery(world, terms, { buffered: true }) as Uint32Array\n}\n\n/**\n * @function queryCheckEntity\n * @description Checks if an entity matches a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to check against.\n * @param {number} eid - The entity ID to check.\n * @returns {boolean} True if the entity matches the query, false otherwise.\n */\nexport function queryCheckEntity(world: World, query: Query, eid: EntityId): boolean {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst { masks, notMasks, orMasks, generations } = query\n\n\tfor (let i = 0; i < generations.length; i++) {\n\t\tconst generationId = generations[i]\n\t\tconst qMask = masks[generationId]\n\t\tconst qNotMask = notMasks[generationId]\n\t\tconst qOrMask = orMasks[generationId]\n\t\tconst eMask = ctx.entityMasks[generationId][eid]\n\n\t\tif (qNotMask && (eMask & qNotMask) !== 0) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qMask && (eMask & qMask) !== qMask) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (qOrMask && (eMask & qOrMask) === 0) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n/**\n * @function queryCheckComponent\n * @description Checks if a component matches a query.\n * @param {Query} query - The query to check against.\n * @param {ComponentData} c - The component data to check.\n * @returns {boolean} True if the component matches the query, false otherwise.\n */\nexport const queryCheckComponent = (query: Query, c: ComponentData) => {\n\tconst { generationId, bitflag } = c\n\tconst { hasMasks } = query\n\tconst mask = hasMasks[generationId]\n\treturn (mask & bitflag) === bitflag\n}\n\n/**\n * @function queryAddEntity\n * @description Adds an entity to a query.\n * @param {Query} query - The query to add the entity to.\n * @param {number} eid - The entity ID to add.\n */\nexport const queryAddEntity = (query: Query, eid: EntityId) => {\n\tquery.toRemove.remove(eid)\n\n\tquery.addObservable.notify(eid)\n\n\tquery.add(eid)\n}\n\n/**\n * @function queryCommitRemovals\n * @description Commits removals for a query.\n * @param {Query} query - The query to commit removals for.\n */\nconst queryCommitRemovals = (query: Query) => {\n\tfor (let i = 0; i < query.toRemove.dense.length; i++) {\n\t\tconst eid = query.toRemove.dense[i]\n\n\t\tquery.remove(eid)\n\t}\n\tquery.toRemove.reset()\n}\n\n/**\n * @function commitRemovals\n * @description Commits all pending removals for queries in the world.\n * @param {World} world - The world object.\n */\nexport const commitRemovals = (world: World) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!ctx.dirtyQueries.size) return\n\tctx.dirtyQueries.forEach(queryCommitRemovals)\n\tctx.dirtyQueries.clear()\n}\n\n/**\n * @function queryRemoveEntity\n * @description Removes an entity from a query.\n * @param {World} world - The world object.\n * @param {Query} query - The query to remove the entity from.\n * @param {number} eid - The entity ID to remove.\n */\nexport const queryRemoveEntity = (world: World, query: Query, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst has = query.has(eid)\n\tif (!has || query.toRemove.has(eid)) return\n\tquery.toRemove.add(eid)\n\tctx.dirtyQueries.add(query)\n\tquery.removeObservable.notify(eid)\n}\n\n/**\n * @function removeQuery\n * @description Removes a query from the world.\n * @param {World} world - The world object.\n * @param {QueryTerm[]} terms - The query terms of the query to remove.\n */\nexport const removeQuery = (world: World, terms: QueryTerm[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst hash = queryHash(world, terms)\n\tconst query = ctx.queriesHashMap.get(hash)\n\tif (query) {\n\t\tctx.queries.delete(query)\n\t\tctx.queriesHashMap.delete(hash)\n\t}\n}\n", "import { getEntityComponents, World } from '.'\nimport { EntityId } from './Entity'\nimport { defineHiddenProperty } from './utils/defineHiddenProperty'\n\n/**\n * Callback function type for when a target is removed from a relation.\n * @callback OnTargetRemovedCallback\n * @param {number} subject - The subject entity ID.\n * @param {number} target - The target entity ID.\n */\nexport type OnTargetRemovedCallback = (subject: EntityId, target: EntityId) => void\n\n/**\n * Possible types for a relation target.\n * @typedef {number | '*' | typeof Wildcard} RelationTarget\n */\nexport type RelationTarget = number | '*' | typeof Wildcard\n/**\n * Symbol for accessing the relation of a component.\n * @type {Symbol}\n */\nexport const $relation = Symbol.for('bitecs-relation')\n\n/**\n * Symbol for accessing the pair target of a component.\n * @type {Symbol}\n */\nexport const $pairTarget = Symbol.for('bitecs-pairTarget')\n\n/**\n * Symbol for checking if a component is a pair component.\n * @type {Symbol}\n */\nexport const $isPairComponent = Symbol.for('bitecs-isPairComponent')\n\n/**\n * Symbol for accessing the relation data of a component.\n * @type {Symbol}\n */\nexport const $relationData = Symbol.for('bitecs-relationData')\n\n/**\n * Interface for relation data.\n * @interface RelationData\n * @template T\n */\ntype RelationData<T> = {\n    pairsMap: Map<number | string | Relation<any>, T>\n    initStore: (eid: EntityId) => T\n    exclusiveRelation: boolean\n    autoRemoveSubject: boolean\n    onTargetRemoved: OnTargetRemovedCallback\n}\n\n/**\n * Type definition for a Relation function.\n * @template T\n * @typedef {function} Relation\n * @param {RelationTarget} target - The target of the relation.\n * @returns {T} The relation component.\n */\nexport type Relation<T> = (target: RelationTarget) => T\n\n/**\n * Creates a base relation.\n * @template T\n * @returns {Relation<T>} The created base relation.\n */\nconst createBaseRelation = <T>(): Relation<T> => {\n    const data = {\n        pairsMap: new Map(),\n        initStore: undefined,\n        exclusiveRelation: false,\n        autoRemoveSubject: false,\n        onTargetRemoved: undefined\n    }\n    const relation = (target: RelationTarget): T => {\n        if (target === undefined) throw Error('Relation target is undefined')\n        const normalizedTarget = target === '*' ? Wildcard : target\n        if (!data.pairsMap.has(normalizedTarget)) {\n            const component = data.initStore ? data.initStore(target) : {} as T\n            defineHiddenProperty(component, $relation, relation)\n            defineHiddenProperty(component, $pairTarget, normalizedTarget)\n            defineHiddenProperty(component, $isPairComponent, true)\n            data.pairsMap.set(normalizedTarget, component)\n        }\n\n        return data.pairsMap.get(normalizedTarget)!\n    }\n\n    defineHiddenProperty(relation, $relationData, data)\n\n    return relation as Relation<T>\n}\n\n/**\n * Adds a store to a relation.\n * @template T\n * @param {function(): T} createStore - Function to create the store.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withStore = <T>(createStore: (eid: EntityId) => T) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.initStore = createStore\n    return relation\n}\n\n/**\n * Makes a relation exclusive.\n * @template T\n * @param {Relation<T>} relation - The relation to make exclusive.\n * @returns {Relation<T>} The modified relation.\n */\nexport const makeExclusive = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.exclusiveRelation = true\n    return relation\n}\n\n/**\n * Adds auto-remove subject behavior to a relation.\n * @template T\n * @param {Relation<T>} relation - The relation to modify.\n * @returns {Relation<T>} The modified relation.\n */\nexport const withAutoRemoveSubject = <T>(relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.autoRemoveSubject = true\n    return relation\n}\n\n/**\n * Adds an onTargetRemoved callback to a relation.\n * @template T\n * @param {OnTargetRemovedCallback} onRemove - The callback to add.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nexport const withOnTargetRemoved = <T>(onRemove: OnTargetRemovedCallback) => (relation: Relation<T>): Relation<T> => {\n    const ctx = relation[$relationData] as RelationData<T>\n    ctx.onTargetRemoved = onRemove\n    return relation\n}\n\n// TODO: withSetter\n/**\n * Adds validation to a relation.\n * @template T\n * @param {function(T): boolean} validateFn - The validation function.\n * @returns {function(Relation<T>): Relation<T>} A function that modifies the relation.\n */\nconst withValidation = <T>(validateFn: (value: T) => boolean) => (relation: Relation<T>): Relation<T> => {\n    const originalRelation = relation\n    return ((target: RelationTarget): T => {\n        const component = originalRelation(target)\n        if (!validateFn(component)) {\n            throw new Error('Validation failed for relation component')\n        }\n        return component\n    }) as Relation<T>\n}\n\n/**\n * Creates a pair from a relation and a target.\n * @template T\n * @param {Relation<T>} relation - The relation.\n * @param {RelationTarget} target - The target.\n * @returns {T} The created pair.\n * @throws {Error} If the relation is undefined.\n */\nexport const Pair = <T>(relation: Relation<T>, target: RelationTarget): T => {\n    if (relation === undefined) throw Error('Relation is undefined')\n    return relation(target)\n}\n\n/**\n * Gets the relation targets for an entity.\n * @param {World} world - The world object.\n * @param {Relation<any>} relation - The relation to get targets for.\n * @param {number} eid - The entity ID.\n * @returns {Array<any>} An array of relation targets.\n */\nexport const getRelationTargets = (world: World, eid: EntityId, relation: Relation<any>): number[] => {\n\tconst components = getEntityComponents(world, eid)\n\tconst targets = []\n\tfor (const c of components) {\n\t\tif (c[$relation] === relation && c[$pairTarget] !== Wildcard && !isRelation(c[$pairTarget])) {\n\t\t\ttargets.push(c[$pairTarget])\n\t\t}\n\t}\n\treturn targets\n}\n\n/**\n * Creates a new relation.\n * @template T\n * @param {...Array<function(Relation<T>): Relation<T>>} modifiers - Modifier functions for the relation.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(...modifiers: Array<(relation: Relation<T>) => Relation<T>>): Relation<T>\n\n/**\n * Creates a new relation with options.\n * @template T\n * @param {Object} options - Options for creating the relation.\n * @param {function(): T} [options.store] - Function to create the store.\n * @param {boolean} [options.exclusive] - Whether the relation is exclusive.\n * @param {boolean} [options.autoRemoveSubject] - Whether to auto-remove the subject.\n * @param {OnTargetRemovedCallback} [options.onTargetRemoved] - Callback for when a target is removed.\n * @returns {Relation<T>} The created relation.\n */\nexport function createRelation<T>(options: {\n    store?: () => T\n    exclusive?: boolean\n    autoRemoveSubject?: boolean\n    onTargetRemoved?: OnTargetRemovedCallback\n}): Relation<T>\nexport function createRelation<T>(\n    ...args: Array<(relation: Relation<T>) => Relation<T>> | [{\n        store?: () => T\n        exclusive?: boolean\n        autoRemoveSubject?: boolean\n        onTargetRemoved?: OnTargetRemovedCallback\n    }]\n): Relation<T> {\n    if (args.length === 1 && typeof args[0] === 'object') {\n        const { store, exclusive, autoRemoveSubject, onTargetRemoved } = args[0]\n        const modifiers = [\n            store && withStore(store),\n            exclusive && makeExclusive,\n            autoRemoveSubject && withAutoRemoveSubject,\n            onTargetRemoved && withOnTargetRemoved(onTargetRemoved)\n        ].filter(Boolean) as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    } else {\n        const modifiers = args as Array<(relation: Relation<T>) => Relation<T>>\n        return modifiers.reduce((acc, modifier) => modifier(acc), createBaseRelation<T>())\n    }\n}\n\n/**\n * Symbol used to mark a relation as a wildcard relation\n */\nexport const $wildcard = Symbol.for('bitecs-wildcard')\n\n/**\n * Creates a wildcard relation that matches any target.\n * @template T\n * @returns {Relation<T>} The created wildcard relation.\n */\nexport function createWildcardRelation<T>(): Relation<T> {\n    const relation = createBaseRelation<T>()\n    Object.defineProperty(relation, $wildcard, {\n        value: true,\n        enumerable: false,\n        writable: false,\n        configurable: false\n    })\n    return relation\n}\n\n/**\n * Gets the singleton wildcard instance.\n * @returns {Relation<any>} The global wildcard relation instance.\n */\nexport function getWildcard(): Relation<any> {\n    const GLOBAL_WILDCARD = Symbol.for('bitecs-global-wildcard')\n    \n    if (!(globalThis as any)[GLOBAL_WILDCARD]) {\n        (globalThis as any)[GLOBAL_WILDCARD] = createWildcardRelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_WILDCARD]\n}\n\n/**\n * Wildcard relation.\n * @type {Relation<any>}\n */\nexport const Wildcard = getWildcard()\n\n/**\n * Creates an IsA relation.\n * @template T\n * @returns {Relation<T>} The created IsA relation.\n */\nexport function createIsARelation<T>(): Relation<T> {\n    return createBaseRelation<T>()\n}\n\n/**\n * Gets the singleton IsA instance.\n * @returns {Relation<any>} The global IsA relation instance.\n */\nexport function getIsA(): Relation<any> {\n    const GLOBAL_ISA = Symbol.for('bitecs-global-isa')\n    \n    if (!(globalThis as any)[GLOBAL_ISA]) {\n        (globalThis as any)[GLOBAL_ISA] = createIsARelation()\n    }\n    \n    return (globalThis as any)[GLOBAL_ISA]\n}\n\n/**\n * IsA relation.\n * @type {Relation<any>}\n */\nexport const IsA = getIsA()\n\n/**\n * Checks if a relation is a wildcard relation.\n * @param {any} relation - The relation to check.\n * @returns {boolean} True if the relation is a wildcard relation, false otherwise.\n */\nexport function isWildcard(relation: any): boolean {\n    if (!relation) return false\n    const symbols = Object.getOwnPropertySymbols(relation)\n    return symbols.includes($wildcard)\n}\n\n/**\n * Checks if a component is a relation.\n * @param {any} component - The component to check.\n * @returns {boolean} True if the component is a relation, false otherwise.\n */\nexport function isRelation(component: any): boolean {\n    if (!component) return false\n    const symbols = Object.getOwnPropertySymbols(component)\n    return symbols.includes($relationData)\n}\n", "import { entityExists, EntityId, getEntityComponents, Prefab } from './Entity'\nimport { queryAddEntity, queryCheckEntity, queryRemoveEntity } from './Query'\nimport { Query } from './Query'\nimport {\n\tIsA,\n\tPair,\n\tWildcard,\n\tgetRelationTargets,\n\t$relationData,\n\t$isPairComponent,\n\t$pairTarget,\n\t$relation\n} from './Relation'\nimport { createObservable, Observable } from './utils/Observer'\nimport { $internal, InternalWorld, World, WorldContext } from './World'\n\n/**\n * Represents a reference to a component.\n * @typedef {any} ComponentRef\n */\nexport type ComponentRef = any\n\n/**\n * Represents the data associated with a component.\n * @interface ComponentData\n * @property {number} id - The unique identifier for the component.\n * @property {number} generationId - The generation ID of the component.\n * @property {number} bitflag - The bitflag used for component masking.\n * @property {ComponentRef} ref - Reference to the component.\n * @property {Set<Query>} queries - Set of queries associated with the component.\n * @property {Observable} setObservable - Observable for component changes.\n */\nexport interface ComponentData {\n\tid: number\n\tgenerationId: number\n\tbitflag: number\n\tref: ComponentRef\n\tqueries: Set<Query>\n\tsetObservable: Observable\n\tgetObservable: Observable\n}\n\n/**\n * Registers a component with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef} component - The component to register.\n * @returns {ComponentData} The registered component data.\n * @throws {Error} If the component is null or undefined.\n */\nexport const registerComponent = (world: World, component: ComponentRef) => {\n\tif (!component) {\n\t\tthrow new Error(`bitECS - Cannot register null or undefined component`)\n\t}\n\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst queries = new Set<Query>()\n\n\tconst data: ComponentData = {\n\t\tid: ctx.componentCount++,\n\t\tgenerationId: ctx.entityMasks.length - 1,\n\t\tbitflag: ctx.bitflag,\n\t\tref: component,\n\t\tqueries,\n\t\tsetObservable: createObservable(),\n\t\tgetObservable: createObservable(),\n\t}\n\n\tctx.componentMap.set(component, data)\n\n\tctx.bitflag *= 2\n\tif (ctx.bitflag >= 2 ** 31) {\n\t\tctx.bitflag = 1\n\t\tctx.entityMasks.push([])\n\t}\n\n\treturn data\n}\n\n/**\n * Registers multiple components with the world.\n * @param {World} world - The world object.\n * @param {ComponentRef[]} components - Array of components to register.\n */\nexport const registerComponents = (world: World, components: ComponentRef[]) => {\n\tcomponents.forEach((component) => registerComponent(world, component))\n}\n\n/**\n * Checks if an entity has a specific component.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {ComponentRef} component - The component to check for.\n * @returns {boolean} True if the entity has the component, false otherwise.\n */\nexport const hasComponent = (world: World, eid: EntityId, component: ComponentRef): boolean => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst registeredComponent = ctx.componentMap.get(component)\n\tif (!registeredComponent) return false\n\n\tconst { generationId, bitflag } = registeredComponent\n\tconst mask = ctx.entityMasks[generationId][eid]\n\n\treturn (mask & bitflag) === bitflag\n}\n/**\n * Retrieves the data associated with a component for a specific entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {ComponentRef} component - The component to retrieve data for.\n * @returns {any} The component data, or undefined if the component is not found or the entity doesn't have the component.\n */\nexport const getComponentData = (world: World, eid: EntityId, component: ComponentRef): any => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst componentData = ctx.componentMap.get(component)\n\n\tif (!componentData) {\n\t\treturn undefined\n\t}\n\n\tif (!hasComponent(world, eid, component)) {\n\t\treturn undefined\n\t}\n\n\t// Notify observers that this component is being accessed\n\treturn componentData.getObservable.notify(eid)\n}\n\n/**\n * Helper function to set component data.\n * @param {ComponentRef} component - The component to set.\n * @param {any} data - The data to set for the component.\n * @returns {{ component: ComponentRef, data: any }} An object containing the component and its data.\n */\nexport const set = <T extends ComponentRef>(component: T, data: any): { component: T, data: any } => ({\n\tcomponent,\n\tdata\n})\n\n/**\n * Recursvely inherits components from one entity to another.\n * @param {World} world - The world object.\n * @param {number} baseEid - The ID of the entity inheriting components.\n * @param {number} inheritedEid - The ID of the entity being inherited from.\n * @param {boolean} isFirstSuper - Whether this is the first super in the inheritance chain.\n */\nconst recursivelyInherit = (ctx: WorldContext, world: World, baseEid: EntityId, inheritedEid: EntityId, visited = new Set<EntityId>()): void => {\n\t// Guard against circular inheritance\n\tif (visited.has(inheritedEid)) return\n\tvisited.add(inheritedEid)\n\t\n\t// Add IsA relation first\n\taddComponent(world, baseEid, IsA(inheritedEid))\n\t\n\t// Copy components and their data from this level\n\t// This needs to happen before recursing to ancestors so closer ancestors take precedence\n\tfor (const component of getEntityComponents(world, inheritedEid)) {\n\t\t// TODO: inherit reference vs copy\n\t\tif (component === Prefab) continue\n\t\t\n\t\t// Only add component if entity doesn't already have it\n\t\t// This ensures closer ancestors take precedence\n\t\tif (!hasComponent(world, baseEid, component)) {\n\t\t\taddComponent(world, baseEid, component)\n\t\t\t\n\t\t\tconst componentData = ctx.componentMap.get(component)\n\t\t\tif (componentData?.setObservable) {\n\t\t\t\tconst data = getComponentData(world, inheritedEid, component)\n\t\t\t\tcomponentData.setObservable.notify(baseEid, data)\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// Then recursively inherit from ancestors\n\t// This ensures more distant ancestors don't override closer ones\n\tfor (const parentEid of getRelationTargets(world, inheritedEid, IsA)) {\n\t\trecursivelyInherit(ctx, world, baseEid, parentEid, visited)\n\t}\n}\n\n/**\n * Represents a component with data to be set on an entity.\n */\ntype ComponentSetter<T = any> = { component: ComponentRef; data: T }\n\n/**\n * Adds one or more components to an entity.\n * @param {World} world - The world object.\n * @param {EntityId} eid - The entity ID.\n * @param {...(ComponentRef | ComponentSetter)} components - Components to add or set.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const addComponent = (world: World, eid: EntityId, ...components: (ComponentRef | ComponentSetter)[]): void => {\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot add component - entity ${eid} does not exist in the world.`)\n\t}\n\t\n\tconst ctx = (world as InternalWorld)[$internal]\n\t\n\tcomponents.forEach(componentOrSet => {\n\t\tconst component = 'component' in componentOrSet ? componentOrSet.component : componentOrSet\n\t\tconst data = 'data' in componentOrSet ? componentOrSet.data : undefined\n\n\t\tif (!ctx.componentMap.has(component)) registerComponent(world, component)\n\n\t\tconst componentData = ctx.componentMap.get(component)!\n\t\tif (data !== undefined) {\n\t\t\tcomponentData.setObservable.notify(eid, data)\n\t\t}\n\n\t\tif (hasComponent(world, eid, component)) return\n\n\t\tconst { generationId, bitflag, queries } = componentData\n\n\t\tctx.entityMasks[generationId][eid] |= bitflag\n\n\t\tif (!hasComponent(world, eid, Prefab)) {\n\t\t\tqueries.forEach((queryData: Query) => {\n\t\t\t\tqueryData.toRemove.remove(eid)\n\t\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t\t})\n\t\t}\n\t\tctx.entityComponents.get(eid)!.add(component)\n\t\tif (component[$isPairComponent]) {\n\t\t\tconst relation = component[$relation]\n\t\t\tconst target = component[$pairTarget]\n\n\t\t\t// Add both Wildcard pairs for relation and target\n\t\t\taddComponent(world, eid, Pair(relation, Wildcard))\n\t\t\taddComponent(world, eid, Pair(Wildcard, target))\n\n\t\t\t// For non-Wildcard targets, add Wildcard pair to track relation targets\n\t\t\tif (typeof target === 'number') {\n\t\t\t\t// Add Wildcard pair for target being a relation target\n\t\t\t\taddComponent(world, target, Pair(Wildcard, eid))\n\t\t\t\taddComponent(world, target, Pair(Wildcard, relation))\n\t\t\t\t// Track entities with relations for autoRemoveSubject\n\t\t\t\tctx.entitiesWithRelations.add(target)\n\t\t\t\tctx.entitiesWithRelations.add(eid)\n\t\t\t}\n\n\t\t\t// add target to a set to make autoRemoveSubject checks faster\n\t\t\tctx.entitiesWithRelations.add(target)\n\n\t\t\tconst relationData = relation[$relationData]\n\t\t\tif (relationData.exclusiveRelation === true && target !== Wildcard) {\n\t\t\t\tconst oldTarget = getRelationTargets(world, eid, relation)[0]\n\t\t\t\tif (oldTarget !== undefined && oldTarget !== null && oldTarget !== target) {\n\t\t\t\t\tremoveComponent(world, eid, relation(oldTarget))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (relation === IsA) {\n\t\t\t\tconst inheritedTargets = getRelationTargets(world, eid, IsA)\n\t\t\t\tfor (const inherited of inheritedTargets) {\n\t\t\t\t\trecursivelyInherit(ctx, world, eid, inherited)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n\n/**\n * Alias for addComponent.\n */\nexport const addComponents = addComponent\n\n/**\n * Removes one or more components from an entity.\n * @param {World} world - The world object.\n * @param {number} eid - The entity ID.\n * @param {...ComponentRef} components - Components to remove.\n * @throws {Error} If the entity does not exist in the world.\n */\nexport const removeComponent = (world: World, eid: EntityId, ...components: ComponentRef[]) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (!entityExists(world, eid)) {\n\t\tthrow new Error(`Cannot remove component - entity ${eid} does not exist in the world.`)\n\t}\n\n\tcomponents.forEach(component => {\n\t\tif (!hasComponent(world, eid, component)) return\n\n\t\tconst componentNode = ctx.componentMap.get(component)!\n\t\tconst { generationId, bitflag, queries } = componentNode\n\n\t\tctx.entityMasks[generationId][eid] &= ~bitflag\n\n\t\tqueries.forEach((queryData: Query) => {\n\t\t\tqueryData.toRemove.remove(eid)\n\n\t\t\tconst match = queryCheckEntity(world, queryData, eid)\n\n\t\t\tif (match) queryAddEntity(queryData, eid)\n\t\t\telse queryRemoveEntity(world, queryData, eid)\n\t\t})\n\n\t\tctx.entityComponents.get(eid)!.delete(component)\n\n\t\tif (component[$isPairComponent]) {\n\t\t\tconst target = component[$pairTarget]\n\t\t\tremoveComponent(world, eid, Pair(Wildcard, target))\n\n\t\t\tconst relation = component[$relation]\n\t\t\tconst otherTargets = getRelationTargets(world, eid, relation)\n\t\t\tif (otherTargets.length === 0) {\n\t\t\t\tremoveComponent(world, eid, Pair(relation, Wildcard))\n\t\t\t}\n\t\t}\n\t})\n}\n\n/**\n * Alias for removeComponent.\n */\nexport const removeComponents = removeComponent\n", "import { addComponent, removeComponent } from './Component'\nimport {\n\tinnerQuery,\n\tqueryAddEntity,\n\tqueryCheckEntity,\n\tqueryRemoveEntity,\n} from './Query'\nimport { Pair, Wildcard, $isPairComponent, $relation, $pairTarget, $relationData } from './Relation'\nimport { World } from \"./World\"\nimport { InternalWorld } from './World'\nimport { addEntityId, isEntityIdAlive, removeEntityId } from './EntityIndex'\nimport { $internal } from './World'\nimport { ComponentRef } from './Component'\n\nexport type EntityId = number\n\nexport const Prefab = {}\nexport const addPrefab = (world: World): EntityId => {\n\tconst eid = addEntity(world)\n\n\taddComponent(world, eid, Prefab)\n\n\treturn eid\n}\n\n/**\n * Adds a new entity to the specified world.\n *\n * @param {World} world\n * @returns {number} eid\n */\nexport const addEntity = (world: World): EntityId => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tconst eid = addEntityId(ctx.entityIndex)\n\n\tctx.notQueries.forEach((q) => {\n\t\tconst match = queryCheckEntity(world, q, eid)\n\t\tif (match) queryAddEntity(q, eid)\n\t})\n\n\tctx.entityComponents.set(eid, new Set())\n\n\treturn eid\n}\n\n/**\n * Removes an existing entity from the specified world.\n *\n * @param {World} world\n * @param {number} eid\n */\n\nexport const removeEntity = (world: World, eid: EntityId) => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\t// Check if entity is already removed\n\tif (!isEntityIdAlive(ctx.entityIndex, eid)) return\n\n\t// Remove relation components from entities that have a relation to this one, breadth-first\n\t// e.g. addComponent(world, child, ChildOf(parent))\n\t// when parent is removed, we need to remove the child\n\tconst removalQueue = [eid]\n\tconst processedEntities = new Set()\n    while (removalQueue.length > 0) {\n        \n\t\tconst currentEid = removalQueue.shift()!\n        if (processedEntities.has(currentEid)) continue\n        processedEntities.add(currentEid)\n\n        const componentRemovalQueue = []\n\n\t\tif (ctx.entitiesWithRelations.has(currentEid)) {\n\t\t\tfor (const subject of innerQuery(world, [Wildcard(currentEid)])) {\n\t\t\t\tif (!entityExists(world, subject)) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tfor (const component of ctx.entityComponents.get(subject)!) {\n\t\t\t\t\tif (!component[$isPairComponent]) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tconst relation = component[$relation]\n\t\t\t\t\tconst relationData = relation[$relationData]\n\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, Pair(Wildcard, currentEid)))\n\n\t\t\t\t\tif (component[$pairTarget] === currentEid) {\n\t\t\t\t\t\tcomponentRemovalQueue.push(() => removeComponent(world, subject, component))\n\t\t\t\t\t\tif (relationData.autoRemoveSubject) {\n\t\t\t\t\t\t\tremovalQueue.push(subject)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (relationData.onTargetRemoved) {\n\t\t\t\t\t\t\tcomponentRemovalQueue.push(() => relationData.onTargetRemoved(world, subject, currentEid))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctx.entitiesWithRelations.delete(currentEid)\n\t\t}\n\n        for (const removeOperation of componentRemovalQueue) {\n            removeOperation()\n        }\n\n\t\tfor (const eid of removalQueue) {\n\t\t\tremoveEntity(world, eid)\n\t\t}\n\n\t\t// Remove entity from all queries\n\t\tfor (const query of ctx.queries) {\n\t\t\tqueryRemoveEntity(world, query, currentEid)\n\t\t}\n\n\t\t// Free the entity ID\n\t\tremoveEntityId(ctx.entityIndex, currentEid)\n\n\t\t// Remove all entity state from world\n\t\tctx.entityComponents.delete(currentEid)\n\n\t\t// Clear entity bitmasks\n\t\tfor (let i = 0; i < ctx.entityMasks.length; i++) {\n\t\t\tctx.entityMasks[i][currentEid] = 0\n\t\t}\n\t}\n}\n\n/**\n *  Returns an array of components that an entity possesses.\n *\n * @param {*} world\n * @param {*} eid\n */\nexport const getEntityComponents = (world: World, eid: EntityId): ComponentRef[] => {\n\tconst ctx = (world as InternalWorld)[$internal]\n\tif (eid === undefined) throw new Error(`getEntityComponents: entity id is undefined.`)\n\tif (!isEntityIdAlive(ctx.entityIndex, eid))\n\t\tthrow new Error(`getEntityComponents: entity ${eid} does not exist in the world.`)\n\treturn Array.from(ctx.entityComponents.get(eid)!)\n}\n\n/**\n * Checks the existence of an entity in a world\n *\n * @param {World} world\n * @param {number} eid\n */\nexport const entityExists = (world: World, eid: EntityId) => isEntityIdAlive((world as InternalWorld)[$internal].entityIndex, eid)\n", "type Func = (...args: any) => any\nexport const pipe = <T extends Func, U extends Func, R extends Func>\n    (...functions: [T, ...U[], R]): ((...args: Parameters<T>) => ReturnType<R>) => {\n    return (...args: Parameters<T>): ReturnType<R> => \n        functions.reduce((result, fn) => [fn(...result)], args as any)[0]\n}\n"],
  "mappings": "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",
  "names": ["defineHiddenProperty", "obj", "key", "value", "getId", "index", "id", "getVersion", "incrementVersion", "newVersion", "withVersioning", "versionBits", "createEntityIndex", "options", "config", "versioning", "entityBits", "entityMask", "versionShift", "versionMask", "addEntityId", "recycledId", "entityId", "removeEntityId", "denseIndex", "lastIndex", "lastId", "newId", "isEntityIdAlive", "$internal", "createBaseWorld", "context", "entityIndex", "createWorld", "args", "arg", "resetWorld", "world", "ctx", "deleteWorld", "getWorldComponents", "getAllEntities", "createSparseSet", "dense", "sparse", "has", "val", "swapped", "SharedArrayBufferOrArrayBuffer", "createUint32SparseSet", "initialCapacity", "length", "newDense", "createObservable", "observers", "observer", "entity", "acc", "listener", "result", "$opType", "$opTerms", "Or", "components", "And", "Not", "Any", "All", "None", "onAdd", "terms", "onRemove", "onSet", "component", "onGet", "observe", "hook", "callback", "type", "hash", "queryHash", "queryData", "registerQuery", "componentData", "registerComponent", "getComponentId", "termToString", "term", "sortedComponentIds", "a", "b", "notComponents", "orComponents", "processComponents", "comps", "targetArray", "comp", "mapComponents", "allComponents", "sparseSet", "toRemove", "generations", "v", "reduceBitflags", "c", "masks", "notMasks", "orMasks", "hasMasks", "addObservable", "removeObservable", "query", "i", "eid", "hasComponent", "Prefab", "queryCheckEntity", "queryAddEntity", "innerQuery", "commitRemovals", "generationId", "qMask", "qNotMask", "qOrMask", "eMask", "queryCommitRemovals", "queryRemoveEntity", "removeQuery", "$relation", "$pairTarget", "$isPairComponent", "$relationData", "createBaseRelation", "data", "relation", "target", "normalizedTarget", "Wildcard", "withStore", "createStore", "makeExclusive", "withAutoRemoveSubject", "withOnTargetRemoved", "Pair", "getRelationTargets", "getEntityComponents", "targets", "isRelation", "createRelation", "store", "exclusive", "autoRemoveSubject", "onTargetRemoved", "modifier", "$wildcard", "createWildcardRelation", "getWildcard", "GLOBAL_WILDCARD", "createIsARelation", "getIsA", "GLOBAL_ISA", "IsA", "isWildcard", "queries", "registerComponents", "registeredComponent", "bitflag", "getComponentData", "set", "recursivelyInherit", "baseEid", "inheritedEid", "visited", "addComponent", "parentEid", "entityExists", "componentOrSet", "oldTarget", "removeComponent", "inheritedTargets", "inherited", "addComponents", "componentNode", "removeComponents", "addPrefab", "addEntity", "q", "removeEntity", "removalQueue", "processedEntities", "currentEid", "componentRemovalQueue", "subject", "relationData", "removeOperation", "pipe", "functions", "fn"]
}
