{
  "version": 3,
  "sources": ["../../src/data/vectorOps.ts", "../../src/std/numeric.ts", "../../typed-binary/src/main-api.ts", "../../typed-binary/src/error.ts", "../../typed-binary/src/io/measurer.ts", "../../typed-binary/src/structure/types.ts", "../../typed-binary/src/structure/array.ts", "../../typed-binary/src/structure/baseTypes.ts", "../../typed-binary/src/structure/chars.ts", "../../typed-binary/src/structure/object.ts", "../../typed-binary/src/structure/concat.ts", "../../typed-binary/src/structure/dynamicArray.ts", "../../typed-binary/src/structure/keyed.ts", "../../typed-binary/src/structure/optional.ts", "../../typed-binary/src/structure/tuple.ts", "../../typed-binary/src/structure/typedArray.ts", "../../typed-binary/src/util.ts", "../../typed-binary/src/io/unwrapBuffer.ts", "../../typed-binary/src/io/bufferIOBase.ts", "../../typed-binary/src/io/float16converter.ts", "../../typed-binary/src/io/bufferReader.ts", "../../typed-binary/src/io/bufferWriter.ts", "../../typed-binary/src/index.ts"],
  "sourcesContent": ["import { mat2x2f, mat3x3f, mat4x4f } from './matrix.ts';\nimport {\n  vec2b,\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3b,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4b,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n} from './vector.ts';\nimport type * as wgsl from './wgslTypes.ts';\nimport type { VecKind } from './wgslTypes.ts';\n\ntype vBase = { kind: VecKind };\ntype mBase = { kind: MatKind };\ntype v2 = wgsl.v2f | wgsl.v2h | wgsl.v2i | wgsl.v2u;\ntype v3 = wgsl.v3f | wgsl.v3h | wgsl.v3i | wgsl.v3u;\ntype v4 = wgsl.v4f | wgsl.v4h | wgsl.v4i | wgsl.v4u;\n\ntype MatKind = 'mat2x2f' | 'mat3x3f' | 'mat4x4f';\n\nconst lengthVec2 = (v: v2) => Math.sqrt(v.x ** 2 + v.y ** 2);\nconst lengthVec3 = (v: v3) => Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2);\nconst lengthVec4 = (v: v4) =>\n  Math.sqrt(v.x ** 2 + v.y ** 2 + v.z ** 2 + v.w ** 2);\n\nconst dotVec2 = (lhs: v2, rhs: v2) => lhs.x * rhs.x + lhs.y * rhs.y;\nconst dotVec3 = (lhs: v3, rhs: v3) =>\n  lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z;\nconst dotVec4 = (lhs: v4, rhs: v4) =>\n  lhs.x * rhs.x + lhs.y * rhs.y + lhs.z * rhs.z + lhs.w * rhs.w;\n\nconst clamp = (value: number, low: number, high: number) =>\n  Math.min(Math.max(low, value), high);\n\ntype UnaryOp = (a: number) => number;\ntype BinaryOp = (a: number, b: number) => number;\n\nconst unary2f = (op: UnaryOp) => (a: wgsl.v2f) => vec2f(op(a.x), op(a.y));\nconst unary2h = (op: UnaryOp) => (a: wgsl.v2h) => vec2h(op(a.x), op(a.y));\nconst unary2i = (op: UnaryOp) => (a: wgsl.v2i) => vec2i(op(a.x), op(a.y));\nconst unary2u = (op: UnaryOp) => (a: wgsl.v2u) => vec2u(op(a.x), op(a.y));\n\nconst unary3f = (op: UnaryOp) => (a: wgsl.v3f) =>\n  vec3f(op(a.x), op(a.y), op(a.z));\n\nconst unary3h = (op: UnaryOp) => (a: wgsl.v3h) =>\n  vec3h(op(a.x), op(a.y), op(a.z));\n\nconst unary3i = (op: UnaryOp) => (a: wgsl.v3i) =>\n  vec3i(op(a.x), op(a.y), op(a.z));\n\nconst unary3u = (op: UnaryOp) => (a: wgsl.v3u) =>\n  vec3u(op(a.x), op(a.y), op(a.z));\n\nconst unary4f = (op: UnaryOp) => (a: wgsl.v4f) =>\n  vec4f(op(a.x), op(a.y), op(a.z), op(a.w));\n\nconst unary4h = (op: UnaryOp) => (a: wgsl.v4h) =>\n  vec4h(op(a.x), op(a.y), op(a.z), op(a.w));\n\nconst unary4i = (op: UnaryOp) => (a: wgsl.v4i) =>\n  vec4i(op(a.x), op(a.y), op(a.z), op(a.w));\n\nconst unary4u = (op: UnaryOp) => (a: wgsl.v4u) =>\n  vec4u(op(a.x), op(a.y), op(a.z), op(a.w));\n\nconst unary2x2f = (op: UnaryOp) => (a: wgsl.m2x2f) => {\n  const a_ = a.columns as [wgsl.v2f, wgsl.v2f];\n  return mat2x2f(unary2f(op)(a_[0]), unary2f(op)(a_[1]));\n};\n\nconst unary3x3f = (op: UnaryOp) => (a: wgsl.m3x3f) => {\n  const a_ = a.columns as [wgsl.v3f, wgsl.v3f, wgsl.v3f];\n  return mat3x3f(unary3f(op)(a_[0]), unary3f(op)(a_[1]), unary3f(op)(a_[2]));\n};\n\nconst unary4x4f = (op: UnaryOp) => (a: wgsl.m4x4f) => {\n  const a_ = a.columns as [wgsl.v4f, wgsl.v4f, wgsl.v4f, wgsl.v4f];\n  return mat4x4f(\n    unary4f(op)(a_[0]),\n    unary4f(op)(a_[1]),\n    unary4f(op)(a_[2]),\n    unary4f(op)(a_[3]),\n  );\n};\n\nconst binaryComponentWise2f = (op: BinaryOp) => (a: wgsl.v2f, b: wgsl.v2f) =>\n  vec2f(op(a.x, b.x), op(a.y, b.y));\n\nconst binaryComponentWise2h = (op: BinaryOp) => (a: wgsl.v2h, b: wgsl.v2h) =>\n  vec2h(op(a.x, b.x), op(a.y, b.y));\n\nconst binaryComponentWise2i = (op: BinaryOp) => (a: wgsl.v2i, b: wgsl.v2i) =>\n  vec2i(op(a.x, b.x), op(a.y, b.y));\n\nconst binaryComponentWise2u = (op: BinaryOp) => (a: wgsl.v2u, b: wgsl.v2u) =>\n  vec2u(op(a.x, b.x), op(a.y, b.y));\n\nconst binaryComponentWise3f = (op: BinaryOp) => (a: wgsl.v3f, b: wgsl.v3f) =>\n  vec3f(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z));\n\nconst binaryComponentWise3h = (op: BinaryOp) => (a: wgsl.v3h, b: wgsl.v3h) =>\n  vec3h(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z));\n\nconst binaryComponentWise3i = (op: BinaryOp) => (a: wgsl.v3i, b: wgsl.v3i) =>\n  vec3i(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z));\n\nconst binaryComponentWise3u = (op: BinaryOp) => (a: wgsl.v3u, b: wgsl.v3u) =>\n  vec3u(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z));\n\nconst binaryComponentWise4f = (op: BinaryOp) => (a: wgsl.v4f, b: wgsl.v4f) =>\n  vec4f(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z), op(a.w, b.w));\n\nconst binaryComponentWise4h = (op: BinaryOp) => (a: wgsl.v4h, b: wgsl.v4h) =>\n  vec4h(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z), op(a.w, b.w));\n\nconst binaryComponentWise4i = (op: BinaryOp) => (a: wgsl.v4i, b: wgsl.v4i) =>\n  vec4i(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z), op(a.w, b.w));\n\nconst binaryComponentWise4u = (op: BinaryOp) => (a: wgsl.v4u, b: wgsl.v4u) =>\n  vec4u(op(a.x, b.x), op(a.y, b.y), op(a.z, b.z), op(a.w, b.w));\n\nconst binaryComponentWise2x2f =\n  (op: BinaryOp) => (a: wgsl.m2x2f, b: wgsl.m2x2f) => {\n    const a_ = a.columns as [wgsl.v2f, wgsl.v2f];\n    const b_ = b.columns as [wgsl.v2f, wgsl.v2f];\n    return mat2x2f(\n      binaryComponentWise2f(op)(a_[0], b_[0]),\n      binaryComponentWise2f(op)(a_[1], b_[1]),\n    );\n  };\n\nconst binaryComponentWise3x3f =\n  (op: BinaryOp) => (a: wgsl.m3x3f, b: wgsl.m3x3f) => {\n    const a_ = a.columns as [wgsl.v3f, wgsl.v3f, wgsl.v3f];\n    const b_ = b.columns as [wgsl.v3f, wgsl.v3f, wgsl.v3f];\n    return mat3x3f(\n      binaryComponentWise3f(op)(a_[0], b_[0]),\n      binaryComponentWise3f(op)(a_[1], b_[1]),\n      binaryComponentWise3f(op)(a_[2], b_[2]),\n    );\n  };\n\nconst binaryComponentWise4x4f =\n  (op: BinaryOp) => (a: wgsl.m4x4f, b: wgsl.m4x4f) => {\n    const a_ = a.columns as [wgsl.v4f, wgsl.v4f, wgsl.v4f, wgsl.v4f];\n    const b_ = b.columns as [wgsl.v4f, wgsl.v4f, wgsl.v4f, wgsl.v4f];\n    return mat4x4f(\n      binaryComponentWise4f(op)(a_[0], b_[0]),\n      binaryComponentWise4f(op)(a_[1], b_[1]),\n      binaryComponentWise4f(op)(a_[2], b_[2]),\n      binaryComponentWise4f(op)(a_[3], b_[3]),\n    );\n  };\n\nexport const NumberOps = {\n  divInteger: (lhs: number, rhs: number) => {\n    if (rhs === 0) {\n      return lhs;\n    }\n    return Math.trunc(lhs / rhs);\n  },\n};\n\nexport const VectorOps = {\n  eq: {\n    vec2f: (e1: wgsl.v2f, e2: wgsl.v2f) => vec2b(e1.x === e2.x, e1.y === e2.y),\n    vec2h: (e1: wgsl.v2h, e2: wgsl.v2h) => vec2b(e1.x === e2.x, e1.y === e2.y),\n    vec2i: (e1: wgsl.v2i, e2: wgsl.v2i) => vec2b(e1.x === e2.x, e1.y === e2.y),\n    vec2u: (e1: wgsl.v2u, e2: wgsl.v2u) => vec2b(e1.x === e2.x, e1.y === e2.y),\n    'vec2<bool>': (e1: wgsl.v2b, e2: wgsl.v2b) =>\n      vec2b(e1.x === e2.x, e1.y === e2.y),\n\n    vec3f: (e1: wgsl.v3f, e2: wgsl.v3f) =>\n      vec3b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z),\n    vec3h: (e1: wgsl.v3h, e2: wgsl.v3h) =>\n      vec3b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z),\n    vec3i: (e1: wgsl.v3i, e2: wgsl.v3i) =>\n      vec3b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z),\n    vec3u: (e1: wgsl.v3u, e2: wgsl.v3u) =>\n      vec3b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z),\n    'vec3<bool>': (e1: wgsl.v3b, e2: wgsl.v3b) =>\n      vec3b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z),\n\n    vec4f: (e1: wgsl.v4f, e2: wgsl.v4f) =>\n      vec4b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z, e1.w === e2.w),\n    vec4h: (e1: wgsl.v4h, e2: wgsl.v4h) =>\n      vec4b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z, e1.w === e2.w),\n    vec4i: (e1: wgsl.v4i, e2: wgsl.v4i) =>\n      vec4b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z, e1.w === e2.w),\n    vec4u: (e1: wgsl.v4u, e2: wgsl.v4u) =>\n      vec4b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z, e1.w === e2.w),\n    'vec4<bool>': (e1: wgsl.v4b, e2: wgsl.v4b) =>\n      vec4b(e1.x === e2.x, e1.y === e2.y, e1.z === e2.z, e1.w === e2.w),\n  } as Record<\n    VecKind,\n    <T extends wgsl.AnyVecInstance>(\n      e1: T,\n      e2: T,\n    ) => T extends wgsl.AnyVec2Instance ? wgsl.v2b\n      : T extends wgsl.AnyVec3Instance ? wgsl.v3b\n      : wgsl.v4b\n  >,\n\n  lt: {\n    vec2f: (e1: wgsl.v2f, e2: wgsl.v2f) => vec2b(e1.x < e2.x, e1.y < e2.y),\n    vec2h: (e1: wgsl.v2h, e2: wgsl.v2h) => vec2b(e1.x < e2.x, e1.y < e2.y),\n    vec2i: (e1: wgsl.v2i, e2: wgsl.v2i) => vec2b(e1.x < e2.x, e1.y < e2.y),\n    vec2u: (e1: wgsl.v2u, e2: wgsl.v2u) => vec2b(e1.x < e2.x, e1.y < e2.y),\n\n    vec3f: (e1: wgsl.v3f, e2: wgsl.v3f) =>\n      vec3b(e1.x < e2.x, e1.y < e2.y, e1.z < e2.z),\n    vec3h: (e1: wgsl.v3h, e2: wgsl.v3h) =>\n      vec3b(e1.x < e2.x, e1.y < e2.y, e1.z < e2.z),\n    vec3i: (e1: wgsl.v3i, e2: wgsl.v3i) =>\n      vec3b(e1.x < e2.x, e1.y < e2.y, e1.z < e2.z),\n    vec3u: (e1: wgsl.v3u, e2: wgsl.v3u) =>\n      vec3b(e1.x < e2.x, e1.y < e2.y, e1.z < e2.z),\n\n    vec4f: (e1: wgsl.v4f, e2: wgsl.v4f) =>\n      vec4b(e1.x < e2.x, e1.y < e2.y, e1.z < e2.z, e1.w < e2.w),\n    vec4h: (e1: wgsl.v4h, e2: wgsl.v4h) =>\n      vec4b(e1.x < e2.x, e1.y < e2.y, e1.z < e2.z, e1.w < e2.w),\n    vec4i: (e1: wgsl.v4i, e2: wgsl.v4i) =>\n      vec4b(e1.x < e2.x, e1.y < e2.y, e1.z < e2.z, e1.w < e2.w),\n    vec4u: (e1: wgsl.v4u, e2: wgsl.v4u) =>\n      vec4b(e1.x < e2.x, e1.y < e2.y, e1.z < e2.z, e1.w < e2.w),\n  } as Record<\n    VecKind,\n    <T extends wgsl.AnyNumericVecInstance>(\n      e1: T,\n      e2: T,\n    ) => T extends wgsl.AnyVec2Instance ? wgsl.v2b\n      : T extends wgsl.AnyVec3Instance ? wgsl.v3b\n      : wgsl.v4b\n  >,\n\n  or: {\n    'vec2<bool>': (e1: wgsl.v2b, e2: wgsl.v2b) =>\n      vec2b(e1.x || e2.x, e1.y || e2.y),\n    'vec3<bool>': (e1: wgsl.v3b, e2: wgsl.v3b) =>\n      vec3b(e1.x || e2.x, e1.y || e2.y, e1.z || e2.z),\n    'vec4<bool>': (e1: wgsl.v4b, e2: wgsl.v4b) =>\n      vec4b(e1.x || e2.x, e1.y || e2.y, e1.z || e2.z, e1.w || e2.w),\n  } as Record<\n    VecKind,\n    <T extends wgsl.AnyBooleanVecInstance>(e1: T, e2: T) => T\n  >,\n\n  all: {\n    'vec2<bool>': (e: wgsl.v2b) => e.x && e.y,\n    'vec3<bool>': (e: wgsl.v3b) => e.x && e.y && e.z,\n    'vec4<bool>': (e: wgsl.v4b) => e.x && e.y && e.z && e.w,\n  } as Record<VecKind, (v: wgsl.AnyBooleanVecInstance) => boolean>,\n\n  abs: {\n    vec2f: unary2f(Math.abs),\n    vec2h: unary2h(Math.abs),\n    vec2i: unary2i(Math.abs),\n    vec2u: unary2u(Math.abs),\n\n    vec3f: unary3f(Math.abs),\n    vec3h: unary3h(Math.abs),\n    vec3i: unary3i(Math.abs),\n    vec3u: unary3u(Math.abs),\n\n    vec4f: unary4f(Math.abs),\n    vec4h: unary4h(Math.abs),\n    vec4i: unary4i(Math.abs),\n    vec4u: unary4u(Math.abs),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  atan2: {\n    vec2f: binaryComponentWise2f(Math.atan2),\n    vec2h: binaryComponentWise2h(Math.atan2),\n\n    vec3f: binaryComponentWise3f(Math.atan2),\n    vec3h: binaryComponentWise3h(Math.atan2),\n\n    vec4f: binaryComponentWise4f(Math.atan2),\n    vec4h: binaryComponentWise4h(Math.atan2),\n  } as Record<VecKind, <T extends vBase>(a: T, b: T) => T>,\n\n  acos: {\n    vec2f: unary2f(Math.acos),\n    vec2h: unary2h(Math.acos),\n    vec2i: unary2i(Math.acos),\n    vec2u: unary2u(Math.acos),\n\n    vec3f: unary3f(Math.acos),\n    vec3h: unary3h(Math.acos),\n    vec3i: unary3i(Math.acos),\n    vec3u: unary3u(Math.acos),\n\n    vec4f: unary4f(Math.acos),\n    vec4h: unary4h(Math.acos),\n    vec4i: unary4i(Math.acos),\n    vec4u: unary4u(Math.acos),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  acosh: {\n    vec2f: unary2f(Math.acosh),\n    vec2h: unary2h(Math.acosh),\n\n    vec3f: unary3f(Math.acosh),\n    vec3h: unary3h(Math.acosh),\n\n    vec4f: unary4f(Math.acosh),\n    vec4h: unary4h(Math.acosh),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  asin: {\n    vec2f: unary2f(Math.asin),\n    vec2h: unary2h(Math.asin),\n    vec2i: unary2i(Math.asin),\n    vec2u: unary2u(Math.asin),\n\n    vec3f: unary3f(Math.asin),\n    vec3h: unary3h(Math.asin),\n    vec3i: unary3i(Math.asin),\n    vec3u: unary3u(Math.asin),\n\n    vec4f: unary4f(Math.asin),\n    vec4h: unary4h(Math.asin),\n    vec4i: unary4i(Math.asin),\n    vec4u: unary4u(Math.asin),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  ceil: {\n    vec2f: unary2f(Math.ceil),\n    vec2h: unary2h(Math.ceil),\n\n    vec3f: unary3f(Math.ceil),\n    vec3h: unary3h(Math.ceil),\n\n    vec4f: unary4f(Math.ceil),\n    vec4h: unary4h(Math.ceil),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  clamp: {\n    vec2f: (v: wgsl.v2f, low: wgsl.v2f, high: wgsl.v2f) =>\n      vec2f(clamp(v.x, low.x, high.x), clamp(v.y, low.y, high.y)),\n    vec2h: (v: wgsl.v2h, low: wgsl.v2h, high: wgsl.v2h) =>\n      vec2h(clamp(v.x, low.x, high.x), clamp(v.y, low.y, high.y)),\n    vec2i: (v: wgsl.v2i, low: wgsl.v2i, high: wgsl.v2i) =>\n      vec2i(clamp(v.x, low.x, high.x), clamp(v.y, low.y, high.y)),\n    vec2u: (v: wgsl.v2u, low: wgsl.v2u, high: wgsl.v2u) =>\n      vec2u(clamp(v.x, low.x, high.x), clamp(v.y, low.y, high.y)),\n\n    vec3f: (v: wgsl.v3f, low: wgsl.v3f, high: wgsl.v3f) =>\n      vec3f(\n        clamp(v.x, low.x, high.x),\n        clamp(v.y, low.y, high.y),\n        clamp(v.z, low.z, high.z),\n      ),\n    vec3h: (v: wgsl.v3h, low: wgsl.v3h, high: wgsl.v3h) =>\n      vec3h(\n        clamp(v.x, low.x, high.x),\n        clamp(v.y, low.y, high.y),\n        clamp(v.z, low.z, high.z),\n      ),\n    vec3i: (v: wgsl.v3i, low: wgsl.v3i, high: wgsl.v3f) =>\n      vec3i(\n        clamp(v.x, low.x, high.x),\n        clamp(v.y, low.y, high.y),\n        clamp(v.z, low.z, high.z),\n      ),\n    vec3u: (v: wgsl.v3u, low: wgsl.v3u, high: wgsl.v3f) =>\n      vec3u(\n        clamp(v.x, low.x, high.x),\n        clamp(v.y, low.y, high.y),\n        clamp(v.z, low.z, high.z),\n      ),\n\n    vec4f: (v: wgsl.v4f, low: wgsl.v4f, high: wgsl.v4f) =>\n      vec4f(\n        clamp(v.x, low.x, high.x),\n        clamp(v.y, low.y, high.y),\n        clamp(v.z, low.z, high.z),\n        clamp(v.w, low.w, high.w),\n      ),\n    vec4h: (v: wgsl.v4h, low: wgsl.v4h, high: wgsl.v4h) =>\n      vec4h(\n        clamp(v.x, low.x, high.x),\n        clamp(v.y, low.y, high.y),\n        clamp(v.z, low.z, high.z),\n        clamp(v.w, low.w, high.w),\n      ),\n    vec4i: (v: wgsl.v4i, low: wgsl.v4i, high: wgsl.v4i) =>\n      vec4i(\n        clamp(v.x, low.x, high.x),\n        clamp(v.y, low.y, high.y),\n        clamp(v.z, low.z, high.z),\n        clamp(v.w, low.w, high.w),\n      ),\n    vec4u: (v: wgsl.v4u, low: wgsl.v4u, high: wgsl.v4u) =>\n      vec4u(\n        clamp(v.x, low.x, high.x),\n        clamp(v.y, low.y, high.y),\n        clamp(v.z, low.z, high.z),\n        clamp(v.w, low.w, high.w),\n      ),\n  } as Record<VecKind, <T extends vBase>(v: T, low: T, high: T) => T>,\n\n  length: {\n    vec2f: lengthVec2,\n    vec2h: lengthVec2,\n\n    vec3f: lengthVec3,\n    vec3h: lengthVec3,\n\n    vec4f: lengthVec4,\n    vec4h: lengthVec4,\n  } as Record<VecKind, (v: vBase) => number>,\n\n  add: {\n    vec2f: binaryComponentWise2f((a, b) => a + b),\n    vec2h: binaryComponentWise2h((a, b) => a + b),\n    vec2i: binaryComponentWise2i((a, b) => a + b),\n    vec2u: binaryComponentWise2u((a, b) => a + b),\n\n    vec3f: binaryComponentWise3f((a, b) => a + b),\n    vec3h: binaryComponentWise3h((a, b) => a + b),\n    vec3i: binaryComponentWise3i((a, b) => a + b),\n    vec3u: binaryComponentWise3u((a, b) => a + b),\n\n    vec4f: binaryComponentWise4f((a, b) => a + b),\n    vec4h: binaryComponentWise4h((a, b) => a + b),\n    vec4i: binaryComponentWise4i((a, b) => a + b),\n    vec4u: binaryComponentWise4u((a, b) => a + b),\n\n    mat2x2f: binaryComponentWise2x2f((a, b) => a + b),\n    mat3x3f: binaryComponentWise3x3f((a, b) => a + b),\n    mat4x4f: binaryComponentWise4x4f((a, b) => a + b),\n  } as Record<\n    VecKind | MatKind,\n    <T extends vBase | mBase>(lhs: T, rhs: T) => T\n  >,\n\n  addMixed: {\n    vec2f: (a: wgsl.v2f, b: number) => unary2f((e) => e + b)(a),\n    vec2h: (a: wgsl.v2h, b: number) => unary2h((e) => e + b)(a),\n    vec2i: (a: wgsl.v2i, b: number) => unary2i((e) => e + b)(a),\n    vec2u: (a: wgsl.v2u, b: number) => unary2u((e) => e + b)(a),\n\n    vec3f: (a: wgsl.v3f, b: number) => unary3f((e) => e + b)(a),\n    vec3h: (a: wgsl.v3h, b: number) => unary3h((e) => e + b)(a),\n    vec3i: (a: wgsl.v3i, b: number) => unary3i((e) => e + b)(a),\n    vec3u: (a: wgsl.v3u, b: number) => unary3u((e) => e + b)(a),\n\n    vec4f: (a: wgsl.v4f, b: number) => unary4f((e) => e + b)(a),\n    vec4h: (a: wgsl.v4h, b: number) => unary4h((e) => e + b)(a),\n    vec4i: (a: wgsl.v4i, b: number) => unary4i((e) => e + b)(a),\n    vec4u: (a: wgsl.v4u, b: number) => unary4u((e) => e + b)(a),\n\n    mat2x2f: (a: wgsl.m2x2f, b: number) => unary2x2f((e) => e + b)(a),\n    mat3x3f: (a: wgsl.m3x3f, b: number) => unary3x3f((e) => e + b)(a),\n    mat4x4f: (a: wgsl.m4x4f, b: number) => unary4x4f((e) => e + b)(a),\n  } as Record<\n    VecKind | MatKind,\n    <T extends vBase | mBase>(lhs: T, rhs: number) => T\n  >,\n\n  mulSxV: {\n    vec2f: (s: number, v: wgsl.v2f) => unary2f((e) => s * e)(v),\n    vec2h: (s: number, v: wgsl.v2h) => unary2h((e) => s * e)(v),\n    vec2i: (s: number, v: wgsl.v2i) => unary2i((e) => s * e)(v),\n    vec2u: (s: number, v: wgsl.v2u) => unary2u((e) => s * e)(v),\n\n    vec3f: (s: number, v: wgsl.v3f) => unary3f((e) => s * e)(v),\n    vec3h: (s: number, v: wgsl.v3h) => unary3h((e) => s * e)(v),\n    vec3i: (s: number, v: wgsl.v3i) => unary3i((e) => s * e)(v),\n    vec3u: (s: number, v: wgsl.v3u) => unary3u((e) => s * e)(v),\n\n    vec4f: (s: number, v: wgsl.v4f) => unary4f((e) => s * e)(v),\n    vec4h: (s: number, v: wgsl.v4h) => unary4h((e) => s * e)(v),\n    vec4i: (s: number, v: wgsl.v4i) => unary4i((e) => s * e)(v),\n    vec4u: (s: number, v: wgsl.v4u) => unary4u((e) => s * e)(v),\n\n    mat2x2f: (s: number, m: wgsl.m2x2f) => unary2x2f((e) => s * e)(m),\n    mat3x3f: (s: number, m: wgsl.m3x3f) => unary3x3f((e) => s * e)(m),\n    mat4x4f: (s: number, m: wgsl.m4x4f) => unary4x4f((e) => s * e)(m),\n  } as Record<\n    VecKind | MatKind,\n    <T extends vBase | wgsl.AnyMatInstance>(s: number, v: T) => T\n  >,\n\n  mulVxV: {\n    vec2f: binaryComponentWise2f((a, b) => a * b),\n    vec2h: binaryComponentWise2h((a, b) => a * b),\n    vec2i: binaryComponentWise2i((a, b) => a * b),\n    vec2u: binaryComponentWise2u((a, b) => a * b),\n\n    vec3f: binaryComponentWise3f((a, b) => a * b),\n    vec3h: binaryComponentWise3h((a, b) => a * b),\n    vec3i: binaryComponentWise3i((a, b) => a * b),\n    vec3u: binaryComponentWise3u((a, b) => a * b),\n\n    vec4f: binaryComponentWise4f((a, b) => a * b),\n    vec4h: binaryComponentWise4h((a, b) => a * b),\n    vec4i: binaryComponentWise4i((a, b) => a * b),\n    vec4u: binaryComponentWise4u((a, b) => a * b),\n\n    mat2x2f: (a: wgsl.m2x2f, b: wgsl.m2x2f) => {\n      const a_ = a.columns;\n      const b_ = b.columns;\n\n      return mat2x2f(\n        a_[0].x * b_[0].x + a_[1].x * b_[0].y,\n        a_[0].y * b_[0].x + a_[1].y * b_[0].y,\n        a_[0].x * b_[1].x + a_[1].x * b_[1].y,\n        a_[0].y * b_[1].x + a_[1].y * b_[1].y,\n      );\n    },\n\n    mat3x3f: (a: wgsl.m3x3f, b: wgsl.m3x3f) => {\n      const a_ = a.columns;\n      const b_ = b.columns;\n\n      return mat3x3f(\n        a_[0].x * b_[0].x + a_[1].x * b_[0].y + a_[2].x * b_[0].z,\n        a_[0].y * b_[0].x + a_[1].y * b_[0].y + a_[2].y * b_[0].z,\n        a_[0].z * b_[0].x + a_[1].z * b_[0].y + a_[2].z * b_[0].z,\n        a_[0].x * b_[1].x + a_[1].x * b_[1].y + a_[2].x * b_[1].z,\n        a_[0].y * b_[1].x + a_[1].y * b_[1].y + a_[2].y * b_[1].z,\n        a_[0].z * b_[1].x + a_[1].z * b_[1].y + a_[2].z * b_[1].z,\n        a_[0].x * b_[2].x + a_[1].x * b_[2].y + a_[2].x * b_[2].z,\n        a_[0].y * b_[2].x + a_[1].y * b_[2].y + a_[2].y * b_[2].z,\n        a_[0].z * b_[2].x + a_[1].z * b_[2].y + a_[2].z * b_[2].z,\n      );\n    },\n\n    mat4x4f: (a: wgsl.m4x4f, b: wgsl.m4x4f) => {\n      const a_ = a.columns;\n      const b_ = b.columns;\n\n      return mat4x4f(\n        a_[0].x * b_[0].x +\n          a_[1].x * b_[0].y +\n          a_[2].x * b_[0].z +\n          a_[3].x * b_[0].w,\n        a_[0].y * b_[0].x +\n          a_[1].y * b_[0].y +\n          a_[2].y * b_[0].z +\n          a_[3].y * b_[0].w,\n        a_[0].z * b_[0].x +\n          a_[1].z * b_[0].y +\n          a_[2].z * b_[0].z +\n          a_[3].z * b_[0].w,\n        a_[0].w * b_[0].x +\n          a_[1].w * b_[0].y +\n          a_[2].w * b_[0].z +\n          a_[3].w * b_[0].w,\n        a_[0].x * b_[1].x +\n          a_[1].x * b_[1].y +\n          a_[2].x * b_[1].z +\n          a_[3].x * b_[1].w,\n        a_[0].y * b_[1].x +\n          a_[1].y * b_[1].y +\n          a_[2].y * b_[1].z +\n          a_[3].y * b_[1].w,\n        a_[0].z * b_[1].x +\n          a_[1].z * b_[1].y +\n          a_[2].z * b_[1].z +\n          a_[3].z * b_[1].w,\n        a_[0].w * b_[1].x +\n          a_[1].w * b_[1].y +\n          a_[2].w * b_[1].z +\n          a_[3].w * b_[1].w,\n        a_[0].x * b_[2].x +\n          a_[1].x * b_[2].y +\n          a_[2].x * b_[2].z +\n          a_[3].x * b_[2].w,\n        a_[0].y * b_[2].x +\n          a_[1].y * b_[2].y +\n          a_[2].y * b_[2].z +\n          a_[3].y * b_[2].w,\n        a_[0].z * b_[2].x +\n          a_[1].z * b_[2].y +\n          a_[2].z * b_[2].z +\n          a_[3].z * b_[2].w,\n        a_[0].w * b_[2].x +\n          a_[1].w * b_[2].y +\n          a_[2].w * b_[2].z +\n          a_[3].w * b_[2].w,\n        a_[0].x * b_[3].x +\n          a_[1].x * b_[3].y +\n          a_[2].x * b_[3].z +\n          a_[3].x * b_[3].w,\n        a_[0].y * b_[3].x +\n          a_[1].y * b_[3].y +\n          a_[2].y * b_[3].z +\n          a_[3].y * b_[3].w,\n        a_[0].z * b_[3].x +\n          a_[1].z * b_[3].y +\n          a_[2].z * b_[3].z +\n          a_[3].z * b_[3].w,\n        a_[0].w * b_[3].x +\n          a_[1].w * b_[3].y +\n          a_[2].w * b_[3].z +\n          a_[3].w * b_[3].w,\n      );\n    },\n  } as Record<\n    VecKind | MatKind,\n    <T extends vBase | wgsl.AnyMatInstance>(lhs: T, rhs: T) => T\n  >,\n\n  mulMxV: {\n    mat2x2f: (m: wgsl.m2x2f, v: wgsl.v2f) => {\n      const m_ = m.columns;\n      return vec2f(\n        m_[0].x * v.x + m_[1].x * v.y,\n        m_[0].y * v.x + m_[1].y * v.y,\n      );\n    },\n\n    mat3x3f: (m: wgsl.m3x3f, v: wgsl.v3f) => {\n      const m_ = m.columns;\n      return vec3f(\n        m_[0].x * v.x + m_[1].x * v.y + m_[2].x * v.z,\n        m_[0].y * v.x + m_[1].y * v.y + m_[2].y * v.z,\n        m_[0].z * v.x + m_[1].z * v.y + m_[2].z * v.z,\n      );\n    },\n\n    mat4x4f: (m: wgsl.m4x4f, v: wgsl.v4f) => {\n      const m_ = m.columns;\n      return vec4f(\n        m_[0].x * v.x + m_[1].x * v.y + m_[2].x * v.z + m_[3].x * v.w,\n        m_[0].y * v.x + m_[1].y * v.y + m_[2].y * v.z + m_[3].y * v.w,\n        m_[0].z * v.x + m_[1].z * v.y + m_[2].z * v.z + m_[3].z * v.w,\n        m_[0].w * v.x + m_[1].w * v.y + m_[2].w * v.z + m_[3].w * v.w,\n      );\n    },\n  } as Record<\n    MatKind,\n    <T extends wgsl.AnyMatInstance>(\n      m: T,\n      v: wgsl.vBaseForMat<T>,\n    ) => wgsl.vBaseForMat<T>\n  >,\n\n  mulVxM: {\n    mat2x2f: (v: wgsl.v2f, m: wgsl.m2x2f) => {\n      const m_ = m.columns;\n      return vec2f(\n        v.x * m_[0].x + v.y * m_[0].y,\n        v.x * m_[1].x + v.y * m_[1].y,\n      );\n    },\n\n    mat3x3f: (v: wgsl.v3f, m: wgsl.m3x3f) => {\n      const m_ = m.columns;\n      return vec3f(\n        v.x * m_[0].x + v.y * m_[0].y + v.z * m_[0].z,\n        v.x * m_[1].x + v.y * m_[1].y + v.z * m_[1].z,\n        v.x * m_[2].x + v.y * m_[2].y + v.z * m_[2].z,\n      );\n    },\n\n    mat4x4f: (v: wgsl.v4f, m: wgsl.m4x4f) => {\n      const m_ = m.columns;\n      return vec4f(\n        v.x * m_[0].x + v.y * m_[0].y + v.z * m_[0].z + v.w * m_[0].w,\n        v.x * m_[1].x + v.y * m_[1].y + v.z * m_[1].z + v.w * m_[1].w,\n        v.x * m_[2].x + v.y * m_[2].y + v.z * m_[2].z + v.w * m_[2].w,\n        v.x * m_[3].x + v.y * m_[3].y + v.z * m_[3].z + v.w * m_[3].w,\n      );\n    },\n  } as Record<\n    MatKind,\n    <T extends wgsl.AnyMatInstance>(\n      v: wgsl.vBaseForMat<T>,\n      m: T,\n    ) => wgsl.vBaseForMat<T>\n  >,\n\n  div: {\n    vec2f: binaryComponentWise2f((a, b) => a / b),\n    vec2h: binaryComponentWise2h((a, b) => a / b),\n    vec2i: binaryComponentWise2i(NumberOps.divInteger),\n    vec2u: binaryComponentWise2u(NumberOps.divInteger),\n\n    vec3f: binaryComponentWise3f((a, b) => a / b),\n    vec3h: binaryComponentWise3h((a, b) => a / b),\n    vec3i: binaryComponentWise3i(NumberOps.divInteger),\n    vec3u: binaryComponentWise3u(NumberOps.divInteger),\n\n    vec4f: binaryComponentWise4f((a, b) => a / b),\n    vec4h: binaryComponentWise4h((a, b) => a / b),\n    vec4i: binaryComponentWise4i(NumberOps.divInteger),\n    vec4u: binaryComponentWise4u(NumberOps.divInteger),\n  } as Record<VecKind, <T extends vBase>(a: T, b: T) => T>,\n\n  divMixed: {\n    vec2f: (a: wgsl.v2f, b: number) => unary2f((e) => e / b)(a),\n    vec2h: (a: wgsl.v2h, b: number) => unary2h((e) => e / b)(a),\n    vec2i: (a: wgsl.v2i, b: number) =>\n      unary2i((e) => NumberOps.divInteger(e, b))(a),\n    vec2u: (a: wgsl.v2u, b: number) =>\n      unary2u((e) => NumberOps.divInteger(e, b))(a),\n\n    vec3f: (a: wgsl.v3f, b: number) => unary3f((e) => e / b)(a),\n    vec3h: (a: wgsl.v3h, b: number) => unary3h((e) => e / b)(a),\n    vec3i: (a: wgsl.v3i, b: number) =>\n      unary3i((e) => NumberOps.divInteger(e, b))(a),\n    vec3u: (a: wgsl.v3u, b: number) =>\n      unary3u((e) => NumberOps.divInteger(e, b))(a),\n\n    vec4f: (a: wgsl.v4f, b: number) => unary4f((e) => e / b)(a),\n    vec4h: (a: wgsl.v4h, b: number) => unary4h((e) => e / b)(a),\n    vec4i: (a: wgsl.v4i, b: number) =>\n      unary4i((e) => NumberOps.divInteger(e, b))(a),\n    vec4u: (a: wgsl.v4u, b: number) =>\n      unary4u((e) => NumberOps.divInteger(e, b))(a),\n  } as Record<VecKind, <T extends vBase>(lhs: T, rhs: number) => T>,\n\n  dot: {\n    vec2f: dotVec2,\n    vec2h: dotVec2,\n    vec2i: dotVec2,\n    vec2u: dotVec2,\n    vec3f: dotVec3,\n    vec3h: dotVec3,\n    vec3i: dotVec3,\n    vec3u: dotVec3,\n    vec4f: dotVec4,\n    vec4h: dotVec4,\n    vec4i: dotVec4,\n    vec4u: dotVec4,\n  } as Record<VecKind, <T extends vBase>(lhs: T, rhs: T) => number>,\n\n  normalize: {\n    vec2f: (v: wgsl.v2f) => {\n      const len = lengthVec2(v);\n      return vec2f(v.x / len, v.y / len);\n    },\n    vec2h: (v: wgsl.v2h) => {\n      const len = lengthVec2(v);\n      return vec2h(v.x / len, v.y / len);\n    },\n    vec2i: (v: wgsl.v2i) => {\n      const len = lengthVec2(v);\n      return vec2i(v.x / len, v.y / len);\n    },\n    vec2u: (v: wgsl.v2u) => {\n      const len = lengthVec2(v);\n      return vec2u(v.x / len, v.y / len);\n    },\n\n    vec3f: (v: wgsl.v3f) => {\n      const len = lengthVec3(v);\n      return vec3f(v.x / len, v.y / len, v.z / len);\n    },\n    vec3h: (v: wgsl.v3h) => {\n      const len = lengthVec3(v);\n      return vec3h(v.x / len, v.y / len, v.z / len);\n    },\n    vec3i: (v: wgsl.v3i) => {\n      const len = lengthVec3(v);\n      return vec3i(v.x / len, v.y / len, v.z / len);\n    },\n    vec3u: (v: wgsl.v3u) => {\n      const len = lengthVec3(v);\n      return vec3u(v.x / len, v.y / len, v.z / len);\n    },\n\n    vec4f: (v: wgsl.v4f) => {\n      const len = lengthVec4(v);\n      return vec4f(v.x / len, v.y / len, v.z / len, v.w / len);\n    },\n    vec4h: (v: wgsl.v4h) => {\n      const len = lengthVec4(v);\n      return vec4h(v.x / len, v.y / len, v.z / len, v.w / len);\n    },\n    vec4i: (v: wgsl.v4i) => {\n      const len = lengthVec4(v);\n      return vec4i(v.x / len, v.y / len, v.z / len, v.w / len);\n    },\n    vec4u: (v: wgsl.v4u) => {\n      const len = lengthVec4(v);\n      return vec4u(v.x / len, v.y / len, v.z / len, v.w / len);\n    },\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  cross: {\n    vec3f: (a: wgsl.v3f, b: wgsl.v3f) => {\n      return vec3f(\n        a.y * b.z - a.z * b.y,\n        a.z * b.x - a.x * b.z,\n        a.x * b.y - a.y * b.x,\n      );\n    },\n    vec3h: (a: wgsl.v3h, b: wgsl.v3h) => {\n      return vec3h(\n        a.y * b.z - a.z * b.y,\n        a.z * b.x - a.x * b.z,\n        a.x * b.y - a.y * b.x,\n      );\n    },\n  } as Record<\n    'vec3f' | 'vec3h',\n    <T extends wgsl.v3f | wgsl.v3h>(a: T, b: T) => T\n  >,\n\n  floor: {\n    vec2f: unary2f(Math.floor),\n    vec2h: unary2h(Math.floor),\n\n    vec3f: unary3f(Math.floor),\n    vec3h: unary3h(Math.floor),\n\n    vec4f: unary4f(Math.floor),\n    vec4h: unary4h(Math.floor),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  max: {\n    vec2f: binaryComponentWise2f(Math.max),\n    vec2h: binaryComponentWise2h(Math.max),\n    vec2i: binaryComponentWise2i(Math.max),\n    vec2u: binaryComponentWise2u(Math.max),\n\n    vec3f: binaryComponentWise3f(Math.max),\n    vec3h: binaryComponentWise3h(Math.max),\n    vec3i: binaryComponentWise3i(Math.max),\n    vec3u: binaryComponentWise3u(Math.max),\n\n    vec4f: binaryComponentWise4f(Math.max),\n    vec4h: binaryComponentWise4h(Math.max),\n    vec4i: binaryComponentWise4i(Math.max),\n    vec4u: binaryComponentWise4u(Math.max),\n  } as Record<VecKind, <T extends vBase>(a: T, b: T) => T>,\n\n  min: {\n    vec2f: binaryComponentWise2f(Math.min),\n    vec2h: binaryComponentWise2h(Math.min),\n    vec2i: binaryComponentWise2i(Math.min),\n    vec2u: binaryComponentWise2u(Math.min),\n\n    vec3f: binaryComponentWise3f(Math.min),\n    vec3h: binaryComponentWise3h(Math.min),\n    vec3i: binaryComponentWise3i(Math.min),\n    vec3u: binaryComponentWise3u(Math.min),\n\n    vec4f: binaryComponentWise4f(Math.min),\n    vec4h: binaryComponentWise4h(Math.min),\n    vec4i: binaryComponentWise4i(Math.min),\n    vec4u: binaryComponentWise4u(Math.min),\n  } as Record<VecKind, <T extends vBase>(a: T, b: T) => T>,\n\n  pow: {\n    vec2f: (base: wgsl.v2f, exponent: wgsl.v2f) =>\n      vec2f(base.x ** exponent.x, base.y ** exponent.y),\n    vec2h: (base: wgsl.v2h, exponent: wgsl.v2h) =>\n      vec2h(base.x ** exponent.x, base.y ** exponent.y),\n\n    vec3f: (base: wgsl.v3f, exponent: wgsl.v3f) =>\n      vec3f(base.x ** exponent.x, base.y ** exponent.y, base.z ** exponent.z),\n    vec3h: (base: wgsl.v3h, exponent: wgsl.v3h) =>\n      vec3h(base.x ** exponent.x, base.y ** exponent.y, base.z ** exponent.z),\n\n    vec4f: (base: wgsl.v4f, exponent: wgsl.v4f) =>\n      vec4f(\n        base.x ** exponent.x,\n        base.y ** exponent.y,\n        base.z ** exponent.z,\n        base.w ** exponent.w,\n      ),\n    vec4h: (base: wgsl.v4h, exponent: wgsl.v4h) =>\n      vec4h(\n        base.x ** exponent.x,\n        base.y ** exponent.y,\n        base.z ** exponent.z,\n        base.w ** exponent.w,\n      ),\n  } as Record<\n    'vec2f' | 'vec3f' | 'vec4f' | 'vec2h' | 'vec3h' | 'vec4h' | 'number',\n    <T extends wgsl.AnyFloatVecInstance | number>(a: T, b: T) => T\n  >,\n\n  sign: {\n    vec2f: unary2f(Math.sign),\n    vec2h: unary2h(Math.sign),\n    vec2i: unary2i(Math.sign),\n\n    vec3f: unary3f(Math.sign),\n    vec3h: unary3h(Math.sign),\n    vec3i: unary3i(Math.sign),\n\n    vec4f: unary4f(Math.sign),\n    vec4h: unary4h(Math.sign),\n    vec4i: unary4i(Math.sign),\n  } as Record<VecKind, <T extends vBase>(e: T) => T>,\n\n  sqrt: {\n    vec2f: unary2f(Math.sqrt),\n    vec2h: unary2h(Math.sqrt),\n\n    vec3f: unary3f(Math.sqrt),\n    vec3h: unary3h(Math.sqrt),\n\n    vec4f: unary4f(Math.sqrt),\n    vec4h: unary4h(Math.sqrt),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  mix: {\n    vec2f: (e1: wgsl.v2f, e2: wgsl.v2f, e3: wgsl.v2f | number) => {\n      if (typeof e3 === 'number') {\n        return vec2f(e1.x * (1 - e3) + e2.x * e3, e1.y * (1 - e3) + e2.y * e3);\n      }\n      return vec2f(\n        e1.x * (1 - e3.x) + e2.x * e3.x,\n        e1.y * (1 - e3.y) + e2.y * e3.y,\n      );\n    },\n    vec2h: (e1: wgsl.v2h, e2: wgsl.v2h, e3: wgsl.v2h | number) => {\n      if (typeof e3 === 'number') {\n        return vec2h(e1.x * (1 - e3) + e2.x * e3, e1.y * (1 - e3) + e2.y * e3);\n      }\n      return vec2h(\n        e1.x * (1 - e3.x) + e2.x * e3.x,\n        e1.y * (1 - e3.y) + e2.y * e3.y,\n      );\n    },\n\n    vec3f: (e1: wgsl.v3f, e2: wgsl.v3f, e3: wgsl.v3f | number) => {\n      if (typeof e3 === 'number') {\n        return vec3f(\n          e1.x * (1 - e3) + e2.x * e3,\n          e1.y * (1 - e3) + e2.y * e3,\n          e1.z * (1 - e3) + e2.z * e3,\n        );\n      }\n      return vec3f(\n        e1.x * (1 - e3.x) + e2.x * e3.x,\n        e1.y * (1 - e3.y) + e2.y * e3.y,\n        e1.z * (1 - e3.z) + e2.z * e3.z,\n      );\n    },\n    vec3h: (e1: wgsl.v3h, e2: wgsl.v3h, e3: wgsl.v3h | number) => {\n      if (typeof e3 === 'number') {\n        return vec3h(\n          e1.x * (1 - e3) + e2.x * e3,\n          e1.y * (1 - e3) + e2.y * e3,\n          e1.z * (1 - e3) + e2.z * e3,\n        );\n      }\n      return vec3h(\n        e1.x * (1 - e3.x) + e2.x * e3.x,\n        e1.y * (1 - e3.y) + e2.y * e3.y,\n        e1.z * (1 - e3.z) + e2.z * e3.z,\n      );\n    },\n\n    vec4f: (e1: wgsl.v4f, e2: wgsl.v4f, e3: wgsl.v4f | number) => {\n      if (typeof e3 === 'number') {\n        return vec4f(\n          e1.x * (1 - e3) + e2.x * e3,\n          e1.y * (1 - e3) + e2.y * e3,\n          e1.z * (1 - e3) + e2.z * e3,\n          e1.w * (1 - e3) + e2.w * e3,\n        );\n      }\n      return vec4f(\n        e1.x * (1 - e3.x) + e2.x * e3.x,\n        e1.y * (1 - e3.y) + e2.y * e3.y,\n        e1.z * (1 - e3.z) + e2.z * e3.z,\n        e1.w * (1 - e3.w) + e2.w * e3.w,\n      );\n    },\n    vec4h: (e1: wgsl.v4h, e2: wgsl.v4h, e3: wgsl.v4h | number) => {\n      if (typeof e3 === 'number') {\n        return vec4h(\n          e1.x * (1 - e3) + e2.x * e3,\n          e1.y * (1 - e3) + e2.y * e3,\n          e1.z * (1 - e3) + e2.z * e3,\n          e1.w * (1 - e3) + e2.w * e3,\n        );\n      }\n      return vec4h(\n        e1.x * (1 - e3.x) + e2.x * e3.x,\n        e1.y * (1 - e3.y) + e2.y * e3.y,\n        e1.z * (1 - e3.z) + e2.z * e3.z,\n        e1.w * (1 - e3.w) + e2.w * e3.w,\n      );\n    },\n  } as Record<\n    'vec2f' | 'vec3f' | 'vec4f' | 'vec2h' | 'vec3h' | 'vec4h',\n    <T extends wgsl.v2f | wgsl.v3f | wgsl.v4f | wgsl.v2h | wgsl.v3h | wgsl.v4h>(\n      a: T,\n      b: T,\n      c: T | number,\n    ) => T\n  >,\n\n  sin: {\n    vec2f: unary2f(Math.sin),\n    vec2h: unary2h(Math.sin),\n\n    vec3f: unary3f(Math.sin),\n    vec3h: unary3h(Math.sin),\n\n    vec4f: unary4f(Math.sin),\n    vec4h: unary4h(Math.sin),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  cos: {\n    vec2f: unary2f(Math.cos),\n    vec2h: unary2h(Math.cos),\n\n    vec3f: unary3f(Math.cos),\n    vec3h: unary3h(Math.cos),\n\n    vec4f: unary4f(Math.cos),\n    vec4h: unary4h(Math.cos),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  cosh: {\n    vec2f: unary2f(Math.cosh),\n    vec2h: unary2h(Math.cosh),\n\n    vec3f: unary3f(Math.cosh),\n    vec3h: unary3h(Math.cosh),\n\n    vec4f: unary4f(Math.cosh),\n    vec4h: unary4h(Math.cosh),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  exp: {\n    vec2f: unary2f(Math.exp),\n    vec2h: unary2h(Math.exp),\n\n    vec3f: unary3f(Math.exp),\n    vec3h: unary3h(Math.exp),\n\n    vec4f: unary4f(Math.exp),\n    vec4h: unary4h(Math.exp),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  exp2: {\n    vec2f: unary2f((val) => 2 ** val),\n    vec2h: unary2h((val) => 2 ** val),\n\n    vec3f: unary3f((val) => 2 ** val),\n    vec3h: unary3h((val) => 2 ** val),\n\n    vec4f: unary4f((val) => 2 ** val),\n    vec4h: unary4h((val) => 2 ** val),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  log: {\n    vec2f: unary2f(Math.log),\n    vec2h: unary2h(Math.log),\n\n    vec3f: unary3f(Math.log),\n    vec3h: unary3h(Math.log),\n\n    vec4f: unary4f(Math.log),\n    vec4h: unary4h(Math.log),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  log2: {\n    vec2f: unary2f(Math.log2),\n    vec2h: unary2h(Math.log2),\n\n    vec3f: unary3f(Math.log2),\n    vec3h: unary3h(Math.log2),\n\n    vec4f: unary4f(Math.log2),\n    vec4h: unary4h(Math.log2),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  fract: {\n    vec2f: unary2f((value) => value - Math.floor(value)),\n    vec2h: unary2h((value) => value - Math.floor(value)),\n\n    vec3f: unary3f((value) => value - Math.floor(value)),\n    vec3h: unary3h((value) => value - Math.floor(value)),\n\n    vec4f: unary4f((value) => value - Math.floor(value)),\n    vec4h: unary4h((value) => value - Math.floor(value)),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  isCloseToZero: {\n    vec2f: (v: wgsl.v2f, n: number) => Math.abs(v.x) <= n && Math.abs(v.y) <= n,\n    vec2h: (v: wgsl.v2h, n: number) => Math.abs(v.x) <= n && Math.abs(v.y) <= n,\n\n    vec3f: (v: wgsl.v3f, n: number) =>\n      Math.abs(v.x) <= n && Math.abs(v.y) <= n && Math.abs(v.z) <= n,\n    vec3h: (v: wgsl.v3h, n: number) =>\n      Math.abs(v.x) <= n && Math.abs(v.y) <= n && Math.abs(v.z) <= n,\n\n    vec4f: (v: wgsl.v4f, n: number) =>\n      Math.abs(v.x) <= n &&\n      Math.abs(v.y) <= n &&\n      Math.abs(v.z) <= n &&\n      Math.abs(v.w) <= n,\n    vec4h: (v: wgsl.v4h, n: number) =>\n      Math.abs(v.x) <= n &&\n      Math.abs(v.y) <= n &&\n      Math.abs(v.z) <= n &&\n      Math.abs(v.w) <= n,\n  } as Record<VecKind, <T extends vBase>(v: T, n: number) => boolean>,\n\n  neg: {\n    vec2f: unary2f((value) => -value),\n    vec2h: unary2h((value) => -value),\n    vec2i: unary2i((value) => -value),\n    vec2u: unary2u((value) => -value),\n    'vec2<bool>': (e: wgsl.v2b) => vec2b(!e.x, !e.y),\n\n    vec3f: unary3f((value) => -value),\n    vec3h: unary3h((value) => -value),\n    vec3i: unary3i((value) => -value),\n    vec3u: unary3u((value) => -value),\n    'vec3<bool>': (e: wgsl.v3b) => vec3b(!e.x, !e.y, !e.z),\n\n    vec4f: unary4f((value) => -value),\n    vec4h: unary4h((value) => -value),\n    vec4i: unary4i((value) => -value),\n    vec4u: unary4u((value) => -value),\n    'vec4<bool>': (e: wgsl.v4b) => vec4b(!e.x, !e.y, !e.z, !e.w),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n\n  select: {\n    vec2f: (f: wgsl.v2f, t: wgsl.v2f, c: wgsl.v2b) =>\n      vec2f(c.x ? t.x : f.x, c.y ? t.y : f.y),\n    vec2h: (f: wgsl.v2h, t: wgsl.v2h, c: wgsl.v2b) =>\n      vec2h(c.x ? t.x : f.x, c.y ? t.y : f.y),\n    vec2i: (f: wgsl.v2i, t: wgsl.v2i, c: wgsl.v2b) =>\n      vec2i(c.x ? t.x : f.x, c.y ? t.y : f.y),\n    vec2u: (f: wgsl.v2u, t: wgsl.v2u, c: wgsl.v2b) =>\n      vec2u(c.x ? t.x : f.x, c.y ? t.y : f.y),\n    'vec2<bool>': (f: wgsl.v2b, t: wgsl.v2b, c: wgsl.v2b) =>\n      vec2b(c.x ? t.x : f.x, c.y ? t.y : f.y),\n\n    vec3f: (f: wgsl.v3f, t: wgsl.v3f, c: wgsl.v3b) =>\n      vec3f(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z),\n    vec3h: (f: wgsl.v3h, t: wgsl.v3h, c: wgsl.v3b) =>\n      vec3h(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z),\n    vec3i: (f: wgsl.v3i, t: wgsl.v3i, c: wgsl.v3b) =>\n      vec3i(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z),\n    vec3u: (f: wgsl.v3u, t: wgsl.v3u, c: wgsl.v3b) =>\n      vec3u(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z),\n    'vec3<bool>': (f: wgsl.v3b, t: wgsl.v3b, c: wgsl.v3b) =>\n      vec3b(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z),\n\n    vec4f: (f: wgsl.v4f, t: wgsl.v4f, c: wgsl.v4b) =>\n      vec4f(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z, c.w ? t.w : f.w),\n    vec4h: (f: wgsl.v4h, t: wgsl.v4h, c: wgsl.v4b) =>\n      vec4h(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z, c.w ? t.w : f.w),\n    vec4i: (f: wgsl.v4i, t: wgsl.v4i, c: wgsl.v4b) =>\n      vec4i(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z, c.w ? t.w : f.w),\n    vec4u: (f: wgsl.v4u, t: wgsl.v4u, c: wgsl.v4b) =>\n      vec4u(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z, c.w ? t.w : f.w),\n    'vec4<bool>': (f: wgsl.v4b, t: wgsl.v4b, c: wgsl.v4b) =>\n      vec4b(c.x ? t.x : f.x, c.y ? t.y : f.y, c.z ? t.z : f.z, c.w ? t.w : f.w),\n  } as Record<\n    VecKind,\n    <T extends wgsl.AnyVecInstance>(\n      f: T,\n      t: T,\n      c: T extends wgsl.AnyVec2Instance ? wgsl.v2b\n        : T extends wgsl.AnyVec3Instance ? wgsl.v3b\n        : wgsl.v4b,\n    ) => T\n  >,\n\n  tanh: {\n    vec2f: unary2f(Math.tanh),\n    vec2h: unary2h(Math.tanh),\n\n    vec3f: unary3f(Math.tanh),\n    vec3h: unary3h(Math.tanh),\n\n    vec4f: unary4f(Math.tanh),\n    vec4h: unary4h(Math.tanh),\n  } as Record<VecKind, <T extends vBase>(v: T) => T>,\n};\n", "import { type AnyData, snip, type Snippet } from '../data/dataTypes.ts';\nimport { f32 } from '../data/numeric.ts';\nimport { VectorOps } from '../data/vectorOps.ts';\nimport {\n  type AbstractFloat,\n  type AbstractInt,\n  type AnyFloatVecInstance,\n  type AnyMatInstance,\n  type AnyNumericVecInstance,\n  type F16,\n  type F32,\n  type I32,\n  isFloat32VecInstance,\n  isMatInstance,\n  isVecInstance,\n  type mBaseForVec,\n  type U32,\n  type v2f,\n  type v2h,\n  type v2i,\n  type v3f,\n  type v3h,\n  type v3i,\n  type v4f,\n  type v4h,\n  type v4i,\n  type vBaseForMat,\n} from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\nimport { $internal } from '../shared/symbols.ts';\n\ntype NumVec = AnyNumericVecInstance;\ntype Mat = AnyMatInstance;\n\nexport function isSnippetNumeric(snippet: Snippet) {\n  return isNumericSchema(snippet.dataType);\n}\n\nexport function isNumericSchema(\n  schema: unknown,\n): schema is AbstractInt | AbstractFloat | F32 | F16 | I32 | U32 {\n  const type = (schema as AnyData)?.type;\n\n  return (\n    !!(schema as AnyData)?.[$internal] &&\n    (type === 'abstractInt' ||\n      type === 'abstractFloat' ||\n      type === 'f32' ||\n      type === 'f16' ||\n      type === 'i32' ||\n      type === 'u32')\n  );\n}\n\nfunction cpuAdd(lhs: number, rhs: number): number; // default addition\nfunction cpuAdd<T extends NumVec>(lhs: number, rhs: T): T; // mixed addition\nfunction cpuAdd<T extends NumVec>(lhs: T, rhs: number): T; // mixed addition\nfunction cpuAdd<T extends NumVec | Mat>(lhs: T, rhs: T): T; // component-wise addition\nfunction cpuAdd<\n  // union overload\n  Lhs extends number | NumVec | Mat,\n  Rhs extends (Lhs extends number ? number | NumVec\n    : Lhs extends NumVec ? number | Lhs\n    : Lhs extends Mat ? Lhs\n    : never),\n>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;\nfunction cpuAdd(lhs: number | NumVec | Mat, rhs: number | NumVec | Mat) {\n  if (typeof lhs === 'number' && typeof rhs === 'number') {\n    return lhs + rhs; // default addition\n  }\n  if (typeof lhs === 'number' && isVecInstance(rhs)) {\n    return VectorOps.addMixed[rhs.kind](rhs, lhs); // mixed addition\n  }\n  if (isVecInstance(lhs) && typeof rhs === 'number') {\n    return VectorOps.addMixed[lhs.kind](lhs, rhs); // mixed addition\n  }\n  if (\n    (isVecInstance(lhs) && isVecInstance(rhs)) ||\n    (isMatInstance(lhs) && isMatInstance(rhs))\n  ) {\n    return VectorOps.add[lhs.kind](lhs, rhs); // component-wise addition\n  }\n\n  throw new Error('Add/Sub called with invalid arguments.');\n}\n\nexport const add = createDualImpl(\n  // CPU implementation\n  cpuAdd,\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} + ${rhs.value})`,\n      isSnippetNumeric(lhs) ? rhs.dataType : lhs.dataType,\n    ),\n  'coerce',\n);\n\nfunction cpuSub(lhs: number, rhs: number): number; // default subtraction\nfunction cpuSub<T extends NumVec>(lhs: number, rhs: T): T; // mixed subtraction\nfunction cpuSub<T extends NumVec>(lhs: T, rhs: number): T; // mixed subtraction\nfunction cpuSub<T extends NumVec | Mat>(lhs: T, rhs: T): T; // component-wise subtraction\nfunction cpuSub<\n  // union overload\n  Lhs extends number | NumVec | Mat,\n  Rhs extends (Lhs extends number ? number | NumVec\n    : Lhs extends NumVec ? number | Lhs\n    : Lhs extends Mat ? Lhs\n    : never),\n>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;\nfunction cpuSub(lhs: number | NumVec | Mat, rhs: number | NumVec | Mat) {\n  // while illegal on the wgsl side, we can do this in js\n  return cpuAdd(lhs, mul(-1, rhs));\n}\n\nexport const sub = createDualImpl(\n  // CPU implementation\n  cpuSub,\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} - ${rhs.value})`,\n      isSnippetNumeric(lhs) ? rhs.dataType : lhs.dataType,\n    ),\n  'sub',\n  'coerce',\n);\n\nfunction cpuMul(lhs: number, rhs: number): number; // default multiplication\nfunction cpuMul<MV extends NumVec | Mat>(lhs: number, rhs: MV): MV; // scale\nfunction cpuMul<MV extends NumVec | Mat>(lhs: MV, rhs: number): MV; // scale\nfunction cpuMul<V extends NumVec>(lhs: V, rhs: V): V; // component-wise multiplication\nfunction cpuMul<M extends Mat, V extends vBaseForMat<M>>(lhs: V, rhs: M): V; // row-vector-matrix\nfunction cpuMul<M extends Mat, V extends vBaseForMat<M>>(lhs: M, rhs: V): V; // matrix-column-vector\nfunction cpuMul<M extends Mat>(lhs: M, rhs: M): M; // matrix multiplication\nfunction cpuMul<\n  // union overload\n  Lhs extends number | NumVec | Mat,\n  Rhs extends (\n    Lhs extends number ? number | NumVec | Mat\n      : Lhs extends NumVec ? number | Lhs | mBaseForVec<Lhs>\n      : Lhs extends Mat ? number | vBaseForMat<Lhs> | Lhs\n      : never\n  ),\n>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;\nfunction cpuMul(lhs: number | NumVec | Mat, rhs: number | NumVec | Mat) {\n  if (typeof lhs === 'number' && typeof rhs === 'number') {\n    return lhs * rhs; // default multiplication\n  }\n  if (typeof lhs === 'number' && (isVecInstance(rhs) || isMatInstance(rhs))) {\n    return VectorOps.mulSxV[rhs.kind](lhs, rhs); // scale\n  }\n  if ((isVecInstance(lhs) || isMatInstance(lhs)) && typeof rhs === 'number') {\n    return VectorOps.mulSxV[lhs.kind](rhs, lhs); // scale\n  }\n  if (isVecInstance(lhs) && isVecInstance(rhs)) {\n    return VectorOps.mulVxV[lhs.kind](lhs, rhs); // component-wise\n  }\n  if (isFloat32VecInstance(lhs) && isMatInstance(rhs)) {\n    return VectorOps.mulVxM[rhs.kind](lhs, rhs); // row-vector-matrix\n  }\n  if (isMatInstance(lhs) && isFloat32VecInstance(rhs)) {\n    return VectorOps.mulMxV[lhs.kind](lhs, rhs); // matrix-column-vector\n  }\n  if (isMatInstance(lhs) && isMatInstance(rhs)) {\n    return VectorOps.mulVxV[lhs.kind](lhs, rhs); // matrix multiplication\n  }\n\n  throw new Error('Mul called with invalid arguments.');\n}\n\nexport const mul = createDualImpl(\n  // CPU implementation\n  cpuMul,\n  // GPU implementation\n  (lhs, rhs) => {\n    const returnType = isSnippetNumeric(lhs)\n      // Scalar * Scalar/Vector/Matrix\n      ? rhs.dataType\n      : isSnippetNumeric(rhs)\n      // Vector/Matrix * Scalar\n      ? lhs.dataType\n      : lhs.dataType.type.startsWith('vec')\n      // Vector * Vector/Matrix\n      ? lhs.dataType\n      : rhs.dataType.type.startsWith('vec')\n      // Matrix * Vector\n      ? rhs.dataType\n      // Matrix * Matrix\n      : lhs.dataType;\n    return snip(`(${lhs.value} * ${rhs.value})`, returnType);\n  },\n  'mul',\n);\n\nfunction cpuDiv(lhs: number, rhs: number): number; // default js division\nfunction cpuDiv<MV extends NumVec>(lhs: number, rhs: MV): MV; // scale\nfunction cpuDiv<MV extends NumVec>(lhs: MV, rhs: number): MV; // scale\nfunction cpuDiv<V extends NumVec>(lhs: V, rhs: V): V; // component-wise division\nfunction cpuDiv<\n  // union overload\n  Lhs extends number | NumVec,\n  Rhs extends (Lhs extends number ? number | NumVec\n    : Lhs extends NumVec ? number | Lhs\n    : never),\n>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;\nfunction cpuDiv(lhs: number | NumVec, rhs: number | NumVec) {\n  if (typeof lhs === 'number' && typeof rhs === 'number') {\n    return (lhs / rhs);\n  }\n  if (typeof lhs === 'number' && isVecInstance(rhs)) {\n    return VectorOps.divMixed[rhs.kind](rhs, lhs);\n  }\n  if (isVecInstance(lhs) && typeof rhs === 'number') {\n    return VectorOps.divMixed[lhs.kind](lhs, rhs);\n  }\n  if (isVecInstance(lhs) && isVecInstance(rhs)) {\n    return VectorOps.div[lhs.kind](lhs, rhs);\n  }\n\n  throw new Error('Div called with invalid arguments.');\n}\n\nexport const div = createDualImpl(\n  // CPU implementation\n  cpuDiv,\n  // GPU implementation\n  (lhs, rhs) => {\n    if (isSnippetNumeric(lhs) && isSnippetNumeric(rhs)) {\n      return snip(`(f32(${lhs.value}) / ${rhs.value})`, f32);\n    }\n    return snip(`(${lhs.value} / ${rhs.value})`, lhs.dataType);\n  },\n  'div',\n);\n\nexport const abs = createDualImpl(\n  // CPU implementation\n  <T extends NumVec | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.abs(value) as T;\n    }\n    return VectorOps.abs[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`abs(${value.value})`, value.dataType),\n  'abs',\n);\n\nexport const atan2 = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(y: T, x: T): T => {\n    if (typeof y === 'number' && typeof x === 'number') {\n      return Math.atan2(y, x) as T;\n    }\n    return VectorOps.atan2[(y as AnyFloatVecInstance).kind](\n      y as never,\n      x as never,\n    ) as T;\n  },\n  // GPU implementation\n  (y, x) => snip(`atan2(${y.value}, ${x.value})`, y.dataType),\n  'atan2',\n);\n\nexport const acos = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.acos(value) as T;\n    }\n    return VectorOps.acos[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`acos(${value.value})`, value.dataType),\n  'acos',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#acosh-builtin\n */\nexport const acosh = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.acosh(value) as T;\n    }\n    return VectorOps.acosh[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`acosh(${value.value})`, value.dataType),\n  'acosh',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#asin-builtin\n */\nexport const asin = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.asin(value) as T;\n    }\n    return VectorOps.asin[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`asin(${value.value})`, value.dataType),\n  'asin',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#ceil-builtin\n */\nexport const ceil = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.ceil(value) as T;\n    }\n    return VectorOps.ceil[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`ceil(${value.value})`, value.dataType),\n  'ceil',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#clamp\n */\nexport const clamp = createDualImpl(\n  // CPU implementation\n  <T extends NumVec | number>(value: T, low: T, high: T): T => {\n    if (typeof value === 'number') {\n      return Math.min(Math.max(low as number, value), high as number) as T;\n    }\n    return VectorOps.clamp[value.kind](\n      value,\n      low as NumVec,\n      high as NumVec,\n    ) as T;\n  },\n  // GPU implementation\n  (value, low, high) =>\n    snip(`clamp(${value.value}, ${low.value}, ${high.value})`, value.dataType),\n  'clamp',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#cos-builtin\n */\nexport const cos = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.cos(value) as T;\n    }\n    return VectorOps.cos[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`cos(${value.value})`, value.dataType),\n  'cos',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#cosh-builtin\n */\nexport const cosh = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.cosh(value) as T;\n    }\n    return VectorOps.cosh[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`cosh(${value.value})`, value.dataType),\n  'cosh',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#cross-builtin\n */\nexport const cross = createDualImpl(\n  // CPU implementation\n  <T extends v3f | v3h>(a: T, b: T): T => VectorOps.cross[a.kind](a, b),\n  // GPU implementation\n  (a, b) => snip(`cross(${a.value}, ${b.value})`, a.dataType),\n  'cross',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#dot-builtin\n */\nexport const dot = createDualImpl(\n  // CPU implementation\n  <T extends NumVec>(lhs: T, rhs: T): number =>\n    VectorOps.dot[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) => snip(`dot(${lhs.value}, ${rhs.value})`, f32),\n  'dot',\n);\n\nexport const normalize = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance>(v: T): T => VectorOps.normalize[v.kind](v),\n  // GPU implementation\n  (v) => snip(`normalize(${v.value})`, v.dataType),\n  'normalize',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#floor-builtin\n */\nexport const floor = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.floor(value) as T;\n    }\n    return VectorOps.floor[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`floor(${value.value})`, value.dataType),\n  'floor',\n);\n\nexport const fract = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(a: T): T => {\n    if (typeof a === 'number') {\n      return (a - Math.floor(a)) as T;\n    }\n    return VectorOps.fract[a.kind](a) as T;\n  },\n  // GPU implementation\n  (a) => snip(`fract(${a.value})`, a.dataType),\n  'fract',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#length-builtin\n */\nexport const length = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): number => {\n    if (typeof value === 'number') {\n      return Math.abs(value);\n    }\n    return VectorOps.length[value.kind](value);\n  },\n  // GPU implementation\n  (value) => snip(`length(${value.value})`, f32),\n  'length',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#log-builtin\n */\nexport const log = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.log(value) as T;\n    }\n    return VectorOps.log[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`log(${value.value})`, value.dataType),\n  'log',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#log2-builtin\n */\nexport const log2 = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.log2(value) as T;\n    }\n    return VectorOps.log2[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`log2(${value.value})`, value.dataType),\n  'log2',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#max-float-builtin\n */\nexport const max = createDualImpl(\n  // CPU implementation\n  <T extends NumVec | number>(a: T, b: T): T => {\n    if (typeof a === 'number') {\n      return Math.max(a, b as number) as T;\n    }\n    return VectorOps.max[a.kind](a, b as NumVec) as T;\n  },\n  // GPU implementation\n  (a, b) => snip(`max(${a.value}, ${b.value})`, a.dataType),\n  'max',\n  'coerce',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#min-float-builtin\n */\nexport const min = createDualImpl(\n  // CPU implementation\n  <T extends NumVec | number>(a: T, b: T): T => {\n    if (typeof a === 'number') {\n      return Math.min(a, b as number) as T;\n    }\n    return VectorOps.min[a.kind](a, b as NumVec) as T;\n  },\n  // GPU implementation\n  (a, b) => snip(`min(${a.value}, ${b.value})`, a.dataType),\n  'min',\n  'coerce',\n);\n\nexport const sign = createDualImpl(\n  // CPU implementation\n  //         \\/ specifically no unsigned variants\n  <T extends v2f | v2h | v2i | v3f | v3h | v3i | v4f | v4h | v4i | number>(\n    e: T,\n  ): T => {\n    if (typeof e === 'number') {\n      return Math.sign(e) as T;\n    }\n    return VectorOps.sign[e.kind](e) as T;\n  },\n  // GPU implementation\n  (e) => snip(`sign(${e.value})`, e.dataType),\n  'sign',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#sin-builtin\n */\nexport const sin = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.sin(value) as T;\n    }\n    return VectorOps.sin[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`sin(${value.value})`, value.dataType),\n  'sin',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#exp-builtin\n */\nexport const exp = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.exp(value) as T;\n    }\n    return VectorOps.exp[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`exp(${value.value})`, value.dataType),\n  'exp',\n);\n\n/**\n * @privateRemarks\n * https://www.w3.org/TR/WGSL/#exp2-builtin\n */\nexport const exp2 = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return (2 ** value) as T;\n    }\n    return VectorOps.exp2[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`exp2(${value.value})`, value.dataType),\n  'exp2',\n);\n\ntype PowOverload = {\n  (base: number, exponent: number): number;\n  <T extends AnyFloatVecInstance>(base: T, exponent: T): T;\n};\n\nexport const pow: PowOverload = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(base: T, exponent: T): T => {\n    if (typeof base === 'number' && typeof exponent === 'number') {\n      return (base ** exponent) as T;\n    }\n    if (\n      typeof base === 'object' &&\n      typeof exponent === 'object' &&\n      'kind' in base &&\n      'kind' in exponent\n    ) {\n      return VectorOps.pow[base.kind](base, exponent) as T;\n    }\n    throw new Error('Invalid arguments to pow()');\n  },\n  // GPU implementation\n  (base, exponent) =>\n    snip(`pow(${base.value}, ${exponent.value})`, base.dataType),\n  'pow',\n);\n\ntype MixOverload = {\n  (e1: number, e2: number, e3: number): number;\n  <T extends AnyFloatVecInstance>(e1: T, e2: T, e3: number): T;\n  <T extends AnyFloatVecInstance>(e1: T, e2: T, e3: T): T;\n};\n\nexport const mix: MixOverload = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(e1: T, e2: T, e3: T | number): T => {\n    if (typeof e1 === 'number') {\n      if (typeof e3 !== 'number' || typeof e2 !== 'number') {\n        throw new Error(\n          'When e1 and e2 are numbers, the blend factor must be a number.',\n        );\n      }\n      return (e1 * (1 - e3) + e2 * e3) as T;\n    }\n\n    if (typeof e1 === 'number' || typeof e2 === 'number') {\n      throw new Error('e1 and e2 need to both be vectors of the same kind.');\n    }\n\n    return VectorOps.mix[e1.kind](e1, e2, e3) as T;\n  },\n  // GPU implementation\n  (e1, e2, e3) =>\n    snip(`mix(${e1.value}, ${e2.value}, ${e3.value})`, e1.dataType),\n  'mix',\n);\n\nexport const reflect = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance>(e1: T, e2: T): T =>\n    sub(e1, mul(2 * dot(e2, e1), e2)),\n  // GPU implementation\n  (e1, e2) => snip(`reflect(${e1.value}, ${e2.value})`, e1.dataType),\n  'reflect',\n);\n\nexport const distance = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(a: T, b: T): number => {\n    if (typeof a === 'number' && typeof b === 'number') {\n      return Math.abs(a - b);\n    }\n    return length(\n      sub(a as AnyFloatVecInstance, b as AnyFloatVecInstance),\n    ) as number;\n  },\n  // GPU implementation\n  (a, b) => snip(`distance(${a.value}, ${b.value})`, f32),\n  'distance',\n);\n\nexport const neg = createDualImpl(\n  // CPU implementation\n  <T extends NumVec | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return -value as T;\n    }\n    return VectorOps.neg[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`-(${value.value})`, value.dataType),\n  'neg',\n);\n\nexport const sqrt = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.sqrt(value) as T;\n    }\n    return VectorOps.sqrt[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`sqrt(${value.value})`, value.dataType),\n  'sqrt',\n);\n\nexport const tanh = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(value: T): T => {\n    if (typeof value === 'number') {\n      return Math.tanh(value) as T;\n    }\n    return VectorOps.tanh[value.kind](value) as T;\n  },\n  // GPU implementation\n  (value) => snip(`tanh(${value.value})`, value.dataType),\n  'tanh',\n);\n", "export { arrayOf } from './structure/array.ts';\nexport {\n  bool,\n  byte,\n  i8,\n  u8,\n  i16,\n  u16,\n  i32,\n  u32,\n  f16,\n  f32,\n  string,\n} from './structure/baseTypes.ts';\nexport { chars } from './structure/chars.ts';\nexport { concat } from './structure/concat.ts';\nexport { dynamicArrayOf } from './structure/dynamicArray.ts';\nexport { keyed } from './structure/keyed.ts';\nexport { object, generic, genericEnum } from './structure/object.ts';\nexport { optional } from './structure/optional.ts';\nexport { tupleOf } from './structure/tuple.ts';\nexport {\n  f32Array,\n  f64Array,\n  i16Array,\n  i32Array,\n  i8Array,\n  u16Array,\n  u32Array,\n  u8Array,\n  u8ClampedArray,\n} from './structure/typedArray.ts';\nexport { MaxValue } from './structure/types.ts';\n\nexport { BufferReader } from './io/bufferReader.ts';\nexport { BufferWriter } from './io/bufferWriter.ts';\nexport { Measurer } from './io/measurer.ts';\nexport {\n  UnresolvedReferenceError,\n  ValidationError,\n} from './error.ts';\n\nexport type {\n  Endianness,\n  IMeasurer,\n  ISerialInput,\n  ISerialOutput,\n} from './io/types.ts';\nexport type { Parsed } from './utilityTypes.ts';\n", "export class UnresolvedReferenceError extends Error {\n  constructor(msg: string) {\n    super(msg);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, UnresolvedReferenceError.prototype);\n  }\n}\n\nexport class ValidationError extends Error {\n  constructor(msg: string) {\n    super(msg);\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n", "import type { IMeasurer } from './types.ts';\n\nclass UnboundedMeasurer implements IMeasurer {\n  size = Number.NaN;\n  unbounded: IMeasurer = this;\n  isUnbounded = true;\n\n  add(): IMeasurer {\n    return this;\n  }\n\n  fork(): IMeasurer {\n    return this;\n  }\n}\n\nconst unboundedMeasurer = new UnboundedMeasurer();\n\nexport class Measurer implements IMeasurer {\n  size = 0;\n  unbounded: IMeasurer = unboundedMeasurer;\n  isUnbounded = false;\n\n  add(bytes: number): IMeasurer {\n    this.size += bytes;\n    return this;\n  }\n\n  fork(): IMeasurer {\n    const forked = new Measurer();\n    forked.size = this.size;\n    return forked;\n  }\n}\n", "import type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport type { Parsed } from '../utilityTypes.ts';\n\nexport type MaxValue = typeof MaxValue;\nexport const MaxValue = Symbol(\n  'The biggest (in amount of bytes needed) value a schema can represent',\n);\n\nexport interface IKeyedSchema<TKeyDef extends string, TUnwrapped>\n  extends ISchema<TUnwrapped> {\n  readonly __keyDefinition: TKeyDef;\n}\n\nexport type AnyKeyedSchema = IKeyedSchema<string, unknown>;\n\n/**\n * Removes one layer of schema wrapping.\n *\n * @example ```\n * Unwrap<ISchema<ISchema<number>>> -> ISchema<number>\n * Unwrap<ISchema<number>> -> number\n * ```\n *\n * Keyed schemas are bypassed.\n *\n * @example ```\n * Unwrap<IKeyedSchema<'abc', ISchema<number>>> -> IKeyedSchema<'abc', number>\n * ```\n */\nexport type Unwrap<T> = T extends IKeyedSchema<infer TKeyDef, infer TInner>\n  ? // bypassing keyed schemas, as that information has to be preserved for parsing\n    IKeyedSchema<TKeyDef, Unwrap<TInner>>\n  : T extends ISchema<infer TInner>\n    ? TInner\n    : T;\n\n/**\n * Removes one layer of schema wrapping of record properties.\n *\n * @example ```\n * Unwrap<{\n *   a: ISchema<number>,\n *   b: ISchema<ISchema<string>>\n * }>\n * // <=>\n * {\n *   a: number,\n *   b: ISchema<string>\n * }\n * ```\n */\nexport type UnwrapRecord<T> = T extends IKeyedSchema<\n  infer TKeyDef,\n  Record<infer K, unknown>\n>\n  ? IKeyedSchema<TKeyDef, { [key in K]: Unwrap<T['__unwrapped'][key]> }>\n  : T extends Record<infer K, unknown>\n    ? { [key in K]: Unwrap<T[key]> }\n    : T;\n\n/* helper type for UnwrapArray */\ntype __UnwrapArray<T> = T extends unknown[]\n  ? {\n      [key in keyof T]: Unwrap<T[key]>;\n    }\n  : never;\n\n/**\n * Removes one layer of schema wrapping of array elements.\n *\n * @example ```\n * Unwrap<[a: ISchema<number>, b: ISchema<ISchema<string>>]>\n * // <=>\n * [a: number, b: ISchema<string>]\n * ```\n */\nexport type UnwrapArray<T> = T extends IKeyedSchema<infer TKeyDef, unknown[]>\n  ? IKeyedSchema<TKeyDef, __UnwrapArray<T['__unwrapped']>>\n  : T extends unknown[]\n    ? __UnwrapArray<T>\n    : T;\n\nexport interface ISchemaWithProperties<TProps extends Record<string, AnySchema>>\n  extends ISchema<UnwrapRecord<TProps>> {\n  readonly properties: TProps;\n}\n\nexport type AnySchemaWithProperties = ISchemaWithProperties<\n  Record<string, AnySchema>\n>;\n\nexport type PropertiesOf<T extends AnySchemaWithProperties> = T['properties'];\n\nexport type PropertyDescription = {\n  bufferOffset: number;\n  schema: ISchema<unknown>;\n};\n\n/**\n * @param TUnwrap one level of unwrapping to the inferred type.\n */\nexport interface ISchema<TUnwrapped> {\n  readonly __unwrapped: TUnwrapped;\n\n  resolveReferences(ctx: IRefResolver): void;\n  write(output: ISerialOutput, value: Parsed<TUnwrapped>): void;\n  read(input: ISerialInput): Parsed<TUnwrapped>;\n  measure(\n    value: Parsed<TUnwrapped> | MaxValue,\n    measurer?: IMeasurer,\n  ): IMeasurer;\n  seekProperty(\n    reference: Parsed<TUnwrapped> | MaxValue,\n    prop: keyof TUnwrapped,\n  ): PropertyDescription | null;\n}\n\nexport type AnySchema = ISchema<unknown>;\n\nexport abstract class Schema<TUnwrapped> implements ISchema<TUnwrapped> {\n  readonly __unwrapped!: TUnwrapped;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  resolveReferences(ctx: IRefResolver): void {\n    // override this if you need to resolve internal references.\n  }\n  abstract write(output: ISerialOutput, value: Parsed<TUnwrapped>): void;\n  abstract read(input: ISerialInput): Parsed<TUnwrapped>;\n  abstract measure(\n    value: Parsed<TUnwrapped> | MaxValue,\n    measurer?: IMeasurer,\n  ): IMeasurer;\n  seekProperty(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _reference: Parsed<TUnwrapped> | MaxValue,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _prop: keyof TUnwrapped,\n  ): PropertyDescription | null {\n    // override this if necessary.\n    return null;\n  }\n}\n\nexport class Ref<K extends string> {\n  constructor(public readonly key: K) {}\n}\n\n////\n// Generic types\n////\n\nexport type SubTypeKey = 'string' | 'enum';\nexport const SubTypeKey = {\n  STRING: 'string',\n  ENUM: 'enum',\n} as const;\n\nexport interface IRefResolver {\n  hasKey(key: string): boolean;\n\n  resolve<TSchema extends AnySchema>(schemaOrRef: TSchema): TSchema;\n  register<K extends string>(key: K, schema: ISchema<unknown>): void;\n}\n\n////\n// Alias types\n////\n", "import { ValidationError } from '../error.ts';\nimport { Measurer } from '../io/measurer.ts';\nimport type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport type { ParseUnwrapped } from '../utilityTypes.ts';\nimport {\n  type AnySchema,\n  type IRefResolver,\n  MaxValue,\n  Schema,\n  type Unwrap,\n} from './types.ts';\n\nexport class ArraySchema<TElement extends AnySchema> extends Schema<\n  Unwrap<TElement>[]\n> {\n  private elementSchema: TElement;\n\n  constructor(\n    private readonly _unstableElementSchema: TElement,\n    public readonly length: number,\n  ) {\n    super();\n\n    // In case this array isn't part of a keyed chain,\n    // let's assume the inner type is stable.\n    this.elementSchema = _unstableElementSchema;\n  }\n\n  override resolveReferences(ctx: IRefResolver): void {\n    this.elementSchema = ctx.resolve(this._unstableElementSchema);\n  }\n\n  override write(\n    output: ISerialOutput,\n    values: ParseUnwrapped<TElement>[],\n  ): void {\n    if (values.length !== this.length) {\n      throw new ValidationError(\n        `Expected array of length ${this.length}, got ${values.length}`,\n      );\n    }\n\n    for (const value of values) {\n      this.elementSchema.write(output, value);\n    }\n  }\n\n  override read(input: ISerialInput): ParseUnwrapped<TElement>[] {\n    const array: ParseUnwrapped<TElement>[] = [];\n\n    for (let i = 0; i < this.length; ++i) {\n      array.push(this.elementSchema.read(input) as ParseUnwrapped<TElement>);\n    }\n\n    return array;\n  }\n\n  /**\n   * Returns the maximum number of bytes this schema can take up.\n   *\n   * Returns `NaN` if the schema is unbounded. If you would like to know\n   * how many bytes a particular value encoding will take up, use `.measure(value)`.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  get maxSize(): number {\n    return this.elementSchema.measure(MaxValue).size * this.length;\n  }\n\n  override measure(\n    values: ParseUnwrapped<TElement>[] | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    for (let i = 0; i < this.length; ++i) {\n      this.elementSchema.measure(\n        values === MaxValue ? MaxValue : values[i],\n        measurer,\n      );\n    }\n\n    return measurer;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function arrayOf<TSchema extends AnySchema>(\n  elementSchema: TSchema,\n  length: number,\n): ArraySchema<TSchema> {\n  return new ArraySchema(elementSchema, length);\n}\n", "import { Measurer } from '../io/measurer.ts';\nimport type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport { MaxValue, Schema } from './types.ts';\n\n////\n// BOOL\n////\n\nexport class BoolSchema extends Schema<boolean> {\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  readonly maxSize = 1;\n\n  read(input: ISerialInput): boolean {\n    return input.readBool();\n  }\n\n  write(output: ISerialOutput, value: boolean): void {\n    output.writeBool(value);\n  }\n\n  measure(\n    _: boolean | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(1);\n  }\n}\n\nexport const bool: BoolSchema = new BoolSchema();\n\n////\n// STRING\n////\n\nexport class StringSchema extends Schema<string> {\n  private static _cachedEncoder: TextEncoder | undefined;\n\n  private static get _encoder() {\n    if (!StringSchema._cachedEncoder) {\n      StringSchema._cachedEncoder = new TextEncoder();\n    }\n    return StringSchema._cachedEncoder;\n  }\n\n  read(input: ISerialInput): string {\n    return input.readString();\n  }\n\n  write<T extends string>(output: ISerialOutput, value: T): void {\n    output.writeString(value);\n  }\n\n  measure(\n    value: string | typeof MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    if (value === MaxValue) {\n      // A string cannot be bound\n      return measurer.unbounded;\n    }\n    const encoded = StringSchema._encoder.encode(value);\n    return measurer.add(encoded.byteLength + 1);\n  }\n}\n\nexport const string: StringSchema = new StringSchema();\n\n////\n// i8\n////\n\nexport class Int8Schema extends Schema<number> {\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  readonly maxSize = 1;\n\n  read(input: ISerialInput): number {\n    return input.readInt8();\n  }\n\n  write(output: ISerialOutput, value: number): void {\n    output.writeInt8(value);\n  }\n\n  measure(\n    _: number | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(1);\n  }\n}\n\nexport const i8: Int8Schema = new Int8Schema();\n\n////\n// u8\n////\n\nexport class Uint8Schema extends Schema<number> {\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  readonly maxSize = 1;\n\n  read(input: ISerialInput): number {\n    return input.readUint8();\n  }\n\n  write(output: ISerialOutput, value: number): void {\n    output.writeUint8(value);\n  }\n\n  measure(\n    _: number | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(1);\n  }\n}\n\nexport const u8: Uint8Schema = new Uint8Schema();\n\n/**\n * Alias for `bin.u8`\n */\nexport const byte: Uint8Schema = u8;\n\n////\n// i16\n////\n\nexport class Int16Schema extends Schema<number> {\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  readonly maxSize = 2;\n\n  read(input: ISerialInput): number {\n    return input.readInt16();\n  }\n\n  write(output: ISerialOutput, value: number): void {\n    output.writeInt16(value);\n  }\n\n  measure(\n    _: number | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(2);\n  }\n}\n\nexport const i16: Int16Schema = new Int16Schema();\n\n////\n// u16\n////\n\nexport class Uint16Schema extends Schema<number> {\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  readonly maxSize = 2;\n\n  read(input: ISerialInput): number {\n    return input.readUint16();\n  }\n\n  write(output: ISerialOutput, value: number): void {\n    output.writeUint16(value);\n  }\n\n  measure(\n    _: number | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(2);\n  }\n}\n\nexport const u16: Uint16Schema = new Uint16Schema();\n\n////\n// i32\n////\n\nexport class Int32Schema extends Schema<number> {\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  readonly maxSize = 4;\n\n  read(input: ISerialInput): number {\n    return input.readInt32();\n  }\n\n  write(output: ISerialOutput, value: number): void {\n    output.writeInt32(value);\n  }\n\n  measure(\n    _: number | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(4);\n  }\n}\n\nexport const i32: Int32Schema = new Int32Schema();\n\n////\n// u32\n////\n\nexport class Uint32Schema extends Schema<number> {\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  readonly maxSize = 4;\n\n  read(input: ISerialInput): number {\n    return input.readUint32();\n  }\n\n  write(output: ISerialOutput, value: number): void {\n    output.writeUint32(value);\n  }\n\n  measure(\n    _: number | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(4);\n  }\n}\n\nexport const u32: Uint32Schema = new Uint32Schema();\n\n////\n// f16\n////\n\nexport class Float16Schema extends Schema<number> {\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  readonly maxSize = 2;\n\n  read(input: ISerialInput): number {\n    return input.readFloat16();\n  }\n\n  write(output: ISerialOutput, value: number): void {\n    output.writeFloat16(value);\n  }\n\n  measure(\n    _: number | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(2);\n  }\n}\n\nexport const f16: Float16Schema = new Float16Schema();\n\n////\n// f32\n////\n\nexport class Float32Schema extends Schema<number> {\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  readonly maxSize = 4;\n\n  read(input: ISerialInput): number {\n    return input.readFloat32();\n  }\n\n  write(output: ISerialOutput, value: number): void {\n    output.writeFloat32(value);\n  }\n\n  measure(\n    _: number | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(4);\n  }\n}\n\nexport const f32: Float32Schema = new Float32Schema();\n", "import { ValidationError } from '../error.ts';\nimport { Measurer } from '../io/measurer.ts';\nimport type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport { Schema } from './types.ts';\n\nexport class CharsSchema<\n  TLength extends number = number,\n> extends Schema<string> {\n  constructor(public readonly length: TLength) {\n    super();\n  }\n\n  write(output: ISerialOutput, value: string): void {\n    if (value.length !== this.length) {\n      throw new ValidationError(\n        `Expected char-string of length ${this.length}, got ${value.length}`,\n      );\n    }\n\n    for (let i = 0; i < value.length; ++i) {\n      output.writeUint8(value.charCodeAt(i));\n    }\n  }\n\n  read(input: ISerialInput): string {\n    let content = '';\n\n    for (let i = 0; i < this.length; ++i) {\n      content += String.fromCharCode(input.readByte());\n    }\n\n    return content;\n  }\n\n  measure(_: string, measurer: IMeasurer = new Measurer()): IMeasurer {\n    return measurer.add(this.length);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function chars<T extends number>(length: T): CharsSchema<T> {\n  return new CharsSchema(length);\n}\n", "import { Measurer } from '../io/measurer.ts';\nimport type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport type { ParseUnwrappedRecord, Parsed } from '../utilityTypes.ts';\nimport {\n  type AnySchema,\n  type AnySchemaWithProperties,\n  type IRefResolver,\n  type ISchema,\n  type ISchemaWithProperties,\n  MaxValue,\n  type PropertyDescription,\n  Schema,\n  SubTypeKey,\n  type Unwrap,\n  type UnwrapRecord,\n} from './types.ts';\n\n// @__NO_SIDE_EFFECTS__\nexport function exactEntries<T extends Record<keyof T, T[keyof T]>>(\n  record: T,\n): [keyof T, T[keyof T]][] {\n  return Object.entries(record) as [keyof T, T[keyof T]][];\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function resolveMap<T extends Record<string, AnySchema>>(\n  ctx: IRefResolver,\n  refs: T,\n): T {\n  const props = {} as T;\n\n  for (const [key, ref] of exactEntries(refs)) {\n    props[key] = ctx.resolve(ref);\n  }\n\n  return props;\n}\n\nexport type AnyObjectSchema = ObjectSchema<Record<string, AnySchema>>;\n\nexport class ObjectSchema<TProps extends Record<string, AnySchema>>\n  extends Schema<UnwrapRecord<TProps>>\n  implements ISchemaWithProperties<TProps>\n{\n  public properties: TProps;\n\n  constructor(private readonly _properties: TProps) {\n    super();\n\n    // In case this object isn't part of a keyed chain,\n    // let's assume properties are stable.\n    this.properties = _properties;\n  }\n\n  override resolveReferences(ctx: IRefResolver): void {\n    this.properties = resolveMap(ctx, this._properties);\n  }\n\n  override write(\n    output: ISerialOutput,\n    value: ParseUnwrappedRecord<TProps>,\n  ): void {\n    type Property = keyof ParseUnwrappedRecord<TProps>;\n\n    for (const [key, property] of exactEntries(this.properties)) {\n      property.write(output, value[key as Property]);\n    }\n  }\n\n  override read(input: ISerialInput): ParseUnwrappedRecord<TProps> {\n    type Property = keyof ParseUnwrappedRecord<TProps>;\n\n    const result = {} as ParseUnwrappedRecord<TProps>;\n\n    for (const [key, property] of exactEntries(this.properties)) {\n      result[key as Property] = property.read(input) as Parsed<\n        UnwrapRecord<TProps>\n      >[Property];\n    }\n\n    return result;\n  }\n\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Is `NaN` if the schema is unbounded. If you would like to know\n   * how many bytes a particular value encoding will take up, use `.measure(value)`.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  get maxSize(): number {\n    const measurer = new Measurer();\n\n    for (const property of Object.values(this.properties)) {\n      property.measure(MaxValue, measurer);\n    }\n\n    return measurer.size;\n  }\n\n  override measure(\n    value: ParseUnwrappedRecord<TProps> | typeof MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    type Property = keyof ParseUnwrappedRecord<TProps>;\n\n    for (const [key, property] of exactEntries(this.properties)) {\n      property.measure(\n        value === MaxValue ? MaxValue : value[key as Property],\n        measurer,\n      );\n    }\n\n    return measurer;\n  }\n\n  override seekProperty(\n    reference: ParseUnwrappedRecord<TProps> | MaxValue,\n    prop: keyof UnwrapRecord<TProps>,\n  ): PropertyDescription | null {\n    let bufferOffset = 0;\n\n    for (const [key, property] of exactEntries(this.properties)) {\n      if (key === prop) {\n        return {\n          bufferOffset,\n          schema: property,\n        };\n      }\n\n      bufferOffset += property.measure(reference).size;\n    }\n\n    return null;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function object<P extends Record<string, AnySchema>>(\n  properties: P,\n): ObjectSchema<P> {\n  return new ObjectSchema(properties);\n}\n\ntype UnwrapGeneric<Base extends Record<string, AnySchema>, Ext> = {\n  [TKey in keyof Ext]: ISchema<\n    UnwrapRecord<Base> & { type: TKey } & UnwrapRecord<Unwrap<Ext[TKey]>>\n  >;\n}[keyof Ext];\n\nexport class GenericObjectSchema<\n  TUnwrapBase extends Record<string, AnySchema>, // Base properties\n  TUnwrapExt extends Record<string, AnySchemaWithProperties>, // Sub type map\n> extends Schema<UnwrapGeneric<TUnwrapBase, TUnwrapExt>> {\n  private _baseObject: ObjectSchema<TUnwrapBase>;\n  public subTypeMap: TUnwrapExt;\n\n  constructor(\n    public readonly keyedBy: SubTypeKey,\n    properties: TUnwrapBase,\n    private readonly _subTypeMap: TUnwrapExt,\n  ) {\n    super();\n\n    this._baseObject = new ObjectSchema(properties);\n\n    // In case this object isn't part of a keyed chain,\n    // let's assume sub types are stable.\n    this.subTypeMap = _subTypeMap;\n  }\n\n  override resolveReferences(ctx: IRefResolver): void {\n    this._baseObject.resolveReferences(ctx);\n    this.subTypeMap = resolveMap(ctx, this._subTypeMap);\n  }\n\n  override write(\n    output: ISerialOutput,\n    value: Parsed<UnwrapGeneric<TUnwrapBase, TUnwrapExt>>,\n  ): void {\n    // Figuring out sub-types\n\n    const subTypeKey = value.type as keyof TUnwrapExt;\n    const subTypeDescription = this.subTypeMap[subTypeKey] || null;\n    if (subTypeDescription === null) {\n      throw new Error(\n        `Unknown sub-type '${subTypeKey.toString()}' in among '${JSON.stringify(\n          Object.keys(this.subTypeMap),\n        )}'`,\n      );\n    }\n\n    // Writing the sub-type out.\n    if (this.keyedBy === SubTypeKey.ENUM) {\n      output.writeUint8(value.type as number);\n    } else {\n      output.writeString(value.type as string);\n    }\n\n    // Writing the base properties\n    this._baseObject.write(output, value as ParseUnwrappedRecord<TUnwrapBase>);\n\n    // Extra sub-type fields\n    for (const [key, extraProp] of exactEntries(\n      subTypeDescription.properties,\n    )) {\n      extraProp.write(output, value[key]);\n    }\n  }\n\n  override read(\n    input: ISerialInput,\n  ): Parsed<UnwrapGeneric<TUnwrapBase, TUnwrapExt>> {\n    const subTypeKey =\n      this.keyedBy === SubTypeKey.ENUM ? input.readByte() : input.readString();\n\n    const subTypeDescription =\n      this.subTypeMap[subTypeKey as keyof TUnwrapExt] || null;\n    if (subTypeDescription === null) {\n      throw new Error(\n        `Unknown sub-type '${subTypeKey}' in among '${JSON.stringify(\n          Object.keys(this.subTypeMap),\n        )}'`,\n      );\n    }\n\n    const result = this._baseObject.read(input) as Parsed<\n      UnwrapGeneric<TUnwrapBase, TUnwrapExt>\n    >;\n\n    // Making the sub type key available to the result object.\n    (result as { type: keyof TUnwrapExt }).type =\n      subTypeKey as keyof TUnwrapExt;\n\n    if (subTypeDescription !== null) {\n      for (const [key, extraProp] of exactEntries(\n        subTypeDescription.properties,\n      )) {\n        // biome-ignore lint/suspicious/noExplicitAny: <covered by tests>\n        (result as any)[key] = extraProp.read(input);\n      }\n    }\n\n    return result;\n  }\n\n  measure(\n    value: Parsed<UnwrapGeneric<TUnwrapBase, TUnwrapExt>> | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    this._baseObject.measure(\n      value as Parsed<UnwrapRecord<TUnwrapBase>> | MaxValue,\n      measurer,\n    );\n\n    // We're a generic object trying to encode a concrete value.\n    if (this.keyedBy === SubTypeKey.ENUM) {\n      measurer.add(1);\n    } else if (value !== MaxValue) {\n      measurer.add((value.type as string).length + 1);\n    } else {\n      // 'type' can be a string of any length, so the schema is unbounded.\n      return measurer.unbounded;\n    }\n\n    // Extra sub-type fields\n    if (value === MaxValue) {\n      const biggestSubType = (\n        Object.values(this.subTypeMap) as TUnwrapExt[keyof TUnwrapExt][]\n      )\n        .map((subType) => {\n          const forkedMeasurer = measurer.fork();\n\n          // Going through extra properties\n          for (const prop of Object.values(subType.properties)) {\n            // Measuring them\n            prop.measure(MaxValue, forkedMeasurer);\n          }\n\n          return [subType, forkedMeasurer.size] as const;\n        })\n        .reduce((a, b) => (a[1] > b[1] ? a : b))[0];\n\n      // Going through extra properties\n      for (const prop of Object.values(biggestSubType.properties)) {\n        // Measuring for real this time\n        prop.measure(MaxValue, measurer);\n      }\n    } else {\n      const subTypeKey = (value as { type: keyof TUnwrapExt }).type;\n      const subTypeDescription = this.subTypeMap[subTypeKey] || null;\n      if (subTypeDescription === null) {\n        throw new Error(\n          `Unknown sub-type '${subTypeKey.toString()}', expected one of '${JSON.stringify(\n            Object.keys(this.subTypeMap),\n          )}'`,\n        );\n      }\n\n      // Going through extra properties\n      for (const [key, prop] of exactEntries(subTypeDescription.properties)) {\n        // Measuring them\n        prop.measure(value[key], measurer);\n      }\n    }\n\n    return measurer;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function generic<\n  P extends Record<string, AnySchema>,\n  S extends {\n    [Key in keyof S]: AnySchemaWithProperties;\n  },\n>(properties: P, subTypeMap: S): GenericObjectSchema<P, S> {\n  return new GenericObjectSchema(SubTypeKey.STRING, properties, subTypeMap);\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function genericEnum<\n  P extends Record<string, AnySchema>,\n  S extends {\n    [Key in keyof S]: AnySchemaWithProperties;\n  },\n>(properties: P, subTypeMap: S): GenericObjectSchema<P, S> {\n  return new GenericObjectSchema(SubTypeKey.ENUM, properties, subTypeMap);\n}\n", "import type { MergeRecordUnion } from '../utilityTypes.ts';\nimport { type AnyObjectSchema, ObjectSchema } from './object.ts';\nimport type { PropertiesOf } from './types.ts';\n\ntype Concat<Objs extends AnyObjectSchema[]> = ObjectSchema<\n  MergeRecordUnion<PropertiesOf<Objs[number]>>\n>;\n\n// @__NO_SIDE_EFFECTS__\nexport function concat<Objs extends AnyObjectSchema[]>(\n  objs: Objs,\n): Concat<Objs> {\n  return new ObjectSchema(\n    Object.fromEntries(\n      objs.flatMap(({ properties }) => Object.entries(properties)),\n    ) as unknown as Concat<Objs>['properties'],\n  );\n}\n", "import { Measurer } from '../io/measurer.ts';\nimport type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport type { ParseUnwrapped } from '../utilityTypes.ts';\nimport {\n  type AnySchema,\n  type IRefResolver,\n  MaxValue,\n  type PropertyDescription,\n  Schema,\n  type Unwrap,\n} from './types.ts';\n\nexport class DynamicArraySchema<TElement extends AnySchema> extends Schema<\n  Unwrap<TElement>[]\n> {\n  public elementType: TElement;\n\n  constructor(private readonly _unstableElementType: TElement) {\n    super();\n\n    // In case this array isn't part of a keyed chain,\n    // let's assume the inner type is stable.\n    this.elementType = _unstableElementType;\n  }\n\n  override resolveReferences(ctx: IRefResolver): void {\n    this.elementType = ctx.resolve(this._unstableElementType);\n  }\n\n  override write(\n    output: ISerialOutput,\n    values: ParseUnwrapped<TElement>[],\n  ): void {\n    output.writeUint32(values.length);\n\n    for (const value of values) {\n      this.elementType.write(output, value);\n    }\n  }\n\n  override read(input: ISerialInput): ParseUnwrapped<TElement>[] {\n    const array: ParseUnwrapped<TElement>[] = [];\n\n    const len = input.readUint32();\n\n    for (let i = 0; i < len; ++i) {\n      array.push(this.elementType.read(input) as ParseUnwrapped<TElement>);\n    }\n\n    return array;\n  }\n\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Is `NaN` if the schema is unbounded. If you would like to know\n   * how many bytes a particular value encoding will take up, use `.measure(value)`.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  get maxSize(): number {\n    return this.measure(MaxValue).size;\n  }\n\n  override measure(\n    values: ParseUnwrapped<TElement>[] | typeof MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    if (values === MaxValue) {\n      // arrays cannot be bound\n      return measurer.unbounded;\n    }\n\n    // Length encoding\n    measurer.add(4); // u32\n\n    // Values encoding\n    for (const value of values) {\n      this.elementType.measure(value, measurer);\n    }\n\n    return measurer;\n  }\n\n  override seekProperty(\n    reference: ParseUnwrapped<TElement>[] | MaxValue,\n    prop: number,\n  ): PropertyDescription | null {\n    if (typeof prop === 'symbol') {\n      return null;\n    }\n\n    const indexProp = Number.parseInt(String(prop), 10);\n    if (Number.isNaN(indexProp)) {\n      return null;\n    }\n\n    if (reference === MaxValue) {\n      return {\n        bufferOffset: this.elementType.measure(MaxValue).size * indexProp,\n        schema: this.elementType,\n      };\n    }\n\n    if (indexProp >= reference.length) {\n      // index out of range\n      return null;\n    }\n\n    const measurer = new Measurer();\n    for (let i = 0; i < indexProp; ++i) {\n      this.elementType.measure(reference[i], measurer);\n    }\n\n    return {\n      bufferOffset: measurer.size,\n      schema: this.elementType,\n    };\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function dynamicArrayOf<TSchema extends AnySchema>(\n  elementSchema: TSchema,\n): DynamicArraySchema<TSchema> {\n  return new DynamicArraySchema(elementSchema);\n}\n", "import { UnresolvedReferenceError } from '../error.ts';\nimport { Measurer } from '../io/measurer.ts';\nimport type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport type { ParseUnwrapped, Parsed } from '../utilityTypes.ts';\nimport {\n  type AnySchema,\n  type IKeyedSchema,\n  type IRefResolver,\n  type ISchema,\n  MaxValue,\n  type PropertyDescription,\n  Ref,\n  type Unwrap,\n} from './types.ts';\n\nclass RefSchema<TKeyDef extends string> implements ISchema<Ref<TKeyDef>> {\n  public readonly __unwrapped!: Ref<TKeyDef>;\n  public readonly ref: Ref<TKeyDef>;\n\n  constructor(key: TKeyDef) {\n    this.ref = new Ref(key);\n  }\n\n  resolveReferences(): void {\n    throw new UnresolvedReferenceError(\n      'Tried to resolve a reference directly. Do it through a RefResolver instead.',\n    );\n  }\n\n  read(): Parsed<Ref<TKeyDef>> {\n    throw new UnresolvedReferenceError(\n      'Tried to read a reference directly. Resolve it instead.',\n    );\n  }\n\n  write(): void {\n    throw new UnresolvedReferenceError(\n      'Tried to write a reference directly. Resolve it instead.',\n    );\n  }\n\n  measure(): IMeasurer {\n    throw new UnresolvedReferenceError(\n      'Tried to measure size of a reference directly. Resolve it instead.',\n    );\n  }\n\n  seekProperty(): PropertyDescription | null {\n    throw new UnresolvedReferenceError(\n      'Tried to seek property of a reference directly. Resolve it instead.',\n    );\n  }\n}\n\nclass RefResolve implements IRefResolver {\n  private registry: { [key: string]: ISchema<unknown> } = {};\n\n  hasKey(key: string): boolean {\n    return this.registry[key] !== undefined;\n  }\n\n  register<K extends string>(key: K, schema: ISchema<unknown>): void {\n    this.registry[key] = schema;\n  }\n\n  resolve<TSchema extends AnySchema>(unstableSchema: TSchema): TSchema {\n    if (unstableSchema instanceof RefSchema) {\n      const ref = unstableSchema.ref;\n      const key = ref.key as string;\n      if (this.registry[key] !== undefined) {\n        return this.registry[key] as TSchema;\n      }\n\n      throw new UnresolvedReferenceError(\n        `Couldn't resolve reference to ${key}. Unknown key.`,\n      );\n    }\n\n    // Since it's not a RefSchema, we assume it can be resolved.\n    unstableSchema.resolveReferences(this);\n\n    return unstableSchema;\n  }\n}\n\nexport class KeyedSchema<\n  TInner extends ISchema<unknown>,\n  TKeyDef extends string,\n> implements IKeyedSchema<TKeyDef, Unwrap<TInner>>\n{\n  public readonly __unwrapped!: Unwrap<TInner>;\n  public readonly __keyDefinition!: TKeyDef;\n  public innerType: TInner;\n\n  constructor(\n    public readonly key: TKeyDef,\n    innerResolver: (ref: ISchema<Ref<TKeyDef>>) => TInner,\n  ) {\n    this.innerType = innerResolver(new RefSchema(key));\n\n    // Automatically resolving after keyed creation.\n    this.resolveReferences(new RefResolve());\n  }\n\n  resolveReferences(ctx: IRefResolver): void {\n    if (!ctx.hasKey(this.key)) {\n      ctx.register(this.key, this.innerType);\n\n      this.innerType.resolveReferences(ctx);\n    }\n  }\n\n  read(input: ISerialInput): ParseUnwrapped<TInner> {\n    return this.innerType.read(input) as ParseUnwrapped<TInner>;\n  }\n\n  write(output: ISerialOutput, value: ParseUnwrapped<TInner>): void {\n    this.innerType.write(output, value);\n  }\n\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Is `NaN` if the schema is unbounded. If you would like to know\n   * how many bytes a particular value encoding will take up, use `.measure(value)`.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  get maxSize(): number {\n    return this.measure(MaxValue).size;\n  }\n\n  measure(\n    value: ParseUnwrapped<TInner> | typeof MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return this.innerType.measure(value, measurer);\n  }\n\n  seekProperty(\n    reference: ParseUnwrapped<TInner> | typeof MaxValue,\n    prop: keyof Unwrap<TInner>,\n  ): PropertyDescription | null {\n    return this.innerType.seekProperty(reference, prop as never);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function keyed<K extends string, P extends ISchema<unknown>>(\n  key: K,\n  inner: (ref: ISchema<Ref<K>>) => P,\n): KeyedSchema<P, K> {\n  return new KeyedSchema(key, inner);\n}\n", "import { Measurer } from '../io/measurer.ts';\nimport type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport type { ParseUnwrapped } from '../utilityTypes.ts';\nimport {\n  type AnySchema,\n  type IRefResolver,\n  MaxValue,\n  Schema,\n  type Unwrap,\n} from './types.ts';\n\nexport class OptionalSchema<TInner extends AnySchema> extends Schema<\n  Unwrap<TInner> | undefined\n> {\n  private innerSchema: TInner;\n\n  constructor(private readonly _innerUnstableSchema: TInner) {\n    super();\n\n    // In case this optional isn't part of a keyed chain,\n    // let's assume the inner type is stable.\n    this.innerSchema = _innerUnstableSchema;\n  }\n\n  override resolveReferences(ctx: IRefResolver): void {\n    this.innerSchema = ctx.resolve(this._innerUnstableSchema);\n  }\n\n  override write(\n    output: ISerialOutput,\n    value: ParseUnwrapped<TInner> | undefined,\n  ): void {\n    if (value !== undefined && value !== null) {\n      output.writeBool(true);\n      this.innerSchema.write(output, value);\n    } else {\n      output.writeBool(false);\n    }\n  }\n\n  override read(input: ISerialInput): ParseUnwrapped<TInner> | undefined {\n    const valueExists = input.readBool();\n\n    if (valueExists) {\n      return this.innerSchema.read(input) as ParseUnwrapped<TInner>;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Is `NaN` if the schema is unbounded. If you would like to know\n   * how many bytes a particular value encoding will take up, use `.measure(value)`.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  get maxSize(): number {\n    return this.measure(MaxValue).size;\n  }\n\n  override measure(\n    value: ParseUnwrapped<TInner> | MaxValue | undefined,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    if (value !== undefined) {\n      this.innerSchema.measure(value, measurer);\n    }\n\n    return measurer.add(1);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function optional<TSchema extends AnySchema>(\n  innerType: TSchema,\n): OptionalSchema<TSchema> {\n  return new OptionalSchema(innerType);\n}\n", "import { ValidationError } from '../error.ts';\nimport { Measurer } from '../io/measurer.ts';\nimport type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport type { Parsed } from '../utilityTypes.ts';\nimport {\n  type AnySchema,\n  type IRefResolver,\n  MaxValue,\n  Schema,\n  type UnwrapArray,\n} from './types.ts';\n\n// @__NO_SIDE_EFFECTS__\nexport function resolveArray<T extends AnySchema[]>(\n  ctx: IRefResolver,\n  refs: T,\n): T {\n  return refs.map((ref) => ctx.resolve(ref)) as T;\n}\n\nexport class TupleSchema<\n  TSequence extends [AnySchema, ...AnySchema[]],\n> extends Schema<UnwrapArray<TSequence>> {\n  private schemas: TSequence;\n\n  constructor(private readonly _unstableSchemas: TSequence) {\n    super();\n\n    // In case this tuple isn't part of a keyed chain,\n    // let's assume the inner type is stable.\n    this.schemas = _unstableSchemas;\n  }\n\n  override resolveReferences(ctx: IRefResolver): void {\n    this.schemas = resolveArray(ctx, this._unstableSchemas);\n  }\n\n  override write(\n    output: ISerialOutput,\n    values: Parsed<UnwrapArray<TSequence>>,\n  ): void {\n    if (values.length !== this.schemas.length) {\n      throw new ValidationError(\n        `Expected tuple of length ${this.schemas.length}, got ${values.length}`,\n      );\n    }\n\n    for (let i = 0; i < this.schemas.length; ++i) {\n      this.schemas[i].write(output, values[i]);\n    }\n  }\n\n  override read(input: ISerialInput): Parsed<UnwrapArray<TSequence>> {\n    const array = [] as Parsed<UnwrapArray<TSequence>>;\n\n    for (let i = 0; i < this.schemas.length; ++i) {\n      array.push(\n        this.schemas[i].read(input) as Parsed<UnwrapArray<TSequence>>[number],\n      );\n    }\n\n    return array;\n  }\n\n  /**\n   * The maximum number of bytes this schema can take up.\n   *\n   * Is `NaN` if the schema is unbounded. If you would like to know\n   * how many bytes a particular value encoding will take up, use `.measure(value)`.\n   *\n   * Alias for `.measure(MaxValue).size`\n   */\n  get maxSize(): number {\n    return this.measure(MaxValue).size;\n  }\n\n  measure(\n    values: Parsed<UnwrapArray<TSequence>> | MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    for (let i = 0; i < this.schemas.length; ++i) {\n      this.schemas[i].measure(\n        values === MaxValue ? MaxValue : values[i],\n        measurer,\n      );\n    }\n\n    return measurer;\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function tupleOf<TSchema extends [AnySchema, ...AnySchema[]]>(\n  schemas: TSchema,\n): TupleSchema<TSchema> {\n  return new TupleSchema(schemas);\n}\n", "import { Measurer } from '../io/measurer.ts';\nimport type { IMeasurer, ISerialInput, ISerialOutput } from '../io/types.ts';\nimport type { Parsed } from '../utilityTypes.ts';\nimport { type MaxValue, Schema } from './types.ts';\n\ntype TypedArrayConstructor<T> = {\n  readonly BYTES_PER_ELEMENT: number;\n  new (buffer: ArrayBufferLike, offset?: number, length?: number): T;\n};\n\nexport class TypedArraySchema<\n  TTypedArray extends ArrayLike<number> & ArrayBufferView,\n> extends Schema<TTypedArray> {\n  public readonly byteLength: number;\n\n  constructor(\n    public readonly length: number,\n    private readonly _arrayConstructor: TypedArrayConstructor<TTypedArray>,\n  ) {\n    super();\n\n    this.byteLength = length * _arrayConstructor.BYTES_PER_ELEMENT;\n  }\n\n  write(output: ISerialOutput, value: Parsed<TTypedArray>): void {\n    output.writeSlice(value);\n  }\n\n  read(input: ISerialInput): Parsed<TTypedArray> {\n    const buffer = new ArrayBuffer(this.byteLength);\n    const view = new this._arrayConstructor(buffer, 0, this.length);\n    input.readSlice(view, 0, this.byteLength);\n    return view as Parsed<TTypedArray>;\n  }\n\n  measure(\n    _value: Parsed<TTypedArray> | typeof MaxValue,\n    measurer: IMeasurer = new Measurer(),\n  ): IMeasurer {\n    return measurer.add(this.byteLength);\n  }\n}\n\n// @__NO_SIDE_EFFECTS__\nexport const u8Array = (length: number): TypedArraySchema<Uint8Array> =>\n  new TypedArraySchema(length, Uint8Array);\n\n// @__NO_SIDE_EFFECTS__\nexport const u8ClampedArray = (\n  length: number,\n): TypedArraySchema<Uint8ClampedArray> =>\n  new TypedArraySchema(length, Uint8ClampedArray);\n\n// @__NO_SIDE_EFFECTS__\nexport const u16Array = (length: number): TypedArraySchema<Uint16Array> =>\n  new TypedArraySchema(length, Uint16Array);\n\n// @__NO_SIDE_EFFECTS__\nexport const u32Array = (length: number): TypedArraySchema<Uint32Array> =>\n  new TypedArraySchema(length, Uint32Array);\n\n// @__NO_SIDE_EFFECTS__\nexport const i8Array = (length: number): TypedArraySchema<Int8Array> =>\n  new TypedArraySchema(length, Int8Array);\n\n// @__NO_SIDE_EFFECTS__\nexport const i16Array = (length: number): TypedArraySchema<Int16Array> =>\n  new TypedArraySchema(length, Int16Array);\n\n// @__NO_SIDE_EFFECTS__\nexport const i32Array = (length: number): TypedArraySchema<Int32Array> =>\n  new TypedArraySchema(length, Int32Array);\n\n// @__NO_SIDE_EFFECTS__\nexport const f32Array = (length: number): TypedArraySchema<Float32Array> =>\n  new TypedArraySchema(length, Float32Array);\n\n// @__NO_SIDE_EFFECTS__\nexport const f64Array = (length: number): TypedArraySchema<Float64Array> =>\n  new TypedArraySchema(length, Float64Array);\n", "/**\n * @returns {Boolean} true if system is big endian\n */\n// @__NO_SIDE_EFFECTS__\nfunction isSystemBigEndian(): boolean {\n  const array = new Uint8Array(4);\n  const view = new Uint32Array(array.buffer);\n\n  view[0] = 1; // setting a one spanning 4 bytes\n\n  return array[0] === 0; // if zero is the left-most byte, one was encoded as big endian\n}\n\n// @__NO_SIDE_EFFECTS__\nexport function getSystemEndianness(): 'big' | 'little' {\n  return isSystemBigEndian() ? 'big' : 'little';\n}\n", "interface UnwrapBufferResult {\n  buffer: ArrayBufferLike;\n  byteOffset: number;\n  byteLength: number;\n}\n\n/**\n * Removes up to one layer of view over a buffer.\n */\n// @__NO_SIDE_EFFECTS__\nexport function unwrapBuffer(\n  buffer: ArrayBufferLike | ArrayBufferView,\n): UnwrapBufferResult {\n  let byteOffset = 0;\n  let innerBuffer = buffer;\n\n  if (!!innerBuffer && 'buffer' in innerBuffer && 'byteOffset' in innerBuffer) {\n    // Getting rid of the outer shell, which allow us to create new views on the buffer instead of creating copies of it.\n    byteOffset += innerBuffer.byteOffset;\n    innerBuffer = innerBuffer.buffer;\n  }\n\n  return { buffer: innerBuffer, byteOffset, byteLength: buffer.byteLength };\n}\n", "import { getSystemEndianness } from '../util.ts';\nimport type { Endianness } from './types.ts';\nimport { unwrapBuffer } from './unwrapBuffer.ts';\n\nexport type BufferIOOptions = {\n  /**\n   * @default 0\n   */\n  byteOffset?: number;\n  /**\n   * @default 'system'\n   */\n  endianness?: Endianness | 'system';\n};\n\nexport class BufferIOBase {\n  protected readonly dataView: DataView;\n  protected readonly littleEndian: boolean;\n  protected byteOffset = 0;\n\n  public readonly endianness: Endianness;\n\n  constructor(buffer: ArrayBufferLike, options?: BufferIOOptions) {\n    const { byteOffset = 0, endianness = 'system' } = options ?? {};\n\n    this.byteOffset = byteOffset;\n\n    const systemEndianness = getSystemEndianness();\n    this.endianness = endianness === 'system' ? systemEndianness : endianness;\n    this.littleEndian = this.endianness === 'little';\n\n    // Getting rid of the outer shell, which causes the Uint8Array line to create a copy, instead of a view.\n    const unwrapped = unwrapBuffer(buffer);\n    this.byteOffset += unwrapped.byteOffset;\n\n    this.dataView = new DataView(unwrapped.buffer);\n  }\n\n  get currentByteOffset(): number {\n    return this.byteOffset;\n  }\n\n  seekTo(offset: number): void {\n    this.byteOffset = offset;\n  }\n\n  skipBytes(bytes: number): void {\n    this.byteOffset += bytes;\n  }\n}\n", "export function numberToFloat16(value: number): number {\n  // conversion according to IEEE 754 binary16 format\n  if (value === 0) return 0;\n  if (Number.isNaN(value)) return 0x7e00;\n  if (!Number.isFinite(value)) return value > 0 ? 0x7c00 : 0xfc00;\n\n  const sign = value < 0 ? 1 : 0;\n  const absValue = Math.abs(value);\n  const exponent = Math.floor(Math.log2(absValue));\n  const mantissa = absValue / 2 ** exponent - 1;\n  const biasedExponent = exponent + 15;\n  const mantissaBits = Math.floor(mantissa * 1024);\n  return (sign << 15) | (biasedExponent << 10) | mantissaBits;\n}\n\nexport function float16ToNumber(uint16Encoding: number): number {\n  const sign = (uint16Encoding & 0x8000) >> 15;\n  const exponent = (uint16Encoding & 0x7c00) >> 10;\n  const mantissa = uint16Encoding & 0x3ff;\n  if (exponent === 0) {\n    return sign === 0 ? mantissa / 1024 : -mantissa / 1024;\n  }\n  if (exponent === 31) {\n    return mantissa === 0\n      ? sign === 0\n        ? Number.POSITIVE_INFINITY\n        : Number.NEGATIVE_INFINITY\n      : Number.NaN;\n  }\n  return (sign === 0 ? 1 : -1) * (1 + mantissa / 1024) * 2 ** (exponent - 15);\n}\n", "import { BufferIOBase } from './bufferIOBase.ts';\nimport { float16ToNumber } from './float16converter.ts';\nimport type { ISerialInput } from './types.ts';\nimport { unwrapBuffer } from './unwrapBuffer.ts';\n\nexport class BufferReader extends BufferIOBase implements ISerialInput {\n  private _cachedTextDecoder: TextDecoder | undefined;\n\n  private get _textDecoder() {\n    if (!this._cachedTextDecoder) {\n      this._cachedTextDecoder = new TextDecoder(undefined, { fatal: true });\n    }\n    return this._cachedTextDecoder;\n  }\n\n  readBool(): boolean {\n    return this.dataView.getUint8(this.byteOffset++) !== 0;\n  }\n\n  readByte(): number {\n    return this.dataView.getUint8(this.byteOffset++);\n  }\n\n  readInt8(): number {\n    return this.dataView.getInt8(this.byteOffset++);\n  }\n\n  readUint8(): number {\n    return this.dataView.getUint8(this.byteOffset++);\n  }\n\n  readInt16(): number {\n    const value = this.dataView.getInt16(this.byteOffset, this.littleEndian);\n    this.byteOffset += 2;\n    return value;\n  }\n\n  readUint16(): number {\n    const value = this.dataView.getUint16(this.byteOffset, this.littleEndian);\n    this.byteOffset += 2;\n    return value;\n  }\n\n  readInt32(): number {\n    const value = this.dataView.getInt32(this.byteOffset, this.littleEndian);\n    this.byteOffset += 4;\n    return value;\n  }\n\n  readUint32(): number {\n    const value = this.dataView.getUint32(this.byteOffset, this.littleEndian);\n    this.byteOffset += 4;\n    return value;\n  }\n\n  readFloat16(): number {\n    const value = this.dataView.getUint16(this.byteOffset, this.littleEndian);\n    this.byteOffset += 2;\n    return float16ToNumber(value);\n  }\n\n  readFloat32(): number {\n    const value = this.dataView.getFloat32(this.byteOffset, this.littleEndian);\n    this.byteOffset += 4;\n    return value;\n  }\n\n  readString(): string {\n    // Looking for the 'NULL' byte.\n    let strLength = 0;\n    while (this.byteOffset + strLength < this.dataView.byteLength) {\n      if (this.dataView.getUint8(this.byteOffset + strLength++) === 0) {\n        break;\n      }\n    }\n\n    const result = this._textDecoder.decode(\n      new Uint8Array(this.dataView.buffer, this.byteOffset, strLength - 1),\n    );\n\n    this.byteOffset += strLength;\n\n    return result;\n  }\n\n  readSlice(\n    bufferView: ArrayLike<number> & ArrayBufferView,\n    offset: number,\n    byteLength: number,\n  ): void {\n    const unwrapped = unwrapBuffer(bufferView);\n    const destU8 = new Uint8Array(\n      unwrapped.buffer,\n      unwrapped.byteOffset + offset,\n    );\n\n    for (let i = 0; i < byteLength; ++i) {\n      destU8[i] = this.dataView.getUint8(this.byteOffset++);\n    }\n  }\n}\n", "import { BufferIOBase } from './bufferIOBase.ts';\nimport { numberToFloat16 } from './float16converter.ts';\nimport type { ISerialOutput } from './types.ts';\nimport { unwrapBuffer } from './unwrapBuffer.ts';\n\nexport class BufferWriter extends BufferIOBase implements ISerialOutput {\n  private _cachedTextEncoder: TextEncoder | undefined;\n\n  private get _textEncoder() {\n    if (!this._cachedTextEncoder) {\n      this._cachedTextEncoder = new TextEncoder();\n    }\n    return this._cachedTextEncoder;\n  }\n\n  writeBool(value: boolean) {\n    this.dataView.setUint8(this.byteOffset++, value ? 1 : 0);\n  }\n\n  writeByte(value: number) {\n    this.dataView.setUint8(this.byteOffset++, value);\n  }\n\n  writeInt8(value: number) {\n    this.dataView.setInt8(this.byteOffset++, value);\n  }\n\n  writeUint8(value: number) {\n    this.dataView.setUint8(this.byteOffset++, value);\n  }\n\n  writeInt16(value: number) {\n    this.dataView.setInt16(this.byteOffset, value, this.littleEndian);\n    this.byteOffset += 2;\n  }\n\n  writeUint16(value: number) {\n    this.dataView.setUint16(this.byteOffset, value, this.littleEndian);\n    this.byteOffset += 2;\n  }\n\n  writeInt32(value: number) {\n    this.dataView.setInt32(this.byteOffset, value, this.littleEndian);\n    this.byteOffset += 4;\n  }\n\n  writeUint32(value: number) {\n    this.dataView.setUint32(this.byteOffset, value, this.littleEndian);\n    this.byteOffset += 4;\n  }\n\n  writeFloat16(value: number): void {\n    this.dataView.setUint16(\n      this.byteOffset,\n      numberToFloat16(value),\n      this.littleEndian,\n    );\n    this.byteOffset += 2;\n  }\n\n  writeFloat32(value: number) {\n    this.dataView.setFloat32(this.byteOffset, value, this.littleEndian);\n    this.byteOffset += 4;\n  }\n\n  writeString(value: string) {\n    const result = this._textEncoder.encodeInto(\n      value,\n      new Uint8Array(this.dataView.buffer, this.byteOffset),\n    );\n    this.byteOffset += result.written;\n\n    // Extra null character\n    this.dataView.setUint8(this.byteOffset++, 0);\n  }\n\n  writeSlice(bufferView: ArrayLike<number> & ArrayBufferView): void {\n    const unwrapped = unwrapBuffer(bufferView);\n\n    const srcU8 = new Uint8Array(\n      unwrapped.buffer,\n      unwrapped.byteOffset,\n      unwrapped.byteLength,\n    );\n\n    for (const srcByte of srcU8) {\n      this.dataView.setUint8(this.byteOffset++, srcByte);\n    }\n  }\n}\n", "import * as bin from './main-api.ts';\nexport * from './main-api.ts';\nexport { bin };\nexport default bin;\n\nexport { getSystemEndianness } from './util.ts';\nexport { MaxValue, SubTypeKey, Schema } from './structure/types.ts';\nexport {\n  BoolSchema,\n  Float16Schema,\n  Float32Schema,\n  Int16Schema,\n  Int32Schema,\n  Int8Schema,\n  StringSchema,\n  Uint16Schema,\n  Uint32Schema,\n  Uint8Schema,\n  /** @deprecated Use Uint8Schema instead. */\n  Uint8Schema as ByteSchema,\n} from './structure/baseTypes.ts';\nexport { ArraySchema } from './structure/array.ts';\nexport { CharsSchema } from './structure/chars.ts';\nexport { DynamicArraySchema } from './structure/dynamicArray.ts';\nexport { KeyedSchema } from './structure/keyed.ts';\nexport { ObjectSchema, GenericObjectSchema } from './structure/object.ts';\nexport { OptionalSchema } from './structure/optional.ts';\nexport { TupleSchema } from './structure/tuple.ts';\nexport { TypedArraySchema } from './structure/typedArray.ts';\n\nexport type { AnyObjectSchema } from './structure/object.ts';\nexport type {\n  Unwrap,\n  UnwrapRecord,\n  UnwrapArray,\n  IKeyedSchema,\n  Ref,\n  IRefResolver,\n  ISchema,\n  AnyKeyedSchema,\n  AnySchema,\n  AnySchemaWithProperties,\n  ISchemaWithProperties,\n} from './structure/types.ts';\nexport type { ParseUnwrapped } from './utilityTypes.ts';\n"],
  "mappings": "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AE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IACdpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAChBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,GAClBpB,EAAG,CAAC,EAAE,IAAIoB,EAAG,CAAC,EAAE,IAC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",
  "names": ["lengthVec2", "v", "lengthVec3", "lengthVec4", "dotVec2", "lhs", "rhs", "dotVec3", "dotVec4", "clamp", "value", "low", "high", "unary2f", "op", "a", "vec2f", "unary2h", "vec2h", "unary2i", "vec2i", "unary2u", "vec2u", "unary3f", "vec3f", "unary3h", "vec3h", "unary3i", "vec3i", "unary3u", "vec3u", "unary4f", "vec4f", "unary4h", "vec4h", "unary4i", "vec4i", "unary4u", "vec4u", "unary2x2f", "a_", "mat2x2f", "unary3x3f", "mat3x3f", "unary4x4f", "mat4x4f", "binaryComponentWise2f", "b", "binaryComponentWise2h", "binaryComponentWise2i", "binaryComponentWise2u", "binaryComponentWise3f", "binaryComponentWise3h", "binaryComponentWise3i", "binaryComponentWise3u", "binaryComponentWise4f", "binaryComponentWise4h", "binaryComponentWise4i", "binaryComponentWise4u", "binaryComponentWise2x2f", "b_", "binaryComponentWise3x3f", "binaryComponentWise4x4f", "NumberOps", "VectorOps", "e1", "e2", "vec2b", "vec3b", "vec4b", "e", "s", "m", "m_", "len", "base", "exponent", "e3", "val", "f", "t", "c", "isSnippetNumeric", "snippet", "isNumericSchema", "schema", "type", "$internal", "cpuAdd", "isVecInstance", "isMatInstance", "add", "createDualImpl", "snip", "cpuSub", "mul", "sub", "cpuMul", "isFloat32VecInstance", "returnType", "cpuDiv", "div", "f32", "abs", "atan2", "y", "x", "acos", "acosh", "asin", "ceil", "cos", "cosh", "cross", "dot", "normalize", "floor", "fract", "length", "log", "log2", "max", "min", "sign", "sin", "exp", "exp2", "pow", "mix", "reflect", "distance", "neg", "sqrt", "tanh", "_StringSchema"]
}
