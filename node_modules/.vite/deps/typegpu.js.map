{
  "version": 3,
  "sources": ["../../src/nodes.ts", "../../src/index.ts", "../../src/extractGpuValueGetter.ts", "../../src/shared/utilityTypes.ts", "../../src/tgsl/generationHelpers.ts", "../../src/core/valueProxyUtils.ts", "../../src/core/constant/tgpuConstant.ts", "../../src/core/slot/slotTypes.ts", "../../src/types.ts", "../../src/core/resolve/externals.ts", "../../src/core/declare/tgpuDeclare.ts", "../../src/core/function/fnCore.ts", "../../src/core/function/extractArgs.ts", "../../src/core/function/ioSchema.ts", "../../src/core/function/templateUtils.ts", "../../src/core/function/tgpuComputeFn.ts", "../../src/core/function/tgpuFn.ts", "../../src/core/function/tgpuFragmentFn.ts", "../../src/core/function/tgpuVertexFn.ts", "../../src/nameRegistry.ts", "../../src/core/vertexLayout/connectAttributesToShader.ts", "../../src/core/resolve/resolveData.ts", "../../src/core/buffer/buffer.ts", "../../src/data/offsets.ts", "../../src/data/alignIO.ts", "../../src/data/compiledIO.ts", "../../src/data/dataIO.ts", "../../src/data/partialIO.ts", "../../src/extension.ts", "../../src/core/buffer/bufferUsage.ts", "../../src/core/sampler/sampler.ts", "../../src/core/texture/externalTexture.ts", "../../src/core/texture/textureFormats.ts", "../../src/core/texture/texture.ts", "../../src/core/texture/usageExtension.ts", "../../src/tgpuBindGroupLayout.ts", "../../src/tgsl/wgslGenerator.ts", "../../src/resolutionCtx.ts", "../../src/core/resolve/tgpuResolve.ts", "../../src/core/querySet/querySet.ts", "../../src/memo.ts", "../../src/core/pipeline/timeable.ts", "../../src/core/pipeline/computePipeline.ts", "../../src/core/vertexLayout/vertexLayout.ts", "../../src/core/pipeline/connectAttachmentToShader.ts", "../../src/core/pipeline/connectTargetsToShader.ts", "../../src/core/pipeline/renderPipeline.ts", "../../src/core/buffer/bufferShorthand.ts", "../../src/core/root/init.ts", "../../src/core/slot/slot.ts", "../../src/core/slot/accessor.ts", "../../src/core/slot/derived.ts", "../../src/core/variable/tgpuVariable.ts", "../../src/index.ts"],
  "sourcesContent": ["//\n// Statement\n//\n\nexport const NodeTypeCatalog = {\n  // frequent\n  block: 0,\n  binaryExpr: 1,\n  assignmentExpr: 2,\n  logicalExpr: 3,\n  unaryExpr: 4,\n  numericLiteral: 5,\n  call: 6,\n  memberAccess: 7,\n  indexAccess: 8,\n\n  // regular\n  return: 10,\n  if: 11,\n  let: 12,\n  const: 13,\n  for: 14,\n  while: 15,\n  continue: 16,\n  break: 17,\n\n  // rare\n  arrayExpr: 100,\n  preUpdate: 101,\n  postUpdate: 102,\n  stringLiteral: 103,\n  objectExpr: 104,\n} as const;\n\nexport type NodeTypeCatalog = typeof NodeTypeCatalog;\n\n/**\n * Represents a return statement\n */\nexport type Return =\n  | readonly [type: NodeTypeCatalog['return'], expr: Expression]\n  | readonly [type: NodeTypeCatalog['return']];\n\n/**\n * Represents an if statement\n */\nexport type If =\n  | readonly [type: NodeTypeCatalog['if'], cond: Expression, then: Statement]\n  | readonly [\n    type: NodeTypeCatalog['if'],\n    cond: Expression,\n    then: Statement,\n    alt: Statement,\n  ];\n\n/**\n * Represents a block of statements\n */\nexport type Block = readonly [type: NodeTypeCatalog['block'], Statement[]];\n\n/**\n * Represents a let statement\n */\nexport type Let =\n  | readonly [type: NodeTypeCatalog['let'], identifier: string]\n  | readonly [\n    type: NodeTypeCatalog['let'],\n    identifier: string,\n    value: Expression,\n  ];\n\n/**\n * Represents a const statement\n */\nexport type Const = readonly [\n  type: NodeTypeCatalog['const'],\n  identifier: string,\n  value: Expression,\n];\n\nexport type For = readonly [\n  type: NodeTypeCatalog['for'],\n  init: Statement | null,\n  condition: Expression | null,\n  update: Statement | null,\n  body: Statement,\n];\n\nexport type While = readonly [\n  type: NodeTypeCatalog['while'],\n  condition: Expression,\n  body: Statement,\n];\n\nexport type Continue = readonly [type: NodeTypeCatalog['continue']];\n\nexport type Break = readonly [type: NodeTypeCatalog['break']];\n\n/**\n * A union type of all statements\n */\nexport type Statement =\n  | Return\n  | If\n  | Block\n  | Let\n  | Const\n  | Expression\n  | For\n  | While\n  | Continue\n  | Break;\n\n//\n// Expression\n//\n\nexport type BinaryOperator =\n  | '=='\n  | '!='\n  | '<'\n  | '<='\n  | '>'\n  | '>='\n  | '<<'\n  | '>>'\n  | '+'\n  | '-'\n  | '*'\n  | '/'\n  | '%'\n  | '|'\n  | '^'\n  | '&';\n\nexport type BinaryExpression = readonly [\n  type: NodeTypeCatalog['binaryExpr'],\n  lhs: Expression,\n  op: BinaryOperator,\n  rhs: Expression,\n];\n\nexport type AssignmentOperator =\n  | '='\n  | '+='\n  | '-='\n  | '*='\n  | '/='\n  | '%='\n  | '<<='\n  | '>>='\n  | '|='\n  | '^='\n  | '&='\n  | '**='\n  | '||='\n  | '&&=';\n\nexport type AssignmentExpression = readonly [\n  type: NodeTypeCatalog['assignmentExpr'],\n  lhs: Expression,\n  op: AssignmentOperator,\n  rhs: Expression,\n];\n\nexport type LogicalOperator = '&&' | '||';\n\nexport type LogicalExpression = readonly [\n  type: NodeTypeCatalog['logicalExpr'],\n  lhs: Expression,\n  op: LogicalOperator,\n  rhs: Expression,\n];\n\nexport type UnaryOperator =\n  | '-'\n  | '+'\n  | '!'\n  | '~'\n  | 'typeof'\n  | 'void'\n  | 'delete';\n\nexport type UnaryExpression = readonly [\n  type: NodeTypeCatalog['unaryExpr'],\n  op: UnaryOperator,\n  inner: Expression,\n];\n\nexport type ObjectExpression = readonly [\n  type: NodeTypeCatalog['objectExpr'],\n  Record<string, Expression>,\n];\n\nexport type ArrayExpression = readonly [\n  type: NodeTypeCatalog['arrayExpr'],\n  values: Expression[],\n];\n\nexport type MemberAccess = readonly [\n  type: NodeTypeCatalog['memberAccess'],\n  object: Expression,\n  member: string,\n];\n\nexport type IndexAccess = readonly [\n  type: NodeTypeCatalog['indexAccess'],\n  object: Expression,\n  property: Expression,\n];\n\nexport type Call = readonly [\n  type: NodeTypeCatalog['call'],\n  identifier: Expression,\n  args: Expression[],\n];\n\nexport type PostUpdate = readonly [\n  type: NodeTypeCatalog['postUpdate'],\n  operator: '++' | '--',\n  argument: Expression,\n];\n\nexport type PreUpdate = readonly [\n  type: NodeTypeCatalog['preUpdate'],\n  operator: '++' | '--',\n  argument: Expression,\n];\n\n/** A numeric literal */\nexport type Num = readonly [type: NodeTypeCatalog['numericLiteral'], string];\n\n/** A string literal */\nexport type Str = readonly [type: NodeTypeCatalog['stringLiteral'], string];\n\nexport type Literal = Num | Str | boolean;\n\n/** Identifiers are just strings, since string literals are rare in WGSL, and identifiers are everywhere. */\nexport type Expression =\n  | string\n  | BinaryExpression\n  | AssignmentExpression\n  | LogicalExpression\n  | UnaryExpression\n  | ObjectExpression\n  | MemberAccess\n  | IndexAccess\n  | ArrayExpression\n  | PreUpdate\n  | PostUpdate\n  | Call\n  | Literal;\n\nexport type AnyNode = Statement | Expression;\n\nexport const FuncParameterType = {\n  identifier: 'i',\n  destructuredObject: 'd',\n} as const;\n\nexport type FuncParameter =\n  | {\n    type: typeof FuncParameterType.identifier;\n    name: string;\n  }\n  | {\n    type: typeof FuncParameterType.destructuredObject;\n    props: {\n      name: string;\n      alias: string;\n    }[];\n  };\n", "/**\n * Each breaking change to the format requires a bump to this number.\n * It's used at runtime by `typegpu` to determine how to interpret\n * a function's AST. It gets embedded by `unplugin-typegpu` into\n * the source code at build time.\n */\nexport const FORMAT_VERSION = 1;\n\nexport * from './nodes.ts';\n", "import { $gpuValueOf } from './shared/symbols.ts';\nimport type { ResolutionCtx } from './types.ts';\n\nexport type GpuValueGetter = (ctx: ResolutionCtx) => unknown;\n\nexport function extractGpuValueGetter(\n  object: unknown,\n): GpuValueGetter | undefined {\n  // biome-ignore lint/suspicious/noExplicitAny: we're inspecting the value\n  if (typeof (object as any)?.[$gpuValueOf] === 'function') {\n    return (object as { [$gpuValueOf]: GpuValueGetter })[$gpuValueOf].bind(\n      object,\n    );\n  }\n  return undefined;\n}\n", "export type Default<T, TDefault> = unknown extends T ? TDefault\n  : T extends undefined ? TDefault\n  : T;\n\nexport type UnionToIntersection<U> =\n  // biome-ignore lint/suspicious/noExplicitAny: <had to be done>\n  (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I\n    : never;\n\nexport type Prettify<T> =\n  & {\n    [K in keyof T]: T[K];\n  }\n  & {};\n\n/**\n * Removes properties from record type that extend `Prop`\n */\nexport type OmitProps<T extends Record<string, unknown>, Prop> = Pick<\n  T,\n  {\n    [Key in keyof T]: T[Key] extends Prop ? never : Key;\n  }[keyof T]\n>;\n\n/**\n * Removes properties from record type that equal `Prop`\n */\nexport type OmitPropsExact<T extends Record<string, unknown>, Prop> = Pick<\n  T,\n  {\n    [Key in keyof T]: [T[Key], Prop] extends [Prop, T[Key]] ? never : Key;\n  }[keyof T]\n>;\n\nexport type NullableToOptional<T> =\n  & {\n    // Props where the value extends `null` -> make them optional and remove null from the type\n    [K in keyof T as T[K] extends null ? K : never]?: T[K];\n  }\n  & {\n    // All other props remain unchanged\n    [K in keyof T as T[K] extends null ? never : K]: T[K];\n  };\n\n/**\n * The opposite of Readonly<T>\n */\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Any typed array\n */\nexport type TypedArray =\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\nexport function assertExhaustive(x: never, location: string): never {\n  throw new Error(`Failed to handle ${x} at ${location}`);\n}\n", "import { arrayOf } from '../data/array.ts';\nimport {\n  type AnyData,\n  isDisarray,\n  isSnippet,\n  isUnstruct,\n  snip,\n  type Snippet,\n  UnknownData,\n} from '../data/dataTypes.ts';\nimport { mat2x2f, mat3x3f, mat4x4f } from '../data/matrix.ts';\nimport {\n  abstractFloat,\n  abstractInt,\n  bool,\n  f16,\n  f32,\n  i32,\n  u32,\n} from '../data/numeric.ts';\nimport {\n  vec2b,\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3b,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4b,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n  vecTypeToPrimitive,\n} from '../data/vector.ts';\nimport {\n  type AnyWgslData,\n  type AnyWgslStruct,\n  type F16,\n  type F32,\n  hasInternalDataType,\n  type I32,\n  isMat,\n  isMatInstance,\n  isVec,\n  isVecInstance,\n  isWgslArray,\n  isWgslStruct,\n  type U32,\n} from '../data/wgslTypes.ts';\nimport { invariant } from '../errors.ts';\nimport { getResolutionCtx } from '../gpuMode.ts';\nimport { $wgslDataType } from '../shared/symbols.ts';\nimport { assertExhaustive } from '../shared/utilityTypes.ts';\nimport { isNumericSchema } from '../std/numeric.ts';\nimport type { ResolutionCtx } from '../types.ts';\n\ntype SwizzleableType = 'f' | 'h' | 'i' | 'u' | 'b';\ntype SwizzleLength = 1 | 2 | 3 | 4;\n\nconst swizzleLenToType: Record<\n  SwizzleableType,\n  Record<SwizzleLength, AnyData>\n> = {\n  f: {\n    1: f32,\n    2: vec2f,\n    3: vec3f,\n    4: vec4f,\n  },\n  h: {\n    1: f16,\n    2: vec2h,\n    3: vec3h,\n    4: vec4h,\n  },\n  i: {\n    1: i32,\n    2: vec2i,\n    3: vec3i,\n    4: vec4i,\n  },\n  u: {\n    1: u32,\n    2: vec2u,\n    3: vec3u,\n    4: vec4u,\n  },\n  b: {\n    1: bool,\n    2: vec2b,\n    3: vec3b,\n    4: vec4b,\n  },\n} as const;\n\nconst kindToSchema = {\n  vec2f: vec2f,\n  vec2h: vec2h,\n  vec2i: vec2i,\n  vec2u: vec2u,\n  'vec2<bool>': vec2b,\n  vec3f: vec3f,\n  vec3h: vec3h,\n  vec3i: vec3i,\n  vec3u: vec3u,\n  'vec3<bool>': vec3b,\n  vec4f: vec4f,\n  vec4h: vec4h,\n  vec4i: vec4i,\n  vec4u: vec4u,\n  'vec4<bool>': vec4b,\n  mat2x2f: mat2x2f,\n  mat3x3f: mat3x3f,\n  mat4x4f: mat4x4f,\n} as const;\n\nconst indexableTypeToResult = {\n  vec2f: f32,\n  vec2h: f16,\n  vec2i: i32,\n  vec2u: u32,\n  'vec2<bool>': bool,\n  vec3f: f32,\n  vec3h: f16,\n  vec3i: i32,\n  vec3u: u32,\n  'vec3<bool>': bool,\n  vec4f: f32,\n  vec4h: f16,\n  vec4i: i32,\n  vec4u: u32,\n  'vec4<bool>': bool,\n  mat2x2f: vec2f,\n  mat3x3f: vec3f,\n  mat4x4f: vec4f,\n} as const;\n\nexport function getTypeForPropAccess(\n  targetType: AnyData,\n  propName: string,\n): AnyData | UnknownData {\n  if (isWgslStruct(targetType) || isUnstruct(targetType)) {\n    return targetType.propTypes[propName] as AnyData ?? UnknownData;\n  }\n\n  if (targetType === bool || isNumericSchema(targetType)) {\n    // No props to be accessed here\n    return UnknownData;\n  }\n\n  const propLength = propName.length;\n  if (\n    isVec(targetType) &&\n    propLength >= 1 &&\n    propLength <= 4\n  ) {\n    const swizzleTypeChar = targetType.type.includes('bool')\n      ? 'b'\n      : (targetType.type[4] as SwizzleableType);\n    const swizzleType =\n      swizzleLenToType[swizzleTypeChar][propLength as SwizzleLength];\n    if (swizzleType) {\n      return swizzleType;\n    }\n  }\n\n  return UnknownData;\n}\n\nexport function getTypeForIndexAccess(\n  dataType: AnyData,\n): AnyData | UnknownData {\n  // array\n  if (isWgslArray(dataType) || isDisarray(dataType)) {\n    return dataType.elementType as AnyData;\n  }\n\n  // vector or matrix\n  if (dataType.type in indexableTypeToResult) {\n    return indexableTypeToResult[\n      dataType.type as keyof typeof indexableTypeToResult\n    ];\n  }\n\n  return UnknownData;\n}\n\nexport function numericLiteralToSnippet(value: string): Snippet | undefined {\n  // Hex literals\n  if (/^0x[0-9a-f]+$/i.test(value)) {\n    return snip(value, abstractInt);\n  }\n\n  // Binary literals\n  if (/^0b[01]+$/i.test(value)) {\n    return snip(`${Number.parseInt(value.slice(2), 2)}`, abstractInt);\n  }\n\n  // Floating point literals\n  if (/^-?(?:\\d+\\.\\d*|\\d*\\.\\d+)$/i.test(value)) {\n    return snip(value, abstractFloat);\n  }\n\n  // Floating point literals with scientific notation\n  if (/^-?\\d+(?:\\.\\d+)?e-?\\d+$/i.test(value)) {\n    return snip(value, abstractFloat);\n  }\n\n  // Integer literals\n  if (/^-?\\d+$/i.test(value)) {\n    return snip(value, abstractInt);\n  }\n\n  return undefined;\n}\n\ntype ConversionAction = 'ref' | 'deref' | 'cast' | 'none';\n\ntype ConversionRankInfo =\n  | { rank: number; action: 'cast'; targetType: AnyData }\n  | { rank: number; action: Exclude<ConversionAction, 'cast'> };\n\nconst INFINITE_RANK: ConversionRankInfo = {\n  rank: Number.POSITIVE_INFINITY,\n  action: 'none',\n};\n\nfunction unwrapDecorated(data: AnyData): AnyData {\n  if (data.type === 'decorated') {\n    return data.inner as AnyData;\n  }\n  return data;\n}\n\nfunction getVectorComponent(type: AnyData): AnyData | undefined {\n  return isVec(type) ? vecTypeToPrimitive[type.type] : undefined;\n}\n\nfunction getAutoConversionRank(\n  src: AnyData,\n  dest: AnyData,\n): ConversionRankInfo {\n  const trueSrc = unwrapDecorated(src);\n  const trueDst = unwrapDecorated(dest);\n\n  if (trueSrc.type === trueDst.type) {\n    return { rank: 0, action: 'none' };\n  }\n\n  if (trueSrc.type === 'abstractFloat') {\n    if (trueDst.type === 'f32') return { rank: 1, action: 'none' };\n    if (trueDst.type === 'f16') return { rank: 2, action: 'none' };\n  }\n\n  if (trueSrc.type === 'abstractInt') {\n    if (trueDst.type === 'i32') return { rank: 3, action: 'none' };\n    if (trueDst.type === 'u32') return { rank: 4, action: 'none' };\n    if (trueDst.type === 'abstractFloat') return { rank: 5, action: 'none' };\n    if (trueDst.type === 'f32') return { rank: 6, action: 'none' };\n    if (trueDst.type === 'f16') return { rank: 7, action: 'none' };\n  }\n\n  if (isVec(trueSrc) && isVec(trueDst)) {\n    const compSrc = getVectorComponent(trueSrc);\n    const compDest = getVectorComponent(trueDst);\n    if (compSrc && compDest) {\n      return getAutoConversionRank(compSrc, compDest);\n    }\n  }\n\n  if (isMat(trueSrc) && isMat(trueDst)) {\n    // Matrix conversion rank depends only on component type (always f32 for now)\n    return { rank: 0, action: 'none' };\n  }\n\n  return INFINITE_RANK;\n}\n\nfunction getImplicitConversionRank(\n  src: AnyData,\n  dest: AnyData,\n): ConversionRankInfo {\n  const trueSrc = unwrapDecorated(src);\n  const trueDst = unwrapDecorated(dest);\n\n  if (\n    trueSrc.type === 'ptr' &&\n    getAutoConversionRank(trueSrc.inner as AnyData, trueDst).rank <\n      Number.POSITIVE_INFINITY\n  ) {\n    return { rank: 0, action: 'deref' };\n  }\n\n  if (\n    trueDst.type === 'ptr' &&\n    getAutoConversionRank(trueSrc, trueDst.inner as AnyData).rank <\n      Number.POSITIVE_INFINITY\n  ) {\n    return { rank: 1, action: 'ref' };\n  }\n\n  const primitivePreference = {\n    f32: 0,\n    f16: 1,\n    i32: 2,\n    u32: 3,\n    bool: 4,\n  } as const;\n  type PrimitiveType = keyof typeof primitivePreference;\n\n  if (\n    trueSrc.type in primitivePreference &&\n    trueDst.type in primitivePreference\n  ) {\n    const srcType = trueSrc.type as PrimitiveType;\n    const destType = trueDst.type as PrimitiveType;\n\n    if (srcType !== destType) {\n      const srcPref = primitivePreference[srcType];\n      const destPref = primitivePreference[destType];\n\n      const rank = destPref < srcPref ? 10 : 20;\n\n      return { rank: rank, action: 'cast', targetType: trueDst };\n    }\n  }\n\n  return INFINITE_RANK;\n}\n\nfunction getConversionRank(\n  src: AnyData,\n  dest: AnyData,\n  allowImplicit: boolean,\n): ConversionRankInfo {\n  const autoRank = getAutoConversionRank(src, dest);\n  if (autoRank.rank < Number.POSITIVE_INFINITY) {\n    return autoRank;\n  }\n  if (allowImplicit) {\n    return getImplicitConversionRank(src, dest);\n  }\n  return INFINITE_RANK;\n}\n\nexport type ConversionResultAction = {\n  sourceIndex: number;\n  action: ConversionAction;\n  targetType?: U32 | F32 | I32 | F16;\n};\n\nexport type ConversionResult = {\n  targetType: AnyData;\n  actions: ConversionResultAction[];\n  hasImplicitConversions?: boolean;\n};\n\nfunction findBestType(\n  types: AnyData[],\n  uniqueTypes: AnyData[],\n  allowImplicit: boolean,\n): ConversionResult | undefined {\n  let bestType: AnyData | undefined;\n  let minSum = Number.POSITIVE_INFINITY;\n  const conversionDetails = new Map<AnyData, ConversionRankInfo[]>();\n\n  for (const targetType of uniqueTypes) {\n    let currentSum = 0;\n    const currentDetails: ConversionRankInfo[] = [];\n    let possible = true;\n\n    for (const sourceType of types) {\n      const conversion = getConversionRank(\n        sourceType,\n        targetType,\n        allowImplicit,\n      );\n      if (conversion.rank === Number.POSITIVE_INFINITY) {\n        possible = false;\n        break;\n      }\n      currentSum += conversion.rank;\n      currentDetails.push(conversion);\n    }\n\n    if (possible && currentSum < minSum) {\n      minSum = currentSum;\n      bestType = targetType;\n      conversionDetails.set(bestType, currentDetails);\n    }\n  }\n\n  if (!bestType) {\n    return undefined;\n  }\n\n  const bestDetails = conversionDetails.get(bestType) as ConversionRankInfo[];\n  const actions: ConversionResultAction[] = bestDetails.map(\n    (detail, index) => ({\n      sourceIndex: index,\n      action: detail.action,\n      ...(detail.action === 'cast' && {\n        targetType: detail.targetType as U32 | F32 | I32 | F16,\n      }),\n    }),\n  );\n\n  const hasCasts = actions.some((action) => action.action === 'cast');\n\n  return { targetType: bestType, actions, hasImplicitConversions: hasCasts };\n}\n\nexport function concretize(type: AnyWgslData): AnyWgslData {\n  if (type.type === 'abstractFloat') {\n    return f32;\n  }\n\n  if (type.type === 'abstractInt') {\n    return i32;\n  }\n\n  return type;\n}\n\nexport function getBestConversion(\n  types: AnyData[],\n  targetTypes?: AnyData[],\n): ConversionResult | undefined {\n  if (types.length === 0) return undefined;\n\n  const uniqueTypes = [...new Set(types.map(unwrapDecorated))];\n  const uniqueTargetTypes = targetTypes\n    ? [...new Set(targetTypes.map(unwrapDecorated))]\n    : uniqueTypes;\n\n  const explicitResult = findBestType(types, uniqueTargetTypes, false);\n  if (explicitResult) {\n    return explicitResult;\n  }\n\n  const implicitResult = findBestType(types, uniqueTargetTypes, true);\n  if (implicitResult) {\n    implicitResult.hasImplicitConversions = implicitResult.actions.some(\n      (action) => action.action === 'cast',\n    );\n    return implicitResult;\n  }\n\n  return undefined;\n}\n\nexport function convertType(\n  sourceType: AnyData,\n  targetType: AnyData,\n  allowImplicit = true,\n): ConversionResult | undefined {\n  const conversion = getConversionRank(sourceType, targetType, allowImplicit);\n\n  if (conversion.rank < Number.POSITIVE_INFINITY) {\n    const actionDetail: ConversionResultAction = {\n      sourceIndex: 0,\n      action: conversion.action,\n    };\n    if (conversion.action === 'cast') {\n      actionDetail.targetType = conversion.targetType as U32 | F32 | I32 | F16;\n    }\n    return {\n      targetType: unwrapDecorated(targetType),\n      actions: [actionDetail],\n      hasImplicitConversions: conversion.action === 'cast',\n    };\n  }\n\n  return undefined;\n}\n\nexport type GenerationCtx = ResolutionCtx & {\n  readonly pre: string;\n  readonly callStack: unknown[];\n  indent(): string;\n  dedent(): string;\n  pushBlockScope(): void;\n  popBlockScope(): void;\n  getById(id: string): Snippet | null;\n  defineVariable(id: string, dataType: AnyWgslData | UnknownData): Snippet;\n};\n\nfunction applyActionToSnippet(\n  ctx: GenerationCtx,\n  value: Snippet,\n  action: ConversionResultAction,\n  targetType: AnyData,\n): Snippet {\n  if (action.action === 'none') {\n    return snip(value.value, targetType);\n  }\n\n  const resolvedValue = ctx.resolve(value.value);\n\n  switch (action.action) {\n    case 'ref':\n      return snip(`&${resolvedValue}`, targetType);\n    case 'deref':\n      return snip(`*${resolvedValue}`, targetType);\n    case 'cast': {\n      return snip(`${ctx.resolve(targetType)}(${resolvedValue})`, targetType);\n    }\n    default: {\n      assertExhaustive(action.action, 'applyActionToSnippet');\n    }\n  }\n}\n\nexport function convertToCommonType(\n  ctx: GenerationCtx,\n  values: Snippet[],\n  restrictTo?: AnyData[],\n): Snippet[] | undefined {\n  const types = values.map((value) => value.dataType);\n\n  if (types.some((type) => type === UnknownData)) {\n    return undefined;\n  }\n\n  const conversion = getBestConversion(types as AnyData[], restrictTo);\n  if (!conversion) {\n    return undefined;\n  }\n\n  if (conversion.hasImplicitConversions) {\n    console.warn(\n      `Implicit conversions from [\\n${\n        values\n          .map((v) => `  ${v.value}: ${v.dataType.type}`)\n          .join(\n            ',\\n',\n          )\n      }\\n] to ${conversion.targetType.type} are supported, but not recommended.\nConsider using explicit conversions instead.`,\n    );\n  }\n\n  return values.map((value, index) => {\n    const action = conversion.actions[index];\n    invariant(action, 'Action should not be undefined');\n    return applyActionToSnippet(ctx, value, action, conversion.targetType);\n  });\n}\n\nexport function convertStructValues(\n  ctx: GenerationCtx,\n  structType: AnyWgslStruct,\n  values: Record<string, Snippet>,\n): Snippet[] {\n  const propKeys = Object.keys(structType.propTypes);\n\n  return propKeys.map((key) => {\n    const val = values[key];\n    if (!val) {\n      throw new Error(`Missing property ${key}`);\n    }\n\n    const targetType = structType.propTypes[key];\n    const converted = convertToCommonType(ctx, [val], [targetType as AnyData]);\n    return converted?.[0] ?? val;\n  });\n}\n\nexport function coerceToSnippet(value: unknown): Snippet {\n  if (isSnippet(value)) {\n    // Already a snippet\n    return value;\n  }\n\n  if (hasInternalDataType(value)) {\n    // The value knows better about what type it is\n    return snip(value, value[$wgslDataType] as AnyData);\n  }\n\n  if (isVecInstance(value) || isMatInstance(value)) {\n    return snip(value, kindToSchema[value.kind]);\n  }\n\n  if (Array.isArray(value)) {\n    const coerced = value.map(coerceToSnippet).filter(Boolean);\n    const context = getResolutionCtx() as GenerationCtx | undefined;\n    if (!context) {\n      throw new Error('Tried to coerce array without a context');\n    }\n\n    const converted = convertToCommonType(context, coerced as Snippet[]);\n    const commonType = getBestConversion(\n      coerced.map((v) => v.dataType as AnyData),\n    )?.targetType as AnyWgslData | undefined;\n\n    if (!converted || !commonType) {\n      return snip(value, UnknownData);\n    }\n\n    return snip(\n      converted.map((v) => v.value).join(', '),\n      arrayOf(concretize(commonType), value.length),\n    );\n  }\n\n  if (\n    typeof value === 'string' || typeof value === 'function' ||\n    typeof value === 'object' || typeof value === 'symbol' ||\n    typeof value === 'undefined' || value === null\n  ) {\n    // Nothing representable in WGSL as-is, so unknown\n    return snip(value, UnknownData);\n  }\n\n  if (typeof value === 'number' || typeof value === 'bigint') {\n    return snip(\n      value,\n      numericLiteralToSnippet(String(value))?.dataType ?? UnknownData,\n    );\n  }\n\n  if (typeof value === 'boolean') {\n    return snip(value, bool);\n  }\n\n  return snip(value, UnknownData);\n}\n", "import type { AnyData } from '../data/dataTypes.ts';\nimport type { BaseData } from '../data/wgslTypes.ts';\nimport {\n  extractGpuValueGetter,\n  type GpuValueGetter,\n} from '../extractGpuValueGetter.ts';\nimport { getName } from '../shared/meta.ts';\nimport { $providing, $wgslDataType } from '../shared/symbols.ts';\nimport { getTypeForPropAccess } from '../tgsl/generationHelpers.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../types.ts';\n\nexport const valueProxyHandler: ProxyHandler<\n  & SelfResolvable\n  & { readonly [$wgslDataType]: BaseData }\n> = {\n  get(target, prop) {\n    if (prop in target) {\n      return Reflect.get(target, prop);\n    }\n\n    if (prop === $providing) {\n      return undefined;\n    }\n\n    if (\n      prop === 'toString' ||\n      prop === Symbol.toStringTag ||\n      prop === Symbol.toPrimitive\n    ) {\n      return () => target.toString();\n    }\n\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) =>\n          `${ctx.resolve(target)}.${String(prop)}`,\n\n        toString: () =>\n          `.value(...).${String(prop)}:${getName(target) ?? '<unnamed>'}`,\n\n        [$wgslDataType]: getTypeForPropAccess(\n          target[$wgslDataType] as AnyData,\n          String(prop),\n        ) as BaseData,\n      },\n      valueProxyHandler,\n    );\n  },\n};\n\nexport function getGpuValueRecursively<T>(\n  ctx: ResolutionCtx,\n  value: unknown,\n): T {\n  let unwrapped = value;\n  let valueGetter: GpuValueGetter | undefined;\n\n  // biome-ignore lint/suspicious/noAssignInExpressions: it's exactly what we want biome\n  while (valueGetter = extractGpuValueGetter(unwrapped)) {\n    unwrapped = valueGetter(ctx);\n  }\n\n  return unwrapped as T;\n}\n", "import type { AnyWgslData } from '../../data/wgslTypes.ts';\nimport { inGPUMode } from '../../gpuMode.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { InferGPU } from '../../shared/repr.ts';\nimport { $gpuValueOf, $internal, $wgslDataType } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuConst<TDataType extends AnyWgslData = AnyWgslData>\n  extends TgpuNamable {\n  readonly value: InferGPU<TDataType>;\n  readonly $: InferGPU<TDataType>;\n\n  readonly [$internal]: {\n    readonly dataType: TDataType;\n  };\n}\n\n/**\n * Creates a module constant with specified value.\n */\nexport function constant<TDataType extends AnyWgslData>(\n  dataType: TDataType,\n  value: InferGPU<TDataType>,\n): TgpuConst<TDataType> {\n  return new TgpuConstImpl(dataType, value);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuConstImpl<TDataType extends AnyWgslData>\n  implements TgpuConst<TDataType>, SelfResolvable {\n  public readonly [$internal]: {\n    readonly dataType: TDataType;\n  };\n\n  constructor(\n    public readonly dataType: TDataType,\n    private readonly _value: InferGPU<TDataType>,\n  ) {\n    this[$internal] = { dataType };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const resolvedValue = ctx.resolveValue(this._value, this.dataType);\n    const resolvedDataType = ctx.resolve(this.dataType);\n\n    ctx.addDeclaration(`const ${id}: ${resolvedDataType} = ${resolvedValue};`);\n\n    return id;\n  }\n\n  toString() {\n    return `const:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): InferGPU<TDataType> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this.dataType,\n      },\n      valueProxyHandler,\n    ) as InferGPU<TDataType>;\n  }\n\n  get value(): InferGPU<TDataType> {\n    if (!inGPUMode()) {\n      return this._value;\n    }\n\n    return this[$gpuValueOf]();\n  }\n\n  get $(): InferGPU<TDataType> {\n    return this.value;\n  }\n}\n", "import type { AnyData } from '../../data/dataTypes.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $gpuRepr,\n  $internal,\n  $providing,\n  $repr,\n} from '../../shared/symbols.ts';\nimport type { TgpuFn } from '../function/tgpuFn.ts';\nimport type { TgpuBufferUsage } from './../buffer/bufferUsage.ts';\n\nexport interface TgpuSlot<T> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'slot';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<T>;\n  readonly [$gpuRepr]: InferGPU<T>;\n  // ---\n\n  readonly defaultValue: T | undefined;\n\n  /**\n   * Used to determine if code generated using either value `a` or `b` in place\n   * of the slot will be equivalent. Defaults to `Object.is`.\n   */\n  areEqual(a: T, b: T): boolean;\n\n  readonly value: InferGPU<T>;\n  readonly $: InferGPU<T>;\n}\n\nexport interface TgpuDerived<T> {\n  readonly resourceType: 'derived';\n  readonly value: InferGPU<T>;\n  readonly $: InferGPU<T>;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<T>;\n  readonly [$gpuRepr]: InferGPU<T>;\n  readonly [$providing]?: Providing | undefined;\n  // ---\n\n  with<TValue>(slot: TgpuSlot<TValue>, value: Eventual<TValue>): TgpuDerived<T>;\n\n  /**\n   * @internal\n   */\n  '~compute'(): T;\n}\n\nexport interface TgpuAccessor<T extends AnyData = AnyData> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'accessor';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<T>;\n  readonly [$gpuRepr]: InferGPU<T>;\n  // ---\n\n  readonly schema: T;\n  readonly defaultValue:\n    | TgpuFn<() => T>\n    | TgpuBufferUsage<T>\n    | Infer<T>\n    | undefined;\n  readonly slot: TgpuSlot<TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>>;\n\n  readonly value: InferGPU<T>;\n  readonly $: InferGPU<T>;\n}\n\n/**\n * Represents a value that is available at resolution time.\n */\nexport type Eventual<T> = T | TgpuSlot<T> | TgpuDerived<T>;\n\nexport type SlotValuePair<T = unknown> = [TgpuSlot<T>, T];\n\nexport type Providing = {\n  inner: unknown;\n  pairs: SlotValuePair[];\n};\n\nexport function isSlot<T>(value: unknown | TgpuSlot<T>): value is TgpuSlot<T> {\n  return (value as TgpuSlot<T>)?.resourceType === 'slot';\n}\n\nexport function isDerived<T extends TgpuDerived<unknown>>(\n  value: T | unknown,\n): value is T {\n  return (value as T)?.resourceType === 'derived';\n}\n\nexport function isProviding(\n  value: unknown,\n): value is { [$providing]: Providing } {\n  return (value as { [$providing]: Providing })?.[$providing] !== undefined;\n}\n\nexport function isAccessor<T extends AnyData>(\n  value: unknown | TgpuAccessor<T>,\n): value is TgpuAccessor<T> {\n  return (value as TgpuAccessor<T>)?.resourceType === 'accessor';\n}\n", "import type { Block } from 'tinyest';\nimport type {\n  TgpuBufferMutable,\n  TgpuBufferReadonly,\n  TgpuBufferUniform,\n  TgpuBufferUsage,\n} from './core/buffer/bufferUsage.ts';\nimport type { TgpuConst } from './core/constant/tgpuConstant.ts';\nimport type { TgpuDeclare } from './core/declare/tgpuDeclare.ts';\nimport type { TgpuComputeFn } from './core/function/tgpuComputeFn.ts';\nimport type { TgpuFn } from './core/function/tgpuFn.ts';\nimport type { TgpuFragmentFn } from './core/function/tgpuFragmentFn.ts';\nimport type { TgpuVertexFn } from './core/function/tgpuVertexFn.ts';\nimport type { TgpuComputePipeline } from './core/pipeline/computePipeline.ts';\nimport type { TgpuRenderPipeline } from './core/pipeline/renderPipeline.ts';\nimport type { TgpuSampler } from './core/sampler/sampler.ts';\nimport {\n  type Eventual,\n  isDerived,\n  isProviding,\n  isSlot,\n  type SlotValuePair,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from './core/slot/slotTypes.ts';\nimport type { TgpuExternalTexture } from './core/texture/externalTexture.ts';\nimport type {\n  TgpuAnyTextureView,\n  TgpuTexture,\n} from './core/texture/texture.ts';\nimport type { TgpuVar } from './core/variable/tgpuVariable.ts';\nimport type { AnyData, Snippet, UnknownData } from './data/dataTypes.ts';\nimport {\n  type AnyMatInstance,\n  type AnyVecInstance,\n  type AnyWgslData,\n  type BaseData,\n  isWgslData,\n} from './data/wgslTypes.ts';\nimport type { NameRegistry } from './nameRegistry.ts';\nimport type { Infer, InferGPU } from './shared/repr.ts';\nimport { $internal } from './shared/symbols.ts';\nimport type {\n  TgpuBindGroupLayout,\n  TgpuLayoutEntry,\n} from './tgpuBindGroupLayout.ts';\n\nexport type ResolvableObject =\n  | SelfResolvable\n  | TgpuBufferUsage\n  | TgpuConst\n  | TgpuDeclare\n  | TgpuFn\n  | TgpuComputeFn\n  | TgpuFragmentFn\n  | TgpuComputePipeline\n  | TgpuRenderPipeline\n  | TgpuVertexFn\n  | TgpuSampler\n  | TgpuAccessor\n  | TgpuExternalTexture\n  | TgpuTexture\n  | TgpuAnyTextureView\n  | TgpuVar\n  | AnyVecInstance\n  | AnyMatInstance\n  | AnyData\n  | TgpuFn;\n\nexport type Wgsl = Eventual<string | number | boolean | ResolvableObject>;\n\nexport type TgpuShaderStage = 'compute' | 'vertex' | 'fragment';\n\nexport interface FnToWgslOptions {\n  args: Snippet[];\n  argAliases: Record<string, Snippet>;\n  returnType: AnyData;\n  body: Block;\n  externalMap: Record<string, unknown>;\n}\n\nexport type ItemLayer = {\n  type: 'item';\n  usedSlots: Set<TgpuSlot<unknown>>;\n};\n\nexport interface ItemStateStack {\n  readonly itemDepth: number;\n  readonly topItem: ItemLayer;\n\n  pushItem(): void;\n  popItem(): void;\n  pushSlotBindings(pairs: SlotValuePair<unknown>[]): void;\n  popSlotBindings(): void;\n  pushFunctionScope(\n    args: Snippet[],\n    argAliases: Record<string, Snippet>,\n    returnType: AnyData,\n    externalMap: Record<string, unknown>,\n  ): void;\n  popFunctionScope(): void;\n  pushBlockScope(): void;\n  popBlockScope(): void;\n  pop(type?: 'functionScope' | 'blockScope' | 'slotBinding' | 'item'): void;\n  readSlot<T>(slot: TgpuSlot<T>): T | undefined;\n  getSnippetById(id: string): Snippet | undefined;\n  defineBlockVariable(id: string, type: AnyWgslData | UnknownData): Snippet;\n}\n\n/**\n * Passed into each resolvable item. All items in a tree share a resolution ctx,\n * but there can be layers added and removed from the item stack when going down\n * and up the tree.\n */\nexport interface ResolutionCtx {\n  readonly names: NameRegistry;\n\n  addDeclaration(declaration: string): void;\n\n  /**\n   * Reserves a bind group number, and returns a placeholder that will be replaced\n   * with a concrete number at the end of the resolution process.\n   */\n  allocateLayoutEntry(layout: TgpuBindGroupLayout): string;\n\n  /**\n   * Reserves a spot in the catch-all bind group, without the indirection of a bind-group.\n   * This means the resource is 'fixed', and cannot be swapped between code execution.\n   */\n  allocateFixedEntry(\n    layoutEntry: TgpuLayoutEntry,\n    resource: object,\n  ): {\n    group: string;\n    binding: number;\n  };\n\n  withSlots<T>(pairs: SlotValuePair<unknown>[], callback: () => T): T;\n\n  /**\n   * Unwraps all layers of slot/derived indirection and returns the concrete value if available.\n   * @throws {MissingSlotValueError}\n   */\n  unwrap<T>(eventual: Eventual<T>): T;\n\n  resolve(item: unknown): string;\n  resolveValue<T extends BaseData>(\n    value: Infer<T> | InferGPU<T>,\n    schema: T,\n  ): string;\n\n  fnToWgsl(options: FnToWgslOptions): {\n    head: Wgsl;\n    body: Wgsl;\n  };\n\n  withVaryingLocations<T>(\n    locations: Record<string, number>,\n    callback: () => T,\n  ): T;\n  get varyingLocations(): Record<string, number> | undefined;\n\n  [$internal]: {\n    itemStateStack: ItemStateStack;\n  };\n}\n\n/**\n * Houses a method '~resolve` that returns a code string\n * representing it, as opposed to offloading the resolution\n * to another mechanism.\n */\nexport interface SelfResolvable {\n  '~resolve'(ctx: ResolutionCtx): string;\n  toString(): string;\n}\n\nexport function isSelfResolvable(value: unknown): value is SelfResolvable {\n  return typeof (value as SelfResolvable)?.['~resolve'] === 'function';\n}\n\nexport function isWgsl(value: unknown): value is Wgsl {\n  return (\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    typeof value === 'string' ||\n    isSelfResolvable(value) ||\n    isWgslData(value) ||\n    isSlot(value) ||\n    isDerived(value) ||\n    isProviding(value)\n  );\n}\n\nexport type BindableBufferUsage = 'uniform' | 'readonly' | 'mutable';\nexport type BufferUsage = 'uniform' | 'readonly' | 'mutable' | 'vertex';\nexport type DefaultConversionStrategy = 'keep' | 'coerce';\n\nexport type FnArgsConversionHint =\n  | AnyData[]\n  | ((...args: Snippet[]) => AnyWgslData[])\n  | DefaultConversionStrategy\n  | undefined;\n\nexport function isGPUBuffer(value: unknown): value is GPUBuffer {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'getMappedRange' in value &&\n    'mapAsync' in value\n  );\n}\n\nexport function isBufferUsage<\n  T extends\n    | TgpuBufferUniform<BaseData>\n    | TgpuBufferReadonly<BaseData>\n    | TgpuBufferMutable<BaseData>,\n>(value: T | unknown): value is T {\n  return (value as T)?.resourceType === 'buffer-usage';\n}\n\nexport function isMarkedInternal(\n  value: unknown,\n): value is { [$internal]: Record<string, unknown> } {\n  return !!(value as { [$internal]: Record<string, unknown> })?.[$internal];\n}\n", "import { isLooseData } from '../../data/dataTypes.ts';\nimport { isWgslStruct } from '../../data/wgslTypes.ts';\nimport { getName, isNamable } from '../../shared/meta.ts';\nimport { isWgsl, type ResolutionCtx } from '../../types.ts';\n\n/**\n * A key-value mapping where keys represent identifiers within shader code,\n * and values can be any type that can be resolved to a code string.\n */\nexport type ExternalMap = Record<string, unknown>;\n\n/**\n * Merges two external maps into one. If a key is present in both maps, the value from the new map is used.\n * If the external value is a namable object, it is given a name if it does not already have one.\n * @param existing - The existing external map.\n * @param newExternals - The new external map.\n */\nexport function applyExternals(\n  existing: ExternalMap,\n  newExternals: ExternalMap,\n) {\n  for (const [key, value] of Object.entries(newExternals)) {\n    existing[key] = value;\n\n    // Giving name to external value, if it does not already have one.\n    if (isNamable(value) && getName(value) === undefined) {\n      value.$name(key);\n    }\n  }\n}\n\nexport function addArgTypesToExternals(\n  implementation: string,\n  argTypes: unknown[],\n  applyExternals: (externals: ExternalMap) => void,\n) {\n  const argTypeNames = [\n    ...implementation.matchAll(/:\\s*(?<arg>.*?)\\s*[,)]/g),\n  ].map((found) => (found ? found[1] : undefined));\n\n  applyExternals(\n    Object.fromEntries(\n      argTypes.flatMap((argType, i) => {\n        const argTypeName = argTypeNames ? argTypeNames[i] : undefined;\n        return isWgslStruct(argType) && argTypeName !== undefined\n          ? [[argTypeName, argType]]\n          : [];\n      }),\n    ),\n  );\n}\n\nexport function addReturnTypeToExternals(\n  implementation: string,\n  returnType: unknown,\n  applyExternals: (externals: ExternalMap) => void,\n) {\n  const matched = implementation.match(/->\\s(?<output>[\\w\\d_]+)\\s{/);\n  const outputName = matched ? matched[1]?.trim() : undefined;\n\n  if (isWgslStruct(returnType) && outputName && !/\\s/g.test(outputName)) {\n    applyExternals({ [outputName]: returnType });\n  }\n}\n\nfunction identifierRegex(name: string) {\n  return new RegExp(\n    `(?<![\\\\w\\\\$_.])${\n      name.replaceAll('.', '\\\\.').replaceAll('$', '\\\\$')\n    }(?![\\\\w\\\\$_])`,\n    'g',\n  );\n}\n\n/**\n * Replaces all occurrences of external names in WGSL code with their resolved values.\n * It adds all necessary definitions to the resolution context.\n * @param ctx - The resolution context.\n * @param externalMap - The external map.\n * @param wgsl - The WGSL code.\n *\n * @returns The WGSL code with all external names replaced with their resolved values.\n */\nexport function replaceExternalsInWgsl(\n  ctx: ResolutionCtx,\n  externalMap: ExternalMap,\n  wgsl: string,\n): string {\n  return Object.entries(externalMap).reduce((acc, [externalName, external]) => {\n    if (isWgsl(external) || isLooseData(external)) {\n      return acc.replaceAll(\n        identifierRegex(externalName),\n        ctx.resolve(external),\n      );\n    }\n\n    if (external !== null && typeof external === 'object') {\n      const foundProperties = [\n        ...wgsl.matchAll(\n          new RegExp(\n            `${\n              externalName.replaceAll('.', '\\\\.').replaceAll('$', '\\\\$')\n            }\\\\.(?<prop>.*?)(?![\\\\w\\\\$_])`,\n            'g',\n          ),\n        ),\n      ].map((found) => found[1]) ?? [];\n\n      return foundProperties.reduce(\n        (innerAcc: string, prop) =>\n          prop && prop in external\n            ? replaceExternalsInWgsl(\n              ctx,\n              {\n                [`${externalName}.${prop}`]:\n                  external[prop as keyof typeof external],\n              },\n              innerAcc,\n            )\n            : innerAcc,\n        acc,\n      );\n    }\n\n    return acc;\n  }, wgsl);\n}\n", "import type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport {\n  applyExternals,\n  type ExternalMap,\n  replaceExternalsInWgsl,\n} from '../resolve/externals.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Extra declaration that shall be included in final WGSL code,\n * when resolving objects that use it.\n */\nexport interface TgpuDeclare {\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\n/**\n * Allows defining extra declarations that shall be included in the final WGSL code,\n * when resolving objects that use them.\n *\n * Using this API is generally discouraged, as it shouldn't be necessary in any common scenario.\n * It was developed to ensure full compatibility of TypeGPU programs with current and future versions of WGSL.\n */\nexport function declare(declaration: string): TgpuDeclare {\n  return new TgpuDeclareImpl(declaration);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuDeclareImpl implements TgpuDeclare, SelfResolvable {\n  private externalsToApply: ExternalMap[] = [];\n\n  constructor(private declaration: string) {}\n\n  $uses(dependencyMap: Record<string, unknown>): this {\n    this.externalsToApply.push(dependencyMap);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const externalMap: ExternalMap = {};\n\n    for (const externals of this.externalsToApply) {\n      applyExternals(externalMap, externals);\n    }\n\n    const replacedDeclaration = replaceExternalsInWgsl(\n      ctx,\n      externalMap,\n      this.declaration,\n    );\n\n    ctx.addDeclaration(replacedDeclaration);\n    return '';\n  }\n\n  toString() {\n    return `declare: ${this.declaration}`;\n  }\n}\n", "import { FuncParameterType } from 'tinyest';\nimport { getAttributesString } from '../../data/attributes.ts';\nimport { type AnyData, snip } from '../../data/dataTypes.ts';\nimport {\n  type AnyWgslStruct,\n  isWgslData,\n  isWgslStruct,\n  Void,\n} from '../../data/wgslTypes.ts';\nimport { MissingLinksError } from '../../errors.ts';\nimport { getMetaData, getName, setName } from '../../shared/meta.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport {\n  applyExternals,\n  type ExternalMap,\n  replaceExternalsInWgsl,\n} from '../resolve/externals.ts';\nimport { extractArgs } from './extractArgs.ts';\nimport type { Implementation } from './fnTypes.ts';\n\nexport interface FnCore {\n  applyExternals(newExternals: ExternalMap): void;\n  resolve(\n    ctx: ResolutionCtx,\n    argTypes: AnyData[],\n    returnType: AnyData,\n  ): string;\n}\n\nexport function createFnCore(\n  implementation: Implementation,\n  fnAttribute = '',\n): FnCore {\n  /**\n   * External application has to be deferred until resolution because\n   * some externals can reference the owner function which has not been\n   * initialized yet (like when accessing the Output struct of a vertex\n   * entry fn).\n   */\n  const externalsToApply: ExternalMap[] = [];\n\n  const core = {\n    applyExternals(newExternals: ExternalMap): void {\n      externalsToApply.push(newExternals);\n    },\n\n    resolve(\n      ctx: ResolutionCtx,\n      argTypes: AnyData[],\n      returnType: AnyData,\n    ): string {\n      const externalMap: ExternalMap = {};\n\n      for (const externals of externalsToApply) {\n        applyExternals(externalMap, externals);\n      }\n\n      const id = ctx.names.makeUnique(getName(this));\n\n      if (typeof implementation === 'string') {\n        const replacedImpl = replaceExternalsInWgsl(\n          ctx,\n          externalMap,\n          implementation,\n        );\n\n        let header = '';\n        let body = '';\n\n        if (fnAttribute !== '') {\n          const input = isWgslStruct(argTypes[0])\n            ? `(in: ${ctx.resolve(argTypes[0])})`\n            : '()';\n\n          const attributes = isWgslData(returnType)\n            ? getAttributesString(returnType)\n            : '';\n          const output = returnType !== Void\n            ? isWgslStruct(returnType)\n              ? `-> ${ctx.resolve(returnType)}`\n              : `-> ${attributes !== '' ? attributes : '@location(0)'} ${\n                ctx.resolve(returnType)\n              }`\n            : '';\n\n          header = `${input} ${output} `;\n          body = replacedImpl;\n        } else {\n          const providedArgs = extractArgs(replacedImpl);\n\n          if (providedArgs.args.length !== argTypes.length) {\n            throw new Error(\n              `WGSL implementation has ${providedArgs.args.length} arguments, while the shell has ${argTypes.length} arguments.`,\n            );\n          }\n\n          const input = providedArgs.args.map((argInfo, i) =>\n            `${argInfo.identifier}: ${\n              checkAndReturnType(\n                ctx,\n                `parameter ${argInfo.identifier}`,\n                argInfo.type,\n                argTypes[i],\n              )\n            }`\n          ).join(', ');\n\n          const output = returnType === Void ? '' : `-> ${\n            checkAndReturnType(\n              ctx,\n              'return type',\n              providedArgs.ret?.type,\n              returnType,\n            )\n          }`;\n\n          header = `(${input}) ${output}`;\n\n          body = replacedImpl.slice(providedArgs.range.end);\n        }\n\n        ctx.addDeclaration(`${fnAttribute}fn ${id}${header}${body}`);\n      } else {\n        // get data generated by the plugin\n        const pluginData = getMetaData(implementation);\n\n        if (pluginData?.externals) {\n          const missing = Object.fromEntries(\n            Object.entries(pluginData.externals).filter(\n              ([name]) => !(name in externalMap),\n            ),\n          );\n\n          applyExternals(externalMap, missing);\n        }\n\n        const ast = pluginData?.ast;\n        if (!ast) {\n          throw new Error(\n            \"Missing metadata for tgpu.fn function body (either missing 'kernel' directive, or misconfigured `unplugin-typegpu`)\",\n          );\n        }\n\n        // verify all required externals are present\n        const missingExternals = ast.externalNames.filter(\n          (name) => !(name in externalMap),\n        );\n        if (missingExternals.length > 0) {\n          throw new MissingLinksError(getName(this), missingExternals);\n        }\n\n        // generate wgsl string\n        const { head, body } = ctx.fnToWgsl({\n          args: argTypes.map((arg, i) =>\n            snip(\n              ast.params[i]?.type === FuncParameterType.identifier\n                ? ast.params[i].name\n                : `_arg_${i}`,\n              arg,\n            )\n          ),\n          argAliases: Object.fromEntries(\n            ast.params.flatMap((param, i) =>\n              param.type === FuncParameterType.destructuredObject\n                ? param.props.map(({ name, alias }) => [\n                  alias,\n                  snip(\n                    `_arg_${i}.${name}`,\n                    (argTypes[i] as AnyWgslStruct)\n                      .propTypes[name],\n                  ),\n                ])\n                : []\n            ),\n          ),\n          returnType,\n          body: ast.body,\n          externalMap,\n        });\n\n        ctx.addDeclaration(\n          `${fnAttribute}fn ${id}${ctx.resolve(head)}${ctx.resolve(body)}`,\n        );\n      }\n\n      return id;\n    },\n  };\n\n  // The implementation could have been given a name by a bundler plugin,\n  // so we try to transfer it to the core.\n  const maybeName = getName(implementation);\n  if (maybeName !== undefined) {\n    setName(core, maybeName);\n  }\n\n  return core;\n}\n\nfunction checkAndReturnType(\n  ctx: ResolutionCtx,\n  name: string,\n  wgslType: string | undefined,\n  jsType: unknown,\n) {\n  const resolvedJsType = ctx.resolve(jsType).replace(/\\s/g, '');\n\n  if (!wgslType) {\n    return resolvedJsType;\n  }\n\n  const resolvedWgslType = wgslType.replace(/\\s/g, '');\n\n  if (resolvedWgslType !== resolvedJsType) {\n    throw new Error(\n      `Type mismatch between TGPU shell and WGSL code string: ${name}, JS type \"${resolvedJsType}\", WGSL type \"${resolvedWgslType}\".`,\n    );\n  }\n\n  return wgslType;\n}\n", "interface FunctionArgsInfo {\n  args: ArgInfo[];\n  ret: ReturnInfo | undefined;\n  range: {\n    begin: number;\n    end: number;\n  };\n}\n\ninterface ArgInfo {\n  identifier: string;\n  attributes: string[];\n  type: string | undefined;\n}\n\ninterface ReturnInfo {\n  attributes: string[];\n  type: string;\n}\n\n/**\n * Extracts info about arguments of a given WGSL function string.\n * @example\n * const code = `\n *   fn add(a: i32, ＠location(0) b: i32, c) -> i32 {\n *     return a + b + c;\n *   }`;\n *\n * extractArgs(code);\n * // {\n * //   args: [\n * //     { identifier: 'a', attributes: [], type: 'i32' },\n * //     { identifier: 'b', attributes: ['＠location(0)'], type: 'i32' },\n * //     { identifier: 'c', attributes: [], type: undefined }\n * //   ],\n * //   ret: { type: 'i32', attributes: [] },\n * //   range: { begin: 11, end: 51 }\n * // }\n */\nexport function extractArgs(rawCode: string): FunctionArgsInfo {\n  const { strippedCode, argRange: range } = strip(rawCode);\n  const code = new ParsableString(strippedCode);\n  code.consume('(');\n\n  const args: ArgInfo[] = [];\n  while (!code.isAt(')')) {\n    // In each loop iteration, process all the attributes, the identifier and the potential type of a single argument.\n\n    const attributes = [];\n    while (code.isAt('@')) {\n      code.parseUntil(closingParenthesis, parentheses);\n      code.consume(')');\n      attributes.push(code.lastParsed);\n    }\n\n    code.parseUntil(identifierEndSymbols);\n    const identifier = code.lastParsed;\n\n    let maybeType: string | undefined;\n    if (code.isAt(':')) {\n      code.consume(':');\n      code.parseUntil(typeEndSymbols, angleBrackets);\n      maybeType = code.lastParsed;\n    }\n\n    args.push({\n      identifier,\n      attributes,\n      type: maybeType,\n    });\n\n    if (code.isAt(',')) {\n      code.consume(',');\n    }\n  }\n  code.consume(')');\n\n  let maybeRet: ReturnInfo | undefined;\n  if (code.isAt('->')) {\n    code.consume('->');\n\n    const attributes = [];\n    while (code.isAt('@')) {\n      code.parseUntil(closingParenthesis, parentheses);\n      code.consume(')');\n      attributes.push(code.lastParsed);\n    }\n\n    maybeRet = { type: code.str.slice(code.pos), attributes };\n  }\n\n  return {\n    args,\n    ret: maybeRet,\n    range: { begin: range[0], end: range[1] },\n  };\n}\n\n/**\n * Strips comments, whitespaces, the name and the body of the function.\n * @example\n * const code = `\n *    fn add( a,  // first argument\n *            ＠location(0) b : i32 ) -> i32   {\n *        return a + b; // returns the sum\n *  }`;\n *\n * strip(code); // \"(a,@location(0)b:i32)->i32\"\n */\nfunction strip(\n  rawCode: string,\n): { strippedCode: string; argRange: [number, number] } {\n  const code = new ParsableString(rawCode);\n  let strippedCode = '';\n  let argsStart: number | undefined;\n\n  while (!code.isFinished()) {\n    // parse character by character while ignoring comments and blankspaces until you find a `{`.\n\n    // skip any blankspace\n    if (code.isAt(blankSpaces)) {\n      code.advanceBy(1); // the blankspace character\n      continue;\n    }\n\n    // skip line comments\n    if (code.isAt('//')) {\n      code.consume('//');\n      code.parseUntil(lineBreaks);\n      code.advanceBy(1); // the line break\n      continue;\n    }\n\n    // skip block comments\n    if (code.isAt('/*')) {\n      code.parseUntil(openingCommentBlock, commentBlocks);\n      code.consume('*/');\n      continue;\n    }\n\n    if (code.isAt('{')) {\n      return {\n        strippedCode,\n        argRange: [argsStart as number, code.pos],\n      };\n    }\n\n    if (code.isAt('(') && argsStart === undefined) {\n      argsStart = code.pos;\n    }\n\n    if (argsStart !== undefined) {\n      strippedCode += code.str[code.pos];\n    }\n    code.advanceBy(1); // parsed character\n  }\n  throw new Error('Invalid wgsl code!');\n}\n\nclass ParsableString {\n  #parseStartPos: number | undefined;\n  #pos: number;\n  constructor(public readonly str: string) {\n    this.#pos = 0;\n  }\n\n  get pos(): number {\n    return this.#pos;\n  }\n\n  /**\n   * This property is equivalent to the substring of `this.str`\n   * from the position of the last `parseUntil` call, to the current position.\n   */\n  get lastParsed(): string {\n    if (this.#parseStartPos === undefined) {\n      throw new Error('Parse was not called yet!');\n    }\n    return this.str.slice(this.#parseStartPos, this.pos);\n  }\n\n  isFinished() {\n    return this.#pos >= this.str.length;\n  }\n\n  isAt(substr: string | Set<string>): boolean {\n    if (typeof substr === 'string') {\n      for (let i = 0; i < substr.length; i++) {\n        if (this.str[this.#pos + i] !== substr[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    for (const elem of substr) {\n      if (this.isAt(elem)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param toFind a set of strings either of which satisfy the search.\n   * @param brackets a pair of brackets that has to be closed for result to be valid. This includes the found character(s).\n   * @example\n   * // internal state:\n   * // '(@attribute(0) identifier: type)'\n   * //   ^\n   * this.parse(new Set(')'), ['(', ')']);\n   * // internal state:\n   * // '(@attribute(0) identifier: type)'\n   * //               ^\n   */\n  parseUntil(\n    toFind: Set<string>,\n    brackets?: readonly [string, string],\n  ): number {\n    this.#parseStartPos = this.#pos;\n    let openedBrackets = 0;\n    while (this.#pos < this.str.length) {\n      if (brackets && this.isAt(brackets[0])) {\n        openedBrackets += 1;\n      }\n      if (brackets && this.isAt(brackets[1])) {\n        openedBrackets -= 1;\n      }\n      if (openedBrackets === 0) {\n        if (this.isAt(toFind)) {\n          return this.#pos;\n        }\n      }\n      this.#pos += 1;\n    }\n    throw new Error('Reached the end of the string without finding a match!');\n  }\n\n  advanceBy(steps: number) {\n    this.#pos += steps;\n  }\n\n  consume(str: string): void {\n    if (!this.isAt(str)) {\n      throw new Error(\n        `Expected '${str}' at position ${this.#pos}, but found '${\n          this.str.slice(this.#pos, this.#pos + str.length)\n        }'`,\n      );\n    }\n    this.advanceBy(str.length);\n  }\n}\n\nconst lineBreaks = new Set<string>([\n  '\\u000A', // line feed\n  '\\u000B', // vertical tab\n  '\\u000C', // form feed\n  '\\u000D', // carriage return\n  '\\u0085', // next line\n  '\\u2028', // line separator\n  '\\u2029', // paragraph separator\n]);\nconst blankSpaces = new Set<string>([\n  ...lineBreaks,\n  '\\u0020', // space\n  '\\u0009', // horizontal tab\n  '\\u200E', // left-to-right mark\n  '\\u200F', // right-to-left mark\n]);\nconst closingParenthesis = new Set<string>([')']);\nconst identifierEndSymbols = new Set([':', ',', ')']);\nconst typeEndSymbols = new Set([',', ')']);\nconst openingCommentBlock = new Set(['*/']);\n\nconst parentheses = ['(', ')'] as const;\nconst angleBrackets = ['<', '>'] as const;\nconst commentBlocks = ['/*', '*/'] as const;\n", "import {\n  type Decorate,\n  type HasCustomLocation,\n  type IsBuiltin,\n  location,\n} from '../../data/attributes.ts';\nimport { isBuiltin } from '../../data/attributes.ts';\nimport { getCustomLocation, isData } from '../../data/dataTypes.ts';\nimport { struct } from '../../data/struct.ts';\nimport {\n  type BaseData,\n  isVoid,\n  type Location,\n  type WgslStruct,\n} from '../../data/wgslTypes.ts';\nimport type { IOData, IOLayout, IORecord } from './fnTypes.ts';\n\nexport type WithLocations<T extends IORecord> = {\n  [Key in keyof T]: IsBuiltin<T[Key]> extends true ? T[Key]\n    : HasCustomLocation<T[Key]> extends true ? T[Key]\n    : Decorate<T[Key], Location>;\n};\n\nexport type IOLayoutToSchema<T extends IOLayout> = T extends BaseData\n  ? Decorate<T, Location<0>>\n  : T extends IORecord ? WgslStruct<WithLocations<T>>\n  // biome-ignore lint/suspicious/noConfusingVoidType: <it actually is void>\n  : T extends { type: 'void' } ? void\n  : never;\n\nexport function withLocations<T extends IOData>(\n  members: IORecord<T> | undefined,\n  locations: Record<string, number> = {},\n): WithLocations<IORecord<T>> {\n  let nextLocation = 0;\n  const usedCustomLocations = new Set<number>();\n\n  return Object.fromEntries(\n    Object.entries(members ?? {}).map(([key, member]) => {\n      const customLocation = getCustomLocation(member);\n\n      if (customLocation !== undefined) {\n        if (usedCustomLocations.has(customLocation)) {\n          throw new Error('Duplicate custom location attributes found');\n        }\n        usedCustomLocations.add(customLocation);\n      }\n\n      return [key, member] as const;\n    }).map(([key, member]) => {\n      if (isBuiltin(member)) { // skipping builtins\n        return [key, member];\n      }\n\n      if (getCustomLocation(member) !== undefined) { // this member is already marked\n        return [key, member];\n      }\n\n      if (locations[key]) { // location has been determined by a previous procedure\n        return [key, location(locations[key], member)];\n      }\n\n      while (usedCustomLocations.has(nextLocation)) {\n        nextLocation++;\n      }\n      return [key, location(nextLocation++, member)];\n    }),\n  );\n}\n\nexport function createIoSchema<\n  T extends IOData,\n  Layout extends IORecord<T> | IOLayout<T>,\n>(layout: Layout, locations: Record<string, number> = {}) {\n  return (\n    isData(layout)\n      ? isVoid(layout)\n        ? layout\n        : getCustomLocation(layout) !== undefined\n        ? layout\n        : location(0, layout)\n      : struct(withLocations(layout, locations) as Record<string, T>)\n  ) as IOLayoutToSchema<Layout>;\n}\n", "import type { Implementation } from './fnTypes.ts';\n\nexport function stripTemplate(\n  arg: Implementation | TemplateStringsArray,\n  ...values: unknown[]\n): Implementation {\n  return isTemplateStringsArray(arg)\n    ? templateLiteralIdentity(arg, ...values)\n    : arg;\n}\n\nfunction isTemplateStringsArray(value: unknown): value is TemplateStringsArray {\n  return (\n    Array.isArray(value) &&\n    'raw' in value &&\n    Array.isArray(value.raw) &&\n    value.raw.every((item) => typeof item === 'string')\n  );\n}\n\nfunction templateLiteralIdentity(\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): string {\n  return strings\n    .slice(1)\n    .reduce(\n      (acc, elem, index) => `${acc}${values[index]}${elem}`,\n      strings[0] as string,\n    );\n}\n", "import type { AnyComputeBuiltin } from '../../builtin.ts';\nimport { Void } from '../../data/wgslTypes.ts';\nimport {\n  getName,\n  isNamable,\n  setName,\n  type TgpuNamable,\n} from '../../shared/meta.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type { Implementation, InferIO, IORecord } from './fnTypes.ts';\nimport { createIoSchema, type IOLayoutToSchema } from './ioSchema.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Describes a compute entry function signature (its arguments, return type and workgroup size)\n */\ntype TgpuComputeFnShellHeader<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n> = {\n  readonly argTypes: [IOLayoutToSchema<ComputeIn>] | [];\n  readonly returnType: Void;\n  readonly workgroupSize: [number, number, number];\n  readonly isEntry: true;\n};\n\n/**\n * Describes a compute entry function signature (its arguments, return type and workgroup size).\n * Allows creating tgpu compute functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuComputeFnShell<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n> =\n  & TgpuComputeFnShellHeader<ComputeIn>\n  /**\n   * Creates a type-safe implementation of this signature\n   */\n  & ((\n    implementation: (input: InferIO<ComputeIn>) => undefined,\n  ) => TgpuComputeFn<ComputeIn>)\n  & /**\n   * @param implementation\n   *   Raw WGSL function implementation with header and body\n   *   without `fn` keyword and function name\n   *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n   */ ((implementation: string) => TgpuComputeFn<ComputeIn>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuComputeFn<ComputeIn>)\n  & {\n    /**\n     * @deprecated Invoke the shell as a function instead.\n     */\n    does:\n      & ((\n        implementation: (input: InferIO<ComputeIn>) => undefined,\n      ) => TgpuComputeFn<ComputeIn>)\n      & /**\n       * @param implementation\n       *   Raw WGSL function implementation with header and body\n       *   without `fn` keyword and function name\n       *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n       */ ((implementation: string) => TgpuComputeFn<ComputeIn>);\n  };\n\nexport interface TgpuComputeFn<\n  // biome-ignore lint/suspicious/noExplicitAny: to allow assigning any compute fn to TgpuComputeFn (non-generic) type\n  ComputeIn extends IORecord<AnyComputeBuiltin> = any,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly shell: TgpuComputeFnShellHeader<ComputeIn>;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\nexport interface ComputeFnOptions {\n  workgroupSize: number[];\n}\n\nexport function computeFn(options: {\n  workgroupSize: number[];\n  // biome-ignore lint/complexity/noBannedTypes: it's fine\n}): TgpuComputeFnShell<{}>;\n\nexport function computeFn<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n>(options: {\n  in: ComputeIn;\n  workgroupSize: number[];\n}): TgpuComputeFnShell<ComputeIn>;\n\n/**\n * Creates a shell of a typed entry function for the compute shader stage. Any function\n * that implements this shell can perform general-purpose computation.\n *\n * @param options.in\n *   Record with builtins used by the compute shader.\n * @param options.workgroupSize\n *   Size of blocks that the thread grid will be divided into (up to 3 dimensions).\n */\nexport function computeFn<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n>(options: {\n  in?: ComputeIn;\n  workgroupSize: number[];\n}): TgpuComputeFnShell<ComputeIn> {\n  const shell: TgpuComputeFnShellHeader<ComputeIn> = {\n    argTypes: options.in && Object.keys(options.in).length !== 0\n      ? [createIoSchema(options.in)]\n      : [],\n    returnType: Void,\n    workgroupSize: [\n      options.workgroupSize[0] ?? 1,\n      options.workgroupSize[1] ?? 1,\n      options.workgroupSize[2] ?? 1,\n    ],\n    isEntry: true,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) =>\n    createComputeFn(\n      shell,\n      options.workgroupSize,\n      stripTemplate(arg, ...values),\n    );\n\n  return Object.assign(Object.assign(call, shell), {\n    does: call,\n  }) as TgpuComputeFnShell<ComputeIn>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction createComputeFn<ComputeIn extends IORecord<AnyComputeBuiltin>>(\n  shell: TgpuComputeFnShellHeader<ComputeIn>,\n  workgroupSize: number[],\n  implementation: Implementation,\n): TgpuComputeFn<ComputeIn> {\n  type This = TgpuComputeFn<ComputeIn> & SelfResolvable & {\n    [$internal]: true;\n    [$getNameForward]: FnCore;\n  };\n\n  const core = createFnCore(\n    implementation,\n    `@compute @workgroup_size(${workgroupSize.join(', ')}) `,\n  );\n  const inputType = shell.argTypes[0];\n\n  const result: This = {\n    shell,\n\n    $uses(newExternals) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$internal]: true,\n    [$getNameForward]: core,\n    $name(newLabel: string): This {\n      setName(core, newLabel);\n      if (isNamable(inputType)) {\n        inputType.$name(`${newLabel}_Input`);\n      }\n      return this;\n    },\n\n    '~resolve'(ctx: ResolutionCtx): string {\n      return core.resolve(\n        ctx,\n        shell.argTypes,\n        shell.returnType,\n      );\n    },\n\n    toString() {\n      return `computeFn:${getName(core) ?? '<unnamed>'}`;\n    },\n  };\n  return result;\n}\n", "import { type AnyData, snip, UnknownData } from '../../data/dataTypes.ts';\nimport { schemaCallWrapper } from '../../data/utils.ts';\nimport { Void } from '../../data/wgslTypes.ts';\nimport { createDualImpl } from '../../shared/generators.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $internal,\n  $providing,\n} from '../../shared/symbols.ts';\nimport type { Prettify } from '../../shared/utilityTypes.ts';\nimport type { GenerationCtx } from '../../tgsl/generationHelpers.ts';\nimport type {\n  FnArgsConversionHint,\n  ResolutionCtx,\n  SelfResolvable,\n  Wgsl,\n} from '../../types.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport {\n  addArgTypesToExternals,\n  addReturnTypeToExternals,\n} from '../resolve/externals.ts';\nimport {\n  type Eventual,\n  isAccessor,\n  type Providing,\n  type SlotValuePair,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from '../slot/slotTypes.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type {\n  AnyFn,\n  Implementation,\n  InferArgs,\n  InferImplSchema,\n  InheritArgNames,\n} from './fnTypes.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Describes a function signature (its arguments and return type)\n */\ntype TgpuFnShellHeader<\n  Args extends AnyData[],\n  Return extends AnyData,\n> = {\n  readonly [$internal]: true;\n  readonly argTypes: Args;\n  readonly returnType: Return;\n  readonly isEntry: false;\n};\n\n/**\n * Describes a function signature (its arguments and return type).\n * Allows creating tgpu functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuFnShell<\n  Args extends AnyData[],\n  Return extends AnyData,\n> =\n  & TgpuFnShellHeader<Args, Return>\n  & (<T extends (...args: InferArgs<Args>) => Infer<Return>>(\n    implementation: T,\n  ) => TgpuFn<\n    Prettify<InheritArgNames<(...args: Args) => Return, T>>['result']\n  >)\n  & ((implementation: string) => TgpuFn<(...args: Args) => Return>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuFn<(...args: Args) => Return>);\n\ninterface TgpuFnBase<ImplSchema extends AnyFn> extends TgpuNamable {\n  readonly [$internal]: {\n    implementation: Implementation<ImplSchema>;\n    argTypes: FnArgsConversionHint;\n  };\n  readonly resourceType: 'function';\n  readonly shell: TgpuFnShellHeader<\n    Parameters<ImplSchema>,\n    Extract<ReturnType<ImplSchema>, AnyData>\n  >;\n  readonly [$providing]?: Providing | undefined;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n  with<T>(slot: TgpuSlot<T>, value: Eventual<T>): TgpuFn<ImplSchema>;\n  with<T extends AnyData>(\n    accessor: TgpuAccessor<T>,\n    value: TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n  ): TgpuFn<ImplSchema>;\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: the widest type requires `any`\nexport type TgpuFn<ImplSchema extends AnyFn = (...args: any[]) => any> =\n  & TgpuFnBase<ImplSchema>\n  & InferImplSchema<ImplSchema>;\n\nexport function fn<\n  Args extends AnyData[] | [],\n>(argTypes: Args, returnType?: undefined): TgpuFnShell<Args, Void>;\n\nexport function fn<\n  Args extends AnyData[] | [],\n  Return extends AnyData,\n>(argTypes: Args, returnType: Return): TgpuFnShell<Args, Return>;\n\nexport function fn<\n  Args extends AnyData[] | [],\n  Return extends AnyData = Void,\n>(argTypes: Args, returnType?: Return | undefined): TgpuFnShell<Args, Return> {\n  const shell: TgpuFnShellHeader<Args, Return> = {\n    [$internal]: true,\n    argTypes,\n    returnType: returnType ?? Void as Return,\n    isEntry: false,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) =>\n    createFn(\n      shell as unknown as TgpuFnShellHeader<never[], never>,\n      stripTemplate(arg, ...values),\n    );\n\n  return Object.assign(call, shell) as unknown as TgpuFnShell<Args, Return>;\n}\n\nexport function isTgpuFn<Args extends AnyData[] | [], Return extends AnyData>(\n  value: unknown | TgpuFn<(...args: Args) => Return>,\n): value is TgpuFn<(...args: Args) => Return> {\n  return !!(value as TgpuFn<(...args: Args) => Return>)?.[$internal] &&\n    (value as TgpuFn<(...args: Args) => Return>)?.resourceType === 'function';\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction stringifyPair([slot, value]: SlotValuePair): string {\n  return `${getName(slot) ?? '<unnamed>'}=${value}`;\n}\n\nfunction createFn<ImplSchema extends AnyFn>(\n  shell: TgpuFnShellHeader<\n    Parameters<ImplSchema>,\n    Extract<ReturnType<ImplSchema>, AnyData>\n  >,\n  implementation: Implementation<ImplSchema>,\n): TgpuFn<ImplSchema> {\n  type This = TgpuFnBase<ImplSchema> & SelfResolvable & {\n    [$getNameForward]: FnCore;\n  };\n\n  const core = createFnCore(implementation as Implementation, '');\n\n  const fnBase: This = {\n    [$internal]: {\n      implementation,\n      argTypes: shell.argTypes,\n    },\n    shell,\n    resourceType: 'function' as const,\n\n    $uses(newExternals: Record<string, unknown>) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$getNameForward]: core,\n    $name(label: string): This {\n      setName(core, label);\n      return this;\n    },\n\n    with(\n      slot: TgpuSlot<unknown> | TgpuAccessor,\n      value: unknown,\n    ): TgpuFn<ImplSchema> {\n      return createBoundFunction(fn, [\n        [isAccessor(slot) ? slot.slot : slot, value],\n      ]);\n    },\n\n    '~resolve'(ctx: ResolutionCtx): string {\n      if (typeof implementation === 'string') {\n        addArgTypesToExternals(\n          implementation,\n          shell.argTypes,\n          core.applyExternals,\n        );\n        addReturnTypeToExternals(\n          implementation,\n          shell.returnType,\n          core.applyExternals,\n        );\n\n        return core.resolve(ctx, shell.argTypes, shell.returnType);\n      }\n\n      const generationCtx = ctx as GenerationCtx;\n      if (generationCtx.callStack === undefined) {\n        throw new Error(\n          'Cannot resolve a TGSL function outside of a generation context',\n        );\n      }\n\n      try {\n        generationCtx.callStack.push(shell.returnType);\n        return core.resolve(ctx, shell.argTypes, shell.returnType);\n      } finally {\n        generationCtx.callStack.pop();\n      }\n    },\n  };\n\n  const call = createDualImpl<InferImplSchema<ImplSchema>>(\n    (...args) => {\n      if (typeof implementation === 'string') {\n        throw new Error(\n          'Cannot execute on the CPU functions constructed with raw WGSL',\n        );\n      }\n\n      const castAndCopiedArgs = args.map((arg, index) =>\n        schemaCallWrapper(shell.argTypes[index], arg)\n      ) as InferArgs<Parameters<ImplSchema>>;\n\n      return implementation(...castAndCopiedArgs);\n    },\n    (...args) =>\n      snip(\n        new FnCall(fn, args.map((arg) => arg.value) as Wgsl[]),\n        shell.returnType ?? UnknownData,\n      ),\n    'tgpuFnCall',\n    shell.argTypes,\n  );\n\n  call[$internal].implementation = implementation;\n\n  const fn = Object.assign(call, fnBase as This) as unknown as TgpuFn<\n    ImplSchema\n  >;\n\n  Object.defineProperty(fn, 'toString', {\n    value() {\n      return `fn:${getName(core) ?? '<unnamed>'}`;\n    },\n  });\n\n  return fn;\n}\n\nfunction createBoundFunction<ImplSchema extends AnyFn>(\n  innerFn: TgpuFn<ImplSchema>,\n  pairs: SlotValuePair[],\n): TgpuFn<ImplSchema> {\n  type This = TgpuFnBase<ImplSchema> & {\n    [$getNameForward]: TgpuFn<ImplSchema>;\n  };\n\n  const fnBase: This = {\n    [$internal]: {\n      implementation: innerFn[$internal].implementation,\n      argTypes: innerFn[$internal].argTypes,\n    },\n    resourceType: 'function',\n    shell: innerFn.shell,\n    [$providing]: {\n      inner: innerFn,\n      pairs,\n    },\n\n    $uses(newExternals) {\n      innerFn.$uses(newExternals);\n      return this;\n    },\n\n    [$getNameForward]: innerFn,\n    $name(label: string): This {\n      innerFn.$name(label);\n      return this;\n    },\n\n    with(\n      slot: TgpuSlot<unknown> | TgpuAccessor,\n      value: unknown,\n    ): TgpuFn<ImplSchema> {\n      return createBoundFunction(fn, [\n        ...pairs,\n        [isAccessor(slot) ? slot.slot : slot, value],\n      ]);\n    },\n  };\n\n  const call = createDualImpl<InferImplSchema<ImplSchema>>(\n    (...args) => innerFn(...args),\n    (...args) =>\n      snip(\n        new FnCall(fn, args.map((arg) => arg.value) as Wgsl[]),\n        innerFn.shell.returnType ?? UnknownData,\n      ),\n    'tgpuFnCall',\n    innerFn.shell.argTypes as AnyData[],\n  );\n\n  const fn = Object.assign(call, fnBase) as TgpuFn<ImplSchema>;\n\n  Object.defineProperty(fn, 'toString', {\n    value() {\n      const fnLabel = getName(innerFn) ?? '<unnamed>';\n\n      return `fn:${fnLabel}[${pairs.map(stringifyPair).join(', ')}]`;\n    },\n  });\n\n  fn[$internal].implementation = innerFn[$internal].implementation;\n\n  return fn;\n}\n\nclass FnCall<ImplSchema extends AnyFn> implements SelfResolvable {\n  readonly [$getNameForward]: TgpuFnBase<ImplSchema>;\n\n  constructor(\n    private readonly _fn: TgpuFnBase<ImplSchema>,\n    private readonly _params: Wgsl[],\n  ) {\n    this[$getNameForward] = _fn;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    return ctx.resolve(\n      `${ctx.resolve(this._fn)}(${\n        this._params.map((param) => ctx.resolve(param)).join(', ')\n      })`,\n    );\n  }\n\n  toString() {\n    return `call:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n", "import type {\n  AnyFragmentInputBuiltin,\n  AnyFragmentOutputBuiltin,\n  OmitBuiltins,\n} from '../../builtin.ts';\nimport type {\n  Decorated,\n  Interpolate,\n  Location,\n  Vec4f,\n} from '../../data/wgslTypes.ts';\nimport {\n  getName,\n  isNamable,\n  setName,\n  type TgpuNamable,\n} from '../../shared/meta.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { GenerationCtx } from '../../tgsl/generationHelpers.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { addReturnTypeToExternals } from '../resolve/externals.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type {\n  BaseIOData,\n  Implementation,\n  InferIO,\n  IOLayout,\n  IORecord,\n} from './fnTypes.ts';\nimport { createIoSchema, type IOLayoutToSchema } from './ioSchema.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type FragmentInConstrained = IORecord<\n  | BaseIOData\n  | Decorated<BaseIOData, (Location | Interpolate)[]>\n  | AnyFragmentInputBuiltin\n>;\n\nexport type FragmentOutConstrained = IOLayout<\n  | Vec4f\n  | Decorated<Vec4f, (Location | Interpolate)[]>\n  | AnyFragmentOutputBuiltin\n>;\n\n/**\n * Describes a fragment entry function signature (its arguments, return type and targets)\n */\ntype TgpuFragmentFnShellHeader<\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n> = {\n  readonly in: FragmentIn | undefined;\n  readonly out: FragmentOut;\n  readonly returnType: IOLayoutToSchema<FragmentOut>;\n  readonly isEntry: true;\n};\n\n/**\n * Describes a fragment entry function signature (its arguments, return type and targets).\n * Allows creating tgpu fragment functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuFragmentFnShell<\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n> =\n  & TgpuFragmentFnShellHeader<FragmentIn, FragmentOut> /**\n   * Creates a type-safe implementation of this signature\n   */\n  & ((\n    implementation: (input: InferIO<FragmentIn>) => InferIO<FragmentOut>,\n  ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>)\n  & /**\n   * @param implementation\n   *   Raw WGSL function implementation with header and body\n   *   without `fn` keyword and function name\n   *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n   */ ((\n    implementation: string,\n  ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>)\n  & {\n    /**\n     * @deprecated Invoke the shell as a function instead.\n     */\n    does:\n      & ((\n        implementation: (input: InferIO<FragmentIn>) => InferIO<FragmentOut>,\n      ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>)\n      & /**\n       * @param implementation\n       *   Raw WGSL function implementation with header and body\n       *   without `fn` keyword and function name\n       *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n       */ ((\n        implementation: string,\n      ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>);\n  };\n\nexport interface TgpuFragmentFn<\n  Varying extends FragmentInConstrained = FragmentInConstrained,\n  Output extends FragmentOutConstrained = FragmentOutConstrained,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly shell: TgpuFragmentFnShellHeader<Varying, Output>;\n  readonly outputType: IOLayoutToSchema<Output>;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\nexport function fragmentFn<\n  FragmentOut extends FragmentOutConstrained,\n>(options: {\n  out: FragmentOut;\n  // biome-ignore lint/complexity/noBannedTypes: it's fine\n}): TgpuFragmentFnShell<{}, FragmentOut>;\n\nexport function fragmentFn<\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n>(options: {\n  in: FragmentIn;\n  out: FragmentOut;\n}): TgpuFragmentFnShell<FragmentIn, FragmentOut>;\n\n/**\n * Creates a shell of a typed entry function for the fragment shader stage. Any function\n * that implements this shell can run for each fragment (pixel), allowing the inner code\n * to process information received from the vertex shader stage and builtins to determine\n * the final color of the pixel (many pixels in case of multiple targets).\n *\n * @param options.in\n *  Values computed in the vertex stage and builtins to be made available to functions that implement this shell.\n * @param options.out\n *  A `vec4f`, signaling this function outputs a color for one target, or a record containing colors for multiple targets.\n */\nexport function fragmentFn<\n  // Not allowing single-value input, as using objects here is more\n  // readable, and refactoring to use a builtin argument is too much hassle.\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n>(options: {\n  in?: FragmentIn;\n  out: FragmentOut;\n}): TgpuFragmentFnShell<FragmentIn, FragmentOut> {\n  const shell: TgpuFragmentFnShellHeader<FragmentIn, FragmentOut> = {\n    in: options.in,\n    out: options.out,\n    returnType: createIoSchema(options.out),\n    isEntry: true,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) => createFragmentFn(shell, stripTemplate(arg, ...values));\n\n  return Object.assign(Object.assign(call, shell), {\n    does: call,\n  }) as TgpuFragmentFnShell<FragmentIn, FragmentOut>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction createFragmentFn(\n  shell: TgpuFragmentFnShellHeader<\n    FragmentInConstrained,\n    FragmentOutConstrained\n  >,\n  implementation: Implementation,\n): TgpuFragmentFn {\n  type This = TgpuFragmentFn & SelfResolvable & {\n    [$internal]: true;\n    [$getNameForward]: FnCore;\n  };\n\n  const core = createFnCore(implementation, '@fragment ');\n  const outputType = shell.returnType;\n  if (typeof implementation === 'string') {\n    addReturnTypeToExternals(\n      implementation,\n      outputType,\n      (externals) => core.applyExternals(externals),\n    );\n  }\n\n  const result: This = {\n    shell,\n    outputType,\n\n    $uses(newExternals) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$internal]: true,\n    [$getNameForward]: core,\n    $name(newLabel: string): This {\n      setName(core, newLabel);\n      if (isNamable(outputType)) {\n        outputType.$name(`${newLabel}_Output`);\n      }\n      return this;\n    },\n\n    '~resolve'(ctx: ResolutionCtx): string {\n      const inputWithLocation = shell.in\n        ? createIoSchema(shell.in, ctx.varyingLocations)\n          .$name(`${getName(this) ?? ''}_Input`)\n        : undefined;\n\n      if (inputWithLocation) {\n        core.applyExternals({ In: inputWithLocation });\n      }\n      core.applyExternals({ Out: outputType });\n\n      if (typeof implementation === 'string') {\n        return core.resolve(\n          ctx,\n          inputWithLocation ? [inputWithLocation] : [],\n          shell.returnType,\n        );\n      }\n\n      const generationCtx = ctx as GenerationCtx;\n      if (generationCtx.callStack === undefined) {\n        throw new Error(\n          'Cannot resolve a TGSL function outside of a generation context',\n        );\n      }\n\n      try {\n        generationCtx.callStack.push(outputType);\n        return core.resolve(\n          ctx,\n          inputWithLocation ? [inputWithLocation] : [],\n          shell.returnType,\n        );\n      } finally {\n        generationCtx.callStack.pop();\n      }\n    },\n\n    toString() {\n      return `fragmentFn:${getName(core) ?? '<unnamed>'}`;\n    },\n  };\n\n  return result;\n}\n", "import type {\n  AnyVertexInputBuiltin,\n  AnyVertexOutputBuiltin,\n  OmitBuiltins,\n} from '../../builtin.ts';\nimport type { Decorated, Interpolate, Location } from '../../data/wgslTypes.ts';\nimport {\n  getName,\n  isNamable,\n  setName,\n  type TgpuNamable,\n} from '../../shared/meta.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { GenerationCtx } from '../../tgsl/generationHelpers.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type {\n  BaseIOData,\n  Implementation,\n  InferIO,\n  IORecord,\n} from './fnTypes.ts';\nimport { createIoSchema, type IOLayoutToSchema } from './ioSchema.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type VertexInConstrained = IORecord<\n  BaseIOData | Decorated<BaseIOData, Location[]> | AnyVertexInputBuiltin\n>;\n\nexport type VertexOutConstrained = IORecord<\n  | BaseIOData\n  | Decorated<BaseIOData, (Location | Interpolate)[]>\n  | AnyVertexOutputBuiltin\n>;\n\n/**\n * Describes a vertex entry function signature (its arguments, return type and attributes)\n */\ntype TgpuVertexFnShellHeader<\n  VertexIn extends VertexInConstrained,\n  VertexOut extends VertexOutConstrained,\n> = {\n  readonly in: VertexIn | undefined;\n  readonly out: VertexOut;\n  readonly argTypes: [IOLayoutToSchema<VertexIn>] | [];\n  readonly isEntry: true;\n};\n\n/**\n * Describes a vertex entry function signature (its arguments, return type and attributes).\n * Allows creating tgpu vertex functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuVertexFnShell<\n  VertexIn extends VertexInConstrained,\n  VertexOut extends VertexOutConstrained,\n> =\n  & TgpuVertexFnShellHeader<VertexIn, VertexOut>\n  & ((\n    implementation: (input: InferIO<VertexIn>) => InferIO<VertexOut>,\n  ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n  & ((\n    implementation: string,\n  ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n  & {\n    /**\n     * @deprecated Invoke the shell as a function instead.\n     */\n    does:\n      & ((\n        implementation: (input: InferIO<VertexIn>) => InferIO<VertexOut>,\n      ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n      & ((\n        implementation: string,\n      ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>);\n  };\n\nexport interface TgpuVertexFn<\n  VertexIn extends VertexInConstrained = VertexInConstrained,\n  VertexOut extends VertexOutConstrained = VertexOutConstrained,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly shell: TgpuVertexFnShellHeader<VertexIn, VertexOut>;\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\nexport function vertexFn<VertexOut extends VertexOutConstrained>(options: {\n  out: VertexOut;\n  // biome-ignore lint/complexity/noBannedTypes: it's fine\n}): TgpuVertexFnShell<{}, VertexOut>;\n\nexport function vertexFn<\n  VertexIn extends VertexInConstrained,\n  // Not allowing single-value output, as it is better practice\n  // to properly label what the vertex shader is outputting.\n  VertexOut extends VertexOutConstrained,\n>(options: {\n  in: VertexIn;\n  out: VertexOut;\n}): TgpuVertexFnShell<VertexIn, VertexOut>;\n\n/**\n * Creates a shell of a typed entry function for the vertex shader stage. Any function\n * that implements this shell can run for each vertex, allowing the inner code to process\n * attributes and determine the final position of the vertex.\n *\n * @param options.in\n *   Vertex attributes and builtins to be made available to functions that implement this shell.\n * @param options.out\n *   A record containing the final position of the vertex, and any information\n *   passed onto the fragment shader stage.\n */\nexport function vertexFn<\n  VertexIn extends VertexInConstrained,\n  // Not allowing single-value output, as it is better practice\n  // to properly label what the vertex shader is outputting.\n  VertexOut extends VertexOutConstrained,\n>(options: {\n  in?: VertexIn;\n  out: VertexOut;\n}): TgpuVertexFnShell<VertexIn, VertexOut> {\n  if (Object.keys(options.out).length === 0) {\n    throw new Error(\n      `A vertexFn output cannot be empty since it must include the 'position' builtin.`,\n    );\n  }\n  const shell: TgpuVertexFnShellHeader<VertexIn, VertexOut> = {\n    in: options.in,\n    out: options.out,\n    argTypes: options.in && Object.keys(options.in).length !== 0\n      ? [createIoSchema(options.in)]\n      : [],\n    isEntry: true,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) => createVertexFn(shell, stripTemplate(arg, ...values));\n\n  return Object.assign(Object.assign(call, shell), {\n    does: call,\n  }) as TgpuVertexFnShell<VertexIn, VertexOut>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction createVertexFn(\n  shell: TgpuVertexFnShellHeader<VertexInConstrained, VertexOutConstrained>,\n  implementation: Implementation,\n): TgpuVertexFn<VertexInConstrained, VertexOutConstrained> {\n  type This =\n    & TgpuVertexFn<VertexInConstrained, VertexOutConstrained>\n    & SelfResolvable\n    & {\n      [$internal]: true;\n      [$getNameForward]: FnCore;\n    };\n\n  const core = createFnCore(implementation, '@vertex ');\n  const inputType = shell.argTypes[0];\n\n  const result: This = {\n    shell,\n\n    $uses(newExternals) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$internal]: true,\n    [$getNameForward]: core,\n    $name(newLabel: string): This {\n      setName(core, newLabel);\n      if (isNamable(inputType)) {\n        inputType.$name(`${newLabel}_Input`);\n      }\n      return this;\n    },\n\n    '~resolve'(ctx: ResolutionCtx): string {\n      const outputWithLocation = createIoSchema(\n        shell.out,\n        ctx.varyingLocations,\n      ).$name(`${getName(this) ?? ''}_Output`);\n\n      if (typeof implementation === 'string') {\n        if (inputType) {\n          core.applyExternals({ In: inputType });\n        }\n        core.applyExternals({ Out: outputWithLocation });\n\n        return core.resolve(\n          ctx,\n          shell.argTypes,\n          outputWithLocation,\n        );\n      }\n\n      const generationCtx = ctx as GenerationCtx;\n      if (generationCtx.callStack === undefined) {\n        throw new Error(\n          'Cannot resolve a TGSL function outside of a generation context',\n        );\n      }\n\n      try {\n        generationCtx.callStack.push(outputWithLocation);\n        return core.resolve(\n          ctx,\n          shell.argTypes,\n          outputWithLocation,\n        );\n      } finally {\n        generationCtx.callStack.pop();\n      }\n    },\n\n    toString() {\n      return `vertexFn:${getName(core) ?? '<unnamed>'}`;\n    },\n  };\n  return result;\n}\n", "export interface NameRegistry {\n  /**\n   * Creates a valid WGSL identifier, each guaranteed to be unique\n   * in the lifetime of a single resolution process.\n   * @param primer Used in the generation process, makes the identifier more recognizable.\n   */\n  makeUnique(primer?: string): string;\n}\n\nexport class RandomNameRegistry implements NameRegistry {\n  private lastUniqueId = 0;\n\n  makeUnique(primer?: string | undefined): string {\n    let label: string;\n    if (primer) {\n      // sanitizing\n      label = primer.replaceAll(/\\s/g, '_'); // whitespace -> _\n      label = label.replaceAll(/[^\\w\\d]/g, ''); // removing illegal characters\n    } else {\n      label = 'item';\n    }\n\n    return `${label}_${this.lastUniqueId++}`;\n  }\n}\n\nexport class StrictNameRegistry implements NameRegistry {\n  /**\n   * Allows to provide a good fallback for instances of the\n   * same function that are bound to different slot values.\n   */\n  private readonly _usedNames = new Set<string>();\n\n  makeUnique(primer?: string | undefined): string {\n    if (primer === undefined) {\n      throw new Error('Unnamed item found when using a strict name registry');\n    }\n\n    let index = 0;\n    let unusedName = primer;\n    while (this._usedNames.has(unusedName)) {\n      index++;\n      unusedName = `${primer}_${index}`;\n    }\n\n    this._usedNames.add(unusedName);\n    return unusedName;\n  }\n}\n", "import { isBuiltin } from '../../data/attributes.ts';\nimport { getCustomLocation } from '../../data/dataTypes.ts';\nimport { isData } from '../../data/dataTypes.ts';\nimport type {\n  AnyVertexAttribs,\n  TgpuVertexAttrib,\n} from '../../shared/vertexFormat.ts';\nimport type { IOData, IOLayout } from '../function/fnTypes.ts';\nimport type {\n  INTERNAL_TgpuVertexAttrib,\n  TgpuVertexLayout,\n} from './vertexLayout.ts';\n\nexport interface ConnectAttributesToShaderResult {\n  usedVertexLayouts: TgpuVertexLayout[];\n  bufferDefinitions: GPUVertexBufferLayout[];\n}\n\nexport function isAttribute<\n  T extends TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib,\n>(value: unknown | T): value is T {\n  return typeof (value as T)?.format === 'string';\n}\n\nexport function connectAttributesToShader(\n  shaderInputLayout: IOLayout,\n  attributes: AnyVertexAttribs,\n): ConnectAttributesToShaderResult {\n  const usedVertexLayouts: TgpuVertexLayout[] = [];\n\n  if (isData(shaderInputLayout)) {\n    // Expecting a single attribute, no record.\n    if (!isAttribute(attributes)) {\n      throw new Error(\n        'Shader expected a single attribute, not a record of attributes to be passed in.',\n      );\n    }\n\n    usedVertexLayouts.push(attributes._layout);\n\n    return {\n      usedVertexLayouts,\n      bufferDefinitions: [\n        {\n          arrayStride: attributes._layout.stride,\n          stepMode: attributes._layout.stepMode,\n          attributes: [\n            {\n              format: attributes.format,\n              offset: attributes.offset,\n              shaderLocation: getCustomLocation(shaderInputLayout) ?? 0,\n            },\n          ],\n        },\n      ],\n    };\n  }\n\n  const bufferDefinitions: GPUVertexBufferLayout[] = [];\n  const layoutToAttribListMap = new WeakMap<\n    TgpuVertexLayout,\n    GPUVertexAttribute[]\n  >();\n  let nextShaderLocation = 0;\n\n  for (\n    const [key, member] of Object.entries(\n      shaderInputLayout as Record<string, IOData>,\n    )\n  ) {\n    if (isBuiltin(member)) {\n      continue;\n    }\n\n    const matchingAttribute = (attributes as Record<string, TgpuVertexAttrib>)[\n      key\n    ] as (TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib) | undefined;\n\n    if (!matchingAttribute) {\n      throw new Error(\n        `An attribute by the name of '${key}' was not provided to the shader.`,\n      );\n    }\n\n    const layout = matchingAttribute._layout;\n    let attribList = layoutToAttribListMap.get(layout);\n    if (!attribList) {\n      // First time seeing this layout\n      usedVertexLayouts.push(layout);\n\n      attribList = [];\n      bufferDefinitions.push({\n        arrayStride: layout.stride,\n        stepMode: layout.stepMode,\n        attributes: attribList,\n      });\n      layoutToAttribListMap.set(layout, attribList);\n    }\n\n    nextShaderLocation = getCustomLocation(member) ?? nextShaderLocation;\n\n    attribList.push({\n      format: matchingAttribute.format,\n      offset: matchingAttribute.offset,\n      shaderLocation: nextShaderLocation++,\n    });\n  }\n\n  return { usedVertexLayouts, bufferDefinitions };\n}\n", "import { getAttributesString } from '../../data/attributes.ts';\nimport {\n  type AnyData,\n  type Disarray,\n  isLooseData,\n  type Unstruct,\n} from '../../data/dataTypes.ts';\nimport { formatToWGSLType } from '../../data/vertexFormatData.ts';\nimport type {\n  AnyWgslData,\n  BaseData,\n  Bool,\n  F16,\n  F32,\n  I32,\n  Mat2x2f,\n  Mat3x3f,\n  Mat4x4f,\n  U32,\n  Vec2b,\n  Vec2f,\n  Vec2h,\n  Vec2i,\n  Vec2u,\n  Vec3b,\n  Vec3f,\n  Vec3h,\n  Vec3i,\n  Vec3u,\n  Vec4b,\n  Vec4f,\n  Vec4h,\n  Vec4i,\n  Vec4u,\n  WgslArray,\n  WgslStruct,\n} from '../../data/wgslTypes.ts';\nimport { getName } from '../../shared/meta.ts';\nimport { assertExhaustive } from '../../shared/utilityTypes.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport { isAttribute } from '../vertexLayout/connectAttributesToShader.ts';\n\n/**\n * Schemas for which their `type` property directly\n * translates to the resulting WGSL code.\n */\nconst identityTypes = [\n  'bool',\n  'f32',\n  'f16',\n  'i32',\n  'u32',\n  'vec2f',\n  'vec3f',\n  'vec4f',\n  'vec2h',\n  'vec3h',\n  'vec4h',\n  'vec2i',\n  'vec3i',\n  'vec4i',\n  'vec2u',\n  'vec3u',\n  'vec4u',\n  'vec2<bool>',\n  'vec3<bool>',\n  'vec4<bool>',\n  'mat2x2f',\n  'mat3x3f',\n  'mat4x4f',\n];\n\ntype IdentityType =\n  | Bool\n  | F32\n  | F16\n  | I32\n  | U32\n  | Vec2f\n  | Vec3f\n  | Vec4f\n  | Vec2h\n  | Vec3h\n  | Vec4h\n  | Vec2i\n  | Vec3i\n  | Vec4i\n  | Vec2u\n  | Vec3u\n  | Vec4u\n  | Vec2b\n  | Vec3b\n  | Vec4b\n  | Mat2x2f\n  | Mat3x3f\n  | Mat4x4f;\n\nfunction isIdentityType(data: AnyWgslData): data is IdentityType {\n  return identityTypes.includes(data.type);\n}\n\n/**\n * Resolves a single property of a struct.\n * @param ctx - The resolution context.\n * @param key - The key of the property.\n * @param property - The property itself.\n *\n * @returns The resolved property string.\n */\nfunction resolveStructProperty(\n  ctx: ResolutionCtx,\n  [key, property]: [string, BaseData],\n) {\n  return `  ${getAttributesString(property)}${key}: ${\n    ctx.resolve(property as AnyWgslData)\n  },\\n`;\n}\n\n/**\n * Resolves a struct and adds its declaration to the resolution context.\n * @param ctx - The resolution context.\n * @param struct - The struct to resolve.\n *\n * @returns The resolved struct name.\n */\nfunction resolveStruct(ctx: ResolutionCtx, struct: WgslStruct) {\n  const id = ctx.names.makeUnique(getName(struct));\n\n  ctx.addDeclaration(`\nstruct ${id} {\n${\n    Object.entries(struct.propTypes)\n      .map((prop) => resolveStructProperty(ctx, prop))\n      .join('')\n  }\\\n}\\n`);\n\n  return id;\n}\n\n/**\n * Resolves an unstruct (struct that does not align data by default) to its struct data counterpart.\n * @param ctx - The resolution context.\n * @param unstruct - The unstruct to resolve.\n *\n * @returns The resolved unstruct name.\n *\n * @example\n * ```ts\n * resolveUnstruct(ctx, {\n *   uv: d.float16x2, // -> d.vec2f after resolution\n *   color: d.snorm8x4, -> d.vec4f after resolution\n * });\n * ```\n */\nfunction resolveUnstruct(ctx: ResolutionCtx, unstruct: Unstruct) {\n  const id = ctx.names.makeUnique(getName(unstruct));\n\n  ctx.addDeclaration(`\nstruct ${id} {\n${\n    Object.entries(unstruct.propTypes)\n      .map((prop) =>\n        isAttribute(prop[1])\n          ? resolveStructProperty(ctx, [\n            prop[0],\n            formatToWGSLType[prop[1].format],\n          ])\n          : resolveStructProperty(ctx, prop)\n      )\n      .join('')\n  }\n}\\n`);\n\n  return id;\n}\n\n/**\n * Resolves an array.\n * @param ctx - The resolution context.\n * @param array - The array to resolve.\n *\n * @returns The resolved array name along with its element type and count (if not runtime-sized).\n *\n * @example\n * ```ts\n * resolveArray(ctx, d.arrayOf(d.u32, 0)); // 'array<u32>' (not a real pattern, a function is preferred)\n * resolveArray(ctx, d.arrayOf(d.u32, 5)); // 'array<u32, 5>'\n * ```\n */\nfunction resolveArray(ctx: ResolutionCtx, array: WgslArray) {\n  const element = ctx.resolve(array.elementType as AnyWgslData);\n\n  return array.elementCount === 0\n    ? `array<${element}>`\n    : `array<${element}, ${array.elementCount}>`;\n}\n\nfunction resolveDisarray(ctx: ResolutionCtx, disarray: Disarray) {\n  const element = ctx.resolve(\n    isAttribute(disarray.elementType)\n      ? formatToWGSLType[disarray.elementType.format]\n      : (disarray.elementType as AnyWgslData),\n  );\n\n  return disarray.elementCount === 0\n    ? `array<${element}>`\n    : `array<${element}, ${disarray.elementCount}>`;\n}\n\n/**\n * Resolves a WGSL data-type schema to a string.\n * @param ctx - The resolution context.\n * @param data - The data-type to resolve.\n *\n * @returns The resolved data-type string.\n */\nexport function resolveData(ctx: ResolutionCtx, data: AnyData): string {\n  if (isLooseData(data)) {\n    if (data.type === 'unstruct') {\n      return resolveUnstruct(ctx, data);\n    }\n\n    if (data.type === 'disarray') {\n      return resolveDisarray(ctx, data);\n    }\n\n    if (data.type === 'loose-decorated') {\n      return ctx.resolve(\n        isAttribute(data.inner)\n          ? formatToWGSLType[data.inner.format]\n          : data.inner,\n      );\n    }\n\n    return ctx.resolve(formatToWGSLType[data.type]);\n  }\n\n  if (isIdentityType(data)) {\n    return data.type;\n  }\n\n  if (data.type === 'struct') {\n    return resolveStruct(ctx, data);\n  }\n\n  if (data.type === 'array') {\n    return resolveArray(ctx, data);\n  }\n\n  if (data.type === 'atomic') {\n    return `atomic<${resolveData(ctx, data.inner)}>`;\n  }\n\n  if (data.type === 'decorated') {\n    return ctx.resolve(data.inner as AnyWgslData);\n  }\n\n  if (data.type === 'ptr') {\n    if (data.addressSpace === 'storage') {\n      return `ptr<storage, ${ctx.resolve(data.inner)}, ${\n        data.access === 'read-write' ? 'read_write' : data.access\n      }>`;\n    }\n    return `ptr<${data.addressSpace}, ${ctx.resolve(data.inner)}>`;\n  }\n\n  if (\n    data.type === 'abstractInt' || data.type === 'abstractFloat' ||\n    data.type === 'void' || data.type === 'u16'\n  ) {\n    throw new Error(`${data.type} has no representation in WGSL`);\n  }\n\n  assertExhaustive(data, 'resolveData');\n}\n", "import { BufferReader, BufferWriter, getSystemEndianness } from 'typed-binary';\nimport {\n  EVAL_ALLOWED_IN_ENV,\n  getCompiledWriterForSchema,\n} from '../../data/compiledIO.ts';\nimport { readData, writeData } from '../../data/dataIO.ts';\nimport { getWriteInstructions } from '../../data/partialIO.ts';\nimport { sizeOf } from '../../data/sizeOf.ts';\nimport type { BaseData, WgslTypeLiteral } from '../../data/wgslTypes.ts';\nimport { isWgslData } from '../../data/wgslTypes.ts';\nimport type { StorageFlag } from '../../extension.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer, InferPartial, MemIdentity } from '../../shared/repr.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport type { UnionToIntersection } from '../../shared/utilityTypes.ts';\nimport { isGPUBuffer } from '../../types.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport {\n  asMutable,\n  asReadonly,\n  asUniform,\n  type TgpuBufferMutable,\n  type TgpuBufferReadonly,\n  type TgpuBufferUniform,\n  type TgpuFixedBufferUsage,\n} from './bufferUsage.ts';\nimport type { AnyData, UnwrapDecorated } from '../../data/dataTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface UniformFlag {\n  usableAsUniform: true;\n}\n\n/**\n * @deprecated Use UniformFlag instead.\n */\nexport type Uniform = UniformFlag;\n\nexport interface VertexFlag {\n  usableAsVertex: true;\n}\n\nexport interface IndexFlag {\n  usableAsIndex: true;\n}\n\n/**\n * @deprecated Use VertexFlag instead.\n */\nexport type Vertex = VertexFlag;\n\ntype LiteralToUsageType<T extends 'uniform' | 'storage' | 'vertex' | 'index'> =\n  T extends 'uniform' ? UniformFlag\n    : T extends 'storage' ? StorageFlag\n    : T extends 'vertex' ? VertexFlag\n    : T extends 'index' ? IndexFlag\n    : never;\n\ntype ViewUsages<TBuffer extends TgpuBuffer<BaseData>> =\n  | (boolean extends TBuffer['usableAsUniform'] ? never : 'uniform')\n  | (boolean extends TBuffer['usableAsStorage'] ? never\n    : 'readonly' | 'mutable');\n\ntype UsageTypeToBufferUsage<TData extends BaseData> = {\n  uniform: TgpuBufferUniform<TData> & TgpuFixedBufferUsage<TData>;\n  mutable: TgpuBufferMutable<TData> & TgpuFixedBufferUsage<TData>;\n  readonly: TgpuBufferReadonly<TData> & TgpuFixedBufferUsage<TData>;\n};\n\nconst usageToUsageConstructor = {\n  uniform: asUniform,\n  mutable: asMutable,\n  readonly: asReadonly,\n};\n\ntype IsIndexCompatible<TData extends BaseData> = UnwrapDecorated<TData> extends\n  {\n    readonly type: 'array';\n    readonly elementType: infer TElement;\n  }\n  ? TElement extends BaseData\n    ? UnwrapDecorated<TElement> extends { readonly type: 'u32' | 'u16' } ? true\n    : false\n  : false\n  : false;\n\nexport interface TgpuBuffer<TData extends BaseData> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'buffer';\n  readonly dataType: TData;\n  readonly initial?: Infer<TData> | undefined;\n\n  readonly buffer: GPUBuffer;\n  readonly destroyed: boolean;\n\n  usableAsUniform: boolean;\n  usableAsStorage: boolean;\n  usableAsVertex: boolean;\n  usableAsIndex: boolean;\n\n  $usage<T extends RestrictUsages<TData>>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToUsageType<T[number]>>;\n  $addFlags(flags: GPUBufferUsageFlags): this;\n\n  as<T extends ViewUsages<this>>(usage: T): UsageTypeToBufferUsage<TData>[T];\n\n  compileWriter(): void;\n  write(data: Infer<TData>): void;\n  writePartial(data: InferPartial<TData>): void;\n  copyFrom(srcBuffer: TgpuBuffer<MemIdentity<TData>>): void;\n  read(): Promise<Infer<TData>>;\n  destroy(): void;\n}\n\nexport function INTERNAL_createBuffer<TData extends AnyData>(\n  group: ExperimentalTgpuRoot,\n  typeSchema: TData,\n  initialOrBuffer?: Infer<TData> | GPUBuffer,\n): TgpuBuffer<TData> {\n  if (!isWgslData(typeSchema)) {\n    return new TgpuBufferImpl(group, typeSchema, initialOrBuffer, [\n      'storage',\n      'uniform',\n    ]);\n  }\n\n  return new TgpuBufferImpl(group, typeSchema, initialOrBuffer);\n}\n\nexport function isBuffer<T extends TgpuBuffer<AnyData>>(\n  value: T | unknown,\n): value is T {\n  return (value as TgpuBuffer<AnyData>).resourceType === 'buffer';\n}\n\nexport function isUsableAsVertex<T extends TgpuBuffer<AnyData>>(\n  buffer: T,\n): buffer is T & VertexFlag {\n  return !!(buffer as unknown as VertexFlag).usableAsVertex;\n}\n\nexport function isUsableAsIndex<T extends TgpuBuffer<AnyData>>(\n  buffer: T,\n): buffer is T & IndexFlag {\n  return !!(buffer as unknown as IndexFlag).usableAsIndex;\n}\n\n// --------------\n// Implementation\n// --------------\nconst endianness = getSystemEndianness();\n\ntype IsArrayOfU32<TData extends BaseData> = UnwrapDecorated<TData> extends {\n  readonly type: 'array';\n  readonly elementType: infer TElement;\n}\n  ? TElement extends BaseData\n    ? UnwrapDecorated<TElement> extends { readonly type: 'u32' } ? true\n    : false\n  : false\n  : false;\n\ntype IsWgslLiteral<TData extends BaseData> = TData extends {\n  readonly type: WgslTypeLiteral;\n} ? true\n  : false;\n\ntype RestrictUsages<TData extends BaseData> = string extends TData['type']\n  ? ('uniform' | 'storage' | 'vertex' | 'index')[]\n  : IsIndexCompatible<TData> extends true\n    ? IsArrayOfU32<TData> extends true\n      ? ('uniform' | 'storage' | 'vertex' | 'index')[]\n    : ['index']\n  : IsWgslLiteral<TData> extends true ? ('uniform' | 'storage' | 'vertex')[]\n  : ['vertex'];\n\nclass TgpuBufferImpl<TData extends AnyData> implements TgpuBuffer<TData> {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'buffer';\n  public flags: GPUBufferUsageFlags = GPUBufferUsage.COPY_DST |\n    GPUBufferUsage.COPY_SRC;\n  private _buffer: GPUBuffer | null = null;\n  private _ownBuffer: boolean;\n  private _destroyed = false;\n  private _hostBuffer: ArrayBuffer | undefined;\n\n  readonly initial: Infer<TData> | undefined;\n\n  usableAsUniform = false;\n  usableAsStorage = false;\n  usableAsVertex = false;\n  usableAsIndex = false;\n\n  constructor(\n    private readonly _group: ExperimentalTgpuRoot,\n    public readonly dataType: TData,\n    public readonly initialOrBuffer?: Infer<TData> | GPUBuffer | undefined,\n    private readonly _disallowedUsages?:\n      ('uniform' | 'storage' | 'vertex' | 'index')[],\n  ) {\n    if (isGPUBuffer(initialOrBuffer)) {\n      this._ownBuffer = false;\n      this._buffer = initialOrBuffer;\n    } else {\n      this._ownBuffer = true;\n      this.initial = initialOrBuffer;\n    }\n  }\n\n  get buffer() {\n    const device = this._group.device;\n\n    if (this._destroyed) {\n      throw new Error('This buffer has been destroyed');\n    }\n\n    if (!this._buffer) {\n      this._buffer = device.createBuffer({\n        size: sizeOf(this.dataType),\n        usage: this.flags,\n        mappedAtCreation: !!this.initial,\n        label: getName(this) ?? '<unnamed>',\n      });\n\n      if (this.initial) {\n        const writer = new BufferWriter(this._buffer.getMappedRange());\n        writeData(writer, this.dataType, this.initial);\n        this._buffer.unmap();\n      }\n    }\n\n    return this._buffer;\n  }\n\n  get destroyed() {\n    return this._destroyed;\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    if (this._buffer) {\n      this._buffer.label = label;\n    }\n    return this;\n  }\n\n  $usage<T extends ('uniform' | 'storage' | 'vertex' | 'index')[]>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToUsageType<T[number]>> {\n    for (const usage of usages) {\n      if (this._disallowedUsages?.includes(usage)) {\n        throw new Error(\n          `Buffer of type ${this.dataType.type} cannot be used as ${usage}`,\n        );\n      }\n\n      this.flags |= usage === 'uniform' ? GPUBufferUsage.UNIFORM : 0;\n      this.flags |= usage === 'storage' ? GPUBufferUsage.STORAGE : 0;\n      this.flags |= usage === 'vertex' ? GPUBufferUsage.VERTEX : 0;\n      this.flags |= usage === 'index' ? GPUBufferUsage.INDEX : 0;\n      this.usableAsUniform = this.usableAsUniform || usage === 'uniform';\n      this.usableAsStorage = this.usableAsStorage || usage === 'storage';\n      this.usableAsVertex = this.usableAsVertex || usage === 'vertex';\n      this.usableAsIndex = this.usableAsIndex || usage === 'index';\n    }\n    return this as this & UnionToIntersection<LiteralToUsageType<T[number]>>;\n  }\n\n  $addFlags(flags: GPUBufferUsageFlags) {\n    if (!this._ownBuffer) {\n      throw new Error(\n        'Cannot add flags to a buffer that is not managed by TypeGPU.',\n      );\n    }\n\n    if (flags & GPUBufferUsage.MAP_READ) {\n      this.flags = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      return this;\n    }\n\n    if (flags & GPUBufferUsage.MAP_WRITE) {\n      this.flags = GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      return this;\n    }\n\n    this.flags |= flags;\n    return this;\n  }\n\n  compileWriter(): void {\n    if (EVAL_ALLOWED_IN_ENV) {\n      getCompiledWriterForSchema(this.dataType);\n    } else {\n      throw new Error('This environment does not allow eval');\n    }\n  }\n\n  write(data: Infer<TData>): void {\n    const gpuBuffer = this.buffer;\n    const device = this._group.device;\n\n    if (gpuBuffer.mapState === 'mapped') {\n      const mapped = gpuBuffer.getMappedRange();\n      if (EVAL_ALLOWED_IN_ENV) {\n        const writer = getCompiledWriterForSchema(this.dataType);\n        writer(new DataView(mapped), 0, data, endianness === 'little');\n        return;\n      }\n      writeData(new BufferWriter(mapped), this.dataType, data);\n      return;\n    }\n\n    const size = sizeOf(this.dataType);\n    if (!this._hostBuffer) {\n      this._hostBuffer = new ArrayBuffer(size);\n    }\n\n    // Flushing any commands yet to be encoded.\n    this._group.flush();\n\n    if (EVAL_ALLOWED_IN_ENV) {\n      const writer = getCompiledWriterForSchema(this.dataType);\n      writer(new DataView(this._hostBuffer), 0, data, endianness === 'little');\n    } else {\n      writeData(new BufferWriter(this._hostBuffer), this.dataType, data);\n    }\n    device.queue.writeBuffer(gpuBuffer, 0, this._hostBuffer, 0, size);\n  }\n\n  public writePartial(data: InferPartial<TData>): void {\n    const gpuBuffer = this.buffer;\n    const device = this._group.device;\n\n    const instructions = getWriteInstructions(this.dataType, data);\n\n    if (gpuBuffer.mapState === 'mapped') {\n      const mappedRange = gpuBuffer.getMappedRange();\n      const mappedView = new Uint8Array(mappedRange);\n\n      for (const instruction of instructions) {\n        mappedView.set(instruction.data, instruction.data.byteOffset);\n      }\n    } else {\n      for (const instruction of instructions) {\n        device.queue.writeBuffer(\n          gpuBuffer,\n          instruction.data.byteOffset,\n          instruction.data,\n          0,\n          instruction.data.byteLength,\n        );\n      }\n    }\n  }\n\n  copyFrom(srcBuffer: TgpuBuffer<MemIdentity<TData>>): void {\n    if (this.buffer.mapState === 'mapped') {\n      throw new Error('Cannot copy to a mapped buffer.');\n    }\n\n    const size = sizeOf(this.dataType);\n    const encoder = this._group.commandEncoder;\n    encoder.copyBufferToBuffer(srcBuffer.buffer, 0, this.buffer, 0, size);\n  }\n\n  async read(): Promise<Infer<TData>> {\n    // Flushing any commands yet to be encoded.\n    this._group.flush();\n\n    const gpuBuffer = this.buffer;\n    const device = this._group.device;\n\n    if (gpuBuffer.mapState === 'mapped') {\n      const mapped = gpuBuffer.getMappedRange();\n      return readData(new BufferReader(mapped), this.dataType);\n    }\n\n    if (gpuBuffer.usage & GPUBufferUsage.MAP_READ) {\n      await gpuBuffer.mapAsync(GPUMapMode.READ);\n      const mapped = gpuBuffer.getMappedRange();\n      const res = readData(new BufferReader(mapped), this.dataType);\n      gpuBuffer.unmap();\n      return res;\n    }\n\n    const stagingBuffer = device.createBuffer({\n      size: sizeOf(this.dataType),\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    const commandEncoder = device.createCommandEncoder();\n    commandEncoder.copyBufferToBuffer(\n      gpuBuffer,\n      0,\n      stagingBuffer,\n      0,\n      sizeOf(this.dataType),\n    );\n\n    device.queue.submit([commandEncoder.finish()]);\n    await device.queue.onSubmittedWorkDone();\n    await stagingBuffer.mapAsync(GPUMapMode.READ, 0, sizeOf(this.dataType));\n\n    const res = readData(\n      new BufferReader(stagingBuffer.getMappedRange()),\n      this.dataType,\n    );\n\n    stagingBuffer.unmap();\n    stagingBuffer.destroy();\n\n    return res;\n  }\n\n  as<T extends ViewUsages<this>>(usage: T): UsageTypeToBufferUsage<TData>[T] {\n    return usageToUsageConstructor[usage]?.(\n      this as never,\n    ) as UsageTypeToBufferUsage<TData>[T];\n  }\n\n  destroy() {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    if (this._ownBuffer) {\n      this._buffer?.destroy();\n    }\n  }\n\n  toString(): string {\n    return `buffer:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n", "import { Measurer } from 'typed-binary';\nimport { roundUp } from '../mathUtils.ts';\nimport alignIO from './alignIO.ts';\nimport { alignmentOf, customAlignmentOf } from './alignmentOf.ts';\nimport { type AnyUnstruct, isUnstruct, type Unstruct } from './dataTypes.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport type { AnyWgslStruct, BaseData, WgslStruct } from './wgslTypes.ts';\n\nexport interface OffsetInfo {\n  offset: number;\n  size: number;\n  padding?: number | undefined;\n}\n\nconst cachedOffsets = new WeakMap<\n  AnyWgslStruct | AnyUnstruct,\n  Record<string, OffsetInfo>\n>();\n\nexport function offsetsForProps<T extends Record<string, BaseData>>(\n  struct: WgslStruct<T> | Unstruct<T>,\n): Record<keyof T, OffsetInfo> {\n  const cached = cachedOffsets.get(struct);\n  if (cached) {\n    return cached as Record<keyof T, OffsetInfo>;\n  }\n\n  const measurer = new Measurer();\n  const offsets = {} as Record<keyof T, OffsetInfo>;\n  let lastEntry: OffsetInfo | undefined = undefined;\n\n  for (const key in struct.propTypes) {\n    const prop = struct.propTypes[key];\n    if (prop === undefined) {\n      throw new Error(`Property ${key} is undefined in struct`);\n    }\n\n    const beforeAlignment = measurer.size;\n\n    alignIO(\n      measurer,\n      isUnstruct(struct) ? customAlignmentOf(prop) : alignmentOf(prop),\n    );\n\n    if (lastEntry) {\n      lastEntry.padding = measurer.size - beforeAlignment;\n    }\n\n    const propSize = sizeOf(prop);\n    offsets[key] = { offset: measurer.size, size: propSize };\n    lastEntry = offsets[key];\n    measurer.add(propSize);\n  }\n\n  if (lastEntry) {\n    lastEntry.padding = roundUp(sizeOf(struct), alignmentOf(struct)) -\n      measurer.size;\n  }\n\n  cachedOffsets.set(\n    struct as\n      | WgslStruct<Record<string, BaseData>>\n      | Unstruct<Record<string, BaseData>>,\n    offsets,\n  );\n\n  return offsets;\n}\n", "import type { IMeasurer, ISerialInput, ISerialOutput } from 'typed-binary';\n\n/**\n * @param io the IO to align\n * @param baseAlignment must be power of 2\n */\nfunction alignIO(\n  io: ISerialInput | ISerialOutput | IMeasurer,\n  baseAlignment: number,\n) {\n  const currentPos = 'size' in io ? io.size : io.currentByteOffset;\n\n  const bitMask = baseAlignment - 1;\n  const offset = currentPos & bitMask;\n\n  if ('skipBytes' in io) {\n    io.skipBytes((baseAlignment - offset) & bitMask);\n  } else {\n    io.add((baseAlignment - offset) & bitMask);\n  }\n}\n\nexport default alignIO;\n", "import { roundUp } from '../mathUtils.ts';\nimport type { Infer } from '../shared/repr.ts';\nimport { alignmentOf } from './alignmentOf.ts';\nimport { isDisarray, isUnstruct } from './dataTypes.ts';\nimport { offsetsForProps } from './offsets.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport * as wgsl from './wgslTypes.ts';\n\nexport const EVAL_ALLOWED_IN_ENV: boolean = (() => {\n  try {\n    new Function('return true');\n    return true;\n  } catch {\n    return false;\n  }\n})();\n\nconst compiledWriters = new WeakMap<\n  wgsl.BaseData,\n  (\n    output: DataView,\n    offset: number,\n    value: unknown,\n    littleEndian?: boolean,\n  ) => void\n>();\n\nconst typeToPrimitive = {\n  u32: 'u32',\n  vec2u: 'u32',\n  vec3u: 'u32',\n  vec4u: 'u32',\n  u16: 'u16',\n\n  i32: 'i32',\n  vec2i: 'i32',\n  vec3i: 'i32',\n  vec4i: 'i32',\n\n  f32: 'f32',\n  vec2f: 'f32',\n  vec3f: 'f32',\n  vec4f: 'f32',\n\n  vec2h: 'f32',\n  vec3h: 'f32',\n  vec4h: 'f32',\n\n  mat2x2f: 'f32',\n  mat3x3f: 'f32',\n  mat4x4f: 'f32',\n} as const;\n\nconst primitiveToWriteFunction = {\n  u32: 'setUint32',\n  i32: 'setInt32',\n  f32: 'setFloat32',\n  u16: 'setUint16',\n} as const;\n\nexport function buildWriter(\n  node: wgsl.BaseData,\n  offsetExpr: string,\n  valueExpr: string,\n): string {\n  if (wgsl.isAtomic(node) || wgsl.isDecorated(node)) {\n    return buildWriter(node.inner, offsetExpr, valueExpr);\n  }\n\n  if (wgsl.isWgslStruct(node) || isUnstruct(node)) {\n    const propOffsets = offsetsForProps(node);\n    const sortedProps = Object.entries(propOffsets).sort(\n      (a, b) => a[1].offset - b[1].offset,\n    );\n    let code = '';\n    for (const [key, propOffset] of sortedProps) {\n      const subSchema = node.propTypes[key];\n      if (!subSchema) continue;\n      code += buildWriter(\n        subSchema,\n        `(${offsetExpr} + ${propOffset.offset})`,\n        `${valueExpr}.${key}`,\n      );\n    }\n    return code;\n  }\n\n  if (wgsl.isWgslArray(node) || isDisarray(node)) {\n    const arrSchema = node as wgsl.WgslArray;\n    const elementSize = roundUp(\n      sizeOf(arrSchema.elementType),\n      alignmentOf(arrSchema.elementType),\n    );\n    let code = '';\n\n    code += `for (let i = 0; i < ${arrSchema.elementCount}; i++) {\\n`;\n    code += buildWriter(\n      arrSchema.elementType,\n      `(${offsetExpr} + i * ${elementSize})`,\n      `${valueExpr}[i]`,\n    );\n    code += '}\\n';\n\n    return code;\n  }\n\n  if (wgsl.isVec(node)) {\n    const primitive = typeToPrimitive[node.type];\n    let code = '';\n    const writeFunc = primitiveToWriteFunction[primitive];\n    const components = ['x', 'y', 'z', 'w'];\n    const count = wgsl.isVec2(node) ? 2 : wgsl.isVec3(node) ? 3 : 4;\n\n    for (let i = 0; i < count; i++) {\n      code += `output.${writeFunc}((${offsetExpr} + ${i * 4}), ${valueExpr}.${\n        components[i]\n      }, littleEndian);\\n`;\n    }\n    return code;\n  }\n\n  if (wgsl.isMat(node)) {\n    const primitive = typeToPrimitive[node.type];\n    const writeFunc = primitiveToWriteFunction[primitive];\n\n    const matSize = wgsl.isMat2x2f(node) ? 2 : wgsl.isMat3x3f(node) ? 3 : 4;\n    const elementCount = matSize * matSize;\n    const rowStride = roundUp(matSize * 4, 8);\n\n    let code = '';\n    for (let i = 0; i < elementCount; i++) {\n      const colIndex = Math.floor(i / matSize);\n      const rowIndex = i % matSize;\n      const byteOffset = colIndex * rowStride + rowIndex * 4;\n\n      code +=\n        `output.${writeFunc}((${offsetExpr} + ${byteOffset}), ${valueExpr}.columns[${colIndex}].${\n          ['x', 'y', 'z', 'w'][rowIndex]\n        }, littleEndian);\\n`;\n    }\n\n    return code;\n  }\n\n  const primitive = typeToPrimitive[node.type as keyof typeof typeToPrimitive];\n  return `output.${\n    primitiveToWriteFunction[primitive]\n  }(${offsetExpr}, ${valueExpr}, littleEndian);\\n`;\n}\n\nexport function getCompiledWriterForSchema<T extends wgsl.BaseData>(\n  schema: T,\n): (\n  output: DataView,\n  offset: number,\n  value: Infer<T>,\n  littleEndian?: boolean,\n) => void {\n  if (compiledWriters.has(schema)) {\n    return compiledWriters.get(schema) as (\n      output: DataView,\n      offset: number,\n      value: Infer<T>,\n      littleEndian?: boolean,\n    ) => void;\n  }\n\n  const body = buildWriter(schema, 'offset', 'value');\n\n  const fn = new Function(\n    'output',\n    'offset',\n    'value',\n    'littleEndian=true',\n    body,\n  ) as (\n    output: DataView,\n    offset: number,\n    value: Infer<T> | unknown,\n    littleEndian?: boolean,\n  ) => void;\n\n  compiledWriters.set(schema, fn);\n\n  return fn;\n}\n", "import type { ISerialInput, ISerialOutput } from 'typed-binary';\nimport type { Infer, InferRecord } from '../shared/repr.ts';\nimport alignIO from './alignIO.ts';\nimport { alignmentOf, customAlignmentOf } from './alignmentOf.ts';\nimport type {\n  AnyConcreteData,\n  AnyData,\n  Disarray,\n  LooseDecorated,\n  Unstruct,\n} from './dataTypes.ts';\nimport { mat2x2f, mat3x3f, mat4x4f } from './matrix.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport {\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n} from './vector.ts';\nimport type * as wgsl from './wgslTypes.ts';\n\ntype DataWriter<TSchema extends wgsl.BaseData> = (\n  output: ISerialOutput,\n  schema: TSchema,\n  value: Infer<TSchema>,\n) => void;\n\ntype DataReader<TSchema extends wgsl.BaseData> = (\n  input: ISerialInput,\n  schema: TSchema,\n) => Infer<TSchema>;\n\ntype CompleteDataWriters = {\n  [TType in AnyConcreteData['type']]: DataWriter<\n    Extract<AnyData, { readonly type: TType }>\n  >;\n};\n\ntype CompleteDataReaders = {\n  [TType in AnyConcreteData['type']]: DataReader<\n    Extract<AnyData, { readonly type: TType }>\n  >;\n};\n\nconst dataWriters = {\n  bool() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  f32(output, _schema: wgsl.F32, value: number) {\n    output.writeFloat32(value);\n  },\n\n  f16(output, _schema: wgsl.F16, value: number) {\n    output.writeFloat16(value);\n  },\n\n  i32(output, _schema: wgsl.I32, value: number) {\n    output.writeInt32(value);\n  },\n\n  u32(output, _schema: wgsl.U32, value: number) {\n    output.writeUint32(value);\n  },\n\n  u16(output, _schema: wgsl.U16, value: number) {\n    output.writeUint16(value);\n  },\n\n  vec2f(output, _, value: wgsl.v2f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n  },\n\n  vec2h(output, _, value: wgsl.v2h) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n  },\n\n  vec2i(output, _, value: wgsl.v2i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n  },\n\n  vec2u(output, _, value: wgsl.v2u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n  },\n\n  'vec2<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  vec3f(output, _, value: wgsl.v3f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n  },\n\n  vec3h(output, _, value: wgsl.v3h) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n    output.writeFloat16(value.z);\n  },\n\n  vec3i(output, _, value: wgsl.v3i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n  },\n\n  vec3u(output, _, value: wgsl.v3u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n  },\n\n  'vec3<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  vec4f(output, _, value: wgsl.v4f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n    output.writeFloat32(value.w);\n  },\n\n  vec4h(output, _, value: wgsl.v4h) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n    output.writeFloat16(value.z);\n    output.writeFloat16(value.w);\n  },\n\n  vec4i(output, _, value: wgsl.v4i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n    output.writeInt32(value.w);\n  },\n\n  vec4u(output, _, value: wgsl.v4u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n    output.writeUint32(value.w);\n  },\n\n  'vec4<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  mat2x2f(output, _, value: wgsl.m2x2f) {\n    for (let i = 0; i < value.length; ++i) {\n      output.writeFloat32(value[i] as number);\n    }\n  },\n\n  mat3x3f(output, _, value: wgsl.m3x3f) {\n    for (let i = 0; i < value.length; ++i) {\n      output.writeFloat32(value[i] as number);\n    }\n  },\n\n  mat4x4f(output, _, value: wgsl.m4x4f) {\n    for (let i = 0; i < value.length; ++i) {\n      output.writeFloat32(value[i] as number);\n    }\n  },\n\n  struct(\n    output,\n    schema: wgsl.WgslStruct,\n    value: InferRecord<Record<string, wgsl.BaseData>>,\n  ) {\n    const alignment = alignmentOf(schema);\n    alignIO(output, alignment);\n\n    for (const [key, property] of Object.entries(schema.propTypes)) {\n      alignIO(output, alignmentOf(property));\n      writeData(output, property, value[key] as wgsl.BaseData);\n    }\n\n    alignIO(output, alignment);\n  },\n\n  array(output, schema: wgsl.WgslArray, value: Infer<wgsl.BaseData>[]) {\n    if (schema.elementCount === 0) {\n      throw new Error('Cannot write using a runtime-sized schema.');\n    }\n\n    const alignment = alignmentOf(schema);\n    alignIO(output, alignment);\n    const beginning = output.currentByteOffset;\n    for (let i = 0; i < Math.min(schema.elementCount, value.length); i++) {\n      alignIO(output, alignment);\n      writeData(output, schema.elementType, value[i]);\n    }\n    output.seekTo(beginning + sizeOf(schema));\n  },\n\n  ptr() {\n    throw new Error('Pointers are not host-shareable');\n  },\n\n  atomic(output, schema: wgsl.Atomic, value: number) {\n    dataWriters[schema.inner.type]?.(output, schema, value);\n  },\n\n  decorated(output, schema: wgsl.Decorated, value: unknown) {\n    const alignment = customAlignmentOf(schema);\n    alignIO(output, alignment);\n\n    const beginning = output.currentByteOffset;\n    dataWriters[(schema.inner as AnyData)?.type]?.(output, schema.inner, value);\n    output.seekTo(beginning + sizeOf(schema));\n  },\n\n  // Loose Types\n\n  uint8(output, _, value: number) {\n    output.writeUint8(value);\n  },\n  uint8x2(output, _, value: wgsl.v2u) {\n    output.writeUint8(value.x);\n    output.writeUint8(value.y);\n  },\n  uint8x4(output, _, value: wgsl.v4u) {\n    output.writeUint8(value.x);\n    output.writeUint8(value.y);\n    output.writeUint8(value.z);\n    output.writeUint8(value.w);\n  },\n  sint8(output, _, value: number) {\n    output.writeInt8(value);\n  },\n  sint8x2(output, _, value: wgsl.v2i) {\n    output.writeInt8(value.x);\n    output.writeInt8(value.y);\n  },\n  sint8x4(output, _, value: wgsl.v4i) {\n    output.writeInt8(value.x);\n    output.writeInt8(value.y);\n    output.writeInt8(value.z);\n    output.writeInt8(value.w);\n  },\n  unorm8(output, _, value: number) {\n    output.writeUint8(value * 255);\n  },\n  unorm8x2(output, _, value: wgsl.v2f) {\n    output.writeUint8(value.x * 255);\n    output.writeUint8(value.y * 255);\n  },\n  unorm8x4(output, _, value: wgsl.v4f) {\n    output.writeUint8(value.x * 255);\n    output.writeUint8(value.y * 255);\n    output.writeUint8(value.z * 255);\n    output.writeUint8(value.w * 255);\n  },\n  snorm8(output, _, value: number) {\n    output.writeUint8(value * 127 + 128);\n  },\n  snorm8x2(output, _, value: wgsl.v2f) {\n    output.writeUint8(value.x * 127 + 128);\n    output.writeUint8(value.y * 127 + 128);\n  },\n  snorm8x4(output, _, value: wgsl.v4f) {\n    output.writeUint8(value.x * 127 + 128);\n    output.writeUint8(value.y * 127 + 128);\n    output.writeUint8(value.z * 127 + 128);\n    output.writeUint8(value.w * 127 + 128);\n  },\n  uint16(output, _, value: number) {\n    output.writeUint16(value);\n  },\n  uint16x2(output, _, value: wgsl.v2u) {\n    output.writeUint16(value.x);\n    output.writeUint16(value.y);\n  },\n  uint16x4(output, _, value: wgsl.v4u) {\n    output.writeUint16(value.x);\n    output.writeUint16(value.y);\n    output.writeUint16(value.z);\n    output.writeUint16(value.w);\n  },\n  sint16(output, _, value: number) {\n    output.writeInt16(value);\n  },\n  sint16x2(output, _, value: wgsl.v2i) {\n    output.writeInt16(value.x);\n    output.writeInt16(value.y);\n  },\n  sint16x4(output, _, value: wgsl.v4i) {\n    output.writeInt16(value.x);\n    output.writeInt16(value.y);\n    output.writeInt16(value.z);\n    output.writeInt16(value.w);\n  },\n  unorm16(output, _, value: number) {\n    output.writeUint16(value * 65535);\n  },\n  unorm16x2(output, _, value: wgsl.v2f) {\n    output.writeUint16(value.x * 65535);\n    output.writeUint16(value.y * 65535);\n  },\n  unorm16x4(output, _, value: wgsl.v4f) {\n    output.writeUint16(value.x * 65535);\n    output.writeUint16(value.y * 65535);\n    output.writeUint16(value.z * 65535);\n    output.writeUint16(value.w * 65535);\n  },\n  snorm16(output, _, value: number) {\n    output.writeUint16(value * 32767 + 32768);\n  },\n  snorm16x2(output, _, value: wgsl.v2f) {\n    output.writeUint16(value.x * 32767 + 32768);\n    output.writeUint16(value.y * 32767 + 32768);\n  },\n  snorm16x4(output, _, value: wgsl.v4f) {\n    output.writeUint16(value.x * 32767 + 32768);\n    output.writeUint16(value.y * 32767 + 32768);\n    output.writeUint16(value.z * 32767 + 32768);\n    output.writeUint16(value.w * 32767 + 32768);\n  },\n  float16(output, _, value: number) {\n    output.writeFloat16(value);\n  },\n  float16x2(output, _, value: wgsl.v2f) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n  },\n  float16x4(output, _, value: wgsl.v4f) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n    output.writeFloat16(value.z);\n    output.writeFloat16(value.w);\n  },\n  float32(output, _, value: number) {\n    output.writeFloat32(value);\n  },\n  float32x2(output, _, value: wgsl.v2f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n  },\n  float32x3(output, _, value: wgsl.v3f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n  },\n  float32x4(output, _, value: wgsl.v4f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n    output.writeFloat32(value.w);\n  },\n  uint32(output, _, value: number) {\n    output.writeUint32(value);\n  },\n  uint32x2(output, _, value: wgsl.v2u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n  },\n  uint32x3(output, _, value: wgsl.v3u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n  },\n  uint32x4(output, _, value: wgsl.v4u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n    output.writeUint32(value.w);\n  },\n  sint32(output, _, value: number) {\n    output.writeInt32(value);\n  },\n  sint32x2(output, _, value: wgsl.v2i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n  },\n  sint32x3(output, _, value: wgsl.v3i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n  },\n  sint32x4(output, _, value: wgsl.v4i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n    output.writeInt32(value.w);\n  },\n  'unorm10-10-10-2'(output, _, value: wgsl.v4f) {\n    let packed = 0;\n    packed |= ((value.x * 1023) & 1023) << 22; // r (10 bits)\n    packed |= ((value.x * 1023) & 1023) << 12; // g (10 bits)\n    packed |= ((value.y * 1023) & 1023) << 2; // b (10 bits)\n    packed |= (value.z * 3) & 3; // a (2 bits)\n    output.writeUint32(packed);\n  },\n  'unorm8x4-bgra'(output, _, value: wgsl.v4f) {\n    output.writeUint8(value.z * 255);\n    output.writeUint8(value.y * 255);\n    output.writeUint8(value.x * 255);\n    output.writeUint8(value.w * 255);\n  },\n\n  disarray(output, schema: Disarray, value: unknown[]) {\n    const alignment = alignmentOf(schema);\n\n    alignIO(output, alignment);\n    const beginning = output.currentByteOffset;\n    for (let i = 0; i < Math.min(schema.elementCount, value.length); i++) {\n      alignIO(output, alignment);\n      dataWriters[(schema.elementType as AnyData)?.type]?.(\n        output,\n        schema.elementType,\n        value[i],\n      );\n    }\n\n    output.seekTo(beginning + sizeOf(schema));\n  },\n\n  unstruct(output, schema: Unstruct, value) {\n    for (const [key, property] of Object.entries(schema.propTypes)) {\n      dataWriters[property.type]?.(output, property, value[key]);\n    }\n  },\n\n  'loose-decorated'(output, schema: LooseDecorated, value: unknown) {\n    const alignment = customAlignmentOf(schema);\n    alignIO(output, alignment);\n\n    const beginning = output.currentByteOffset;\n    const writer = dataWriters[(schema.inner as AnyData)?.type];\n    writer?.(output, schema.inner, value);\n    output.seekTo(beginning + sizeOf(schema));\n    return value;\n  },\n} satisfies CompleteDataWriters as Record<\n  string,\n  (output: ISerialOutput, schema: unknown, value: unknown) => void\n>;\n\nexport function writeData<TData extends wgsl.BaseData>(\n  output: ISerialOutput,\n  schema: TData,\n  value: Infer<TData>,\n): void {\n  const writer = dataWriters[schema.type];\n  if (!writer) {\n    throw new Error(`Cannot write data of type '${schema.type}'.`);\n  }\n\n  writer(output, schema, value);\n}\n\nconst dataReaders = {\n  bool(): boolean {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  f32(input: ISerialInput): number {\n    return input.readFloat32();\n  },\n\n  f16(input: ISerialInput): number {\n    return input.readFloat16();\n  },\n\n  i32(input: ISerialInput): number {\n    return input.readInt32();\n  },\n\n  u32(input: ISerialInput): number {\n    return input.readUint32();\n  },\n\n  u16(input: ISerialInput): number {\n    return input.readUint16();\n  },\n\n  vec2f(input: ISerialInput): wgsl.v2f {\n    return vec2f(input.readFloat32(), input.readFloat32());\n  },\n\n  vec3f(input: ISerialInput): wgsl.v3f {\n    return vec3f(input.readFloat32(), input.readFloat32(), input.readFloat32());\n  },\n\n  vec4f(input: ISerialInput): wgsl.v4f {\n    return vec4f(\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n    );\n  },\n\n  vec2h(input): wgsl.v2h {\n    return vec2h(input.readFloat16(), input.readFloat16());\n  },\n\n  vec3h(input: ISerialInput): wgsl.v3h {\n    return vec3h(input.readFloat16(), input.readFloat16(), input.readFloat16());\n  },\n\n  vec4h(input: ISerialInput): wgsl.v4h {\n    return vec4h(\n      input.readFloat16(),\n      input.readFloat16(),\n      input.readFloat16(),\n      input.readFloat16(),\n    );\n  },\n\n  vec2i(input): wgsl.v2i {\n    return vec2i(input.readInt32(), input.readInt32());\n  },\n\n  vec3i(input: ISerialInput): wgsl.v3i {\n    return vec3i(input.readInt32(), input.readInt32(), input.readInt32());\n  },\n\n  vec4i(input: ISerialInput): wgsl.v4i {\n    return vec4i(\n      input.readInt32(),\n      input.readInt32(),\n      input.readInt32(),\n      input.readInt32(),\n    );\n  },\n\n  vec2u(input): wgsl.v2u {\n    return vec2u(input.readUint32(), input.readUint32());\n  },\n\n  vec3u(input: ISerialInput): wgsl.v3u {\n    return vec3u(input.readUint32(), input.readUint32(), input.readUint32());\n  },\n\n  vec4u(input: ISerialInput): wgsl.v4u {\n    return vec4u(\n      input.readUint32(),\n      input.readUint32(),\n      input.readUint32(),\n      input.readUint32(),\n    );\n  },\n\n  'vec2<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  'vec3<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  'vec4<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  mat2x2f(input: ISerialInput): wgsl.m2x2f {\n    return mat2x2f(\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n    );\n  },\n\n  mat3x3f(input: ISerialInput): wgsl.m3x3f {\n    const skipOneAfter = () => {\n      const value = input.readFloat32();\n      input.readFloat32(); // skipping;\n      return value;\n    };\n\n    return mat3x3f(\n      input.readFloat32(),\n      input.readFloat32(),\n      skipOneAfter(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      skipOneAfter(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      skipOneAfter(),\n    );\n  },\n\n  mat4x4f(input: ISerialInput): wgsl.m4x4f {\n    return mat4x4f(\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n    );\n  },\n\n  struct(input: ISerialInput, schema: wgsl.WgslStruct) {\n    const alignment = alignmentOf(schema);\n    alignIO(input, alignment);\n    const result = {} as Record<string, unknown>;\n\n    for (const [key, property] of Object.entries(schema.propTypes)) {\n      alignIO(input, alignmentOf(property));\n      result[key] = readData(input, property);\n    }\n\n    alignIO(input, alignment);\n    return result as InferRecord<Record<string, wgsl.BaseData>>;\n  },\n\n  array(input, schema) {\n    if (schema.elementCount === 0) {\n      throw new Error('Cannot read using a runtime-sized schema.');\n    }\n\n    const alignment = alignmentOf(schema);\n    const elements: unknown[] = [];\n\n    for (let i = 0; i < schema.elementCount; i++) {\n      alignIO(input, alignment);\n      const elementType = schema.elementType as wgsl.AnyWgslData;\n      const value = readData(input, elementType);\n      elements.push(value);\n    }\n\n    alignIO(input, alignment);\n    return elements as never[];\n  },\n\n  ptr() {\n    throw new Error('Pointers are not host-shareable');\n  },\n\n  atomic(input, schema: wgsl.Atomic): number {\n    return readData(input, schema.inner);\n  },\n\n  decorated(input, schema: wgsl.Decorated) {\n    const alignment = customAlignmentOf(schema);\n    alignIO(input, alignment);\n\n    const beginning = input.currentByteOffset;\n    const value = readData(input, schema.inner);\n    input.seekTo(beginning + sizeOf(schema));\n    return value as never;\n  },\n\n  // Loose Types\n\n  uint8: (i) => i.readUint8(),\n  uint8x2: (i) => vec2u(i.readUint8(), i.readUint8()),\n  uint8x4: (i) =>\n    vec4u(i.readUint8(), i.readUint8(), i.readUint8(), i.readUint8()),\n  sint8: (i) => i.readInt8(),\n  sint8x2: (i) => {\n    return vec2i(i.readInt8(), i.readInt8());\n  },\n  sint8x4: (i) => vec4i(i.readInt8(), i.readInt8(), i.readInt8(), i.readInt8()),\n  unorm8: (i) => i.readUint8() / 255,\n  unorm8x2: (i) => vec2f(i.readUint8() / 255, i.readUint8() / 255),\n  unorm8x4: (i) =>\n    vec4f(\n      i.readUint8() / 255,\n      i.readUint8() / 255,\n      i.readUint8() / 255,\n      i.readUint8() / 255,\n    ),\n  snorm8: (i) => (i.readUint8() - 128) / 127,\n  snorm8x2: (i) =>\n    vec2f((i.readUint8() - 128) / 127, (i.readUint8() - 128) / 127),\n  snorm8x4: (i) =>\n    vec4f(\n      (i.readUint8() - 128) / 127,\n      (i.readUint8() - 128) / 127,\n      (i.readUint8() - 128) / 127,\n      (i.readUint8() - 128) / 127,\n    ),\n  uint16: (i) => i.readUint16(),\n  uint16x2: (i) => vec2u(i.readUint16(), i.readUint16()),\n  uint16x4: (i) =>\n    vec4u(i.readUint16(), i.readUint16(), i.readUint16(), i.readUint16()),\n  sint16: (i) => i.readInt16(),\n  sint16x2: (i) => vec2i(i.readInt16(), i.readInt16()),\n  sint16x4: (i) =>\n    vec4i(i.readInt16(), i.readInt16(), i.readInt16(), i.readInt16()),\n  unorm16: (i) => i.readUint16() / 65535,\n  unorm16x2: (i) => vec2f(i.readUint16() / 65535, i.readUint16() / 65535),\n  unorm16x4: (i) =>\n    vec4f(\n      i.readUint16() / 65535,\n      i.readUint16() / 65535,\n      i.readUint16() / 65535,\n      i.readUint16() / 65535,\n    ),\n  snorm16: (i) => (i.readUint16() - 32768) / 32767,\n  snorm16x2: (i): wgsl.v2f =>\n    vec2f(dataReaders.snorm16(i), dataReaders.snorm16(i)),\n  snorm16x4: (i): wgsl.v4f =>\n    vec4f(\n      dataReaders.snorm16(i),\n      dataReaders.snorm16(i),\n      dataReaders.snorm16(i),\n      dataReaders.snorm16(i),\n    ),\n  float16(i) {\n    return i.readFloat16();\n  },\n  float16x2: (i) => vec2f(i.readFloat16(), i.readFloat16()),\n  float16x4: (i) =>\n    vec4f(i.readFloat16(), i.readFloat16(), i.readFloat16(), i.readFloat16()),\n  float32: (i) => i.readFloat32(),\n  float32x2: (i) => vec2f(i.readFloat32(), i.readFloat32()),\n  float32x3: (i) => vec3f(i.readFloat32(), i.readFloat32(), i.readFloat32()),\n  float32x4: (i) =>\n    vec4f(i.readFloat32(), i.readFloat32(), i.readFloat32(), i.readFloat32()),\n  uint32: (i) => i.readUint32(),\n  uint32x2: (i) => vec2u(i.readUint32(), i.readUint32()),\n  uint32x3: (i) => vec3u(i.readUint32(), i.readUint32(), i.readUint32()),\n  uint32x4: (i) =>\n    vec4u(i.readUint32(), i.readUint32(), i.readUint32(), i.readUint32()),\n  sint32: (i) => i.readInt32(),\n  sint32x2: (i) => vec2i(i.readInt32(), i.readInt32()),\n  sint32x3: (i) => vec3i(i.readInt32(), i.readInt32(), i.readInt32()),\n  sint32x4: (i) =>\n    vec4i(i.readInt32(), i.readInt32(), i.readInt32(), i.readInt32()),\n  'unorm10-10-10-2'(i) {\n    const packed = i.readUint32();\n    const r = (packed >> 22) / 1023;\n    const g = ((packed >> 12) & 1023) / 1023;\n    const b = ((packed >> 2) & 1023) / 1023;\n    const a = (packed & 3) / 3;\n    return vec4f(r, g, b, a);\n  },\n  'unorm8x4-bgra'(i) {\n    const b = i.readByte() / 255;\n    const g = i.readByte() / 255;\n    const r = i.readByte() / 255;\n    const a = i.readByte() / 255;\n    return vec4f(r, g, b, a);\n  },\n\n  unstruct(input, schema: Unstruct) {\n    const result = {} as Record<string, unknown>;\n\n    for (const [key, property] of Object.entries(schema.propTypes)) {\n      result[key] = readData(input, property);\n    }\n\n    return result as InferRecord<Record<string, wgsl.BaseData>>;\n  },\n\n  disarray(input, schema: Disarray) {\n    const alignment = alignmentOf(schema);\n    const elements: unknown[] = [];\n\n    for (let i = 0; i < schema.elementCount; i++) {\n      alignIO(input, alignment);\n      elements.push(readData(input, schema.elementType));\n    }\n\n    alignIO(input, alignment);\n    return elements;\n  },\n\n  'loose-decorated'(input, schema: LooseDecorated) {\n    alignIO(input, customAlignmentOf(schema));\n\n    const beginning = input.currentByteOffset;\n    const value = readData(input, schema.inner);\n    input.seekTo(beginning + sizeOf(schema));\n    return value;\n  },\n} satisfies CompleteDataReaders;\n\nexport function readData<TData extends wgsl.BaseData>(\n  input: ISerialInput,\n  schema: TData,\n): Infer<TData> {\n  const reader = (dataReaders as Record<string, unknown>)[\n    schema.type\n  ] as DataReader<TData>;\n  if (!reader) {\n    throw new Error(`Cannot read data of type '${schema.type}'.`);\n  }\n\n  return reader(input, schema);\n}\n", "import { BufferWriter } from 'typed-binary';\nimport { roundUp } from '../mathUtils.ts';\nimport type { Infer, InferPartial } from '../shared/repr.ts';\nimport { alignmentOf } from './alignmentOf.ts';\nimport { writeData } from './dataIO.ts';\nimport { isDisarray, isUnstruct } from './dataTypes.ts';\nimport { offsetsForProps } from './offsets.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport type * as wgsl from './wgslTypes.ts';\nimport { isWgslArray, isWgslStruct } from './wgslTypes.ts';\n\nexport interface WriteInstruction {\n  data: Uint8Array;\n}\n\nexport function getWriteInstructions<TData extends wgsl.BaseData>(\n  schema: TData,\n  data: InferPartial<TData>,\n): WriteInstruction[] {\n  const totalSize = sizeOf(schema);\n  if (totalSize === 0 || data === undefined || data === null) {\n    return [];\n  }\n\n  const bigBuffer = new ArrayBuffer(totalSize);\n  const writer = new BufferWriter(bigBuffer);\n\n  const segments: Array<{\n    start: number;\n    end: number;\n    padding?: number | undefined;\n  }> = [];\n\n  function gatherAndWrite<T extends wgsl.BaseData>(\n    node: T,\n    partialValue: InferPartial<T> | undefined,\n    offset: number,\n    padding?: number | undefined,\n  ) {\n    if (partialValue === undefined || partialValue === null) {\n      return;\n    }\n\n    if (isWgslStruct(node) || isUnstruct(node)) {\n      const propOffsets = offsetsForProps(node);\n\n      for (const [key, propOffset] of Object.entries(propOffsets)) {\n        const subSchema = node.propTypes[key];\n        if (!subSchema) {\n          continue;\n        }\n\n        const childValue = partialValue[key as keyof typeof partialValue];\n        if (childValue !== undefined) {\n          gatherAndWrite(\n            subSchema,\n            childValue,\n            offset + propOffset.offset,\n            propOffset.padding ?? padding,\n          );\n        }\n      }\n      return;\n    }\n\n    if (isWgslArray(node) || isDisarray(node)) {\n      const arrSchema = node as wgsl.WgslArray;\n      const elementSize = roundUp(\n        sizeOf(arrSchema.elementType),\n        alignmentOf(arrSchema.elementType),\n      );\n\n      if (!Array.isArray(partialValue)) {\n        throw new Error('Partial value for array must be an array');\n      }\n      const arrayPartialValue =\n        (partialValue as InferPartial<wgsl.WgslArray>) ?? [];\n\n      arrayPartialValue.sort((a, b) => a.idx - b.idx);\n\n      for (const { idx, value } of arrayPartialValue) {\n        gatherAndWrite(\n          arrSchema.elementType,\n          value,\n          offset + idx * elementSize,\n          elementSize - sizeOf(arrSchema.elementType),\n        );\n      }\n    } else {\n      const leafSize = sizeOf(node);\n      writer.seekTo(offset);\n      writeData(writer, node, partialValue as Infer<T>);\n\n      segments.push({ start: offset, end: offset + leafSize, padding });\n    }\n  }\n\n  gatherAndWrite(schema, data, 0);\n\n  if (segments.length === 0) {\n    return [];\n  }\n\n  const instructions: WriteInstruction[] = [];\n  let current = segments[0];\n\n  for (let i = 1; i < segments.length; i++) {\n    const next = segments[i];\n    if (!next || !current) {\n      throw new Error('Internal error: missing segment');\n    }\n    if (next.start === current.end + (current.padding ?? 0)) {\n      current.end = next.end;\n      current.padding = next.padding;\n    } else {\n      instructions.push({\n        data: new Uint8Array(\n          bigBuffer,\n          current.start,\n          current.end - current.start,\n        ),\n      });\n      current = next;\n    }\n  }\n\n  if (!current) {\n    throw new Error('Internal error: missing segment');\n  }\n\n  instructions.push({\n    data: new Uint8Array(bigBuffer, current.start, current.end - current.start),\n  });\n\n  return instructions;\n}\n", "import { getName } from './shared/meta.ts';\n\nexport interface NotAllowed<TMsg> {\n  reason: TMsg;\n}\n\nexport type ExtensionGuard<TFlag, TMsg, TAllowed> = boolean extends TFlag\n  ? NotAllowed<TMsg> | TAllowed\n  : TAllowed;\n\n// #region Shared usage extensions\n\nexport interface StorageFlag {\n  usableAsStorage: true;\n}\n\n/**\n * @deprecated Use StorageFlag instead.\n */\nexport type Storage = StorageFlag;\n\nexport function isUsableAsStorage<T>(value: T): value is T & StorageFlag {\n  return !!(value as unknown as StorageFlag)?.usableAsStorage;\n}\n\n/**\n * @category Errors\n */\nexport class NotStorageError extends Error {\n  constructor(value: object) {\n    super(\n      `Resource '${\n        getName(value) ?? '<unnamed>'\n      }' cannot be bound as 'storage'. Use .$usage('storage') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotStorageError.prototype);\n  }\n}\n\n// #endregion\n", "import type { AnyData } from '../../data/dataTypes.ts';\nimport type { AnyWgslData, BaseData } from '../../data/wgslTypes.ts';\nimport { isUsableAsStorage, type StorageFlag } from '../../extension.ts';\nimport { inGPUMode } from '../../gpuMode.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $gpuValueOf,\n  $internal,\n  $repr,\n  $wgslDataType,\n} from '../../shared/symbols.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type {\n  BindableBufferUsage,\n  ResolutionCtx,\n  SelfResolvable,\n} from '../../types.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\nimport type { TgpuBuffer, UniformFlag } from './buffer.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuBufferUsage<\n  TData extends BaseData = BaseData,\n  TUsage extends BindableBufferUsage = BindableBufferUsage,\n> {\n  readonly resourceType: 'buffer-usage';\n  readonly usage: TUsage;\n  readonly [$repr]: Infer<TData>;\n  value: InferGPU<TData>;\n  $: InferGPU<TData>;\n\n  readonly [$internal]: {\n    readonly dataType: TData;\n  };\n}\n\nexport interface TgpuBufferUniform<TData extends BaseData>\n  extends TgpuBufferUsage<TData, 'uniform'> {\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n}\n\nexport interface TgpuBufferReadonly<TData extends BaseData>\n  extends TgpuBufferUsage<TData, 'readonly'> {\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n}\n\nexport interface TgpuFixedBufferUsage<TData extends BaseData>\n  extends TgpuNamable {\n  readonly buffer: TgpuBuffer<TData>;\n}\n\nexport interface TgpuBufferMutable<TData extends BaseData>\n  extends TgpuBufferUsage<TData, 'mutable'> {}\n\nexport function isUsableAsUniform<T extends TgpuBuffer<AnyData>>(\n  buffer: T,\n): buffer is T & UniformFlag {\n  return !!(buffer as unknown as UniformFlag).usableAsUniform;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst usageToVarTemplateMap: Record<BindableBufferUsage, string> = {\n  uniform: 'uniform',\n  mutable: 'storage, read_write',\n  readonly: 'storage, read',\n};\n\nclass TgpuFixedBufferImpl<\n  TData extends AnyWgslData,\n  TUsage extends BindableBufferUsage,\n> implements\n  TgpuBufferUsage<TData, TUsage>,\n  SelfResolvable,\n  TgpuFixedBufferUsage<TData> {\n  /** Type-token, not available at runtime */\n  declare public readonly [$repr]: Infer<TData>;\n  public readonly resourceType = 'buffer-usage' as const;\n  public readonly [$internal]: { readonly dataType: TData };\n  public readonly [$getNameForward]: TgpuBuffer<TData>;\n\n  constructor(\n    public readonly usage: TUsage,\n    public readonly buffer: TgpuBuffer<TData>,\n  ) {\n    this[$internal] = { dataType: buffer.dataType };\n    this[$getNameForward] = buffer;\n  }\n\n  $name(label: string) {\n    this.buffer.$name(label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const { group, binding } = ctx.allocateFixedEntry(\n      this.usage === 'uniform'\n        ? { uniform: this.buffer.dataType }\n        : { storage: this.buffer.dataType, access: this.usage },\n      this.buffer,\n    );\n    const usage = usageToVarTemplateMap[this.usage];\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var<${usage}> ${id}: ${\n        ctx.resolve(\n          this.buffer.dataType,\n        )\n      };`,\n    );\n\n    return id;\n  }\n\n  toString(): string {\n    return `${this.usage}:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): InferGPU<TData> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this.buffer.dataType,\n      },\n      valueProxyHandler,\n    ) as InferGPU<TData>;\n  }\n\n  get value(): InferGPU<TData> {\n    if (!inGPUMode()) {\n      throw new Error(`Cannot access buffer's value directly in JS.`);\n    }\n\n    return this[$gpuValueOf]();\n  }\n\n  get $(): InferGPU<TData> {\n    return this.value;\n  }\n}\n\nexport class TgpuLaidOutBufferImpl<\n  TData extends BaseData,\n  TUsage extends BindableBufferUsage,\n> implements TgpuBufferUsage<TData, TUsage>, SelfResolvable {\n  /** Type-token, not available at runtime */\n  declare public readonly [$repr]: Infer<TData>;\n  public readonly resourceType = 'buffer-usage' as const;\n  public readonly [$internal]: { readonly dataType: TData };\n\n  constructor(\n    public readonly usage: TUsage,\n    public readonly dataType: TData,\n    private readonly _membership: LayoutMembership,\n  ) {\n    this[$internal] = { dataType };\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n    const usage = usageToVarTemplateMap[this.usage];\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var<${usage}> ${id}: ${\n        ctx.resolve(this.dataType as AnyWgslData)\n      };`,\n    );\n\n    return id;\n  }\n\n  toString(): string {\n    return `${this.usage}:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): InferGPU<TData> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this.dataType,\n      },\n      valueProxyHandler,\n    ) as InferGPU<TData>;\n  }\n\n  get value(): InferGPU<TData> {\n    if (!inGPUMode()) {\n      throw new Error(`Cannot access buffer's value directly in JS.`);\n    }\n\n    return this[$gpuValueOf]();\n  }\n\n  get $(): InferGPU<TData> {\n    return this.value;\n  }\n}\n\nconst mutableUsageMap = new WeakMap<\n  TgpuBuffer<AnyWgslData>,\n  TgpuFixedBufferImpl<AnyWgslData, 'mutable'>\n>();\n\n/**\n * @deprecated Use buffer.as('mutable') instead.\n */\nexport function asMutable<TData extends AnyWgslData>(\n  buffer: TgpuBuffer<TData> & StorageFlag,\n): TgpuBufferMutable<TData> & TgpuFixedBufferUsage<TData> {\n  if (!isUsableAsStorage(buffer)) {\n    throw new Error(\n      `Cannot pass ${buffer} to asMutable, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`,\n    );\n  }\n\n  let usage = mutableUsageMap.get(buffer);\n  if (!usage) {\n    usage = new TgpuFixedBufferImpl('mutable', buffer);\n    mutableUsageMap.set(buffer, usage);\n  }\n  return usage as unknown as\n    & TgpuBufferMutable<TData>\n    & TgpuFixedBufferUsage<TData>;\n}\n\nconst readonlyUsageMap = new WeakMap<\n  TgpuBuffer<AnyWgslData>,\n  TgpuFixedBufferImpl<AnyWgslData, 'readonly'>\n>();\n\n/**\n * @deprecated Use buffer.as('readonly') instead.\n */\nexport function asReadonly<TData extends AnyWgslData>(\n  buffer: TgpuBuffer<TData> & StorageFlag,\n): TgpuBufferReadonly<TData> & TgpuFixedBufferUsage<TData> {\n  if (!isUsableAsStorage(buffer)) {\n    throw new Error(\n      `Cannot pass ${buffer} to asReadonly, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`,\n    );\n  }\n\n  let usage = readonlyUsageMap.get(buffer);\n  if (!usage) {\n    usage = new TgpuFixedBufferImpl('readonly', buffer);\n    readonlyUsageMap.set(buffer, usage);\n  }\n  return usage as unknown as\n    & TgpuBufferReadonly<TData>\n    & TgpuFixedBufferUsage<TData>;\n}\n\nconst uniformUsageMap = new WeakMap<\n  TgpuBuffer<AnyWgslData>,\n  TgpuFixedBufferImpl<AnyWgslData, 'uniform'>\n>();\n\n/**\n * @deprecated Use buffer.as('uniform') instead.\n */\nexport function asUniform<TData extends AnyWgslData>(\n  buffer: TgpuBuffer<TData> & UniformFlag,\n): TgpuBufferUniform<TData> & TgpuFixedBufferUsage<TData> {\n  if (!isUsableAsUniform(buffer)) {\n    throw new Error(\n      `Cannot pass ${buffer} to asUniform, as it is not allowed to be used as a uniform. To allow it, call .$usage('uniform') when creating the buffer.`,\n    );\n  }\n\n  let usage = uniformUsageMap.get(buffer);\n  if (!usage) {\n    usage = new TgpuFixedBufferImpl('uniform', buffer);\n    uniformUsageMap.set(buffer, usage);\n  }\n  return usage as unknown as\n    & TgpuBufferUniform<TData>\n    & TgpuFixedBufferUsage<TData>;\n}\n", "import type { AnyData } from '../../data/dataTypes.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport { $internal, $wgslDataType } from '../../shared/symbols.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { Unwrapper } from '../../unwrapper.ts';\n\ninterface SamplerInternals {\n  readonly unwrap?: ((branch: Unwrapper) => GPUSampler) | undefined;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport interface SamplerProps {\n  addressModeU?: GPUAddressMode;\n  addressModeV?: GPUAddressMode;\n  /**\n   * Specifies the address modes for the texture width, height, and depth\n   * coordinates, respectively.\n   */\n  addressModeW?: GPUAddressMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is smaller than or equal to one\n   * texel.\n   */\n  magFilter?: GPUFilterMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is larger than one texel.\n   */\n  minFilter?: GPUFilterMode;\n  /**\n   * Specifies behavior for sampling between mipmap levels.\n   */\n  mipmapFilter?: GPUMipmapFilterMode;\n  lodMinClamp?: number;\n  /**\n   * Specifies the minimum and maximum levels of detail, respectively, used internally when\n   * sampling a texture.\n   */\n  lodMaxClamp?: number;\n  /**\n   * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is\n   * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.\n   * Anisotropic filtering improves the image quality of textures sampled at oblique viewing\n   * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of\n   * anisotropy supported when filtering.\n   *\n   * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range\n   * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}\n   * will be clamped to the maximum value that the platform supports.\n   * The precise filtering behavior is implementation-dependent.\n   */\n  maxAnisotropy?: number;\n}\n\nexport interface ComparisonSamplerProps {\n  compare: GPUCompareFunction;\n  addressModeU?: GPUAddressMode;\n  addressModeV?: GPUAddressMode;\n  /**\n   * Specifies the address modes for the texture width, height, and depth\n   * coordinates, respectively.\n   */\n  addressModeW?: GPUAddressMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is smaller than or equal to one\n   * texel.\n   */\n  magFilter?: GPUFilterMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is larger than one texel.\n   */\n  minFilter?: GPUFilterMode;\n  /**\n   * Specifies behavior for sampling between mipmap levels.\n   */\n  mipmapFilter?: GPUMipmapFilterMode;\n  lodMinClamp?: number;\n  /**\n   * Specifies the minimum and maximum levels of detail, respectively, used internally when\n   * sampling a texture.\n   */\n  lodMaxClamp?: number;\n  /**\n   * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is\n   * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.\n   * Anisotropic filtering improves the image quality of textures sampled at oblique viewing\n   * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of\n   * anisotropy supported when filtering.\n   *\n   * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range\n   * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}\n   * will be clamped to the maximum value that the platform supports.\n   * The precise filtering behavior is implementation-dependent.\n   */\n  maxAnisotropy?: number;\n}\n\nexport interface TgpuSampler {\n  readonly [$internal]: SamplerInternals;\n  readonly resourceType: 'sampler';\n}\n\nexport interface TgpuComparisonSampler {\n  readonly [$internal]: SamplerInternals;\n  readonly resourceType: 'sampler-comparison';\n}\n\nexport interface TgpuFixedSampler extends TgpuSampler, TgpuNamable {}\n\nexport interface TgpuFixedComparisonSampler\n  extends TgpuComparisonSampler, TgpuNamable {}\n\nexport function sampler(props: SamplerProps): TgpuFixedSampler {\n  return new TgpuFixedSamplerImpl(props);\n}\n\nexport function comparisonSampler(\n  props: ComparisonSamplerProps,\n): TgpuFixedComparisonSampler {\n  return new TgpuFixedComparisonSamplerImpl(props);\n}\n\nexport function isSampler(resource: unknown): resource is TgpuSampler {\n  const maybe = resource as TgpuSampler | undefined;\n  return maybe?.resourceType === 'sampler' && !!maybe[$internal];\n}\n\nexport function isComparisonSampler(\n  resource: unknown,\n): resource is TgpuComparisonSampler {\n  const maybe = resource as TgpuComparisonSampler | undefined;\n  return maybe?.resourceType === 'sampler-comparison' && !!maybe[$internal];\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuLaidOutSamplerImpl implements TgpuSampler, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: SamplerInternals;\n  public readonly resourceType = 'sampler';\n\n  constructor(private readonly _membership: LayoutMembership) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper sampler schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have sampler schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {};\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: sampler;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nexport class TgpuLaidOutComparisonSamplerImpl\n  implements TgpuComparisonSampler, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: SamplerInternals;\n  public readonly resourceType = 'sampler-comparison';\n\n  constructor(private readonly _membership: LayoutMembership) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper sampler schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have sampler schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {};\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: sampler_comparison;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nclass TgpuFixedSamplerImpl implements TgpuFixedSampler, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: SamplerInternals;\n  public readonly resourceType = 'sampler';\n\n  private _filtering: boolean;\n  private _sampler: GPUSampler | null = null;\n\n  constructor(private readonly _props: SamplerProps) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper sampler schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have sampler schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {\n      unwrap: (branch) => {\n        if (!this._sampler) {\n          this._sampler = branch.device.createSampler({\n            ...this._props,\n            label: getName(this) ?? '<unnamed>',\n          });\n        }\n\n        return this._sampler;\n      },\n    };\n\n    // Based on https://www.w3.org/TR/webgpu/#sampler-creation\n    this._filtering = _props.minFilter === 'linear' ||\n      _props.magFilter === 'linear' ||\n      _props.mipmapFilter === 'linear';\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n\n    const { group, binding } = ctx.allocateFixedEntry(\n      {\n        sampler: this._filtering ? 'filtering' : 'non-filtering',\n      },\n      this,\n    );\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: sampler;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nclass TgpuFixedComparisonSamplerImpl\n  implements TgpuFixedComparisonSampler, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: SamplerInternals;\n  public readonly resourceType = 'sampler-comparison';\n\n  private _sampler: GPUSampler | null = null;\n\n  constructor(private readonly _props: ComparisonSamplerProps) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper sampler schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have sampler schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {\n      unwrap: (branch) => {\n        if (!this._sampler) {\n          this._sampler = branch.device.createSampler({\n            ...this._props,\n            label: getName(this) ?? '<unnamed>',\n          });\n        }\n\n        return this._sampler;\n      },\n    };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const { group, binding } = ctx.allocateFixedEntry(\n      { sampler: 'comparison' },\n      this,\n    );\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: sampler_comparison;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n", "import { getName, setName } from '../../shared/meta.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuExternalTexture {\n  readonly resourceType: 'external-texture';\n}\n\nexport function isExternalTexture<T extends TgpuExternalTexture>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.resourceType === 'external-texture';\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuExternalTextureImpl\n  implements TgpuExternalTexture, SelfResolvable {\n  public readonly resourceType = 'external-texture';\n\n  constructor(private readonly _membership: LayoutMembership) {\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: texture_external;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n", "import { f32, i32, u32 } from '../../data/numeric.ts';\nimport { vec4f, vec4i, vec4u } from '../../data/vector.ts';\nimport type {\n  F32,\n  I32,\n  U32,\n  Vec4f,\n  Vec4i,\n  Vec4u,\n} from '../../data/wgslTypes.ts';\nimport type { Default } from '../../shared/utilityTypes.ts';\nimport type { TextureProps } from './textureProps.ts';\n\nexport const texelFormatToChannelType = {\n  r8unorm: f32,\n  r8snorm: f32,\n  r8uint: u32,\n  r8sint: i32,\n  r16uint: u32,\n  r16sint: i32,\n  r16float: f32,\n  rg8unorm: f32,\n  rg8snorm: f32,\n  rg8uint: u32,\n  rg8sint: i32,\n  r32uint: u32,\n  r32sint: i32,\n  r32float: f32,\n  rg16uint: u32,\n  rg16sint: i32,\n  rg16float: f32,\n  rgba8unorm: f32,\n  'rgba8unorm-srgb': f32,\n  rgba8snorm: f32,\n  rgba8uint: u32,\n  rgba8sint: i32,\n  bgra8unorm: f32,\n  'bgra8unorm-srgb': f32,\n  rgb9e5ufloat: f32,\n  rgb10a2uint: u32,\n  rgb10a2unorm: f32,\n  rg11b10ufloat: f32,\n  rg32uint: u32,\n  rg32sint: i32,\n  rg32float: f32,\n  rgba16uint: u32,\n  rgba16sint: i32,\n  rgba16float: f32,\n  rgba32uint: u32,\n  rgba32sint: i32,\n  rgba32float: f32,\n  stencil8: f32, // NOTE: Honestly have no idea if this is right\n  depth16unorm: f32,\n  depth24plus: f32, // NOTE: Honestly have no idea if this is right\n  'depth24plus-stencil8': f32, // NOTE: Honestly have no idea if this is right\n  depth32float: f32,\n  'depth32float-stencil8': f32,\n  'bc1-rgba-unorm': f32,\n  'bc1-rgba-unorm-srgb': f32,\n  'bc2-rgba-unorm': f32,\n  'bc2-rgba-unorm-srgb': f32,\n  'bc3-rgba-unorm': f32,\n  'bc3-rgba-unorm-srgb': f32,\n  'bc4-r-unorm': f32,\n  'bc4-r-snorm': f32,\n  'bc5-rg-unorm': f32,\n  'bc5-rg-snorm': f32,\n  'bc6h-rgb-ufloat': f32,\n  'bc6h-rgb-float': f32,\n  'bc7-rgba-unorm': f32,\n  'bc7-rgba-unorm-srgb': f32,\n  'etc2-rgb8unorm': f32,\n  'etc2-rgb8unorm-srgb': f32,\n  'etc2-rgb8a1unorm': f32,\n  'etc2-rgb8a1unorm-srgb': f32,\n  'etc2-rgba8unorm': f32,\n  'etc2-rgba8unorm-srgb': f32,\n  'eac-r11unorm': f32,\n  'eac-r11snorm': f32,\n  'eac-rg11unorm': f32,\n  'eac-rg11snorm': f32,\n  'astc-4x4-unorm': f32,\n  'astc-4x4-unorm-srgb': f32,\n  'astc-5x4-unorm': f32,\n  'astc-5x4-unorm-srgb': f32,\n  'astc-5x5-unorm': f32,\n  'astc-5x5-unorm-srgb': f32,\n  'astc-6x5-unorm': f32,\n  'astc-6x5-unorm-srgb': f32,\n  'astc-6x6-unorm': f32,\n  'astc-6x6-unorm-srgb': f32,\n  'astc-8x5-unorm': f32,\n  'astc-8x5-unorm-srgb': f32,\n  'astc-8x6-unorm': f32,\n  'astc-8x6-unorm-srgb': f32,\n  'astc-8x8-unorm': f32,\n  'astc-8x8-unorm-srgb': f32,\n  'astc-10x5-unorm': f32,\n  'astc-10x5-unorm-srgb': f32,\n  'astc-10x6-unorm': f32,\n  'astc-10x6-unorm-srgb': f32,\n  'astc-10x8-unorm': f32,\n  'astc-10x8-unorm-srgb': f32,\n  'astc-10x10-unorm': f32,\n  'astc-10x10-unorm-srgb': f32,\n  'astc-12x10-unorm': f32,\n  'astc-12x10-unorm-srgb': f32,\n  'astc-12x12-unorm': f32,\n  'astc-12x12-unorm-srgb': f32,\n  'r16snorm': f32,\n  'r16unorm': f32,\n  'rg16unorm': f32,\n  'rg16snorm': f32,\n  'rgba16unorm': f32,\n  'rgba16snorm': f32,\n} satisfies Record<GPUTextureFormat, U32 | I32 | F32>;\n\nexport type TexelFormatToChannelType = typeof texelFormatToChannelType;\n\ntype TexelFormatToStringChannels = {\n  [Key in keyof TexelFormatToChannelType]:\n    TexelFormatToChannelType[Key]['type'];\n};\ntype KeysWithValue<T extends Record<string, unknown>, TValue> = keyof {\n  [Key in keyof T as T[Key] extends TValue ? Key : never]: Key;\n};\nexport type ChannelTypeToLegalFormats = {\n  [Key in TexelFormatToChannelType[keyof TexelFormatToChannelType]['type']]:\n    KeysWithValue<\n      TexelFormatToStringChannels,\n      Key\n    >;\n};\n\nexport type SampleTypeToStringChannelType = {\n  float: 'f32';\n  'unfilterable-float': 'f32';\n  depth: 'f32';\n  sint: 'i32';\n  uint: 'u32';\n};\n\nexport type ViewDimensionToDimension = {\n  '1d': '1d';\n  '2d': '2d';\n  '2d-array': '2d';\n  '3d': '3d';\n  cube: '2d';\n  'cube-array': '2d';\n};\n\n/**\n * https://www.w3.org/TR/WGSL/#storage-texel-formats\n */\nexport type StorageTextureTexelFormat =\n  | 'rgba8unorm'\n  | 'rgba8snorm'\n  | 'rgba8uint'\n  | 'rgba8sint'\n  | 'rgba16uint'\n  | 'rgba16sint'\n  | 'rgba16float'\n  | 'r32uint'\n  | 'r32sint'\n  | 'r32float'\n  | 'rg32uint'\n  | 'rg32sint'\n  | 'rg32float'\n  | 'rgba32uint'\n  | 'rgba32sint'\n  | 'rgba32float'\n  | 'bgra8unorm';\n\nexport const texelFormatToDataType = {\n  rgba8unorm: vec4f as Vec4f,\n  rgba8snorm: vec4f as Vec4f,\n  rgba8uint: vec4u as Vec4u,\n  rgba8sint: vec4i as Vec4i,\n  rgba16uint: vec4u as Vec4u,\n  rgba16sint: vec4i as Vec4i,\n  rgba16float: vec4f as Vec4f,\n  r32uint: vec4u as Vec4u,\n  r32sint: vec4i as Vec4i,\n  r32float: vec4f as Vec4f,\n  rg32uint: vec4u as Vec4u,\n  rg32sint: vec4i as Vec4i,\n  rg32float: vec4f as Vec4f,\n  rgba32uint: vec4u as Vec4u,\n  rgba32sint: vec4i as Vec4i,\n  rgba32float: vec4f as Vec4f,\n  bgra8unorm: vec4f as Vec4f,\n} as const;\n\nexport const channelKindToFormat = {\n  f32: 'float',\n  u32: 'uint',\n  i32: 'sint',\n} as const;\n\nexport const channelFormatToSchema = {\n  float: f32,\n  'unfilterable-float': f32,\n  uint: u32,\n  sint: i32,\n  depth: f32, // I guess?\n};\nexport type ChannelFormatToSchema = typeof channelFormatToSchema;\n\nexport type TexelFormatToDataType = typeof texelFormatToDataType;\nexport type TexelFormatToDataTypeOrNever<T> = T extends\n  keyof TexelFormatToDataType ? TexelFormatToDataType[T] : never;\n\n/**\n * Represents what formats a storage view can choose from based on its owner texture's props.\n */\nexport type StorageFormatOptions<TProps extends TextureProps> = Extract<\n  TProps['format'] | Default<TProps['viewFormats'], []>[number],\n  StorageTextureTexelFormat\n>;\n\n/**\n * Represents what formats a sampled view can choose from based on its owner texture's props.\n */\nexport type SampledFormatOptions<TProps extends TextureProps> =\n  | TProps['format']\n  | Default<TProps['viewFormats'], []>[number];\n", "import type { AnyData } from '../../data/dataTypes.ts';\nimport type {\n  F32,\n  I32,\n  U32,\n  Vec4f,\n  Vec4i,\n  Vec4u,\n} from '../../data/wgslTypes.ts';\nimport { invariant } from '../../errors.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport {\n  $getNameForward,\n  $internal,\n  $wgslDataType,\n} from '../../shared/symbols.ts';\nimport type {\n  Default,\n  UnionToIntersection,\n} from '../../shared/utilityTypes.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport {\n  channelFormatToSchema,\n  channelKindToFormat,\n  type SampledFormatOptions,\n  type StorageFormatOptions,\n  type StorageTextureTexelFormat,\n  type TexelFormatToChannelType,\n  texelFormatToChannelType,\n  type TexelFormatToDataType,\n  texelFormatToDataType,\n  type TexelFormatToDataTypeOrNever,\n} from './textureFormats.ts';\nimport type { TextureProps } from './textureProps.ts';\nimport type { AllowedUsages, LiteralToExtensionMap } from './usageExtension.ts';\n\ntype ResolveStorageDimension<\n  TDimension extends GPUTextureViewDimension,\n  TProps extends TextureProps,\n> = StorageTextureDimension extends TDimension\n  ? Default<TProps['dimension'], '2d'>\n  : TDimension extends StorageTextureDimension ? TDimension\n  : '2d';\n\ntype ViewUsages<\n  TProps extends TextureProps,\n  TTexture extends TgpuTexture<TProps>,\n> = boolean extends TTexture['usableAsSampled']\n  ? boolean extends TTexture['usableAsStorage'] ? never\n  : 'readonly' | 'writeonly' | 'mutable'\n  : boolean extends TTexture['usableAsStorage'] ? 'sampled'\n  : 'readonly' | 'writeonly' | 'mutable' | 'sampled';\n\ninterface TextureInternals {\n  unwrap(): GPUTexture;\n}\n\ninterface TextureViewInternals {\n  readonly unwrap?: (() => GPUTextureView) | undefined;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport type ChannelData = U32 | I32 | F32;\nexport type TexelData = Vec4u | Vec4i | Vec4f;\n\n/**\n * @param TProps all properties that distinguish this texture apart from other textures on the type level.\n */\nexport interface TgpuTexture<TProps extends TextureProps = TextureProps>\n  extends TgpuNamable {\n  readonly [$internal]: TextureInternals;\n  readonly resourceType: 'texture';\n  readonly props: TProps; // <- storing to be able to differentiate structurally between different textures.\n\n  // Extensions\n  readonly usableAsStorage: boolean;\n  readonly usableAsSampled: boolean;\n  readonly usableAsRender: boolean;\n\n  $usage<T extends AllowedUsages<TProps>[]>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToExtensionMap[T[number]]>;\n\n  createView<\n    TUsage extends ViewUsages<TProps, this>,\n    TDimension extends 'sampled' extends TUsage ? GPUTextureViewDimension\n      : StorageTextureDimension,\n    TFormat extends 'sampled' extends TUsage ? SampledFormatOptions<TProps>\n      : StorageFormatOptions<TProps>,\n  >(\n    access: TUsage,\n    params?: TextureViewParams<TDimension, TFormat>,\n  ): {\n    mutable: TgpuMutableTexture<\n      ResolveStorageDimension<TDimension, TProps>,\n      TexelFormatToDataTypeOrNever<\n        StorageFormatOptions<TProps> extends TFormat ? TProps['format']\n          : TFormat\n      >\n    >;\n    readonly: TgpuReadonlyTexture<\n      ResolveStorageDimension<TDimension, TProps>,\n      TexelFormatToDataTypeOrNever<\n        StorageFormatOptions<TProps> extends TFormat ? TProps['format']\n          : TFormat\n      >\n    >;\n    writeonly: TgpuWriteonlyTexture<\n      ResolveStorageDimension<TDimension, TProps>,\n      TexelFormatToDataTypeOrNever<\n        StorageFormatOptions<TProps> extends TFormat ? TProps['format']\n          : TFormat\n      >\n    >;\n    sampled: TgpuSampledTexture<\n      GPUTextureViewDimension extends TDimension\n        ? Default<TProps['dimension'], '2d'>\n        : TDimension,\n      TexelFormatToChannelType[\n        SampledFormatOptions<TProps> extends TFormat ? TProps['format']\n          : TFormat\n      ]\n    >;\n  }[TUsage];\n\n  destroy(): void;\n}\n\nexport type StorageTextureAccess = 'readonly' | 'writeonly' | 'mutable';\n\n/**\n * Based on @see GPUTextureViewDimension\n * https://www.w3.org/TR/WGSL/#texture-depth\n */\nexport type StorageTextureDimension =\n  | '1d'\n  | '2d'\n  | '2d-array'\n  // | 'cube' <- not supported by storage textures\n  // | 'cube-array' <- not supported by storage textures\n  | '3d';\n\nexport type TextureViewParams<\n  TDimension extends GPUTextureViewDimension | undefined,\n  TFormat extends GPUTextureFormat | undefined,\n> = {\n  format?: TFormat;\n  dimension?: TDimension;\n  aspect?: GPUTextureAspect;\n  baseMipLevel?: number;\n  mipLevelCount?: number;\n  baseArrayLayout?: number;\n  arrayLayerCount?: number;\n};\n\nexport interface TgpuStorageTexture<\n  TDimension extends StorageTextureDimension = StorageTextureDimension,\n  TData extends TexelData = TexelData,\n> {\n  readonly [$internal]: TextureViewInternals;\n  readonly resourceType: 'texture-storage-view';\n  readonly dimension: TDimension;\n  readonly texelDataType: TData;\n  readonly access: StorageTextureAccess;\n}\n\n/**\n * A texture accessed as \"readonly\" storage on the GPU.\n */\nexport interface TgpuReadonlyTexture<\n  TDimension extends StorageTextureDimension = StorageTextureDimension,\n  TData extends TexelData = TexelData,\n> extends TgpuStorageTexture<TDimension, TData> {\n  readonly access: 'readonly';\n}\n\n/**\n * A texture accessed as \"writeonly\" storage on the GPU.\n */\nexport interface TgpuWriteonlyTexture<\n  TDimension extends StorageTextureDimension = StorageTextureDimension,\n  TData extends TexelData = TexelData,\n> extends TgpuStorageTexture<TDimension, TData> {\n  readonly access: 'writeonly';\n}\n\n/**\n * A texture accessed as \"mutable\" (or read_write) storage on the GPU.\n */\nexport interface TgpuMutableTexture<\n  TDimension extends StorageTextureDimension = StorageTextureDimension,\n  TData extends TexelData = TexelData,\n> extends TgpuStorageTexture<TDimension, TData> {\n  readonly access: 'mutable';\n}\n\n/**\n * A texture accessed as sampled on the GPU.\n */\nexport interface TgpuSampledTexture<\n  TDimension extends GPUTextureViewDimension = GPUTextureViewDimension,\n  TData extends ChannelData = ChannelData,\n> {\n  readonly [$internal]: TextureViewInternals;\n  readonly resourceType: 'texture-sampled-view';\n  readonly dimension: TDimension;\n  readonly channelDataType: TData;\n}\n\nexport function INTERNAL_createTexture(\n  props: TextureProps,\n  branch: ExperimentalTgpuRoot,\n): TgpuTexture<TextureProps> {\n  return new TgpuTextureImpl(props, branch);\n}\n\nexport function isTexture<T extends TgpuTexture>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.resourceType === 'texture' && !!(value as T)[$internal];\n}\n\nexport function isStorageTextureView<\n  T extends TgpuReadonlyTexture | TgpuWriteonlyTexture | TgpuMutableTexture,\n>(value: unknown | T): value is T {\n  return (\n    (value as T)?.resourceType === 'texture-storage-view' &&\n    !!(value as T)[$internal]\n  );\n}\n\nexport function isSampledTextureView<T extends TgpuSampledTexture>(\n  value: unknown | T,\n): value is T {\n  return (\n    (value as T)?.resourceType === 'texture-sampled-view' &&\n    !!(value as T)[$internal]\n  );\n}\n\nexport type TgpuAnyTextureView =\n  | TgpuReadonlyTexture\n  | TgpuWriteonlyTexture\n  | TgpuMutableTexture\n  | TgpuSampledTexture;\n\n// --------------\n// Implementation\n// --------------\n\nconst accessMap = {\n  mutable: 'read_write',\n  readonly: 'read',\n  writeonly: 'write',\n} as const;\n\nclass TgpuTextureImpl implements TgpuTexture {\n  public readonly [$internal]: TextureInternals;\n  public readonly resourceType = 'texture';\n  public usableAsSampled = false;\n  public usableAsStorage = false;\n  public usableAsRender = false;\n\n  private _destroyed = false;\n  private _flags = GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n  private _texture: GPUTexture | null = null;\n\n  constructor(\n    public readonly props: TextureProps,\n    private readonly _branch: ExperimentalTgpuRoot,\n  ) {\n    this[$internal] = {\n      unwrap: () => {\n        if (this._destroyed) {\n          throw new Error('This texture has been destroyed');\n        }\n\n        if (!this._texture) {\n          this._texture = this._branch.device.createTexture({\n            label: getName(this) ?? '<unnamed>',\n            format: this.props.format,\n            size: this.props.size,\n            usage: this._flags,\n            dimension: this.props.dimension ?? '2d',\n            viewFormats: this.props.viewFormats ?? [],\n            mipLevelCount: this.props.mipLevelCount ?? 1,\n            sampleCount: this.props.sampleCount ?? 1,\n          });\n        }\n\n        return this._texture;\n      },\n    };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  $usage<T extends ('sampled' | 'storage' | 'render')[]>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToExtensionMap[T[number]]> {\n    const hasStorage = usages.includes('storage');\n    const hasSampled = usages.includes('sampled');\n    const hasRender = usages.includes('render');\n    this._flags |= hasSampled ? GPUTextureUsage.TEXTURE_BINDING : 0;\n    this._flags |= hasStorage ? GPUTextureUsage.STORAGE_BINDING : 0;\n    this._flags |= hasRender ? GPUTextureUsage.RENDER_ATTACHMENT : 0;\n    this.usableAsStorage ||= hasStorage;\n    this.usableAsSampled ||= hasSampled;\n    this.usableAsRender ||= hasRender;\n\n    return this as this & UnionToIntersection<LiteralToExtensionMap[T[number]]>;\n  }\n\n  createView(\n    access: 'mutable' | 'readonly' | 'writeonly' | 'sampled',\n    params?: TextureViewParams<GPUTextureViewDimension, GPUTextureFormat>,\n  ) {\n    if (access === 'sampled') {\n      return this._asSampled(params);\n    }\n\n    const storageParams = params as TextureViewParams<\n      StorageTextureDimension,\n      StorageTextureTexelFormat\n    >;\n\n    switch (access) {\n      case 'mutable':\n        return this._asMutable(storageParams);\n      case 'readonly':\n        return this._asReadonly(storageParams);\n      case 'writeonly':\n        return this._asWriteonly(storageParams);\n    }\n  }\n\n  private _asStorage(\n    params:\n      | TextureViewParams<StorageTextureDimension, StorageTextureTexelFormat>\n      | undefined,\n    access: StorageTextureAccess,\n  ): TgpuFixedStorageTextureImpl {\n    if (!this.usableAsStorage) {\n      throw new Error('Unusable as storage');\n    }\n\n    const format = params?.format ?? this.props.format;\n    const type = texelFormatToDataType[format as keyof TexelFormatToDataType];\n    invariant(!!type, `Unsupported storage texture format: ${format}`);\n\n    return new TgpuFixedStorageTextureImpl(params ?? {}, access, this);\n  }\n\n  private _asReadonly(\n    params?: TextureViewParams<\n      StorageTextureDimension,\n      StorageTextureTexelFormat\n    >,\n  ) {\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n    return this._asStorage(params, 'readonly') as any;\n  }\n\n  private _asWriteonly(\n    params?: TextureViewParams<\n      StorageTextureDimension,\n      StorageTextureTexelFormat\n    >,\n  ) {\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n    return this._asStorage(params, 'writeonly') as any;\n  }\n\n  private _asMutable(\n    params?: TextureViewParams<\n      StorageTextureDimension,\n      StorageTextureTexelFormat\n    >,\n  ) {\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n    return this._asStorage(params, 'mutable') as any;\n  }\n\n  private _asSampled(\n    params?: TextureViewParams<GPUTextureViewDimension, GPUTextureFormat>,\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n  ): any {\n    if (!this.usableAsSampled) {\n      throw new Error('Unusable as sampled');\n    }\n\n    const format = params?.format ?? this.props.format;\n    const type = texelFormatToDataType[format as keyof TexelFormatToDataType];\n\n    if (!type) {\n      throw new Error(`Unsupported storage texture format: ${format}`);\n    }\n\n    return new TgpuFixedSampledTextureImpl(params, this);\n  }\n\n  destroy() {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    this._texture?.destroy();\n  }\n}\n\nconst dimensionToCodeMap = {\n  '1d': '1d',\n  '2d': '2d',\n  '2d-array': '2d_array',\n  cube: 'cube',\n  'cube-array': 'cube_array',\n  '3d': '3d',\n} satisfies Record<GPUTextureViewDimension, string>;\n\nclass TgpuFixedStorageTextureImpl\n  implements TgpuStorageTexture, SelfResolvable, TgpuNamable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: TextureViewInternals;\n  public readonly [$getNameForward]: TgpuTexture<TextureProps>;\n  public readonly resourceType = 'texture-storage-view';\n  public readonly texelDataType: TexelData;\n  public readonly dimension: StorageTextureDimension;\n\n  private _view: GPUTextureView | undefined;\n  private readonly _format: StorageTextureTexelFormat;\n\n  constructor(\n    props:\n      | TextureViewParams<StorageTextureDimension, StorageTextureTexelFormat>\n      | undefined,\n    public readonly access: StorageTextureAccess,\n    private readonly _texture: TgpuTexture,\n  ) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper texture schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have texture schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {\n      unwrap: () => {\n        if (!this._view) {\n          this._view = this._texture[$internal].unwrap().createView({\n            label: `${getName(this) ?? '<unnamed>'} - View`,\n            format: this._format,\n            dimension: this.dimension,\n          });\n        }\n\n        return this._view;\n      },\n    };\n    this[$getNameForward] = _texture;\n\n    this.dimension = props?.dimension ?? _texture.props.dimension ?? '2d';\n    this._format = props?.format ??\n      (_texture.props.format as StorageTextureTexelFormat);\n    this.texelDataType = texelFormatToDataType[this._format];\n  }\n\n  $name(label: string): this {\n    this._texture.$name(label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const { group, binding } = ctx.allocateFixedEntry(\n      {\n        storageTexture: this._format,\n        access: this.access,\n        viewDimension: this.dimension,\n      },\n      this,\n    );\n    const type = `texture_storage_${dimensionToCodeMap[this.dimension]}`;\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: ${type}<${this._format}, ${\n        accessMap[this.access]\n      }>;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nexport class TgpuLaidOutStorageTextureImpl\n  implements TgpuStorageTexture, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: TextureViewInternals;\n  public readonly resourceType = 'texture-storage-view';\n  public readonly texelDataType: TexelData;\n\n  constructor(\n    private readonly _format: StorageTextureTexelFormat,\n    public readonly dimension: StorageTextureDimension,\n    public readonly access: StorageTextureAccess,\n    private readonly _membership: LayoutMembership,\n  ) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper texture schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have texture schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {};\n    this.texelDataType = texelFormatToDataType[this._format];\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n    const type = `texture_storage_${dimensionToCodeMap[this.dimension]}`;\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: ${type}<${this._format}, ${\n        accessMap[this.access]\n      }>;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nclass TgpuFixedSampledTextureImpl\n  implements TgpuSampledTexture, SelfResolvable, TgpuNamable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: TextureViewInternals;\n  public readonly [$getNameForward]: TgpuTexture<TextureProps>;\n  public readonly resourceType = 'texture-sampled-view';\n  public readonly channelDataType: ChannelData;\n  public readonly dimension: GPUTextureViewDimension;\n\n  private _format: GPUTextureFormat;\n  private _view: GPUTextureView | undefined;\n\n  constructor(\n    private readonly _props:\n      | TextureViewParams<GPUTextureViewDimension, GPUTextureFormat>\n      | undefined,\n    private readonly _texture: TgpuTexture,\n  ) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper texture schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have texture schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {\n      unwrap: () => {\n        if (!this._view) {\n          this._view = this._texture[$internal].unwrap().createView({\n            label: `${getName(this) ?? '<unnamed>'} - View`,\n            ...this._props,\n          });\n        }\n\n        return this._view;\n      },\n    };\n    this[$getNameForward] = _texture;\n    this.dimension = _props?.dimension ?? _texture.props.dimension ?? '2d';\n    this._format = _props?.format ??\n      (_texture.props.format as GPUTextureFormat);\n    this.channelDataType = texelFormatToChannelType[this._format];\n  }\n\n  $name(label: string): this {\n    this._texture.$name(label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n\n    const multisampled = (this._texture.props.sampleCount ?? 1) > 1;\n    const { group, binding } = ctx.allocateFixedEntry(\n      {\n        texture: channelKindToFormat[this.channelDataType.type],\n        viewDimension: this.dimension,\n        multisampled,\n      },\n      this,\n    );\n\n    const type = multisampled\n      ? 'texture_multisampled_2d'\n      : `texture_${dimensionToCodeMap[this.dimension]}`;\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: ${type}<${\n        ctx.resolve(this.channelDataType)\n      }>;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nexport class TgpuLaidOutSampledTextureImpl\n  implements TgpuSampledTexture, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: TextureViewInternals;\n  public readonly resourceType = 'texture-sampled-view';\n  public readonly channelDataType: ChannelData;\n\n  constructor(\n    sampleType: GPUTextureSampleType,\n    public readonly dimension: GPUTextureViewDimension,\n    private readonly _multisampled: boolean,\n    private readonly _membership: LayoutMembership,\n  ) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper texture schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have texture schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {};\n    setName(this, _membership.key);\n    this.channelDataType = channelFormatToSchema[sampleType];\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n\n    const type = this._multisampled\n      ? 'texture_multisampled_2d'\n      : `texture_${dimensionToCodeMap[this.dimension]}`;\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: ${type}<${\n        ctx.resolve(this.channelDataType)\n      }>;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n", "import type { StorageFlag } from '../../extension.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { StorageTextureTexelFormat } from './textureFormats.ts';\nimport type { TextureProps } from './textureProps.ts';\n\nexport interface Sampled {\n  usableAsSampled: true;\n}\n\nexport interface Render {\n  usableAsRender: true;\n}\n\nexport type LiteralToExtensionMap = {\n  storage: StorageFlag; // <- shared between buffers and textures\n  sampled: Sampled;\n  render: Render;\n};\n\nexport type TextureExtensionLiteral = keyof LiteralToExtensionMap;\n\nexport type AllowedUsages<TProps extends TextureProps> =\n  | 'sampled'\n  | 'render'\n  | (TProps['format'] extends StorageTextureTexelFormat ? 'storage' : never);\n\nexport function isUsableAsSampled<T>(value: T): value is T & Sampled {\n  return !!(value as unknown as Sampled)?.usableAsSampled;\n}\n\nexport function isUsableAsRender<T>(value: T): value is T & Render {\n  return !!(value as unknown as Render)?.usableAsRender;\n}\n\n/**\n * @category Errors\n */\nexport class NotSampledError extends Error {\n  constructor(value: object) {\n    super(\n      `Resource '${\n        getName(value) ?? '<unnamed>'\n      }' cannot be bound as 'sampled'. Use .$usage('sampled') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotSampledError.prototype);\n  }\n}\n\n/**\n * @category Errors\n */\nexport class NotRenderError extends Error {\n  constructor(value: object) {\n    super(\n      `Resource '${\n        getName(value) ?? '<unnamed>'\n      }' cannot be bound as 'render'. Use .$usage('render') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotRenderError.prototype);\n  }\n}\n", "import {\n  isBuffer,\n  type TgpuBuffer,\n  type UniformFlag,\n} from './core/buffer/buffer.ts';\nimport {\n  isUsableAsUniform,\n  type TgpuBufferMutable,\n  type TgpuBufferReadonly,\n  type TgpuBufferUniform,\n  TgpuLaidOutBufferImpl,\n} from './core/buffer/bufferUsage.ts';\nimport {\n  isComparisonSampler,\n  isSampler,\n  type TgpuComparisonSampler,\n  TgpuLaidOutComparisonSamplerImpl,\n  TgpuLaidOutSamplerImpl,\n  type TgpuSampler,\n} from './core/sampler/sampler.ts';\nimport { TgpuExternalTextureImpl } from './core/texture/externalTexture.ts';\nimport {\n  isSampledTextureView,\n  isStorageTextureView,\n  isTexture,\n  type StorageTextureDimension,\n  TgpuLaidOutSampledTextureImpl,\n  TgpuLaidOutStorageTextureImpl,\n  type TgpuMutableTexture,\n  type TgpuReadonlyTexture,\n  type TgpuSampledTexture,\n  type TgpuTexture,\n  type TgpuWriteonlyTexture,\n} from './core/texture/texture.ts';\nimport type {\n  ChannelFormatToSchema,\n  ChannelTypeToLegalFormats,\n  SampleTypeToStringChannelType,\n  StorageTextureTexelFormat,\n  TexelFormatToDataType,\n  ViewDimensionToDimension,\n} from './core/texture/textureFormats.ts';\nimport type { TextureProps } from './core/texture/textureProps.ts';\nimport {\n  isUsableAsSampled,\n  NotSampledError,\n  type Sampled,\n} from './core/texture/usageExtension.ts';\nimport type { AnyData } from './data/dataTypes.ts';\nimport type { AnyWgslData, BaseData } from './data/wgslTypes.ts';\nimport { NotUniformError } from './errors.ts';\nimport {\n  isUsableAsStorage,\n  NotStorageError,\n  type StorageFlag,\n} from './extension.ts';\nimport type { TgpuNamable } from './shared/meta.ts';\nimport { getName, setName } from './shared/meta.ts';\nimport type { Infer, MemIdentity } from './shared/repr.ts';\nimport { $internal } from './shared/symbols.ts';\nimport type {\n  Default,\n  NullableToOptional,\n  Prettify,\n} from './shared/utilityTypes.ts';\nimport type { TgpuShaderStage } from './types.ts';\nimport type { Unwrapper } from './unwrapper.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface LayoutMembership {\n  layout: TgpuBindGroupLayout;\n  key: string;\n  idx: number;\n}\n\nexport type TgpuLayoutEntryBase = {\n  /**\n   * Limits this resource's visibility to specific shader stages.\n   *\n   * By default, each resource is visible to all shader stage types, but\n   * depending on the underlying implementation, this may have performance implications.\n   *\n   * @default ['compute'] for mutable resources\n   * @default ['compute','vertex','fragment'] for everything else\n   */\n  visibility?: TgpuShaderStage[];\n};\n\nexport type TgpuLayoutUniform = TgpuLayoutEntryBase & {\n  uniform: AnyWgslData;\n};\n\nexport type TgpuLayoutStorage = TgpuLayoutEntryBase & {\n  storage: AnyWgslData | ((arrayLength: number) => AnyWgslData);\n  /** @default 'readonly' */\n  access?: 'mutable' | 'readonly';\n};\n\nexport type TgpuLayoutSampler = TgpuLayoutEntryBase & {\n  sampler: 'filtering' | 'non-filtering';\n};\n\nexport type TgpuLayoutComparisonSampler = TgpuLayoutEntryBase & {\n  sampler: 'comparison';\n};\n\nexport type TgpuLayoutTexture<\n  TSampleType extends GPUTextureSampleType = GPUTextureSampleType,\n> = TgpuLayoutEntryBase & {\n  /**\n   * - 'float' - f32\n   * - 'unfilterable-float' - f32, cannot be used with filtering samplers\n   * - 'depth' - f32\n   * - 'sint' - i32\n   * - 'uint' - u32\n   */\n  texture: TSampleType;\n  /**\n   * @default '2d'\n   */\n  viewDimension?: GPUTextureViewDimension;\n  /**\n   * @default false\n   */\n  multisampled?: boolean;\n};\nexport type TgpuLayoutStorageTexture<\n  TFormat extends StorageTextureTexelFormat = StorageTextureTexelFormat,\n> = TgpuLayoutEntryBase & {\n  storageTexture: TFormat;\n  /** @default 'writeonly' */\n  access?: 'readonly' | 'writeonly' | 'mutable';\n  /** @default '2d' */\n  viewDimension?: StorageTextureDimension;\n};\nexport type TgpuLayoutExternalTexture = TgpuLayoutEntryBase & {\n  externalTexture: Record<string, never>;\n};\n\nexport type TgpuLayoutEntry =\n  | TgpuLayoutUniform\n  | TgpuLayoutStorage\n  | TgpuLayoutSampler\n  | TgpuLayoutComparisonSampler\n  | TgpuLayoutTexture\n  | TgpuLayoutStorageTexture\n  | TgpuLayoutExternalTexture;\n\ntype UnwrapRuntimeConstructorInner<\n  T extends BaseData | ((_: number) => BaseData),\n> = T extends (_: number) => BaseData ? ReturnType<T> : T;\n\nexport type UnwrapRuntimeConstructor<\n  T extends AnyData | ((_: number) => AnyData),\n> = T extends unknown ? UnwrapRuntimeConstructorInner<T> : never;\n\nexport interface TgpuBindGroupLayout<\n  Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n    string,\n    TgpuLayoutEntry | null\n  >,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'bind-group-layout';\n  readonly entries: Entries;\n  readonly bound: {\n    [K in keyof Entries]: BindLayoutEntry<Entries[K]>;\n  };\n  readonly value: {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n  readonly $: {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n\n  /**\n   * An explicit numeric index assigned to this bind group layout. If undefined, a unique\n   * index is assigned automatically during resolution. This can be changed with the\n   * `.$idx()` method.\n   */\n  readonly index: number | undefined;\n\n  /**\n   * Associates this bind group layout with an explicit numeric index. When a call to this\n   * method is omitted, a unique numeric index is assigned to it automatically.\n   *\n   * Used when generating WGSL code: `@group(${index}) @binding(...) ...;`\n   */\n  $idx(index?: number): this;\n\n  /**\n   * Creates a raw WebGPU resource based on the typed descriptor.\n   * NOTE: This creates a new resource every time, better to use `root.unwrap(...)` instead.\n   * @param unwrapper Used to unwrap any resources that this resource depends on.\n   */\n  unwrap(unwrapper: Unwrapper): GPUBindGroupLayout;\n}\n\ntype StorageUsageForEntry<T extends TgpuLayoutStorage> = T extends {\n  access?: infer Access;\n} // Is the access defined on the type?\n  ? 'mutable' | 'readonly' extends Access // Is the access ambiguous?\n    ?\n      | TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>\n      | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>>\n  : 'readonly' extends Access // Is the access strictly 'readonly'?\n    ? TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>\n  : 'mutable' extends Access // Is the access strictly 'mutable'?\n    ? TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>>\n  :\n    | TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>\n    | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>>\n  : TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>; // <- access is undefined, so default to 'readonly';\n\ntype GetUsageForStorageTexture<\n  T extends TgpuLayoutStorageTexture,\n  TAccess extends 'readonly' | 'writeonly' | 'mutable',\n> = {\n  mutable: TgpuMutableTexture<\n    Default<GetDimension<T['viewDimension']>, '2d'>,\n    TexelFormatToDataType[T['storageTexture']]\n  >;\n  readonly: TgpuReadonlyTexture<\n    Default<GetDimension<T['viewDimension']>, '2d'>,\n    TexelFormatToDataType[T['storageTexture']]\n  >;\n  writeonly: TgpuWriteonlyTexture<\n    Default<GetDimension<T['viewDimension']>, '2d'>,\n    TexelFormatToDataType[T['storageTexture']]\n  >;\n}[TAccess];\n\ntype StorageTextureUsageForEntry<T extends TgpuLayoutStorageTexture> = T extends\n  unknown ? GetUsageForStorageTexture<T, Default<T['access'], 'writeonly'>>\n  : never;\n\ntype GetDimension<T extends GPUTextureViewDimension | undefined> = T extends\n  keyof ViewDimensionToDimension ? ViewDimensionToDimension[T]\n  : undefined;\n\ntype GetTextureRestriction<T extends TgpuLayoutTexture> = Default<\n  GetDimension<T['viewDimension']>,\n  '2d'\n> extends infer Dimension ? Dimension extends '2d' ? {\n      format:\n        ChannelTypeToLegalFormats[SampleTypeToStringChannelType[T['texture']]];\n      dimension?: Dimension;\n    }\n  : {\n    format:\n      ChannelTypeToLegalFormats[SampleTypeToStringChannelType[T['texture']]];\n    dimension: Dimension;\n  }\n  : never;\n\ntype GetStorageTextureRestriction<T extends TgpuLayoutStorageTexture> = Default<\n  GetDimension<T['viewDimension']>,\n  '2d'\n> extends infer Dimension ? Dimension extends '2d' ? {\n      format: T['storageTexture'];\n      dimension?: Dimension;\n    }\n  : {\n    format: T['storageTexture'];\n    dimension: Dimension;\n  }\n  : never;\n\nexport type LayoutEntryToInput<T extends TgpuLayoutEntry | null> =\n  // Widest type\n  TgpuLayoutEntry | null extends T ?\n      | TgpuBuffer<AnyWgslData>\n      | GPUBuffer\n      | TgpuSampler\n      | GPUSampler\n      | TgpuComparisonSampler\n      | GPUSampler\n      | TgpuTexture\n      | TgpuSampledTexture\n      | TgpuMutableTexture\n      | TgpuReadonlyTexture\n      | TgpuWriteonlyTexture\n      | GPUTextureView\n      | GPUExternalTexture\n    // Strict type-checking\n    : T extends TgpuLayoutUniform ?\n        | (\n          & TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['uniform']>>>\n          & UniformFlag\n        )\n        | GPUBuffer\n    : T extends TgpuLayoutStorage ?\n        | (\n          & TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['storage']>>>\n          & StorageFlag\n        )\n        | GPUBuffer\n    : T extends TgpuLayoutSampler ? TgpuSampler | GPUSampler\n    : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler | GPUSampler\n    : T extends TgpuLayoutTexture ?\n        | GPUTextureView\n        | (\n          & Sampled\n          & TgpuTexture<\n            Prettify<TextureProps & GetTextureRestriction<T>>\n          >\n        )\n        | TgpuSampledTexture<\n          Default<T['viewDimension'], '2d'>,\n          ChannelFormatToSchema[T['texture']]\n        >\n    : T extends TgpuLayoutStorageTexture ?\n        | GPUTextureView\n        | (\n          & StorageFlag\n          & TgpuTexture<\n            Prettify<TextureProps & GetStorageTextureRestriction<T>>\n          >\n        )\n        | StorageTextureUsageForEntry<T>\n    : T extends TgpuLayoutExternalTexture ? GPUExternalTexture\n    : never;\n\nexport type BindLayoutEntry<T extends TgpuLayoutEntry | null> = T extends\n  TgpuLayoutUniform ? TgpuBufferUniform<T['uniform']>\n  : T extends TgpuLayoutStorage ? StorageUsageForEntry<T>\n  : T extends TgpuLayoutSampler ? TgpuSampler\n  : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler\n  : T extends TgpuLayoutTexture ? TgpuSampledTexture<\n      Default<T['viewDimension'], '2d'>,\n      ChannelFormatToSchema[T['texture']]\n    >\n  : T extends TgpuLayoutStorageTexture ? StorageTextureUsageForEntry<T>\n  : never;\n\nexport type InferLayoutEntry<T extends TgpuLayoutEntry | null> = T extends\n  TgpuLayoutUniform ? Infer<T['uniform']>\n  : T extends TgpuLayoutStorage ? Infer<UnwrapRuntimeConstructor<T['storage']>>\n  : T extends TgpuLayoutSampler ? TgpuSampler\n  : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler\n  : T extends TgpuLayoutTexture ? TgpuSampledTexture<\n      Default<T['viewDimension'], '2d'>,\n      ChannelFormatToSchema[T['texture']]\n    >\n  : T extends TgpuLayoutStorageTexture ? StorageTextureUsageForEntry<T>\n  : never;\n\nexport type ExtractBindGroupInputFromLayout<\n  T extends Record<string, TgpuLayoutEntry | null>,\n> = NullableToOptional<\n  { [K in keyof T]: LayoutEntryToInput<T[K]> }\n>;\n\nexport type TgpuBindGroup<\n  Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n    string,\n    TgpuLayoutEntry | null\n  >,\n> = {\n  readonly resourceType: 'bind-group';\n  readonly layout: TgpuBindGroupLayout<Entries>;\n  unwrap(unwrapper: Unwrapper): GPUBindGroup;\n};\n\nexport function bindGroupLayout<\n  Entries extends Record<string, TgpuLayoutEntry | null>,\n>(entries: Entries): TgpuBindGroupLayout<Prettify<Entries>> {\n  return new TgpuBindGroupLayoutImpl(entries);\n}\n\nexport function isBindGroupLayout<T extends TgpuBindGroupLayout>(\n  value: T | unknown,\n): value is T {\n  return !!value && (value as T).resourceType === 'bind-group-layout';\n}\n\nexport function isBindGroup<T extends TgpuBindGroup>(\n  value: T | unknown,\n): value is T {\n  return !!value && (value as T).resourceType === 'bind-group';\n}\n\n/**\n * @category Errors\n */\nexport class MissingBindingError extends Error {\n  constructor(groupLabel: string | undefined, key: string) {\n    super(\n      `Bind group '${\n        groupLabel ?? '<unnamed>'\n      }' is missing a required binding '${key}'`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingBindingError.prototype);\n  }\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst DEFAULT_MUTABLE_VISIBILITY: TgpuShaderStage[] = ['compute'];\nconst DEFAULT_READONLY_VISIBILITY: TgpuShaderStage[] = [\n  'compute',\n  'vertex',\n  'fragment',\n];\n\nclass TgpuBindGroupLayoutImpl<\n  Entries extends Record<string, TgpuLayoutEntry | null>,\n> implements TgpuBindGroupLayout<Entries> {\n  public readonly [$internal] = true;\n  private _index: number | undefined;\n\n  public readonly resourceType = 'bind-group-layout' as const;\n\n  public readonly bound = {} as {\n    [K in keyof Entries]: BindLayoutEntry<Entries[K]>;\n  };\n\n  public readonly value = {} as {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n\n  public readonly $ = this.value as {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n\n  constructor(public readonly entries: Entries) {\n    let idx = 0;\n\n    for (const [key, entry] of Object.entries(entries)) {\n      if (entry === null) {\n        idx++;\n        continue;\n      }\n\n      const membership: LayoutMembership = { layout: this, key, idx };\n\n      if ('uniform' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutBufferImpl(\n          'uniform',\n          entry.uniform,\n          membership,\n        );\n      }\n\n      if ('storage' in entry) {\n        const dataType = 'type' in entry.storage\n          ? entry.storage\n          : entry.storage(0);\n\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutBufferImpl(\n          entry.access ?? 'readonly',\n          dataType,\n          membership,\n        );\n      }\n\n      if ('texture' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutSampledTextureImpl(\n          entry.texture,\n          entry.viewDimension ?? '2d',\n          entry.multisampled ?? false,\n          membership,\n        );\n      }\n\n      if ('storageTexture' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutStorageTextureImpl(\n          entry.storageTexture,\n          entry.viewDimension ?? '2d',\n          entry.access ?? 'writeonly',\n          membership,\n        );\n      }\n\n      if ('externalTexture' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuExternalTextureImpl(membership);\n      }\n\n      if ('sampler' in entry) {\n        if (entry.sampler === 'comparison') {\n          // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n          (this.bound[key] as any) = new TgpuLaidOutComparisonSamplerImpl(\n            membership,\n          );\n        } else {\n          // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n          (this.bound[key] as any) = new TgpuLaidOutSamplerImpl(membership);\n        }\n      }\n\n      if (\n        'texture' in entry ||\n        'storageTexture' in entry ||\n        'externalTexture' in entry ||\n        'sampler' in entry\n      ) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.value as any)[key] = this.bound[key];\n      } else {\n        Object.defineProperty(this.value, key, {\n          get: () => {\n            // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n            return (this.bound[key] as any).value;\n          },\n        });\n      }\n\n      idx++;\n    }\n  }\n\n  toString(): string {\n    return `bindGroupLayout:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get index(): number | undefined {\n    return this._index;\n  }\n\n  $name(label: string): this {\n    setName(this, label);\n    return this;\n  }\n\n  $idx(index?: number): this {\n    this._index = index;\n    return this;\n  }\n\n  unwrap(unwrapper: Unwrapper) {\n    const unwrapped = unwrapper.device.createBindGroupLayout({\n      label: getName(this) ?? '<unnamed>',\n      entries: Object.values(this.entries)\n        .map((entry, idx) => {\n          if (entry === null) {\n            return null;\n          }\n\n          let visibility = entry.visibility;\n\n          const binding: GPUBindGroupLayoutEntry = {\n            binding: idx,\n            visibility: 0,\n          };\n\n          if ('uniform' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n\n            binding.buffer = {\n              type: 'uniform' as const,\n            };\n          } else if ('storage' in entry) {\n            visibility = visibility ??\n              (entry.access === 'mutable'\n                ? DEFAULT_MUTABLE_VISIBILITY\n                : DEFAULT_READONLY_VISIBILITY);\n\n            binding.buffer = {\n              type: entry.access === 'mutable'\n                ? ('storage' as const)\n                : ('read-only-storage' as const),\n            };\n          } else if ('sampler' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n\n            binding.sampler = {\n              type: entry.sampler,\n            };\n          } else if ('texture' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n\n            binding.texture = {\n              sampleType: entry.texture,\n              viewDimension: entry.viewDimension ?? '2d',\n              multisampled: entry.multisampled ?? false,\n            };\n          } else if ('storageTexture' in entry) {\n            const access = entry.access ?? 'writeonly';\n\n            visibility = visibility ??\n              (access === 'readonly'\n                ? DEFAULT_READONLY_VISIBILITY\n                : DEFAULT_MUTABLE_VISIBILITY);\n\n            binding.storageTexture = {\n              format: entry.storageTexture,\n              access: {\n                mutable: 'read-write' as const,\n                readonly: 'read-only' as const,\n                writeonly: 'write-only' as const,\n              }[access],\n              viewDimension: entry.viewDimension ?? '2d',\n            };\n          } else if ('externalTexture' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n            binding.externalTexture = {};\n          }\n\n          if (visibility?.includes('compute')) {\n            binding.visibility |= GPUShaderStage.COMPUTE;\n          }\n          if (visibility?.includes('vertex')) {\n            binding.visibility |= GPUShaderStage.VERTEX;\n          }\n          if (visibility?.includes('fragment')) {\n            binding.visibility |= GPUShaderStage.FRAGMENT;\n          }\n\n          return binding;\n        })\n        .filter((v): v is Exclude<typeof v, null> => v !== null),\n    });\n\n    return unwrapped;\n  }\n}\n\nexport class TgpuBindGroupImpl<\n  Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n    string,\n    TgpuLayoutEntry | null\n  >,\n> implements TgpuBindGroup<Entries> {\n  public readonly resourceType = 'bind-group' as const;\n\n  constructor(\n    public readonly layout: TgpuBindGroupLayout<Entries>,\n    public readonly entries: ExtractBindGroupInputFromLayout<Entries>,\n  ) {\n    // Checking if all entries are present.\n    for (const key of Object.keys(layout.entries)) {\n      if (layout.entries[key] !== null && !(key in entries)) {\n        throw new MissingBindingError(getName(layout), key);\n      }\n    }\n  }\n\n  public unwrap(unwrapper: Unwrapper): GPUBindGroup {\n    const unwrapped = unwrapper.device.createBindGroup({\n      label: getName(this.layout) ?? '<unnamed>',\n      layout: unwrapper.unwrap(this.layout),\n      entries: Object.entries(this.layout.entries)\n        .map(([key, entry], idx) => {\n          if (entry === null) {\n            return null;\n          }\n\n          const value = this.entries[key as keyof typeof this.entries];\n\n          if (value === undefined) {\n            throw new Error(\n              `'${key}' is a resource required to populate bind group layout '${\n                getName(this.layout) ?? '<unnamed>'\n              }'.`,\n            );\n          }\n\n          if ('uniform' in entry) {\n            let resource: GPUBufferBinding;\n\n            if (isBuffer(value)) {\n              if (!isUsableAsUniform(value)) {\n                throw new NotUniformError(value);\n              }\n              resource = { buffer: unwrapper.unwrap(value) };\n            } else {\n              resource = { buffer: value as GPUBuffer };\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('storage' in entry) {\n            let resource: GPUBufferBinding;\n\n            if (isBuffer(value)) {\n              if (!isUsableAsStorage(value)) {\n                throw new NotStorageError(value);\n              }\n              resource = { buffer: unwrapper.unwrap(value) };\n            } else {\n              resource = { buffer: value as GPUBuffer };\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('texture' in entry) {\n            let resource: GPUTextureView;\n\n            if (isTexture(value)) {\n              if (!isUsableAsSampled(value)) {\n                throw new NotSampledError(value);\n              }\n\n              resource = unwrapper.unwrap(\n                (value as TgpuTexture & Sampled).createView('sampled'),\n              );\n            } else if (isSampledTextureView(value)) {\n              resource = unwrapper.unwrap(value);\n            } else {\n              resource = value as GPUTextureView;\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('storageTexture' in entry) {\n            let resource: GPUTextureView;\n\n            if (isTexture(value)) {\n              if (!isUsableAsStorage(value)) {\n                throw new NotStorageError(value);\n              }\n\n              if (entry.access === 'readonly') {\n                resource = unwrapper.unwrap(\n                  (value as TgpuTexture & StorageFlag).createView('readonly'),\n                );\n              } else if (entry.access === 'mutable') {\n                resource = unwrapper.unwrap(\n                  (value as TgpuTexture & StorageFlag).createView('mutable'),\n                );\n              } else {\n                resource = unwrapper.unwrap(\n                  (value as TgpuTexture & StorageFlag).createView('writeonly'),\n                );\n              }\n            } else if (isStorageTextureView(value)) {\n              resource = unwrapper.unwrap(value);\n            } else {\n              resource = value as GPUTextureView;\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('sampler' in entry) {\n            if (isSampler(value) || isComparisonSampler(value)) {\n              return {\n                binding: idx,\n                resource: unwrapper.unwrap(value as TgpuSampler),\n              };\n            }\n\n            return {\n              binding: idx,\n              resource: value as GPUSampler,\n            };\n          }\n\n          if ('externalTexture' in entry) {\n            return {\n              binding: idx,\n              resource: value as GPUExternalTexture,\n            };\n          }\n\n          throw new Error(\n            `Malformed bind group entry: ${value} (${JSON.stringify(value)})`,\n          );\n        })\n        .filter((v): v is Exclude<typeof v, null> => v !== null),\n    });\n\n    return unwrapped;\n  }\n}\n", "import * as tinyest from 'tinyest';\nimport { arrayOf } from '../data/array.ts';\nimport {\n  type AnyData,\n  isData,\n  isLooseData,\n  snip,\n  type Snippet,\n  UnknownData,\n} from '../data/dataTypes.ts';\nimport * as d from '../data/index.ts';\nimport { abstractInt } from '../data/numeric.ts';\nimport * as wgsl from '../data/wgslTypes.ts';\nimport { getName } from '../shared/meta.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { type FnArgsConversionHint, isMarkedInternal } from '../types.ts';\nimport {\n  coerceToSnippet,\n  concretize,\n  convertStructValues,\n  convertToCommonType,\n  type GenerationCtx,\n  getTypeForIndexAccess,\n  getTypeForPropAccess,\n  numericLiteralToSnippet,\n} from './generationHelpers.ts';\nimport { ResolutionError } from '../errors.ts';\n\nconst { NodeTypeCatalog: NODE } = tinyest;\n\nconst parenthesizedOps = [\n  '==',\n  '!=',\n  '<',\n  '<=',\n  '>',\n  '>=',\n  '<<',\n  '>>',\n  '+',\n  '-',\n  '*',\n  '/',\n  '%',\n  '|',\n  '^',\n  '&',\n  '&&',\n  '||',\n];\n\nconst binaryLogicalOps = ['&&', '||', '==', '!=', '<', '<=', '>', '>='];\n\ntype Operator =\n  | tinyest.BinaryOperator\n  | tinyest.AssignmentOperator\n  | tinyest.LogicalOperator\n  | tinyest.UnaryOperator;\n\nfunction operatorToType<\n  TL extends AnyData | UnknownData,\n  TR extends AnyData | UnknownData,\n>(lhs: TL, op: Operator, rhs?: TR): TL | TR | wgsl.Bool {\n  if (!rhs) {\n    if (op === '!' || op === '~') {\n      return d.bool;\n    }\n\n    return lhs;\n  }\n\n  if (binaryLogicalOps.includes(op)) {\n    return d.bool;\n  }\n\n  if (op === '=') {\n    return rhs;\n  }\n\n  return lhs;\n}\n\nfunction assertExhaustive(value: never): never {\n  throw new Error(\n    `'${JSON.stringify(value)}' was not handled by the WGSL generator.`,\n  );\n}\n\nexport function generateBlock(\n  ctx: GenerationCtx,\n  [_, statements]: tinyest.Block,\n): string {\n  ctx.pushBlockScope();\n  try {\n    return `${ctx.indent()}{\n${statements.map((statement) => generateStatement(ctx, statement)).join('\\n')}\n${ctx.dedent()}}`;\n  } finally {\n    ctx.popBlockScope();\n  }\n}\n\nexport function registerBlockVariable(\n  ctx: GenerationCtx,\n  id: string,\n  dataType: wgsl.AnyWgslData | UnknownData,\n): Snippet {\n  return ctx.defineVariable(id, dataType);\n}\n\nexport function generateIdentifier(ctx: GenerationCtx, id: string): Snippet {\n  const res = ctx.getById(id);\n  if (!res) {\n    throw new Error(`Identifier ${id} not found`);\n  }\n\n  return res;\n}\n\nexport function generateExpression(\n  ctx: GenerationCtx,\n  expression: tinyest.Expression,\n): Snippet {\n  if (typeof expression === 'string') {\n    return generateIdentifier(ctx, expression);\n  }\n\n  if (typeof expression === 'boolean') {\n    return snip(expression ? 'true' : 'false', d.bool);\n  }\n\n  if (\n    expression[0] === NODE.logicalExpr ||\n    expression[0] === NODE.binaryExpr ||\n    expression[0] === NODE.assignmentExpr\n  ) {\n    // Logical/Binary/Assignment Expression\n    const [_, lhs, op, rhs] = expression;\n    const lhsExpr = generateExpression(ctx, lhs);\n    const rhsExpr = generateExpression(ctx, rhs);\n\n    const forcedType = expression[0] === NODE.assignmentExpr\n      ? [lhsExpr.dataType as AnyData]\n      : [];\n\n    const converted = convertToCommonType(\n      ctx,\n      [lhsExpr, rhsExpr],\n      forcedType,\n    ) as\n      | [Snippet, Snippet]\n      | undefined;\n    const [convLhs, convRhs] = converted || [lhsExpr, rhsExpr];\n\n    const lhsStr = ctx.resolve(convLhs.value);\n    const rhsStr = ctx.resolve(convRhs.value);\n    const type = operatorToType(convLhs.dataType, op, convRhs.dataType);\n\n    return snip(\n      parenthesizedOps.includes(op)\n        ? `(${lhsStr} ${op} ${rhsStr})`\n        : `${lhsStr} ${op} ${rhsStr}`,\n      type,\n    );\n  }\n\n  if (expression[0] === NODE.postUpdate) {\n    // Post-Update Expression\n    const [_, op, arg] = expression;\n    const argExpr = generateExpression(ctx, arg);\n    const argStr = ctx.resolve(argExpr.value);\n\n    return snip(`${argStr}${op}`, argExpr.dataType);\n  }\n\n  if (expression[0] === NODE.unaryExpr) {\n    // Unary Expression\n    const [_, op, arg] = expression;\n    const argExpr = generateExpression(ctx, arg);\n    const argStr = ctx.resolve(argExpr.value);\n\n    const type = operatorToType(argExpr.dataType, op);\n    return snip(`${op}${argStr}`, type);\n  }\n\n  if (expression[0] === NODE.memberAccess) {\n    // Member Access\n    const [_, targetNode, property] = expression;\n    const target = generateExpression(ctx, targetNode);\n\n    if (target.dataType.type === 'unknown') {\n      // No idea what the type is, so we act on the snippet's value and try to guess\n\n      // biome-ignore lint/suspicious/noExplicitAny: we're inspecting the value, and it could be any value\n      const propValue = (target.value as any)[property];\n\n      // We try to extract any type information based on the prop's value\n      return coerceToSnippet(propValue);\n    }\n\n    if (wgsl.isPtr(target.dataType)) {\n      return snip(\n        `(*${ctx.resolve(target.value)}).${property}`,\n        getTypeForPropAccess(target.dataType.inner as AnyData, property),\n      );\n    }\n\n    if (wgsl.isWgslArray(target.dataType) && property === 'length') {\n      if (target.dataType.elementCount === 0) {\n        // Dynamically-sized array\n        return snip(`arrayLength(&${ctx.resolve(target.value)})`, d.u32);\n      }\n\n      return snip(String(target.dataType.elementCount), abstractInt);\n    }\n\n    if (wgsl.isMat(target.dataType) && property === 'columns') {\n      return snip(target.value, target.dataType);\n    }\n\n    if (\n      wgsl.isVec(target.dataType) && wgsl.isVecInstance(target.value)\n    ) {\n      // We're operating on a vector that's known at resolution time\n      // biome-ignore lint/suspicious/noExplicitAny: it's probably a swizzle\n      return coerceToSnippet((target.value as any)[property]);\n    }\n\n    return snip(\n      `${ctx.resolve(target.value)}.${property}`,\n      getTypeForPropAccess(target.dataType, property),\n    );\n  }\n\n  if (expression[0] === NODE.indexAccess) {\n    // Index Access\n    const [_, targetNode, propertyNode] = expression;\n    const target = generateExpression(ctx, targetNode);\n    const property = generateExpression(ctx, propertyNode);\n    const targetStr = ctx.resolve(target.value);\n    const propertyStr = ctx.resolve(property.value);\n\n    if (target.dataType.type === 'unknown') {\n      // No idea what the type is, so we act on the snippet's value and try to guess\n\n      if (\n        Array.isArray(propertyNode) && propertyNode[0] === NODE.numericLiteral\n      ) {\n        return coerceToSnippet(\n          // biome-ignore lint/suspicious/noExplicitAny: we're inspecting the value, and it could be any value\n          (target.value as any)[propertyNode[1] as number],\n        );\n      }\n\n      throw new Error(\n        `Cannot index value ${targetStr} of unknown type with index ${propertyStr}`,\n      );\n    }\n\n    if (wgsl.isPtr(target.dataType)) {\n      return snip(\n        `(*${targetStr})[${propertyStr}]`,\n        getTypeForIndexAccess(target.dataType.inner as AnyData),\n      );\n    }\n\n    return snip(\n      `${targetStr}[${propertyStr}]`,\n      isData(target.dataType)\n        ? getTypeForIndexAccess(target.dataType)\n        : UnknownData,\n    );\n  }\n\n  if (expression[0] === NODE.numericLiteral) {\n    // Numeric Literal\n    const type = numericLiteralToSnippet(expression[1]);\n    if (!type) {\n      throw new Error(`Invalid numeric literal ${expression[1]}`);\n    }\n    return type;\n  }\n\n  if (expression[0] === NODE.call) {\n    // Function Call\n    const [_, callee, args] = expression;\n    const id = generateExpression(ctx, callee);\n\n    ctx.callStack.push(id.value);\n\n    const argSnippets = args.map((arg) => generateExpression(ctx, arg));\n    const resolvedSnippets = argSnippets.map((res) =>\n      snip(ctx.resolve(res.value), res.dataType)\n    );\n    const argValues = resolvedSnippets.map((res) => res.value);\n\n    ctx.callStack.pop();\n\n    resolvedSnippets.forEach((sn, idx) => {\n      if (sn.dataType === UnknownData) {\n        throw new Error(\n          `Tried to pass '${sn.value}' of unknown type as argument #${idx} to '${\n            typeof id.value === 'string'\n              ? id.value\n              : getName(id.value) ?? '<unnamed>'\n          }()'`,\n        );\n      }\n    });\n\n    if (typeof id.value === 'string') {\n      return snip(`${id.value}(${argValues.join(', ')})`, id.dataType);\n    }\n\n    if (wgsl.isWgslStruct(id.value)) {\n      const resolvedId = ctx.resolve(id.value);\n\n      return snip(\n        `${resolvedId}(${argValues.join(', ')})`,\n        // Unintuitive, but the type of the return value is the struct itself\n        id.value,\n      );\n    }\n\n    if (!isMarkedInternal(id.value)) {\n      throw new Error(\n        `Function ${String(id.value)} ${\n          getName(id.value)\n        } has not been created using TypeGPU APIs. Did you mean to wrap the function with tgpu.fn(args, return)(...) ?`,\n      );\n    }\n\n    const argTypes = id.value[$internal]?.argTypes as\n      | FnArgsConversionHint\n      | undefined;\n    let convertedResources: Snippet[];\n    try {\n      if (!argTypes || argTypes === 'keep') {\n        convertedResources = resolvedSnippets;\n      } else if (argTypes === 'coerce') {\n        convertedResources = convertToCommonType(ctx, resolvedSnippets) ??\n          resolvedSnippets;\n      } else {\n        const pairs =\n          (Array.isArray(argTypes) ? argTypes : (argTypes(...resolvedSnippets)))\n            .map((type, i) => [type, resolvedSnippets[i] as Snippet] as const);\n\n        convertedResources = pairs.map(([type, sn]) => {\n          if (sn.dataType.type === 'unknown') {\n            console.warn(\n              `Internal error: unknown type when generating expression: ${expression}`,\n            );\n            return sn;\n          }\n\n          const conv = convertToCommonType(ctx, [sn], [type])?.[0];\n          if (!conv) {\n            throw new ResolutionError(\n              `Cannot convert argument of type '${sn.dataType.type}' to '${type.type}' for function ${\n                getName(id.value)\n              }`,\n              [{\n                function: id.value,\n                callStack: ctx.callStack,\n                error:\n                  `Cannot convert argument of type '${sn.dataType.type}' to '${type.type}'`,\n                toString: () => getName(id.value),\n              }],\n            );\n          }\n          return conv;\n        });\n      }\n\n      // Assuming that `id` is callable\n      const fnRes = (id.value as unknown as (...args: unknown[]) => unknown)(\n        ...convertedResources,\n      ) as Snippet;\n      return snip(ctx.resolve(fnRes.value), fnRes.dataType);\n    } catch (error) {\n      throw new ResolutionError(error, [{\n        toString: () => getName(id.value),\n      }]);\n    }\n  }\n\n  if (expression[0] === NODE.objectExpr) {\n    // Object Literal\n    const obj = expression[1];\n    const callee = ctx.callStack[ctx.callStack.length - 1];\n\n    if (wgsl.isWgslStruct(callee)) {\n      const propKeys = Object.keys(callee.propTypes);\n      const entries = Object.fromEntries(\n        propKeys.map((key) => {\n          const val = obj[key];\n          if (val === undefined) {\n            throw new Error(\n              `Missing property ${key} in object literal for struct ${callee}`,\n            );\n          }\n          return [key, generateExpression(ctx, val)];\n        }),\n      );\n\n      const convertedValues = convertStructValues(ctx, callee, entries);\n\n      return snip(\n        convertedValues.map((v) => ctx.resolve(v.value)).join(', '),\n        callee,\n      );\n    }\n\n    if (isMarkedInternal(callee)) {\n      const argTypes = callee[$internal]?.argTypes;\n\n      if (typeof argTypes === 'object' && argTypes !== null) {\n        const propKeys = Object.keys(argTypes);\n        const snippets: Record<string, Snippet> = {};\n\n        for (const key of propKeys) {\n          const val = obj[key];\n          if (val === undefined) {\n            throw new Error(\n              `Missing property ${key} in object literal for function ${callee}`,\n            );\n          }\n          const expr = generateExpression(ctx, val);\n          const targetType = argTypes[key as keyof typeof argTypes];\n          const converted = convertToCommonType(ctx, [expr], [targetType]);\n          snippets[key] = converted?.[0] ?? expr;\n        }\n\n        return snip(snippets, UnknownData);\n      }\n    }\n\n    throw new Error(\n      'Object expressions are only allowed as return values of functions or as arguments to structs.',\n    );\n  }\n\n  if (expression[0] === NODE.arrayExpr) {\n    const [_, valuesRaw] = expression;\n    // Array Expression\n    const values = valuesRaw.map((value) =>\n      generateExpression(ctx, value as tinyest.Expression)\n    );\n    if (values.length === 0) {\n      throw new Error('Cannot create empty array literal.');\n    }\n\n    const convertedValues = convertToCommonType(ctx, values);\n    if (!convertedValues) {\n      throw new Error(\n        'The given values cannot be automatically converted to a common type. Consider explicitly casting them.',\n      );\n    }\n\n    const targetType = convertedValues[0]?.dataType as AnyData;\n    const type = targetType.type === 'abstractFloat'\n      ? d.f32\n      : targetType.type === 'abstractInt'\n      ? d.i32\n      : targetType;\n\n    const typeId = ctx.resolve(type);\n\n    const arrayType = `array<${typeId}, ${values.length}>`;\n    const arrayValues = convertedValues.map((sn) => ctx.resolve(sn.value));\n\n    return snip(\n      `${arrayType}( ${arrayValues.join(', ')} )`,\n      arrayOf(\n        type as wgsl.AnyWgslData,\n        values.length,\n      ) as wgsl.AnyWgslData,\n    );\n  }\n\n  if (expression[0] === NODE.stringLiteral) {\n    throw new Error('Cannot use string literals in TGSL.');\n  }\n\n  if (expression[0] === NODE.preUpdate) {\n    throw new Error('Cannot use pre-updates in TGSL.');\n  }\n\n  assertExhaustive(expression);\n}\n\nfunction blockifySingleStatement(statement: tinyest.Statement): tinyest.Block {\n  return typeof statement !== 'object' ||\n      statement[0] !== NODE.block\n    ? [NODE.block, [statement]]\n    : statement;\n}\n\nexport function generateStatement(\n  ctx: GenerationCtx,\n  statement: tinyest.Statement,\n): string {\n  if (typeof statement === 'string') {\n    return `${ctx.pre}${\n      ctx.resolve(generateIdentifier(ctx, statement).value)\n    };`;\n  }\n\n  if (typeof statement === 'boolean') {\n    return `${ctx.pre}${statement ? 'true' : 'false'};`;\n  }\n\n  if (statement[0] === NODE.return) {\n    const returnNode = statement[1];\n    const returnValue = returnNode !== undefined\n      ? ctx.resolve(generateExpression(ctx, returnNode).value)\n      : undefined;\n\n    // check if the thing at the top of the call stack is a struct and the statement is a plain JS object\n    // if so wrap the value returned in a constructor of the struct (its resolved name)\n    if (\n      wgsl.isWgslStruct(ctx.callStack[ctx.callStack.length - 1]) &&\n      typeof returnNode === 'object' &&\n      returnNode[0] === NODE.objectExpr\n    ) {\n      const resolvedStruct = ctx.resolve(\n        ctx.callStack[ctx.callStack.length - 1],\n      );\n      return `${ctx.pre}return ${resolvedStruct}(${returnValue});`;\n    }\n\n    return returnValue\n      ? `${ctx.pre}return ${returnValue};`\n      : `${ctx.pre}return;`;\n  }\n\n  if (statement[0] === NODE.if) {\n    const [_, cond, cons, alt] = statement;\n    const condExpr = generateExpression(ctx, cond);\n    let condSnippet = condExpr;\n    const converted = convertToCommonType(ctx, [condExpr], [d.bool]);\n    if (converted?.[0]) {\n      [condSnippet] = converted;\n    }\n    const condition = ctx.resolve(condSnippet.value);\n\n    ctx.indent(); // {\n    const consequent = generateStatement(ctx, blockifySingleStatement(cons));\n    ctx.dedent(); // }\n\n    ctx.indent(); // {\n    const alternate = alt\n      ? generateStatement(ctx, blockifySingleStatement(alt))\n      : undefined;\n    ctx.dedent(); // }\n\n    if (!alternate) {\n      return `\\\n${ctx.pre}if (${condition})\n${consequent}`;\n    }\n\n    return `\\\n${ctx.pre}if (${condition})\n${consequent}\n${ctx.pre}else\n${alternate}`;\n  }\n\n  if (statement[0] === NODE.let || statement[0] === NODE.const) {\n    const [_, rawId, rawValue] = statement;\n    const eq = rawValue !== undefined\n      ? generateExpression(ctx, rawValue)\n      : undefined;\n\n    if (!eq) {\n      throw new Error(\n        `Cannot create variable '${rawId}' without an initial value.`,\n      );\n    }\n\n    if (isLooseData(eq.dataType)) {\n      throw new Error(\n        `Cannot create variable '${rawId}' with loose data type.`,\n      );\n    }\n\n    registerBlockVariable(\n      ctx,\n      rawId,\n      concretize(eq.dataType as wgsl.AnyWgslData),\n    );\n    const id = ctx.resolve(generateIdentifier(ctx, rawId).value);\n\n    // If the value is a plain JS object it has to be an output struct\n    if (\n      typeof rawValue === 'object' &&\n      rawValue[0] === NODE.objectExpr &&\n      wgsl.isWgslStruct(ctx.callStack[ctx.callStack.length - 1])\n    ) {\n      const structType = ctx.callStack[\n        ctx.callStack.length - 1\n      ] as wgsl.WgslStruct;\n      const obj = rawValue[1];\n\n      const entries: Record<string, Snippet> = {};\n      for (const [key, value] of Object.entries(obj)) {\n        if (!value) {\n          throw new Error(`Missing property ${key} in object literal`);\n        }\n        entries[key] = generateExpression(ctx, value);\n      }\n\n      const convertedValues = convertStructValues(ctx, structType, entries);\n      const resolvedStruct = ctx.resolve(structType);\n      return `${ctx.pre}var ${id} = ${resolvedStruct}(${\n        convertedValues.map((sn) => ctx.resolve(sn.value)).join(', ')\n      });`;\n    }\n\n    return `${ctx.pre}var ${id} = ${ctx.resolve(eq.value)};`;\n  }\n\n  if (statement[0] === NODE.block) {\n    return generateBlock(ctx, statement);\n  }\n\n  if (statement[0] === NODE.for) {\n    const [_, init, condition, update, body] = statement;\n\n    const initStatement = init ? generateStatement(ctx, init) : undefined;\n    const initStr = initStatement ? initStatement.slice(0, -1) : '';\n\n    const conditionExpr = condition\n      ? generateExpression(ctx, condition)\n      : undefined;\n    let condSnippet = conditionExpr;\n    if (conditionExpr) {\n      const converted = convertToCommonType(ctx, [conditionExpr], [d.bool]);\n      if (converted?.[0]) {\n        [condSnippet] = converted;\n      }\n    }\n    const conditionStr = condSnippet ? ctx.resolve(condSnippet.value) : '';\n\n    const updateStatement = update ? generateStatement(ctx, update) : undefined;\n    const updateStr = updateStatement ? updateStatement.slice(0, -1) : '';\n\n    ctx.indent();\n    const bodyStr = generateStatement(ctx, blockifySingleStatement(body));\n    ctx.dedent();\n\n    return `\\\n${ctx.pre}for (${initStr}; ${conditionStr}; ${updateStr})\n${bodyStr}`;\n  }\n\n  if (statement[0] === NODE.while) {\n    const [_, condition, body] = statement;\n    const condExpr = generateExpression(ctx, condition);\n    let condSnippet = condExpr;\n    if (condExpr) {\n      const converted = convertToCommonType(ctx, [condExpr], [d.bool]);\n      if (converted?.[0]) {\n        [condSnippet] = converted;\n      }\n    }\n    const conditionStr = ctx.resolve(condSnippet.value);\n\n    ctx.indent();\n    const bodyStr = generateStatement(ctx, blockifySingleStatement(body));\n    ctx.dedent();\n\n    return `\\\n${ctx.pre}while (${conditionStr})\n${bodyStr}`;\n  }\n\n  if (statement[0] === NODE.continue) {\n    return `${ctx.pre}continue;`;\n  }\n\n  if (statement[0] === NODE.break) {\n    return `${ctx.pre}break;`;\n  }\n\n  return `${ctx.pre}${ctx.resolve(generateExpression(ctx, statement).value)};`;\n}\n\nexport function generateFunction(\n  ctx: GenerationCtx,\n  body: tinyest.Block,\n): string {\n  return generateBlock(ctx, body);\n}\n", "import { resolveData } from './core/resolve/resolveData.ts';\nimport {\n  type Eventual,\n  isDerived,\n  isProviding,\n  isSlot,\n  type SlotValuePair,\n  type TgpuDerived,\n  type TgpuSlot,\n} from './core/slot/slotTypes.ts';\nimport { getAttributesString } from './data/attributes.ts';\nimport {\n  type AnyData,\n  isData,\n  snip,\n  type Snippet,\n  type UnknownData,\n} from './data/dataTypes.ts';\nimport { type BaseData, isWgslArray, isWgslStruct } from './data/wgslTypes.ts';\nimport { MissingSlotValueError, ResolutionError } from './errors.ts';\nimport { popMode, provideCtx, pushMode, RuntimeMode } from './gpuMode.ts';\nimport type { NameRegistry } from './nameRegistry.ts';\nimport { naturalsExcept } from './shared/generators.ts';\nimport type { Infer } from './shared/repr.ts';\nimport { $internal, $providing } from './shared/symbols.ts';\nimport {\n  bindGroupLayout,\n  type TgpuBindGroup,\n  TgpuBindGroupImpl,\n  type TgpuBindGroupLayout,\n  type TgpuLayoutEntry,\n} from './tgpuBindGroupLayout.ts';\nimport { coerceToSnippet } from './tgsl/generationHelpers.ts';\nimport { generateFunction } from './tgsl/wgslGenerator.ts';\nimport type {\n  FnToWgslOptions,\n  ItemLayer,\n  ItemStateStack,\n  ResolutionCtx,\n  Wgsl,\n} from './types.ts';\nimport { isSelfResolvable, isWgsl } from './types.ts';\n\n/**\n * Inserted into bind group entry definitions that belong\n * to the automatically generated catch-all bind group.\n *\n * A non-occupied group index can only be determined after\n * every resource has been resolved, so this acts as a placeholder\n * to be replaced with an actual numeric index at the very end\n * of the resolution process.\n */\nconst CATCHALL_BIND_GROUP_IDX_MARKER = '#CATCHALL#';\n\nexport type ResolutionCtxImplOptions = {\n  readonly names: NameRegistry;\n};\n\ntype SlotToValueMap = Map<TgpuSlot<unknown>, unknown>;\n\ntype SlotBindingLayer = {\n  type: 'slotBinding';\n  bindingMap: WeakMap<TgpuSlot<unknown>, unknown>;\n};\n\ntype FunctionScopeLayer = {\n  type: 'functionScope';\n  args: Snippet[];\n  argAliases: Record<string, Snippet>;\n  externalMap: Record<string, unknown>;\n  returnType: AnyData;\n};\n\ntype BlockScopeLayer = {\n  type: 'blockScope';\n  declarations: Map<string, AnyData | UnknownData>;\n};\n\nclass ItemStateStackImpl implements ItemStateStack {\n  private _stack: (\n    | ItemLayer\n    | SlotBindingLayer\n    | FunctionScopeLayer\n    | BlockScopeLayer\n  )[] = [];\n  private _itemDepth = 0;\n\n  get itemDepth(): number {\n    return this._itemDepth;\n  }\n\n  get topItem(): ItemLayer {\n    const state = this._stack[this._stack.length - 1];\n    if (!state || state.type !== 'item') {\n      throw new Error('Internal error, expected item layer to be on top.');\n    }\n    return state;\n  }\n\n  pushItem() {\n    this._itemDepth++;\n    this._stack.push({\n      type: 'item',\n      usedSlots: new Set(),\n    });\n  }\n\n  popItem() {\n    this.pop('item');\n  }\n\n  pushSlotBindings(pairs: SlotValuePair<unknown>[]) {\n    this._stack.push({\n      type: 'slotBinding',\n      bindingMap: new WeakMap(pairs),\n    });\n  }\n\n  popSlotBindings() {\n    this.pop('slotBinding');\n  }\n\n  pushFunctionScope(\n    args: Snippet[],\n    argAliases: Record<string, Snippet>,\n    returnType: AnyData,\n    externalMap: Record<string, unknown>,\n  ) {\n    this._stack.push({\n      type: 'functionScope',\n      args,\n      argAliases,\n      returnType,\n      externalMap,\n    });\n  }\n\n  popFunctionScope() {\n    this.pop('functionScope');\n  }\n\n  pushBlockScope() {\n    this._stack.push({\n      type: 'blockScope',\n      declarations: new Map<string, AnyData | UnknownData>(),\n    });\n  }\n\n  popBlockScope() {\n    this.pop('blockScope');\n  }\n\n  pop(type?: (typeof this._stack)[number]['type']) {\n    const layer = this._stack[this._stack.length - 1];\n    if (!layer || (type && layer.type !== type)) {\n      throw new Error(`Internal error, expected a ${type} layer to be on top.`);\n    }\n\n    this._stack.pop();\n    if (type === 'item') {\n      this._itemDepth--;\n    }\n  }\n\n  readSlot<T>(slot: TgpuSlot<T>): T | undefined {\n    for (let i = this._stack.length - 1; i >= 0; --i) {\n      const layer = this._stack[i];\n      if (layer?.type === 'item') {\n        // Binding not available yet, so this layer is dependent on the slot's value.\n        layer.usedSlots.add(slot);\n      } else if (layer?.type === 'slotBinding') {\n        const boundValue = layer.bindingMap.get(slot);\n\n        if (boundValue !== undefined) {\n          return boundValue as T;\n        }\n      } else if (\n        layer?.type === 'functionScope' ||\n        layer?.type === 'blockScope'\n      ) {\n        // Skip\n      } else {\n        throw new Error('Unknown layer type.');\n      }\n    }\n\n    return slot.defaultValue;\n  }\n\n  getSnippetById(id: string): Snippet | undefined {\n    for (let i = this._stack.length - 1; i >= 0; --i) {\n      const layer = this._stack[i];\n\n      if (layer?.type === 'functionScope') {\n        const arg = layer.args.find((a) => a.value === id);\n        if (arg !== undefined) {\n          return arg;\n        }\n\n        if (layer.argAliases[id]) {\n          return layer.argAliases[id];\n        }\n\n        const external = layer.externalMap[id];\n\n        if (external !== undefined && external !== null) {\n          return coerceToSnippet(external);\n        }\n\n        // Since functions cannot access resources from the calling scope, we\n        // return early here.\n        return undefined;\n      }\n\n      if (layer?.type === 'blockScope') {\n        const declarationType = layer.declarations.get(id);\n        if (declarationType !== undefined) {\n          return snip(id, declarationType);\n        }\n      } else {\n        // Skip\n      }\n    }\n\n    return undefined;\n  }\n\n  defineBlockVariable(id: string, type: AnyData | UnknownData): Snippet {\n    if (type.type === 'unknown') {\n      throw Error(`Tried to define variable '${id}' of unknown type`);\n    }\n\n    for (let i = this._stack.length - 1; i >= 0; --i) {\n      const layer = this._stack[i];\n\n      if (layer?.type === 'blockScope') {\n        layer.declarations.set(id, type);\n\n        return snip(id, type);\n      }\n    }\n\n    throw new Error('No block scope found to define a variable in.');\n  }\n}\n\nconst INDENT = [\n  '', // 0\n  '  ', // 1\n  '    ', // 2\n  '      ', // 3\n  '        ', // 4\n  '          ', // 5\n  '            ', // 6\n  '              ', // 7\n  '                ', // 8\n];\n\nconst N = INDENT.length - 1;\n\nexport class IndentController {\n  private identLevel = 0;\n\n  get pre(): string {\n    return (\n      INDENT[this.identLevel] ??\n        (INDENT[N] as string).repeat(this.identLevel / N) +\n          INDENT[this.identLevel % N]\n    );\n  }\n\n  indent(): string {\n    const str = this.pre;\n    this.identLevel++;\n    return str;\n  }\n\n  dedent(): string {\n    this.identLevel--;\n    return this.pre;\n  }\n}\n\ninterface FixedBindingConfig {\n  layoutEntry: TgpuLayoutEntry;\n  resource: object;\n}\n\nexport class ResolutionCtxImpl implements ResolutionCtx {\n  private readonly _memoizedResolves = new WeakMap<\n    // WeakMap because if the item does not exist anymore,\n    // apart from this map, there is no way to access the cached value anyway.\n    object,\n    { slotToValueMap: SlotToValueMap; result: string }[]\n  >();\n  private readonly _memoizedDerived = new WeakMap<\n    // WeakMap because if the \"derived\" does not exist anymore,\n    // apart from this map, there is no way to access the cached value anyway.\n    TgpuDerived<unknown>,\n    { slotToValueMap: SlotToValueMap; result: unknown }[]\n  >();\n\n  private readonly _indentController = new IndentController();\n  private readonly _itemStateStack = new ItemStateStackImpl();\n  private readonly _declarations: string[] = [];\n  private _varyingLocations: Record<string, number> | undefined;\n\n  get varyingLocations() {\n    return this._varyingLocations;\n  }\n\n  readonly [$internal] = {\n    itemStateStack: this._itemStateStack,\n  };\n\n  // -- Bindings\n  /**\n   * A map from registered bind group layouts to random strings put in\n   * place of their group index. The whole tree has to be traversed to\n   * collect every use of a typed bind group layout, since they can be\n   * explicitly imposed group indices, and they cannot collide.\n   */\n  public readonly bindGroupLayoutsToPlaceholderMap = new Map<\n    TgpuBindGroupLayout,\n    string\n  >();\n  private _nextFreeLayoutPlaceholderIdx = 0;\n  public readonly fixedBindings: FixedBindingConfig[] = [];\n  // --\n\n  public readonly callStack: unknown[] = [];\n  public readonly names: NameRegistry;\n\n  constructor(opts: ResolutionCtxImplOptions) {\n    this.names = opts.names;\n  }\n\n  get pre(): string {\n    return this._indentController.pre;\n  }\n\n  indent(): string {\n    return this._indentController.indent();\n  }\n\n  dedent(): string {\n    return this._indentController.dedent();\n  }\n\n  getById(id: string): Snippet | null {\n    const item = this._itemStateStack.getSnippetById(id);\n\n    if (item === undefined) {\n      return null;\n    }\n\n    return item;\n  }\n\n  defineVariable(id: string, dataType: AnyData | UnknownData): Snippet {\n    return this._itemStateStack.defineBlockVariable(id, dataType);\n  }\n\n  pushBlockScope() {\n    this._itemStateStack.pushBlockScope();\n  }\n\n  popBlockScope() {\n    this._itemStateStack.popBlockScope();\n  }\n\n  fnToWgsl(options: FnToWgslOptions): { head: Wgsl; body: Wgsl } {\n    this._itemStateStack.pushFunctionScope(\n      options.args,\n      options.argAliases,\n      options.returnType,\n      options.externalMap,\n    );\n\n    try {\n      return {\n        head: resolveFunctionHeader(this, options.args, options.returnType),\n        body: generateFunction(this, options.body),\n      };\n    } finally {\n      this._itemStateStack.popFunctionScope();\n    }\n  }\n\n  addDeclaration(declaration: string): void {\n    this._declarations.push(declaration);\n  }\n\n  allocateLayoutEntry(layout: TgpuBindGroupLayout): string {\n    const memoMap = this.bindGroupLayoutsToPlaceholderMap;\n    let placeholderKey = memoMap.get(layout);\n\n    if (!placeholderKey) {\n      placeholderKey = `#BIND_GROUP_LAYOUT_${this\n        ._nextFreeLayoutPlaceholderIdx++}#`;\n      memoMap.set(layout, placeholderKey);\n    }\n\n    return placeholderKey;\n  }\n\n  allocateFixedEntry(\n    layoutEntry: TgpuLayoutEntry,\n    resource: object,\n  ): { group: string; binding: number } {\n    const binding = this.fixedBindings.length;\n    this.fixedBindings.push({ layoutEntry, resource });\n\n    return {\n      group: CATCHALL_BIND_GROUP_IDX_MARKER,\n      binding,\n    };\n  }\n\n  readSlot<T>(slot: TgpuSlot<T>): T {\n    const value = this._itemStateStack.readSlot(slot);\n\n    if (value === undefined) {\n      throw new MissingSlotValueError(slot);\n    }\n\n    return value;\n  }\n\n  withSlots<T>(pairs: SlotValuePair<unknown>[], callback: () => T): T {\n    this._itemStateStack.pushSlotBindings(pairs);\n\n    try {\n      return callback();\n    } finally {\n      this._itemStateStack.popSlotBindings();\n    }\n  }\n\n  withVaryingLocations<T>(\n    locations: Record<string, number>,\n    callback: () => T,\n  ): T {\n    this._varyingLocations = locations;\n\n    try {\n      return callback();\n    } finally {\n      this._varyingLocations = undefined;\n    }\n  }\n\n  unwrap<T>(eventual: Eventual<T>): T {\n    if (isProviding(eventual)) {\n      return this.withSlots(\n        eventual[$providing].pairs,\n        () => this.unwrap(eventual[$providing].inner) as T,\n      );\n    }\n\n    let maybeEventual = eventual;\n\n    // Unwrapping all layers of slots.\n    while (true) {\n      if (isSlot(maybeEventual)) {\n        maybeEventual = this.readSlot(maybeEventual);\n      } else if (isDerived(maybeEventual)) {\n        maybeEventual = this._getOrCompute(maybeEventual);\n      } else {\n        break;\n      }\n    }\n\n    return maybeEventual;\n  }\n\n  _getOrCompute<T>(derived: TgpuDerived<T>): T {\n    // All memoized versions of `derived`\n    const instances = this._memoizedDerived.get(derived) ?? [];\n\n    this._itemStateStack.pushItem();\n\n    try {\n      for (const instance of instances) {\n        const slotValuePairs = [...instance.slotToValueMap.entries()];\n\n        if (\n          slotValuePairs.every(([slot, expectedValue]) =>\n            slot.areEqual(this._itemStateStack.readSlot(slot), expectedValue)\n          )\n        ) {\n          return instance.result as T;\n        }\n      }\n\n      // If we got here, no item with the given slot-to-value combo exists in cache yet\n      // Derived computations are always done on the CPU\n      pushMode(RuntimeMode.CPU);\n\n      let result: T;\n      try {\n        result = derived['~compute']();\n      } finally {\n        popMode(RuntimeMode.CPU);\n      }\n\n      // We know which slots the item used while resolving\n      const slotToValueMap = new Map<TgpuSlot<unknown>, unknown>();\n      for (const usedSlot of this._itemStateStack.topItem.usedSlots) {\n        slotToValueMap.set(usedSlot, this._itemStateStack.readSlot(usedSlot));\n      }\n\n      instances.push({ slotToValueMap, result });\n      this._memoizedDerived.set(derived, instances);\n      return result;\n    } catch (err) {\n      if (err instanceof ResolutionError) {\n        throw err.appendToTrace(derived);\n      }\n\n      throw new ResolutionError(err, [derived]);\n    } finally {\n      this._itemStateStack.popItem();\n    }\n  }\n\n  /**\n   * @param item The item whose resolution should be either retrieved from the cache (if there is a cache hit), or resolved.\n   */\n  _getOrInstantiate(item: object): string {\n    // All memoized versions of `item`\n    const instances = this._memoizedResolves.get(item) ?? [];\n\n    this._itemStateStack.pushItem();\n\n    try {\n      for (const instance of instances) {\n        const slotValuePairs = [...instance.slotToValueMap.entries()];\n\n        if (\n          slotValuePairs.every(([slot, expectedValue]) =>\n            slot.areEqual(this._itemStateStack.readSlot(slot), expectedValue)\n          )\n        ) {\n          return instance.result;\n        }\n      }\n\n      // If we got here, no item with the given slot-to-value combo exists in cache yet\n      let result: string;\n      if (isData(item)) {\n        result = resolveData(this, item);\n      } else if (isDerived(item) || isSlot(item)) {\n        result = this.resolve(this.unwrap(item));\n      } else if (isSelfResolvable(item)) {\n        result = item['~resolve'](this);\n      } else {\n        result = this.resolveValue(item);\n      }\n\n      // We know which slots the item used while resolving\n      const slotToValueMap = new Map<TgpuSlot<unknown>, unknown>();\n      for (const usedSlot of this._itemStateStack.topItem.usedSlots) {\n        slotToValueMap.set(usedSlot, this._itemStateStack.readSlot(usedSlot));\n      }\n\n      instances.push({ slotToValueMap, result });\n      this._memoizedResolves.set(item, instances);\n\n      return result;\n    } catch (err) {\n      if (err instanceof ResolutionError) {\n        throw err.appendToTrace(item);\n      }\n\n      throw new ResolutionError(err, [item]);\n    } finally {\n      this._itemStateStack.popItem();\n    }\n  }\n\n  resolve(item: unknown): string {\n    if (isProviding(item)) {\n      return this.withSlots(\n        item[$providing].pairs,\n        () => this.resolve(item[$providing].inner),\n      );\n    }\n\n    if ((item && typeof item === 'object') || typeof item === 'function') {\n      if (this._itemStateStack.itemDepth === 0) {\n        try {\n          pushMode(RuntimeMode.GPU);\n          const result = provideCtx(this, () => this._getOrInstantiate(item));\n          return `${[...this._declarations].join('\\n\\n')}${result}`;\n        } finally {\n          popMode(RuntimeMode.GPU);\n        }\n      }\n\n      return this._getOrInstantiate(item);\n    }\n\n    return String(item);\n  }\n\n  resolveValue<T extends BaseData>(\n    value: Infer<T>,\n    schema?: T | undefined,\n  ): string {\n    if (isWgsl(value)) {\n      return this.resolve(value);\n    }\n\n    if (schema && isWgslArray(schema)) {\n      return `array(${\n        (value as unknown[]).map((element) =>\n          this.resolveValue(element, schema.elementType)\n        )\n      })`;\n    }\n\n    if (Array.isArray(value)) {\n      return `array(${value.map((element) => this.resolveValue(element))})`;\n    }\n\n    if (schema && isWgslStruct(schema)) {\n      return `${this.resolve(schema)}(${\n        Object.entries(schema.propTypes).map(([key, type_]) =>\n          this.resolveValue((value as Infer<typeof schema>)[key], type_)\n        )\n      })`;\n    }\n\n    throw new Error(\n      `Value ${value} (as json: ${\n        JSON.stringify(value)\n      }) of schema ${schema} is not resolvable to WGSL`,\n    );\n  }\n}\n\n/**\n * The results of a WGSL resolution.\n *\n * @param code - The resolved code.\n * @param usedBindGroupLayouts - List of used `tgpu.bindGroupLayout`s.\n * @param catchall - Automatically constructed bind group for buffer usages and buffer shorthands, preceded by its index.\n */\nexport interface ResolutionResult {\n  code: string;\n  usedBindGroupLayouts: TgpuBindGroupLayout[];\n  catchall: [number, TgpuBindGroup] | undefined;\n}\n\nexport function resolve(\n  item: Wgsl,\n  options: ResolutionCtxImplOptions,\n): ResolutionResult {\n  const ctx = new ResolutionCtxImpl(options);\n  let code = ctx.resolve(item);\n\n  const memoMap = ctx.bindGroupLayoutsToPlaceholderMap;\n  const usedBindGroupLayouts: TgpuBindGroupLayout[] = [];\n  const takenIndices = new Set<number>(\n    [...memoMap.keys()]\n      .map((layout) => layout.index)\n      .filter((v): v is number => v !== undefined),\n  );\n\n  const automaticIds = naturalsExcept(takenIndices);\n\n  const layoutEntries = ctx.fixedBindings.map(\n    (binding, idx) =>\n      [String(idx), binding.layoutEntry] as [string, TgpuLayoutEntry],\n  );\n\n  const createCatchallGroup = () => {\n    const catchallIdx = automaticIds.next().value;\n    const catchallLayout = bindGroupLayout(Object.fromEntries(layoutEntries));\n    usedBindGroupLayouts[catchallIdx] = catchallLayout;\n    code = code.replaceAll(CATCHALL_BIND_GROUP_IDX_MARKER, String(catchallIdx));\n\n    return [\n      catchallIdx,\n      new TgpuBindGroupImpl(\n        catchallLayout,\n        Object.fromEntries(\n          ctx.fixedBindings.map(\n            (binding, idx) =>\n              // biome-ignore lint/suspicious/noExplicitAny: <it's fine>\n              [String(idx), binding.resource] as [string, any],\n          ),\n        ),\n      ),\n    ] as [number, TgpuBindGroup];\n  };\n\n  // Retrieving the catch-all binding index first, because it's inherently\n  // the least swapped bind group (fixed and cannot be swapped).\n  const catchall = layoutEntries.length > 0 ? createCatchallGroup() : undefined;\n\n  for (const [layout, placeholder] of memoMap.entries()) {\n    const idx = layout.index ?? automaticIds.next().value;\n    usedBindGroupLayouts[idx] = layout;\n    code = code.replaceAll(placeholder, String(idx));\n  }\n\n  return {\n    code,\n    usedBindGroupLayouts,\n    catchall,\n  };\n}\n\nexport function resolveFunctionHeader(\n  ctx: ResolutionCtx,\n  args: Snippet[],\n  returnType: AnyData,\n) {\n  const argList = args\n    .map((arg) => `${arg.value}: ${ctx.resolve(arg.dataType as AnyData)}`)\n    .join(', ');\n\n  return returnType.type !== 'void'\n    ? `(${argList}) -> ${getAttributesString(returnType)} ${\n      ctx.resolve(returnType)\n    }`\n    : `(${argList})`;\n}\n", "import { RandomNameRegistry, StrictNameRegistry } from '../../nameRegistry.ts';\nimport {\n  type ResolutionResult,\n  resolve as resolveImpl,\n} from '../../resolutionCtx.ts';\nimport type { SelfResolvable, Wgsl } from '../../types.ts';\nimport { applyExternals, replaceExternalsInWgsl } from './externals.ts';\n\nexport interface TgpuResolveOptions {\n  /**\n   * Map of external names to their resolvable values.\n   */\n  externals: Record<string, Wgsl | object>;\n  /**\n   * The code template to use for the resolution. All external names will be replaced with their resolved values.\n   * @default ''\n   */\n  template?: string | undefined;\n  /**\n   * The naming strategy used for generating identifiers for resolved externals and their dependencies.\n   * @default 'random'\n   */\n  names?: 'strict' | 'random' | undefined;\n}\n\n/**\n * Resolves a template with external values. Each external will get resolved to a code string and replaced in the template.\n * Any dependencies of the externals will also be resolved and included in the output.\n * @param options - The options for the resolution.\n *\n * @returns {ResolutionResult}\n *\n * @example\n * ```ts\n * const Gradient = d.struct({\n *   from: d.vec3f,\n *   to: d.vec3f,\n * });\n *\n * const { code, usedBindGroupLayouts, catchall } = tgpu.resolveWithContext({\n *   template: `\n *     fn getGradientAngle(gradient: Gradient) -> f32 {\n *       return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n *     }\n *   `,\n *   externals: {\n *     Gradient,\n *   },\n * });\n *\n * console.log(code);\n * // struct Gradient_0 {\n * //   from: vec3f,\n * //   to: vec3f,\n * // }\n * // fn getGradientAngle(gradient: Gradient_0) -> f32 {\n * //   return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n * // }\n * ```\n */\nexport function resolveWithContext(\n  options: TgpuResolveOptions,\n): ResolutionResult {\n  const {\n    externals,\n    template,\n    names,\n  } = options;\n\n  const dependencies = {} as Record<string, Wgsl>;\n  applyExternals(dependencies, externals ?? {});\n\n  const resolutionObj: SelfResolvable = {\n    '~resolve'(ctx) {\n      return replaceExternalsInWgsl(ctx, dependencies, template ?? '');\n    },\n\n    toString: () => '<root>',\n  };\n\n  return resolveImpl(resolutionObj, {\n    names: names === 'strict'\n      ? new StrictNameRegistry()\n      : new RandomNameRegistry(),\n  });\n}\n\n/**\n * Resolves a template with external values. Each external will get resolved to a code string and replaced in the template.\n * Any dependencies of the externals will also be resolved and included in the output.\n * @param options - The options for the resolution.\n *\n * @returns The resolved code.\n *\n * @example\n * ```ts\n * const Gradient = d.struct({\n *   from: d.vec3f,\n *   to: d.vec3f,\n * });\n *\n * const resolved = tgpu.resolve({\n *   template: `\n *     fn getGradientAngle(gradient: Gradient) -> f32 {\n *       return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n *     }\n *   `,\n *   externals: {\n *     Gradient,\n *   },\n * });\n *\n * console.log(resolved);\n * // struct Gradient_0 {\n * //   from: vec3f,\n * //   to: vec3f,\n * // }\n * // fn getGradientAngle(gradient: Gradient_0) -> f32 {\n * //   return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n * // }\n * ```\n */\nexport function resolve(options: TgpuResolveOptions): string {\n  return resolveWithContext(options).code;\n}\n", "import { setName, type TgpuNamable } from '../../shared/meta.ts';\nimport type { ExperimentalTgpuRoot } from '../../core/root/rootTypes.ts';\nimport { $internal } from '../../shared/symbols.ts';\n\nexport interface TgpuQuerySet<T extends GPUQueryType> extends TgpuNamable {\n  readonly resourceType: 'query-set';\n  readonly type: T;\n  readonly count: number;\n\n  readonly querySet: GPUQuerySet;\n  readonly destroyed: boolean;\n  readonly available: boolean;\n\n  readonly [$internal]: {\n    readonly readBuffer: GPUBuffer;\n    readonly resolveBuffer: GPUBuffer;\n  };\n\n  resolve(): void;\n  read(): Promise<bigint[]>;\n  destroy(): void;\n}\n\nexport function INTERNAL_createQuerySet<T extends GPUQueryType>(\n  group: ExperimentalTgpuRoot,\n  type: T,\n  count: number,\n  rawQuerySet?: GPUQuerySet,\n): TgpuQuerySet<T> {\n  return new TgpuQuerySetImpl(group, type, count, rawQuerySet);\n}\n\nexport function isQuerySet<T extends GPUQueryType>(\n  value: unknown,\n): value is TgpuQuerySet<T> {\n  const maybe = value as TgpuQuerySet<T>;\n  return maybe?.resourceType === 'query-set' && !!maybe[$internal];\n}\n\nclass TgpuQuerySetImpl<T extends GPUQueryType> implements TgpuQuerySet<T> {\n  public readonly resourceType = 'query-set' as const;\n  private _querySet: GPUQuerySet | null = null;\n  private readonly _ownQuerySet: boolean;\n  private _destroyed = false;\n  private _available = true;\n  private _readBuffer: GPUBuffer | null = null;\n  private _resolveBuffer: GPUBuffer | null = null;\n\n  constructor(\n    private readonly _group: ExperimentalTgpuRoot,\n    public readonly type: T,\n    public readonly count: number,\n    private readonly rawQuerySet?: GPUQuerySet,\n  ) {\n    this._ownQuerySet = !rawQuerySet;\n    this._querySet = rawQuerySet || null;\n  }\n\n  get querySet(): GPUQuerySet {\n    if (this._destroyed) {\n      throw new Error('This QuerySet has been destroyed.');\n    }\n    if (this.rawQuerySet) {\n      return this.rawQuerySet;\n    }\n    if (this._querySet) {\n      return this._querySet;\n    }\n\n    this._querySet = this._group.device.createQuerySet({\n      type: this.type,\n      count: this.count,\n    });\n    return this._querySet;\n  }\n\n  get destroyed(): boolean {\n    return this._destroyed;\n  }\n\n  get available(): boolean {\n    return this._available;\n  }\n\n  get [$internal]() {\n    const self = this;\n    return {\n      get readBuffer(): GPUBuffer {\n        if (!self._readBuffer) {\n          self._readBuffer = self._group.device.createBuffer({\n            size: self.count * BigUint64Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n          });\n        }\n        return self._readBuffer;\n      },\n      get resolveBuffer(): GPUBuffer {\n        if (!self._resolveBuffer) {\n          self._resolveBuffer = self._group.device.createBuffer({\n            size: self.count * BigUint64Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n          });\n        }\n        return self._resolveBuffer;\n      },\n    };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    if (this._querySet) {\n      this._querySet.label = label;\n    }\n    return this;\n  }\n\n  resolve(): void {\n    if (this._destroyed) {\n      throw new Error('This QuerySet has been destroyed.');\n    }\n    if (!this._available) {\n      throw new Error('This QuerySet is busy resolving or reading.');\n    }\n\n    const commandEncoder = this._group.device.createCommandEncoder();\n    commandEncoder.resolveQuerySet(\n      this.querySet,\n      0,\n      this.count,\n      this[$internal].resolveBuffer,\n      0,\n    );\n    this._group.device.queue.submit([commandEncoder.finish()]);\n  }\n\n  async read(): Promise<bigint[]> {\n    this._group.flush();\n    if (!this._resolveBuffer) {\n      throw new Error('QuerySet must be resolved before reading.');\n    }\n\n    this._available = false;\n    try {\n      const commandEncoder = this._group.device.createCommandEncoder();\n      commandEncoder.copyBufferToBuffer(\n        this[$internal].resolveBuffer,\n        0,\n        this[$internal].readBuffer,\n        0,\n        this.count * BigUint64Array.BYTES_PER_ELEMENT,\n      );\n      this._group.device.queue.submit([commandEncoder.finish()]);\n      await this._group.device.queue.onSubmittedWorkDone();\n\n      const readBuffer = this[$internal].readBuffer;\n      await readBuffer.mapAsync(GPUMapMode.READ);\n      const data = new BigUint64Array(readBuffer.getMappedRange().slice());\n      readBuffer.unmap();\n      return Array.from(data);\n    } finally {\n      this._available = true;\n    }\n  }\n\n  destroy(): void {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n\n    if (this._querySet && this._ownQuerySet) {\n      this._querySet.destroy();\n    }\n    this._readBuffer?.destroy();\n    this._resolveBuffer?.destroy();\n    this._readBuffer = this._resolveBuffer = null;\n  }\n}\n", "/**\n * Caches results of the function passed in as\n * the argument to the constructor.\n *\n * If the key can be garbage collected, it will be.\n */\nexport class WeakMemo<TKey extends object, TValue, TArgs extends unknown[]> {\n  private readonly _map = new WeakMap<TKey, TValue>();\n\n  constructor(private readonly _make: (key: TKey, ...args: TArgs) => TValue) {}\n\n  getOrMake(key: TKey, ...args: TArgs): TValue {\n    if (this._map.has(key)) {\n      return this._map.get(key) as TValue;\n    }\n\n    const value = this._make(key, ...args);\n    this._map.set(key, value);\n    return value;\n  }\n}\n", "import { isQuerySet, type TgpuQuerySet } from '../querySet/querySet.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport { $internal } from '../../shared/symbols.ts';\n\nexport interface Timeable {\n  withPerformanceCallback(\n    callback: (start: bigint, end: bigint) => void | Promise<void>,\n  ): this;\n\n  withTimestampWrites(options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  }): this;\n}\n\nexport type TimestampWritesPriors = {\n  readonly timestampWrites?: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  };\n  readonly performanceCallback?: (\n    start: bigint,\n    end: bigint,\n  ) => void | Promise<void>;\n  readonly hasAutoQuerySet?: boolean;\n};\n\nexport function createWithPerformanceCallback<T extends TimestampWritesPriors>(\n  currentPriors: T,\n  callback: (start: bigint, end: bigint) => void | Promise<void>,\n  root: ExperimentalTgpuRoot,\n): T {\n  if (!root.enabledFeatures.has('timestamp-query')) {\n    throw new Error(\n      'Performance callback requires the \"timestamp-query\" feature to be enabled on GPU device.',\n    );\n  }\n\n  if (!currentPriors.timestampWrites) {\n    return {\n      ...currentPriors,\n      performanceCallback: callback,\n      hasAutoQuerySet: true,\n      timestampWrites: {\n        querySet: root.createQuerySet('timestamp', 2),\n        beginningOfPassWriteIndex: 0,\n        endOfPassWriteIndex: 1,\n      },\n    };\n  }\n\n  return {\n    ...currentPriors,\n    performanceCallback: callback,\n  };\n}\n\nexport function createWithTimestampWrites<T extends TimestampWritesPriors>(\n  currentPriors: T,\n  options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  },\n  root: ExperimentalTgpuRoot,\n): T {\n  if (!root.enabledFeatures.has('timestamp-query')) {\n    throw new Error(\n      'Timestamp writes require the \"timestamp-query\" feature to be enabled on GPU device.',\n    );\n  }\n\n  if (currentPriors.hasAutoQuerySet && currentPriors.timestampWrites) {\n    currentPriors.timestampWrites.querySet.destroy();\n  }\n\n  const timestampWrites: TimestampWritesPriors['timestampWrites'] = {\n    querySet: options.querySet,\n  };\n\n  if (options.beginningOfPassWriteIndex !== undefined) {\n    timestampWrites.beginningOfPassWriteIndex =\n      options.beginningOfPassWriteIndex;\n  }\n  if (options.endOfPassWriteIndex !== undefined) {\n    timestampWrites.endOfPassWriteIndex = options.endOfPassWriteIndex;\n  }\n\n  return {\n    ...currentPriors,\n    hasAutoQuerySet: false,\n    timestampWrites,\n  };\n}\n\nexport function setupTimestampWrites(\n  priors: TimestampWritesPriors,\n  root: ExperimentalTgpuRoot,\n): {\n  timestampWrites?:\n    | GPUComputePassTimestampWrites\n    | GPURenderPassTimestampWrites;\n} {\n  if (!priors.timestampWrites) {\n    return {};\n  }\n\n  const { querySet, beginningOfPassWriteIndex, endOfPassWriteIndex } =\n    priors.timestampWrites;\n\n  const timestampWrites:\n    | GPUComputePassTimestampWrites\n    | GPURenderPassTimestampWrites = {\n      querySet: isQuerySet(querySet) ? root.unwrap(querySet) : querySet,\n    };\n\n  if (beginningOfPassWriteIndex !== undefined) {\n    timestampWrites.beginningOfPassWriteIndex = beginningOfPassWriteIndex;\n  }\n  if (endOfPassWriteIndex !== undefined) {\n    timestampWrites.endOfPassWriteIndex = endOfPassWriteIndex;\n  }\n\n  return { timestampWrites };\n}\n\nexport function triggerPerformanceCallback({\n  root,\n  priors,\n}: {\n  root: ExperimentalTgpuRoot;\n  priors: TimestampWritesPriors;\n}): void | Promise<void> {\n  const querySet = priors.timestampWrites?.querySet;\n  const callback = priors.performanceCallback as (\n    start: bigint,\n    end: bigint,\n  ) => void | Promise<void>;\n\n  if (!querySet) {\n    throw new Error(\n      'Cannot dispatch workgroups with performance callback without a query set.',\n    );\n  }\n\n  if (!isQuerySet(querySet)) {\n    throw new Error(\n      'Performance callback with raw GPUQuerySet is not supported. Use TgpuQuerySet instead.',\n    );\n  }\n\n  root.commandEncoder.resolveQuerySet(\n    root.unwrap(querySet),\n    0,\n    querySet.count,\n    querySet[$internal].resolveBuffer,\n    0,\n  );\n\n  root.flush();\n  root.device.queue.onSubmittedWorkDone().then(async () => {\n    if (!querySet.available) {\n      return;\n    }\n    const result = await querySet.read();\n    const start =\n      result[priors.timestampWrites?.beginningOfPassWriteIndex ?? 0];\n    const end = result[priors.timestampWrites?.endOfPassWriteIndex ?? 1];\n\n    if (start === undefined || end === undefined) {\n      throw new Error('QuerySet did not return valid timestamps.');\n    }\n\n    await callback(start, end);\n  });\n}\n", "import type { TgpuQuerySet } from '../../core/querySet/querySet.ts';\nimport { MissingBindGroupsError } from '../../errors.ts';\nimport { type ResolutionResult, resolve } from '../../resolutionCtx.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type {\n  TgpuBindGroup,\n  TgpuBindGroupLayout,\n} from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { TgpuComputeFn } from '../function/tgpuComputeFn.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport type { TgpuSlot } from '../slot/slotTypes.ts';\nimport {\n  createWithPerformanceCallback,\n  createWithTimestampWrites,\n  setupTimestampWrites,\n  type Timeable,\n  type TimestampWritesPriors,\n  triggerPerformanceCallback,\n} from './timeable.ts';\nimport { PERF } from '../../shared/meta.ts';\n\ninterface ComputePipelineInternals {\n  readonly rawPipeline: GPUComputePipeline;\n  readonly priors: TgpuComputePipelinePriors & TimestampWritesPriors;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuComputePipeline\n  extends TgpuNamable, SelfResolvable, Timeable {\n  readonly [$internal]: ComputePipelineInternals;\n  readonly resourceType: 'compute-pipeline';\n\n  with(\n    bindGroupLayout: TgpuBindGroupLayout,\n    bindGroup: TgpuBindGroup,\n  ): TgpuComputePipeline;\n\n  dispatchWorkgroups(\n    x: number,\n    y?: number | undefined,\n    z?: number | undefined,\n  ): void;\n}\n\nexport function INTERNAL_createComputePipeline(\n  branch: ExperimentalTgpuRoot,\n  slotBindings: [TgpuSlot<unknown>, unknown][],\n  entryFn: TgpuComputeFn,\n) {\n  return new TgpuComputePipelineImpl(\n    new ComputePipelineCore(branch, slotBindings, entryFn),\n    {},\n  );\n}\n\nexport function isComputePipeline(\n  value: unknown,\n): value is TgpuComputePipeline {\n  const maybe = value as TgpuComputePipeline | undefined;\n  return maybe?.resourceType === 'compute-pipeline' && !!maybe[$internal];\n}\n\n// --------------\n// Implementation\n// --------------\n\ntype TgpuComputePipelinePriors = {\n  readonly bindGroupLayoutMap?: Map<TgpuBindGroupLayout, TgpuBindGroup>;\n} & TimestampWritesPriors;\n\ntype Memo = {\n  pipeline: GPUComputePipeline;\n  usedBindGroupLayouts: TgpuBindGroupLayout[];\n  catchall: [number, TgpuBindGroup] | undefined;\n};\n\nclass TgpuComputePipelineImpl implements TgpuComputePipeline {\n  public readonly [$internal]: ComputePipelineInternals;\n  public readonly resourceType = 'compute-pipeline';\n  readonly [$getNameForward]: ComputePipelineCore;\n\n  constructor(\n    private readonly _core: ComputePipelineCore,\n    private readonly _priors: TgpuComputePipelinePriors,\n  ) {\n    this[$internal] = {\n      get rawPipeline() {\n        return _core.unwrap().pipeline;\n      },\n      get priors() {\n        return _priors;\n      },\n    };\n    this[$getNameForward] = _core;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    return ctx.resolve(this._core);\n  }\n\n  toString(): string {\n    return `computePipeline:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get rawPipeline(): GPUComputePipeline {\n    return this._core.unwrap().pipeline;\n  }\n\n  with(\n    bindGroupLayout: TgpuBindGroupLayout,\n    bindGroup: TgpuBindGroup,\n  ): TgpuComputePipeline {\n    return new TgpuComputePipelineImpl(this._core, {\n      ...this._priors,\n      bindGroupLayoutMap: new Map([\n        ...(this._priors.bindGroupLayoutMap ?? []),\n        [bindGroupLayout, bindGroup],\n      ]),\n    });\n  }\n\n  withPerformanceCallback(\n    callback: (start: bigint, end: bigint) => void | Promise<void>,\n  ): this {\n    const newPriors = createWithPerformanceCallback(\n      this._priors,\n      callback,\n      this._core.branch,\n    );\n    return new TgpuComputePipelineImpl(this._core, newPriors) as this;\n  }\n\n  withTimestampWrites(options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  }): this {\n    const newPriors = createWithTimestampWrites(\n      this._priors,\n      options,\n      this._core.branch,\n    );\n    return new TgpuComputePipelineImpl(this._core, newPriors) as this;\n  }\n\n  dispatchWorkgroups(\n    x: number,\n    y?: number | undefined,\n    z?: number | undefined,\n  ): void {\n    const memo = this._core.unwrap();\n    const { branch } = this._core;\n\n    const passDescriptor: GPUComputePassDescriptor = {\n      label: getName(this._core) ?? '<unnamed>',\n      ...setupTimestampWrites(this._priors, branch),\n    };\n\n    const pass = branch.commandEncoder.beginComputePass(passDescriptor);\n\n    pass.setPipeline(memo.pipeline);\n\n    const missingBindGroups = new Set(memo.usedBindGroupLayouts);\n\n    memo.usedBindGroupLayouts.forEach((layout, idx) => {\n      if (memo.catchall && idx === memo.catchall[0]) {\n        // Catch-all\n        pass.setBindGroup(idx, branch.unwrap(memo.catchall[1]));\n        missingBindGroups.delete(layout);\n      } else {\n        const bindGroup = this._priors.bindGroupLayoutMap?.get(layout);\n        if (bindGroup !== undefined) {\n          missingBindGroups.delete(layout);\n          pass.setBindGroup(idx, branch.unwrap(bindGroup));\n        }\n      }\n    });\n\n    if (missingBindGroups.size > 0) {\n      throw new MissingBindGroupsError(missingBindGroups);\n    }\n\n    pass.dispatchWorkgroups(x, y, z);\n    pass.end();\n\n    if (this._priors.performanceCallback) {\n      triggerPerformanceCallback({\n        root: branch,\n        priors: this._priors,\n      });\n    }\n  }\n\n  $name(label: string): this {\n    setName(this._core, label);\n    return this;\n  }\n}\n\nclass ComputePipelineCore implements SelfResolvable {\n  private _memo: Memo | undefined;\n\n  constructor(\n    public readonly branch: ExperimentalTgpuRoot,\n    private readonly _slotBindings: [TgpuSlot<unknown>, unknown][],\n    private readonly _entryFn: TgpuComputeFn,\n  ) {}\n\n  '~resolve'(ctx: ResolutionCtx) {\n    return ctx.withSlots(this._slotBindings, () => {\n      ctx.resolve(this._entryFn);\n      return '';\n    });\n  }\n\n  toString() {\n    return 'computePipelineCore';\n  }\n\n  public unwrap(): Memo {\n    if (this._memo === undefined) {\n      const device = this.branch.device;\n\n      // Resolving code\n      let resolutionResult: ResolutionResult;\n\n      let resolveMeasure: PerformanceMeasure | undefined;\n      if (PERF?.enabled) {\n        const resolveStart = performance.mark('typegpu:resolution:start');\n        resolutionResult = resolve(this, {\n          names: this.branch.nameRegistry,\n        });\n        resolveMeasure = performance.measure('typegpu:resolution', {\n          start: resolveStart.name,\n        });\n      } else {\n        resolutionResult = resolve(this, {\n          names: this.branch.nameRegistry,\n        });\n      }\n\n      const { code, usedBindGroupLayouts, catchall } = resolutionResult;\n\n      if (catchall !== undefined) {\n        usedBindGroupLayouts[catchall[0]]?.$name(\n          `${getName(this) ?? '<unnamed>'} - Automatic Bind Group & Layout`,\n        );\n      }\n\n      const module = device.createShaderModule({\n        label: `${getName(this) ?? '<unnamed>'} - Shader`,\n        code,\n      });\n\n      this._memo = {\n        pipeline: device.createComputePipeline({\n          label: getName(this) ?? '<unnamed>',\n          layout: device.createPipelineLayout({\n            label: `${getName(this) ?? '<unnamed>'} - Pipeline Layout`,\n            bindGroupLayouts: usedBindGroupLayouts.map((l) =>\n              this.branch.unwrap(l)\n            ),\n          }),\n          compute: { module },\n        }),\n        usedBindGroupLayouts,\n        catchall,\n      };\n\n      if (PERF?.enabled) {\n        (async () => {\n          const start = performance.mark('typegpu:compile-start');\n          await device.queue.onSubmittedWorkDone();\n          const compileMeasure = performance.measure('typegpu:compiled', {\n            start: start.name,\n          });\n\n          PERF?.record('resolution', {\n            resolveDuration: resolveMeasure?.duration,\n            compileDuration: compileMeasure.duration,\n            wgslSize: code.length,\n          });\n        })();\n      }\n    }\n\n    return this._memo;\n  }\n}\n", "import { alignmentOf, customAlignmentOf } from '../../data/alignmentOf.ts';\nimport type { Disarray } from '../../data/dataTypes.ts';\nimport {\n  getCustomLocation,\n  isLooseDecorated,\n  isUnstruct,\n} from '../../data/dataTypes.ts';\nimport { sizeOf } from '../../data/sizeOf.ts';\nimport type { BaseData, WgslArray } from '../../data/wgslTypes.ts';\nimport { isDecorated, isWgslStruct } from '../../data/wgslTypes.ts';\nimport { roundUp } from '../../mathUtils.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { setName } from '../../shared/meta.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport {\n  kindToDefaultFormatMap,\n  type TgpuVertexAttrib,\n  type VertexFormat,\n  vertexFormats,\n} from '../../shared/vertexFormat.ts';\nimport type {\n  ArrayToContainedAttribs,\n  DataToContainedAttribs,\n} from './vertexAttribute.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuVertexLayout<\n  TData extends WgslArray | Disarray = WgslArray | Disarray,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'vertex-layout';\n  readonly stride: number;\n  readonly stepMode: 'vertex' | 'instance';\n  readonly attrib: ArrayToContainedAttribs<TData>;\n  readonly vertexLayout: GPUVertexBufferLayout;\n  schemaForCount(n: number): TData;\n}\n\nexport interface INTERNAL_TgpuVertexAttrib {\n  readonly _layout: TgpuVertexLayout;\n}\n\nexport function vertexLayout<TData extends WgslArray | Disarray>(\n  schemaForCount: (count: number) => TData,\n  stepMode: 'vertex' | 'instance' = 'vertex',\n): TgpuVertexLayout<TData> {\n  return new TgpuVertexLayoutImpl(schemaForCount, stepMode);\n}\n\nexport function isVertexLayout<T extends TgpuVertexLayout>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.resourceType === 'vertex-layout';\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst defaultAttribEntry = Symbol('defaultAttribEntry');\n\nfunction dataToContainedAttribs<\n  TLayoutData extends WgslArray | Disarray,\n  TData extends BaseData,\n>(\n  layout: TgpuVertexLayout<TLayoutData>,\n  data: TData,\n  offset: number,\n  customLocationMap: Record<string | symbol, number>,\n  key?: string,\n): DataToContainedAttribs<TData> {\n  if (isDecorated(data) || isLooseDecorated(data)) {\n    const customLocation = getCustomLocation(data);\n    if (customLocation !== undefined) {\n      customLocationMap[key ?? defaultAttribEntry] = customLocation;\n    }\n\n    return dataToContainedAttribs(\n      layout,\n      data.inner,\n      roundUp(offset, customAlignmentOf(data)),\n      customLocationMap,\n    );\n  }\n\n  if (isWgslStruct(data)) {\n    let memberOffset = offset;\n\n    return Object.fromEntries(\n      Object.entries(data.propTypes).map(([key, value]) => {\n        memberOffset = roundUp(memberOffset, alignmentOf(value));\n        const attrib = [\n          key,\n          dataToContainedAttribs(\n            layout,\n            value,\n            memberOffset,\n            customLocationMap,\n            key,\n          ),\n        ];\n        memberOffset += sizeOf(value);\n        return attrib;\n      }),\n    ) as DataToContainedAttribs<TData>;\n  }\n\n  if (isUnstruct(data)) {\n    let memberOffset = offset;\n\n    return Object.fromEntries(\n      Object.entries(data.propTypes).map(([key, value]) => {\n        memberOffset = roundUp(memberOffset, customAlignmentOf(value));\n        const attrib = [\n          key,\n          dataToContainedAttribs(\n            layout,\n            value,\n            memberOffset,\n            customLocationMap,\n            key,\n          ),\n        ];\n        memberOffset += sizeOf(value);\n        return attrib;\n      }),\n    ) as DataToContainedAttribs<TData>;\n  }\n\n  if ('type' in data && typeof data.type === 'string') {\n    if (vertexFormats.includes(data.type as VertexFormat)) {\n      return {\n        _layout: layout, // hidden property, used to determine which buffers to apply when executing the pipeline\n        format: data.type as VertexFormat,\n        offset,\n        // biome-ignore lint/suspicious/noExplicitAny: <too many type shenanigans>\n      } satisfies TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib as any;\n    }\n\n    const format = (kindToDefaultFormatMap as Record<string, VertexFormat>)[\n      data.type\n    ];\n\n    if (format) {\n      return {\n        _layout: layout, // hidden property, used to determine which buffers to apply when executing the pipeline\n        format,\n        offset,\n        // biome-ignore lint/suspicious/noExplicitAny: <too many type shenanigans>\n      } satisfies TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib as any;\n    }\n  }\n\n  throw new Error(`Unsupported data used in vertex layout: ${String(data)}`);\n}\n\nclass TgpuVertexLayoutImpl<TData extends WgslArray | Disarray>\n  implements TgpuVertexLayout<TData> {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'vertex-layout';\n  public readonly stride: number;\n  public readonly attrib: ArrayToContainedAttribs<TData>;\n  private readonly _customLocationMap = {} as Record<string | symbol, number>;\n\n  constructor(\n    public readonly schemaForCount: (count: number) => TData,\n    public readonly stepMode: 'vertex' | 'instance',\n  ) {\n    // `0` signals that the data-type is runtime-sized, and should not be used to create buffers.\n    const arraySchema = schemaForCount(0);\n\n    this.stride = roundUp(\n      sizeOf(arraySchema.elementType),\n      alignmentOf(arraySchema),\n    );\n    this.attrib = dataToContainedAttribs(\n      this,\n      arraySchema.elementType,\n      0,\n      this._customLocationMap,\n    );\n  }\n\n  get vertexLayout(): GPUVertexBufferLayout {\n    // If defaultAttribEntry is in the custom location map,\n    // it means that the vertex layout is based on a single attribute\n    if (this._customLocationMap[defaultAttribEntry] !== undefined) {\n      if (\n        typeof this.attrib.format !== 'string' ||\n        typeof this.attrib.offset !== 'number'\n      ) {\n        throw new Error(\n          'Single attribute vertex layouts must have a format and offset.',\n        );\n      }\n\n      return {\n        arrayStride: this.stride,\n        stepMode: this.stepMode,\n        attributes: [\n          {\n            format: this.attrib.format,\n            offset: this.attrib.offset,\n            shaderLocation: this._customLocationMap[defaultAttribEntry],\n          },\n        ],\n      };\n    }\n\n    // check if all attributes have custom locations\n    const allAttributesHaveCustomLocations = Object.keys(this.attrib).every(\n      (key) => this._customLocationMap[key] !== undefined,\n    );\n\n    if (!allAttributesHaveCustomLocations) {\n      throw new Error(\n        'All attributes must have custom locations in order to unwrap a vertex layout.',\n      );\n    }\n\n    return {\n      arrayStride: this.stride,\n      stepMode: this.stepMode,\n      attributes: [\n        ...Object.entries(this.attrib).map(([key, attrib]) => ({\n          format: attrib.format,\n          offset: attrib.offset,\n          shaderLocation: this._customLocationMap[key],\n        })),\n      ] as GPUVertexAttribute[],\n    };\n  }\n\n  $name(label: string): this {\n    setName(this, label);\n    return this;\n  }\n}\n", "import { isData } from '../../data/dataTypes.ts';\nimport type { FragmentOutConstrained } from '../function/tgpuFragmentFn.ts';\nimport type {\n  AnyFragmentColorAttachment,\n  ColorAttachment,\n} from './renderPipeline.ts';\n\nfunction isColorAttachment(\n  value: unknown | ColorAttachment,\n): value is ColorAttachment {\n  return typeof (value as ColorAttachment)?.loadOp === 'string';\n}\n\nexport function connectAttachmentToShader(\n  shaderOutputLayout: FragmentOutConstrained,\n  attachment: AnyFragmentColorAttachment,\n): ColorAttachment[] {\n  if (isData(shaderOutputLayout)) {\n    if (!isColorAttachment(attachment)) {\n      throw new Error('Expected a single color attachment, not a record.');\n    }\n\n    return [attachment];\n  }\n\n  const result: ColorAttachment[] = [];\n  for (const key of Object.keys(shaderOutputLayout)) {\n    const matching = (attachment as Record<string, ColorAttachment>)[key];\n\n    if (!matching) {\n      throw new Error(\n        `A color attachment by the name of '${key}' was not provided to the shader.`,\n      );\n    }\n\n    result.push(matching);\n  }\n\n  return result;\n}\n", "import { isVoid } from '../../data/wgslTypes.ts';\nimport { isData } from '../../data/dataTypes.ts';\nimport type { FragmentOutConstrained } from '../function/tgpuFragmentFn.ts';\nimport type { AnyFragmentTargets } from './renderPipeline.ts';\n\nfunction isColorTargetState(\n  value: unknown | GPUColorTargetState,\n): value is GPUColorTargetState {\n  return typeof (value as GPUColorTargetState)?.format === 'string';\n}\n\nexport function connectTargetsToShader(\n  shaderOutputLayout: FragmentOutConstrained,\n  targets: AnyFragmentTargets,\n): GPUColorTargetState[] {\n  if (isData(shaderOutputLayout)) {\n    if (isVoid(shaderOutputLayout)) {\n      return [];\n    }\n\n    if (!isColorTargetState(targets)) {\n      throw new Error(\n        'Expected a single color target configuration, not a record.',\n      );\n    }\n\n    return [targets];\n  }\n\n  const result: GPUColorTargetState[] = [];\n  for (const key of Object.keys(shaderOutputLayout)) {\n    const matchingTarget = (targets as Record<string, GPUColorTargetState>)[\n      key\n    ];\n\n    if (!matchingTarget) {\n      throw new Error(\n        `A color target by the name of '${key}' was not provided to the shader.`,\n      );\n    }\n\n    result.push(matchingTarget);\n  }\n\n  return result;\n}\n", "import type {\n  IndexFlag,\n  TgpuBuffer,\n  VertexFlag,\n} from '../../core/buffer/buffer.ts';\n\nimport type { TgpuQuerySet } from '../../core/querySet/querySet.ts';\nimport { isBuiltin } from '../../data/attributes.ts';\nimport { type Disarray, getCustomLocation } from '../../data/dataTypes.ts';\nimport {\n  type AnyWgslData,\n  isWgslData,\n  type U16,\n  type U32,\n  type WgslArray,\n} from '../../data/wgslTypes.ts';\nimport {\n  MissingBindGroupsError,\n  MissingVertexBuffersError,\n} from '../../errors.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport { type ResolutionResult, resolve } from '../../resolutionCtx.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { AnyVertexAttribs } from '../../shared/vertexFormat.ts';\nimport {\n  isBindGroupLayout,\n  type TgpuBindGroup,\n  type TgpuBindGroupLayout,\n  type TgpuLayoutEntry,\n} from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { IOData, IOLayout, IORecord } from '../function/fnTypes.ts';\nimport type { TgpuFragmentFn } from '../function/tgpuFragmentFn.ts';\nimport type { TgpuVertexFn } from '../function/tgpuVertexFn.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport type { TgpuSlot } from '../slot/slotTypes.ts';\nimport { isTexture, type TgpuTexture } from '../texture/texture.ts';\nimport type { Render } from '../texture/usageExtension.ts';\nimport { connectAttributesToShader } from '../vertexLayout/connectAttributesToShader.ts';\nimport {\n  isVertexLayout,\n  type TgpuVertexLayout,\n} from '../vertexLayout/vertexLayout.ts';\nimport { connectAttachmentToShader } from './connectAttachmentToShader.ts';\nimport { connectTargetsToShader } from './connectTargetsToShader.ts';\nimport { isGPUBuffer } from '../../types.ts';\nimport { sizeOf } from '../../data/index.ts';\nimport {\n  createWithPerformanceCallback,\n  createWithTimestampWrites,\n  setupTimestampWrites,\n  type Timeable,\n  type TimestampWritesPriors,\n  triggerPerformanceCallback,\n} from './timeable.ts';\nimport { PERF } from '../../shared/meta.ts';\n\ninterface RenderPipelineInternals {\n  readonly core: RenderPipelineCore;\n  readonly priors: TgpuRenderPipelinePriors & TimestampWritesPriors;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport interface HasIndexBuffer {\n  readonly hasIndexBuffer: true;\n\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): void;\n}\n\nexport interface TgpuRenderPipeline<Output extends IOLayout = IOLayout>\n  extends TgpuNamable, SelfResolvable, Timeable {\n  readonly [$internal]: RenderPipelineInternals;\n  readonly resourceType: 'render-pipeline';\n  readonly hasIndexBuffer: boolean;\n\n  with<TData extends WgslArray | Disarray>(\n    vertexLayout: TgpuVertexLayout<TData>,\n    buffer: TgpuBuffer<TData> & VertexFlag,\n  ): this;\n  with<Entries extends Record<string, TgpuLayoutEntry | null>>(\n    bindGroupLayout: TgpuBindGroupLayout<Entries>,\n    bindGroup: TgpuBindGroup<Entries>,\n  ): this;\n\n  withColorAttachment(\n    attachment: FragmentOutToColorAttachment<Output>,\n  ): this;\n\n  withDepthStencilAttachment(\n    attachment: DepthStencilAttachment,\n  ): this;\n\n  withIndexBuffer(\n    buffer: TgpuBuffer<AnyWgslData> & IndexFlag,\n    offsetElements?: number,\n    sizeElements?: number,\n  ): this & HasIndexBuffer;\n  withIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offsetBytes?: number,\n    sizeBytes?: number,\n  ): this & HasIndexBuffer;\n\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): void;\n}\n\nexport type FragmentOutToTargets<T extends IOLayout> = T extends IOData\n  ? GPUColorTargetState\n  : T extends Record<string, unknown>\n    ? { [Key in keyof T]: GPUColorTargetState }\n  : T extends { type: 'void' } ? Record<string, never>\n  : never;\n\nexport type FragmentOutToColorAttachment<T extends IOLayout> = T extends IOData\n  ? ColorAttachment\n  : T extends Record<string, unknown> ? { [Key in keyof T]: ColorAttachment }\n  : never;\n\nexport type AnyFragmentTargets =\n  | GPUColorTargetState\n  | Record<string, GPUColorTargetState>;\n\nexport interface ColorAttachment {\n  /**\n   * A {@link GPUTextureView} describing the texture subresource that will be output to for this\n   * color attachment.\n   */\n  view: (TgpuTexture & Render) | GPUTextureView;\n  /**\n   * Indicates the depth slice index of {@link GPUTextureViewDimension#\"3d\"} {@link GPURenderPassColorAttachment#view}\n   * that will be output to for this color attachment.\n   */\n  depthSlice?: GPUIntegerCoordinate;\n  /**\n   * A {@link GPUTextureView} describing the texture subresource that will receive the resolved\n   * output for this color attachment if {@link GPURenderPassColorAttachment#view} is\n   * multisampled.\n   */\n  resolveTarget?: GPUTextureView;\n  /**\n   * Indicates the value to clear {@link GPURenderPassColorAttachment#view} to prior to executing the\n   * render pass. If not map/exist|provided, defaults to `{r: 0, g: 0, b: 0, a: 0}`. Ignored\n   * if {@link GPURenderPassColorAttachment#loadOp} is not {@link GPULoadOp#\"clear\"}.\n   * The components of {@link GPURenderPassColorAttachment#clearValue} are all double values.\n   * They are converted to a texel value of texture format matching the render attachment.\n   * If conversion fails, a validation error is generated.\n   */\n  clearValue?: GPUColor;\n  /**\n   * Indicates the load operation to perform on {@link GPURenderPassColorAttachment#view} prior to\n   * executing the render pass.\n   * Note: It is recommended to prefer clearing; see {@link GPULoadOp#\"clear\"} for details.\n   */\n  loadOp: GPULoadOp;\n  /**\n   * The store operation to perform on {@link GPURenderPassColorAttachment#view}\n   * after executing the render pass.\n   */\n  storeOp: GPUStoreOp;\n}\n\nexport interface DepthStencilAttachment {\n  /**\n   * A {@link GPUTextureView} | ({@link TgpuTexture} & {@link Render}) describing the texture subresource that will be output to\n   * and read from for this depth/stencil attachment.\n   */\n  view: (TgpuTexture & Render) | GPUTextureView;\n  /**\n   * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s depth component\n   * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#depthLoadOp}\n   * is not {@link GPULoadOp#\"clear\"}. Must be between 0.0 and 1.0, inclusive (unless unrestricted depth is enabled).\n   */\n  depthClearValue?: number;\n  /**\n   * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * depth component prior to executing the render pass.\n   * Note: It is recommended to prefer clearing; see {@link GPULoadOp#\"clear\"} for details.\n   */\n  depthLoadOp?: GPULoadOp;\n  /**\n   * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * depth component after executing the render pass.\n   */\n  depthStoreOp?: GPUStoreOp;\n  /**\n   * Indicates that the depth component of {@link GPURenderPassDepthStencilAttachment#view}\n   * is read only.\n   */\n  depthReadOnly?: boolean;\n  /**\n   * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s stencil component\n   * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#stencilLoadOp}\n   * is not {@link GPULoadOp#\"clear\"}.\n   * The value will be converted to the type of the stencil aspect of `view` by taking the same\n   * number of LSBs as the number of bits in the stencil aspect of one texel block|texel of `view`.\n   */\n  stencilClearValue?: GPUStencilValue;\n  /**\n   * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * stencil component prior to executing the render pass.\n   * Note: It is recommended to prefer clearing; see {@link GPULoadOp#\"clear\"} for details.\n   */\n  stencilLoadOp?: GPULoadOp;\n  /**\n   * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * stencil component after executing the render pass.\n   */\n  stencilStoreOp?: GPUStoreOp;\n  /**\n   * Indicates that the stencil component of {@link GPURenderPassDepthStencilAttachment#view}\n   * is read only.\n   */\n  stencilReadOnly?: boolean;\n}\n\nexport type AnyFragmentColorAttachment =\n  | ColorAttachment\n  | Record<string, ColorAttachment>;\n\nexport type RenderPipelineCoreOptions = {\n  branch: ExperimentalTgpuRoot;\n  slotBindings: [TgpuSlot<unknown>, unknown][];\n  vertexAttribs: AnyVertexAttribs;\n  vertexFn: TgpuVertexFn;\n  fragmentFn: TgpuFragmentFn;\n  primitiveState:\n    | GPUPrimitiveState\n    | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {\n      stripIndexFormat?: U32 | U16;\n    }\n    | undefined;\n  depthStencilState: GPUDepthStencilState | undefined;\n  targets: AnyFragmentTargets;\n  multisampleState: GPUMultisampleState | undefined;\n};\n\nexport function INTERNAL_createRenderPipeline(\n  options: RenderPipelineCoreOptions,\n) {\n  return new TgpuRenderPipelineImpl(new RenderPipelineCore(options), {});\n}\n\nexport function isRenderPipeline(value: unknown): value is TgpuRenderPipeline {\n  const maybe = value as TgpuRenderPipeline | undefined;\n  return maybe?.resourceType === 'render-pipeline' && !!maybe[$internal];\n}\n\n// --------------\n// Implementation\n// --------------\n\ntype TgpuRenderPipelinePriors = {\n  readonly vertexLayoutMap?:\n    | Map<TgpuVertexLayout, TgpuBuffer<AnyWgslData> & VertexFlag>\n    | undefined;\n  readonly bindGroupLayoutMap?:\n    | Map<TgpuBindGroupLayout, TgpuBindGroup>\n    | undefined;\n  readonly colorAttachment?: AnyFragmentColorAttachment | undefined;\n  readonly depthStencilAttachment?: DepthStencilAttachment | undefined;\n  readonly indexBuffer?:\n    | {\n      buffer: TgpuBuffer<AnyWgslData> & IndexFlag | GPUBuffer;\n      indexFormat: GPUIndexFormat;\n      offsetBytes?: number | undefined;\n      sizeBytes?: number | undefined;\n    }\n    | undefined;\n} & TimestampWritesPriors;\n\ntype Memo = {\n  pipeline: GPURenderPipeline;\n  usedBindGroupLayouts: TgpuBindGroupLayout[];\n  catchall: [number, TgpuBindGroup] | undefined;\n};\n\nclass TgpuRenderPipelineImpl implements TgpuRenderPipeline {\n  public readonly [$internal]: RenderPipelineInternals;\n  public readonly resourceType = 'render-pipeline';\n  [$getNameForward]: RenderPipelineCore;\n  public readonly hasIndexBuffer: boolean = false;\n\n  constructor(core: RenderPipelineCore, priors: TgpuRenderPipelinePriors) {\n    this[$internal] = {\n      core,\n      priors,\n    };\n    this[$getNameForward] = core;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    return ctx.resolve(this[$internal].core);\n  }\n\n  toString(): string {\n    return `renderPipeline:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  $name(label: string): this {\n    setName(this[$internal].core, label);\n    return this;\n  }\n\n  with<TData extends WgslArray<AnyWgslData>>(\n    vertexLayout: TgpuVertexLayout<TData>,\n    buffer: TgpuBuffer<TData> & VertexFlag,\n  ): this;\n  with(\n    bindGroupLayout: TgpuBindGroupLayout,\n    bindGroup: TgpuBindGroup,\n  ): this;\n  with(\n    definition: TgpuVertexLayout | TgpuBindGroupLayout,\n    resource: (TgpuBuffer<AnyWgslData> & VertexFlag) | TgpuBindGroup,\n  ): this {\n    const internals = this[$internal];\n\n    if (isBindGroupLayout(definition)) {\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        bindGroupLayoutMap: new Map([\n          ...(internals.priors.bindGroupLayoutMap ?? []),\n          [definition, resource as TgpuBindGroup],\n        ]),\n      }) as this;\n    }\n\n    if (isVertexLayout(definition)) {\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        vertexLayoutMap: new Map([\n          ...(internals.priors.vertexLayoutMap ?? []),\n          [definition, resource as TgpuBuffer<AnyWgslData> & VertexFlag],\n        ]),\n      }) as this;\n    }\n\n    throw new Error('Unsupported value passed into .with()');\n  }\n\n  withPerformanceCallback(\n    callback: (start: bigint, end: bigint) => void | Promise<void>,\n  ): this {\n    const internals = this[$internal];\n    const newPriors = createWithPerformanceCallback(\n      internals.priors,\n      callback,\n      internals.core.options.branch,\n    );\n    return new TgpuRenderPipelineImpl(internals.core, newPriors) as this;\n  }\n\n  withTimestampWrites(options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  }): this {\n    const internals = this[$internal];\n    const newPriors = createWithTimestampWrites(\n      internals.priors,\n      options,\n      internals.core.options.branch,\n    );\n    return new TgpuRenderPipelineImpl(internals.core, newPriors) as this;\n  }\n\n  withColorAttachment(\n    attachment: AnyFragmentColorAttachment,\n  ): this {\n    const internals = this[$internal];\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      colorAttachment: attachment,\n    }) as this;\n  }\n\n  withDepthStencilAttachment(\n    attachment: DepthStencilAttachment,\n  ): this {\n    const internals = this[$internal];\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      depthStencilAttachment: attachment,\n    }) as this;\n  }\n\n  withIndexBuffer(\n    buffer: TgpuBuffer<AnyWgslData> & IndexFlag,\n    offsetElements?: number,\n    sizeElements?: number,\n  ): this & HasIndexBuffer;\n  withIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offsetBytes?: number,\n    sizeBytes?: number,\n  ): this & HasIndexBuffer;\n  withIndexBuffer(\n    buffer: TgpuBuffer<AnyWgslData> & IndexFlag | GPUBuffer,\n    indexFormatOrOffset?: GPUIndexFormat | number,\n    offsetElementsOrSizeBytes?: number,\n    sizeElementsOrUndefined?: number,\n  ): this & HasIndexBuffer {\n    const internals = this[$internal];\n\n    if (isGPUBuffer(buffer)) {\n      if (typeof indexFormatOrOffset !== 'string') {\n        throw new Error(\n          'If a GPUBuffer is passed, indexFormat must be provided.',\n        );\n      }\n\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        indexBuffer: {\n          buffer,\n          indexFormat: indexFormatOrOffset,\n          offsetBytes: offsetElementsOrSizeBytes,\n          sizeBytes: sizeElementsOrUndefined,\n        },\n      }) as unknown as this & HasIndexBuffer;\n    }\n\n    const dataTypeToIndexFormat = {\n      'u32': 'uint32',\n      'u16': 'uint16',\n    } as const;\n\n    const elementType = (buffer.dataType as WgslArray<U32 | U16>).elementType;\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      indexBuffer: {\n        buffer,\n        indexFormat: dataTypeToIndexFormat[elementType.type],\n        offsetBytes: indexFormatOrOffset !== undefined\n          ? (indexFormatOrOffset as number) * sizeOf(elementType)\n          : undefined,\n        sizeBytes: sizeElementsOrUndefined !== undefined\n          ? sizeElementsOrUndefined * sizeOf(elementType)\n          : undefined,\n      },\n    }) as unknown as this & HasIndexBuffer;\n  }\n\n  private setupRenderPass(): GPURenderPassEncoder {\n    const internals = this[$internal];\n    const memo = internals.core.unwrap();\n    const { branch, fragmentFn } = internals.core.options;\n\n    const colorAttachments = connectAttachmentToShader(\n      fragmentFn.shell.out,\n      internals.priors.colorAttachment ?? {},\n    ).map((attachment) => {\n      if (isTexture(attachment.view)) {\n        return {\n          ...attachment,\n          view: branch.unwrap(attachment.view).createView(),\n        };\n      }\n\n      return attachment;\n    }) as GPURenderPassColorAttachment[];\n\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      label: getName(internals.core) ?? '<unnamed>',\n      colorAttachments,\n      ...setupTimestampWrites(\n        internals.priors,\n        branch,\n      ),\n    };\n\n    if (internals.priors.depthStencilAttachment !== undefined) {\n      const attachment = internals.priors.depthStencilAttachment;\n      if (isTexture(attachment.view)) {\n        renderPassDescriptor.depthStencilAttachment = {\n          ...attachment,\n          view: branch.unwrap(attachment.view).createView(),\n        };\n      } else {\n        renderPassDescriptor.depthStencilAttachment =\n          attachment as GPURenderPassDepthStencilAttachment;\n      }\n    }\n\n    const pass = branch.commandEncoder.beginRenderPass(renderPassDescriptor);\n\n    pass.setPipeline(memo.pipeline);\n\n    const missingBindGroups = new Set(memo.usedBindGroupLayouts);\n\n    memo.usedBindGroupLayouts.forEach((layout, idx) => {\n      if (memo.catchall && idx === memo.catchall[0]) {\n        // Catch-all\n        pass.setBindGroup(idx, branch.unwrap(memo.catchall[1]));\n        missingBindGroups.delete(layout);\n      } else {\n        const bindGroup = internals.priors.bindGroupLayoutMap?.get(layout);\n        if (bindGroup !== undefined) {\n          missingBindGroups.delete(layout);\n          pass.setBindGroup(idx, branch.unwrap(bindGroup));\n        }\n      }\n    });\n\n    const missingVertexLayouts = new Set(internals.core.usedVertexLayouts);\n\n    const usedVertexLayouts = internals.core.usedVertexLayouts;\n    usedVertexLayouts.forEach((vertexLayout, idx) => {\n      const buffer = internals.priors.vertexLayoutMap?.get(vertexLayout);\n      if (buffer) {\n        missingVertexLayouts.delete(vertexLayout);\n        pass.setVertexBuffer(idx, branch.unwrap(buffer));\n      }\n    });\n\n    if (missingBindGroups.size > 0) {\n      throw new MissingBindGroupsError(missingBindGroups);\n    }\n\n    if (missingVertexLayouts.size > 0) {\n      throw new MissingVertexBuffersError(missingVertexLayouts);\n    }\n\n    return pass;\n  }\n\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): void {\n    const internals = this[$internal];\n    const pass = this.setupRenderPass();\n    const { branch } = internals.core.options;\n\n    pass.draw(vertexCount, instanceCount, firstVertex, firstInstance);\n\n    pass.end();\n\n    internals.priors.performanceCallback\n      ? triggerPerformanceCallback({\n        root: branch,\n        priors: internals.priors,\n      })\n      : branch.flush();\n  }\n\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): void {\n    const internals = this[$internal];\n\n    if (!internals.priors.indexBuffer) {\n      throw new Error('No index buffer set for this render pipeline.');\n    }\n\n    const { buffer, indexFormat, offsetBytes, sizeBytes } =\n      internals.priors.indexBuffer;\n\n    const pass = this.setupRenderPass();\n    const { branch } = internals.core.options;\n\n    if (isGPUBuffer(buffer)) {\n      pass.setIndexBuffer(buffer, indexFormat, offsetBytes, sizeBytes);\n    } else {\n      pass.setIndexBuffer(\n        branch.unwrap(buffer),\n        indexFormat,\n        offsetBytes,\n        sizeBytes,\n      );\n    }\n\n    pass.drawIndexed(\n      indexCount,\n      instanceCount,\n      firstIndex,\n      baseVertex,\n      firstInstance,\n    );\n\n    pass.end();\n\n    internals.priors.performanceCallback\n      ? triggerPerformanceCallback({\n        root: branch,\n        priors: internals.priors,\n      })\n      : branch.flush();\n  }\n}\n\nclass RenderPipelineCore implements SelfResolvable {\n  public readonly usedVertexLayouts: TgpuVertexLayout[];\n\n  private _memo: Memo | undefined;\n  private readonly _vertexBufferLayouts: GPUVertexBufferLayout[];\n  private readonly _targets: GPUColorTargetState[];\n\n  constructor(public readonly options: RenderPipelineCoreOptions) {\n    const connectedAttribs = connectAttributesToShader(\n      options.vertexFn.shell.in ?? {},\n      options.vertexAttribs,\n    );\n\n    this._vertexBufferLayouts = connectedAttribs.bufferDefinitions;\n    this.usedVertexLayouts = connectedAttribs.usedVertexLayouts;\n\n    this._targets = connectTargetsToShader(\n      options.fragmentFn.shell.out,\n      options.targets,\n    );\n  }\n\n  '~resolve'(ctx: ResolutionCtx) {\n    const {\n      vertexFn,\n      fragmentFn,\n      slotBindings,\n    } = this.options;\n\n    const locations = matchUpVaryingLocations(\n      vertexFn.shell.out,\n      fragmentFn.shell.in,\n      getName(vertexFn) ?? '<unnamed>',\n      getName(fragmentFn) ?? '<unnamed>',\n    );\n\n    return ctx.withVaryingLocations(\n      locations,\n      () =>\n        ctx.withSlots(slotBindings, () => {\n          ctx.resolve(vertexFn);\n          ctx.resolve(fragmentFn);\n          return '';\n        }),\n    );\n  }\n\n  toString() {\n    return 'renderPipelineCore';\n  }\n\n  public unwrap(): Memo {\n    if (this._memo === undefined) {\n      const {\n        branch,\n        primitiveState,\n        depthStencilState,\n        multisampleState,\n      } = this.options;\n      const device = branch.device;\n\n      // Resolving code\n      let resolutionResult: ResolutionResult;\n\n      let resolveMeasure: PerformanceMeasure | undefined;\n      if (PERF?.enabled) {\n        const resolveStart = performance.mark('typegpu:resolution:start');\n        resolutionResult = resolve(this, {\n          names: branch.nameRegistry,\n        });\n        resolveMeasure = performance.measure('typegpu:resolution', {\n          start: resolveStart.name,\n        });\n      } else {\n        resolutionResult = resolve(this, {\n          names: branch.nameRegistry,\n        });\n      }\n\n      const { code, usedBindGroupLayouts, catchall } = resolutionResult;\n\n      if (catchall !== undefined) {\n        usedBindGroupLayouts[catchall[0]]?.$name(\n          `${getName(this) ?? '<unnamed>'} - Automatic Bind Group & Layout`,\n        );\n      }\n\n      const module = device.createShaderModule({\n        label: `${getName(this) ?? '<unnamed>'} - Shader`,\n        code,\n      });\n\n      const descriptor: GPURenderPipelineDescriptor = {\n        layout: device.createPipelineLayout({\n          label: `${getName(this) ?? '<unnamed>'} - Pipeline Layout`,\n          bindGroupLayouts: usedBindGroupLayouts.map((l) => branch.unwrap(l)),\n        }),\n        vertex: {\n          module,\n          buffers: this._vertexBufferLayouts,\n        },\n        fragment: {\n          module,\n          targets: this._targets,\n        },\n      };\n\n      const label = getName(this);\n      if (label !== undefined) {\n        descriptor.label = label;\n      }\n\n      if (primitiveState) {\n        if (isWgslData(primitiveState.stripIndexFormat)) {\n          descriptor.primitive = {\n            ...primitiveState,\n            stripIndexFormat: {\n              'u32': 'uint32',\n              'u16': 'uint16',\n            }[primitiveState.stripIndexFormat.type] as GPUIndexFormat,\n          };\n        } else {\n          descriptor.primitive = primitiveState as GPUPrimitiveState;\n        }\n      }\n\n      if (depthStencilState) {\n        descriptor.depthStencil = depthStencilState;\n      }\n\n      if (multisampleState) {\n        descriptor.multisample = multisampleState;\n      }\n\n      this._memo = {\n        pipeline: device.createRenderPipeline(descriptor),\n        usedBindGroupLayouts,\n        catchall,\n      };\n\n      if (PERF?.enabled) {\n        (async () => {\n          const start = performance.mark('typegpu:compile-start');\n          await device.queue.onSubmittedWorkDone();\n          const compileMeasure = performance.measure('typegpu:compiled', {\n            start: start.name,\n          });\n\n          PERF?.record('resolution', {\n            resolveDuration: resolveMeasure?.duration,\n            compileDuration: compileMeasure.duration,\n            wgslSize: code.length,\n          });\n        })();\n      }\n    }\n\n    return this._memo;\n  }\n}\n\n/**\n * Assumes vertexOut and fragmentIn are matching when it comes to the keys, that is fragmentIn's keyset is a subset of vertexOut's\n * Logs a warning, when they don't match in terms of custom locations\n */\nexport function matchUpVaryingLocations(\n  vertexOut: IORecord,\n  fragmentIn: IORecord | undefined,\n  vertexFnName: string,\n  fragmentFnName: string,\n) {\n  const locations: Record<\n    string,\n    number\n  > = {};\n  const usedLocations = new Set<number>();\n\n  function saveLocation(key: string, location: number) {\n    locations[key] = location;\n    usedLocations.add(location);\n  }\n\n  // respect custom locations and pair up vertex and fragment varying with the same key\n  for (const [key, value] of Object.entries(vertexOut)) {\n    const customLocation = getCustomLocation(value);\n    if (customLocation !== undefined) {\n      saveLocation(key, customLocation);\n    }\n  }\n\n  for (const [key, value] of Object.entries(fragmentIn ?? {})) {\n    const customLocation = getCustomLocation(value);\n    if (customLocation === undefined) {\n      continue;\n    }\n\n    if (locations[key] === undefined) {\n      saveLocation(key, customLocation);\n    } else if (locations[key] !== customLocation) {\n      console.warn(\n        `Mismatched location between vertexFn (${vertexFnName}) output (${\n          locations[key]\n        }) and fragmentFn (${fragmentFnName}) input (${customLocation}) for the key \"${key}\", using the location set on vertex output.`,\n      );\n    }\n  }\n\n  // automatically assign remaining locations to the rest\n  let nextLocation = 0;\n  for (const key of Object.keys(vertexOut ?? {})) {\n    if (isBuiltin(vertexOut[key]) || locations[key] !== undefined) {\n      continue;\n    }\n\n    while (usedLocations.has(nextLocation)) {\n      nextLocation++;\n    }\n\n    saveLocation(key, nextLocation);\n  }\n\n  return locations;\n}\n", "import type { BaseData } from '../../data/wgslTypes.ts';\nimport type { StorageFlag } from '../../extension.ts';\nimport { setName, type TgpuNamable } from '../../shared/meta.ts';\nimport type { Infer, InferGPU, InferPartial } from '../../shared/repr.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { TgpuBuffer, UniformFlag } from './buffer.ts';\nimport type { TgpuBufferUsage } from './bufferUsage.ts';\n\n// ----------\n// Public API\n// ----------\n\ninterface TgpuBufferShorthandBase<TData extends BaseData> extends TgpuNamable {\n  readonly [$internal]: true;\n\n  // Accessible on the CPU\n  write(data: Infer<TData>): void;\n  writePartial(data: InferPartial<TData>): void;\n  read(): Promise<Infer<TData>>;\n  // ---\n}\n\nexport interface TgpuMutable<TData extends BaseData>\n  extends TgpuBufferShorthandBase<TData> {\n  readonly resourceType: 'mutable';\n  readonly buffer: TgpuBuffer<TData> & StorageFlag;\n\n  // Accessible on the GPU\n  value: InferGPU<TData>;\n  $: InferGPU<TData>;\n  // ---\n}\n\nexport interface TgpuReadonly<TData extends BaseData>\n  extends TgpuBufferShorthandBase<TData> {\n  readonly resourceType: 'readonly';\n  readonly buffer: TgpuBuffer<TData> & StorageFlag;\n\n  // Accessible on the GPU\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n  // ---\n}\n\nexport interface TgpuUniform<TData extends BaseData>\n  extends TgpuBufferShorthandBase<TData> {\n  readonly resourceType: 'uniform';\n  readonly buffer: TgpuBuffer<TData> & UniformFlag;\n\n  // Accessible on the GPU\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n  // ---\n}\n\nexport type TgpuBufferShorthand<TData extends BaseData> =\n  | TgpuMutable<TData>\n  | TgpuReadonly<TData>\n  | TgpuUniform<TData>;\n\nexport function isBufferShorthand<TData extends BaseData>(\n  value: unknown | TgpuBufferShorthand<TData>,\n): value is TgpuBufferShorthand<TData> {\n  return value instanceof TgpuBufferShorthandImpl;\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuBufferShorthandImpl<\n  TType extends 'mutable' | 'readonly' | 'uniform',\n  TData extends BaseData,\n> implements SelfResolvable {\n  readonly [$internal] = true;\n  readonly [$getNameForward]: object;\n  readonly #usage: TgpuBufferUsage<TData, TType>;\n\n  constructor(\n    public readonly resourceType: TType,\n    public readonly buffer:\n      & TgpuBuffer<TData>\n      & (TType extends 'mutable' | 'readonly' ? StorageFlag : UniformFlag),\n  ) {\n    this[$getNameForward] = buffer;\n    // biome-ignore lint/suspicious/noExplicitAny: too complex a type\n    this.#usage = (this.buffer as any).as(this.resourceType);\n  }\n\n  $name(label: string): this {\n    setName(this[$getNameForward], label);\n    return this;\n  }\n\n  write(data: Infer<TData>): void {\n    this.buffer.write(data);\n  }\n\n  writePartial(data: InferPartial<TData>): void {\n    this.buffer.writePartial(data);\n  }\n\n  read(): Promise<Infer<TData>> {\n    return this.buffer.read();\n  }\n\n  get value(): InferGPU<TData> {\n    return this.#usage.value;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    return ctx.resolve(this.#usage);\n  }\n\n  get $(): InferGPU<TData> {\n    return this.value;\n  }\n}\n", "import {\n  INTERNAL_createQuerySet,\n  isQuerySet,\n  type TgpuQuerySet,\n} from '../../core/querySet/querySet.ts';\nimport type { AnyComputeBuiltin, OmitBuiltins } from '../../builtin.ts';\nimport type { AnyData, Disarray } from '../../data/dataTypes.ts';\nimport type {\n  AnyWgslData,\n  BaseData,\n  U16,\n  U32,\n  WgslArray,\n} from '../../data/wgslTypes.ts';\nimport {\n  invariant,\n  MissingBindGroupsError,\n  MissingVertexBuffersError,\n} from '../../errors.ts';\nimport { WeakMemo } from '../../memo.ts';\nimport {\n  type NameRegistry,\n  RandomNameRegistry,\n  StrictNameRegistry,\n} from '../../nameRegistry.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport type { AnyVertexAttribs } from '../../shared/vertexFormat.ts';\nimport type {\n  ExtractBindGroupInputFromLayout,\n  TgpuBindGroup,\n  TgpuBindGroupLayout,\n  TgpuLayoutEntry,\n} from '../../tgpuBindGroupLayout.ts';\nimport {\n  isBindGroup,\n  isBindGroupLayout,\n  TgpuBindGroupImpl,\n} from '../../tgpuBindGroupLayout.ts';\nimport {\n  INTERNAL_createBuffer,\n  isBuffer,\n  type TgpuBuffer,\n  type VertexFlag,\n} from '../buffer/buffer.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport type { IOLayout } from '../function/fnTypes.ts';\nimport type { TgpuComputeFn } from '../function/tgpuComputeFn.ts';\nimport type { TgpuFn } from '../function/tgpuFn.ts';\nimport type { TgpuFragmentFn } from '../function/tgpuFragmentFn.ts';\nimport type { TgpuVertexFn } from '../function/tgpuVertexFn.ts';\nimport {\n  INTERNAL_createComputePipeline,\n  isComputePipeline,\n  type TgpuComputePipeline,\n} from '../pipeline/computePipeline.ts';\nimport {\n  type AnyFragmentTargets,\n  INTERNAL_createRenderPipeline,\n  isRenderPipeline,\n  type RenderPipelineCoreOptions,\n  type TgpuRenderPipeline,\n} from '../pipeline/renderPipeline.ts';\nimport {\n  isComparisonSampler,\n  isSampler,\n  type TgpuComparisonSampler,\n  type TgpuSampler,\n} from '../sampler/sampler.ts';\nimport {\n  isAccessor,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from '../slot/slotTypes.ts';\nimport {\n  INTERNAL_createTexture,\n  isSampledTextureView,\n  isStorageTextureView,\n  isTexture,\n  type TgpuMutableTexture,\n  type TgpuReadonlyTexture,\n  type TgpuSampledTexture,\n  type TgpuTexture,\n  type TgpuWriteonlyTexture,\n} from '../texture/texture.ts';\nimport type { LayoutToAllowedAttribs } from '../vertexLayout/vertexAttribute.ts';\nimport {\n  isVertexLayout,\n  type TgpuVertexLayout,\n} from '../vertexLayout/vertexLayout.ts';\nimport type {\n  Configurable,\n  CreateTextureOptions,\n  CreateTextureResult,\n  ExperimentalTgpuRoot,\n  RenderPass,\n  TgpuRoot,\n  WithBinding,\n  WithCompute,\n  WithFragment,\n  WithVertex,\n} from './rootTypes.ts';\nimport {\n  TgpuBufferShorthandImpl,\n  type TgpuMutable,\n  type TgpuReadonly,\n  type TgpuUniform,\n} from '../buffer/bufferShorthand.ts';\n\nclass ConfigurableImpl implements Configurable {\n  constructor(readonly bindings: [TgpuSlot<unknown>, unknown][]) {}\n\n  with<T extends AnyWgslData>(\n    slot: TgpuSlot<T> | TgpuAccessor<T>,\n    value: T | TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n  ): Configurable {\n    return new ConfigurableImpl([\n      ...this.bindings,\n      [isAccessor(slot) ? slot.slot : slot, value],\n    ]);\n  }\n\n  pipe(transform: (cfg: Configurable) => Configurable): Configurable {\n    const newCfg = transform(this);\n    return new ConfigurableImpl([\n      ...this.bindings,\n      ...newCfg.bindings,\n    ]);\n  }\n}\n\nclass WithBindingImpl implements WithBinding {\n  constructor(\n    private readonly _getRoot: () => ExperimentalTgpuRoot,\n    private readonly _slotBindings: [TgpuSlot<unknown>, unknown][],\n  ) {}\n\n  with<T extends AnyWgslData>(\n    slot: TgpuSlot<T> | TgpuAccessor<T>,\n    value: T | TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n  ): WithBinding {\n    return new WithBindingImpl(this._getRoot, [\n      ...this._slotBindings,\n      [isAccessor(slot) ? slot.slot : slot, value],\n    ]);\n  }\n\n  withCompute<ComputeIn extends Record<string, AnyComputeBuiltin>>(\n    entryFn: TgpuComputeFn<ComputeIn>,\n  ): WithCompute {\n    return new WithComputeImpl(this._getRoot(), this._slotBindings, entryFn);\n  }\n\n  withVertex<VertexIn extends IOLayout>(\n    vertexFn: TgpuVertexFn,\n    attribs: LayoutToAllowedAttribs<OmitBuiltins<VertexIn>>,\n  ): WithVertex {\n    return new WithVertexImpl({\n      branch: this._getRoot(),\n      primitiveState: undefined,\n      depthStencilState: undefined,\n      slotBindings: this._slotBindings,\n      vertexFn,\n      vertexAttribs: attribs as AnyVertexAttribs,\n      multisampleState: undefined,\n    });\n  }\n\n  pipe(transform: (cfg: Configurable) => Configurable): WithBinding {\n    const newCfg = transform(new ConfigurableImpl([]));\n    return new WithBindingImpl(this._getRoot, [\n      ...this._slotBindings,\n      ...newCfg.bindings,\n    ]);\n  }\n}\n\nclass WithComputeImpl implements WithCompute {\n  constructor(\n    private readonly _root: ExperimentalTgpuRoot,\n    private readonly _slotBindings: [TgpuSlot<unknown>, unknown][],\n    private readonly _entryFn: TgpuComputeFn,\n  ) {}\n\n  createPipeline(): TgpuComputePipeline {\n    return INTERNAL_createComputePipeline(\n      this._root,\n      this._slotBindings,\n      this._entryFn,\n    );\n  }\n}\n\nclass WithVertexImpl implements WithVertex {\n  constructor(\n    private readonly _options: Omit<\n      RenderPipelineCoreOptions,\n      'fragmentFn' | 'targets'\n    >,\n  ) {}\n\n  withFragment(\n    fragmentFn: TgpuFragmentFn | 'n/a',\n    targets: AnyFragmentTargets | 'n/a',\n    _mismatch?: unknown,\n  ): WithFragment {\n    invariant(typeof fragmentFn !== 'string', 'Just type mismatch validation');\n    invariant(typeof targets !== 'string', 'Just type mismatch validation');\n\n    return new WithFragmentImpl({\n      ...this._options,\n      fragmentFn,\n      targets,\n    });\n  }\n}\n\nclass WithFragmentImpl implements WithFragment {\n  constructor(private readonly _options: RenderPipelineCoreOptions) {}\n\n  withPrimitive(\n    primitiveState:\n      | GPUPrimitiveState\n      | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {\n        stripIndexFormat?: U32 | U16;\n      }\n      | undefined,\n  ): WithFragment {\n    return new WithFragmentImpl({ ...this._options, primitiveState });\n  }\n\n  withDepthStencil(\n    depthStencilState: GPUDepthStencilState | undefined,\n  ): WithFragment {\n    return new WithFragmentImpl({ ...this._options, depthStencilState });\n  }\n\n  withMultisample(\n    multisampleState: GPUMultisampleState | undefined,\n  ): WithFragment {\n    return new WithFragmentImpl({ ...this._options, multisampleState });\n  }\n\n  createPipeline(): TgpuRenderPipeline {\n    return INTERNAL_createRenderPipeline(this._options);\n  }\n}\n\ninterface Disposable {\n  destroy(): void;\n}\n\n/**\n * Holds all data that is necessary to facilitate CPU and GPU communication.\n * Programs that share a root can interact via GPU buffers.\n */\nclass TgpuRootImpl extends WithBindingImpl\n  implements TgpuRoot, ExperimentalTgpuRoot {\n  '~unstable': Omit<ExperimentalTgpuRoot, keyof TgpuRoot>;\n\n  private _disposables: Disposable[] = [];\n\n  private _unwrappedBindGroupLayouts = new WeakMemo(\n    (key: TgpuBindGroupLayout) => key.unwrap(this),\n  );\n  private _unwrappedBindGroups = new WeakMemo((key: TgpuBindGroup) =>\n    key.unwrap(this)\n  );\n\n  private _commandEncoder: GPUCommandEncoder | null = null;\n\n  constructor(\n    public readonly device: GPUDevice,\n    public readonly nameRegistry: NameRegistry,\n    private readonly _ownDevice: boolean,\n  ) {\n    super(() => this, []);\n\n    this['~unstable'] = this;\n  }\n\n  get commandEncoder() {\n    if (!this._commandEncoder) {\n      this._commandEncoder = this.device.createCommandEncoder();\n    }\n\n    return this._commandEncoder;\n  }\n\n  get enabledFeatures() {\n    return new Set(this.device.features) as ReadonlySet<GPUFeatureName>;\n  }\n\n  createBuffer<TData extends AnyData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuBuffer<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer);\n    this._disposables.push(buffer);\n    return buffer;\n  }\n\n  createUniform<TData extends AnyWgslData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuUniform<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer)\n      // biome-ignore lint/suspicious/noExplicitAny: i'm sure it's fine\n      .$usage('uniform' as any);\n    this._disposables.push(buffer);\n\n    return new TgpuBufferShorthandImpl('uniform', buffer);\n  }\n\n  createMutable<TData extends AnyWgslData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuMutable<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer)\n      // biome-ignore lint/suspicious/noExplicitAny: i'm sure it's fine\n      .$usage('storage' as any);\n    this._disposables.push(buffer);\n\n    return new TgpuBufferShorthandImpl('mutable', buffer);\n  }\n\n  createReadonly<TData extends AnyWgslData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuReadonly<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer)\n      // biome-ignore lint/suspicious/noExplicitAny: i'm sure it's fine\n      .$usage('storage' as any);\n    this._disposables.push(buffer);\n\n    return new TgpuBufferShorthandImpl('readonly', buffer);\n  }\n\n  createQuerySet<T extends GPUQueryType>(\n    type: T,\n    count: number,\n    rawQuerySet?: GPUQuerySet,\n  ): TgpuQuerySet<T> {\n    return INTERNAL_createQuerySet(this, type, count, rawQuerySet);\n  }\n\n  createBindGroup<\n    Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n      string,\n      TgpuLayoutEntry | null\n    >,\n  >(\n    layout: TgpuBindGroupLayout<Entries>,\n    entries: ExtractBindGroupInputFromLayout<Entries>,\n  ) {\n    return new TgpuBindGroupImpl(layout, entries);\n  }\n\n  destroy() {\n    for (const disposable of this._disposables) {\n      disposable.destroy();\n    }\n\n    if (this._ownDevice) {\n      this.device.destroy();\n    }\n  }\n\n  createTexture<\n    TWidth extends number,\n    THeight extends number,\n    TDepth extends number,\n    TSize extends\n      | readonly [TWidth]\n      | readonly [TWidth, THeight]\n      | readonly [TWidth, THeight, TDepth],\n    TFormat extends GPUTextureFormat,\n    TMipLevelCount extends number,\n    TSampleCount extends number,\n    TViewFormat extends GPUTextureFormat,\n    TDimension extends GPUTextureDimension,\n  >(\n    props: CreateTextureOptions<\n      TSize,\n      TFormat,\n      TMipLevelCount,\n      TSampleCount,\n      TViewFormat,\n      TDimension\n    >,\n  ): TgpuTexture<\n    CreateTextureResult<\n      TSize,\n      TFormat,\n      TMipLevelCount,\n      TSampleCount,\n      TViewFormat,\n      TDimension\n    >\n  > {\n    const texture = INTERNAL_createTexture(props, this);\n    this._disposables.push(texture);\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n    return texture as any;\n  }\n\n  unwrap(resource: TgpuComputePipeline): GPUComputePipeline;\n  unwrap(resource: TgpuRenderPipeline): GPURenderPipeline;\n  unwrap(resource: TgpuBindGroupLayout): GPUBindGroupLayout;\n  unwrap(resource: TgpuBindGroup): GPUBindGroup;\n  unwrap(resource: TgpuBuffer<AnyData>): GPUBuffer;\n  unwrap(resource: TgpuTexture): GPUTexture;\n  unwrap(\n    resource:\n      | TgpuReadonlyTexture\n      | TgpuWriteonlyTexture\n      | TgpuMutableTexture\n      | TgpuSampledTexture,\n  ): GPUTextureView;\n  unwrap(resource: TgpuVertexLayout): GPUVertexBufferLayout;\n  unwrap(resource: TgpuSampler): GPUSampler;\n  unwrap(resource: TgpuComparisonSampler): GPUSampler;\n  unwrap(resource: TgpuQuerySet<GPUQueryType>): GPUQuerySet;\n  unwrap(\n    resource:\n      | TgpuComputePipeline\n      | TgpuRenderPipeline\n      | TgpuBindGroupLayout\n      | TgpuBindGroup\n      | TgpuBuffer<AnyData>\n      | TgpuTexture\n      | TgpuReadonlyTexture\n      | TgpuWriteonlyTexture\n      | TgpuMutableTexture\n      | TgpuSampledTexture\n      | TgpuVertexLayout\n      | TgpuSampler\n      | TgpuComparisonSampler\n      | TgpuQuerySet<GPUQueryType>,\n  ):\n    | GPUComputePipeline\n    | GPURenderPipeline\n    | GPUBindGroupLayout\n    | GPUBindGroup\n    | GPUBuffer\n    | GPUTexture\n    | GPUTextureView\n    | GPUVertexBufferLayout\n    | GPUSampler\n    | GPUQuerySet {\n    if (isComputePipeline(resource)) {\n      return resource[$internal].rawPipeline;\n    }\n\n    if (isRenderPipeline(resource)) {\n      return resource[$internal].core.unwrap().pipeline;\n    }\n\n    if (isBindGroupLayout(resource)) {\n      return this._unwrappedBindGroupLayouts.getOrMake(resource);\n    }\n\n    if (isBindGroup(resource)) {\n      return this._unwrappedBindGroups.getOrMake(resource);\n    }\n\n    if (isBuffer(resource)) {\n      return resource.buffer;\n    }\n\n    if (isTexture(resource)) {\n      return resource[$internal].unwrap();\n    }\n\n    if (isStorageTextureView(resource)) {\n      if (resource[$internal].unwrap) {\n        return resource[$internal].unwrap();\n      }\n      throw new Error('Cannot unwrap laid-out texture view.');\n    }\n\n    if (isSampledTextureView(resource)) {\n      if (resource[$internal].unwrap) {\n        return resource[$internal].unwrap();\n      }\n      throw new Error('Cannot unwrap laid-out texture view.');\n    }\n\n    if (isVertexLayout(resource)) {\n      return resource.vertexLayout;\n    }\n\n    if (isSampler(resource)) {\n      if (resource[$internal].unwrap) {\n        return resource[$internal].unwrap(this);\n      }\n      throw new Error('Cannot unwrap laid-out sampler.');\n    }\n\n    if (isComparisonSampler(resource)) {\n      if (resource[$internal].unwrap) {\n        return resource[$internal].unwrap(this);\n      }\n      throw new Error('Cannot unwrap laid-out comparison sampler.');\n    }\n\n    if (isQuerySet(resource)) {\n      return resource.querySet;\n    }\n\n    throw new Error(`Unknown resource type: ${resource}`);\n  }\n\n  beginRenderPass(\n    descriptor: GPURenderPassDescriptor,\n    callback: (pass: RenderPass) => void,\n  ): void {\n    const pass = this.commandEncoder.beginRenderPass(descriptor);\n\n    const bindGroups = new Map<\n      TgpuBindGroupLayout,\n      TgpuBindGroup | GPUBindGroup\n    >();\n    const vertexBuffers = new Map<\n      TgpuVertexLayout,\n      {\n        buffer:\n          | (TgpuBuffer<WgslArray<BaseData> | Disarray<BaseData>> & VertexFlag)\n          | GPUBuffer;\n        offset?: number | undefined;\n        size?: number | undefined;\n      }\n    >();\n\n    let currentPipeline: TgpuRenderPipeline | undefined;\n\n    const setupPassBeforeDraw = () => {\n      if (!currentPipeline) {\n        throw new Error('Cannot draw without a call to pass.setPipeline');\n      }\n\n      const { core, priors } = currentPipeline[$internal];\n      const memo = core.unwrap();\n\n      pass.setPipeline(memo.pipeline);\n\n      const missingBindGroups = new Set(memo.usedBindGroupLayouts);\n      memo.usedBindGroupLayouts.forEach((layout, idx) => {\n        if (memo.catchall && idx === memo.catchall[0]) {\n          // Catch-all\n          pass.setBindGroup(idx, this.unwrap(memo.catchall[1]));\n          missingBindGroups.delete(layout);\n        } else {\n          const bindGroup = priors.bindGroupLayoutMap?.get(layout) ??\n            bindGroups.get(layout);\n          if (bindGroup !== undefined) {\n            missingBindGroups.delete(layout);\n            if (isBindGroup(bindGroup)) {\n              pass.setBindGroup(idx, this.unwrap(bindGroup));\n            } else {\n              pass.setBindGroup(idx, bindGroup);\n            }\n          }\n        }\n      });\n\n      const missingVertexLayouts = new Set<TgpuVertexLayout>();\n      core.usedVertexLayouts.forEach((vertexLayout, idx) => {\n        const priorBuffer = priors.vertexLayoutMap?.get(vertexLayout);\n        const opts = priorBuffer\n          ? {\n            buffer: priorBuffer,\n            offset: undefined,\n            size: undefined,\n          }\n          : vertexBuffers.get(vertexLayout);\n\n        if (!opts || !opts.buffer) {\n          missingVertexLayouts.add(vertexLayout);\n        } else if (isBuffer(opts.buffer)) {\n          pass.setVertexBuffer(\n            idx,\n            this.unwrap(opts.buffer),\n            opts.offset,\n            opts.size,\n          );\n        } else {\n          pass.setVertexBuffer(idx, opts.buffer, opts.offset, opts.size);\n        }\n      });\n\n      if (missingBindGroups.size > 0) {\n        throw new MissingBindGroupsError(missingBindGroups);\n      }\n\n      if (missingVertexLayouts.size > 0) {\n        throw new MissingVertexBuffersError(missingVertexLayouts);\n      }\n    };\n\n    callback({\n      setViewport(...args) {\n        pass.setViewport(...args);\n      },\n      setScissorRect(...args) {\n        pass.setScissorRect(...args);\n      },\n      setBlendConstant(...args) {\n        pass.setBlendConstant(...args);\n      },\n      setStencilReference(...args) {\n        pass.setStencilReference(...args);\n      },\n      beginOcclusionQuery(...args) {\n        pass.beginOcclusionQuery(...args);\n      },\n      endOcclusionQuery(...args) {\n        pass.endOcclusionQuery(...args);\n      },\n      executeBundles(...args) {\n        pass.executeBundles(...args);\n      },\n      setPipeline(pipeline) {\n        currentPipeline = pipeline;\n      },\n\n      setIndexBuffer: (buffer, indexFormat, offset, size) => {\n        if (isBuffer(buffer)) {\n          pass.setIndexBuffer(this.unwrap(buffer), indexFormat, offset, size);\n        } else {\n          pass.setIndexBuffer(buffer, indexFormat, offset, size);\n        }\n      },\n\n      setVertexBuffer(vertexLayout, buffer, offset, size) {\n        vertexBuffers.set(vertexLayout, { buffer, offset, size });\n      },\n\n      setBindGroup(bindGroupLayout, bindGroup) {\n        bindGroups.set(bindGroupLayout, bindGroup);\n      },\n\n      draw(vertexCount, instanceCount, firstVertex, firstInstance) {\n        setupPassBeforeDraw();\n        pass.draw(vertexCount, instanceCount, firstVertex, firstInstance);\n      },\n\n      drawIndexed(...args) {\n        setupPassBeforeDraw();\n        pass.drawIndexed(...args);\n      },\n\n      drawIndirect(...args) {\n        setupPassBeforeDraw();\n        pass.drawIndirect(...args);\n      },\n\n      drawIndexedIndirect(...args) {\n        setupPassBeforeDraw();\n        pass.drawIndexedIndirect(...args);\n      },\n    });\n\n    pass.end();\n  }\n\n  flush() {\n    if (!this._commandEncoder) {\n      return;\n    }\n\n    this.device.queue.submit([this._commandEncoder.finish()]);\n    this._commandEncoder = null;\n  }\n}\n\n/**\n * Options passed into {@link init}.\n */\nexport type InitOptions = {\n  adapter?: GPURequestAdapterOptions | undefined;\n  device?:\n    | GPUDeviceDescriptor & { optionalFeatures?: Iterable<GPUFeatureName> }\n    | undefined;\n  /** @default 'random' */\n  unstable_names?: 'random' | 'strict' | undefined;\n};\n\n/**\n * Options passed into {@link initFromDevice}.\n */\nexport type InitFromDeviceOptions = {\n  device: GPUDevice;\n  /** @default 'random' */\n  unstable_names?: 'random' | 'strict' | undefined;\n};\n\n/**\n * Requests a new GPU device and creates a root around it.\n * If a specific device should be used instead, use @see initFromDevice.\n *\n * @example\n * When given no options, the function will ask the browser for a suitable GPU device.\n * ```ts\n * const root = await tgpu.init();\n * ```\n *\n * @example\n * If there are specific options that should be used when requesting a device, you can pass those in.\n * ```ts\n * const adapterOptions: GPURequestAdapterOptions = ...;\n * const deviceDescriptor: GPUDeviceDescriptor = ...;\n * const root = await tgpu.init({ adapter: adapterOptions, device: deviceDescriptor });\n * ```\n */\nexport async function init(options?: InitOptions): Promise<TgpuRoot> {\n  const {\n    adapter: adapterOpt,\n    device: deviceOpt,\n    unstable_names: names = 'random',\n  } = options ?? {};\n\n  if (!navigator.gpu) {\n    throw new Error('WebGPU is not supported by this browser.');\n  }\n\n  const adapter = await navigator.gpu.requestAdapter(adapterOpt);\n\n  if (!adapter) {\n    throw new Error('Could not find a compatible GPU');\n  }\n\n  const availableFeatures: GPUFeatureName[] = [];\n  for (const feature of deviceOpt?.requiredFeatures ?? []) {\n    if (!adapter.features.has(feature)) {\n      throw new Error(\n        `Requested feature \"${feature}\" is not supported by the adapter.`,\n      );\n    }\n    availableFeatures.push(feature);\n  }\n  for (const feature of deviceOpt?.optionalFeatures ?? []) {\n    if (adapter.features.has(feature)) {\n      availableFeatures.push(feature);\n    } else {\n      console.warn(\n        `Optional feature \"${feature}\" is not supported by the adapter.`,\n      );\n    }\n  }\n\n  return new TgpuRootImpl(\n    await adapter.requestDevice({\n      ...deviceOpt,\n      requiredFeatures: availableFeatures,\n    }),\n    names === 'random' ? new RandomNameRegistry() : new StrictNameRegistry(),\n    true,\n  );\n}\n\n/**\n * Creates a root from the given device, instead of requesting it like @see init.\n *\n * @example\n * ```ts\n * const device: GPUDevice = ...;\n * const root = tgpu.initFromDevice({ device });\n * ```\n */\nexport function initFromDevice(options: InitFromDeviceOptions): TgpuRoot {\n  const {\n    device,\n    unstable_names: names = 'random',\n  } = options ?? {};\n\n  return new TgpuRootImpl(\n    device,\n    names === 'random' ? new RandomNameRegistry() : new StrictNameRegistry(),\n    false,\n  );\n}\n", "import { getResolutionCtx } from '../../gpuMode.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $gpuRepr,\n  $gpuValueOf,\n  $internal,\n  $repr,\n} from '../../shared/symbols.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport { getGpuValueRecursively } from '../valueProxyUtils.ts';\nimport type { TgpuSlot } from './slotTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport function slot<T>(defaultValue?: T): TgpuSlot<T> {\n  return new TgpuSlotImpl(defaultValue);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuSlotImpl<T> implements TgpuSlot<T> {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'slot';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<T>;\n  declare readonly [$gpuRepr]: InferGPU<T>;\n  // ---\n\n  constructor(public defaultValue: T | undefined = undefined) {}\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  areEqual(a: T, b: T): boolean {\n    return Object.is(a, b);\n  }\n\n  toString(): string {\n    return `slot:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](ctx: ResolutionCtx): InferGPU<T> {\n    return getGpuValueRecursively(ctx, ctx.unwrap(this));\n  }\n\n  get value(): InferGPU<T> {\n    const ctx = getResolutionCtx();\n    if (!ctx) {\n      throw new Error(`Cannot access tgpu.slot's value outside of resolution.`);\n    }\n\n    return this[$gpuValueOf](ctx);\n  }\n\n  get $(): InferGPU<T> {\n    return this.value;\n  }\n}\n", "import type { AnyWgslData } from '../../data/wgslTypes.ts';\nimport { inGPUMode } from '../../gpuMode.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $gpuRepr,\n  $gpuValueOf,\n  $internal,\n  $repr,\n  $wgslDataType,\n} from '../../shared/symbols.ts';\nimport {\n  isBufferUsage,\n  type ResolutionCtx,\n  type SelfResolvable,\n} from '../../types.ts';\nimport { isBufferShorthand } from '../buffer/bufferShorthand.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport { isTgpuFn, type TgpuFn } from '../function/tgpuFn.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\nimport { slot } from './slot.ts';\nimport type { TgpuAccessor, TgpuSlot } from './slotTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport function accessor<T extends AnyWgslData>(\n  schema: T,\n  defaultValue?: TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n): TgpuAccessor<T> {\n  return new TgpuAccessorImpl(schema, defaultValue);\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuAccessorImpl<T extends AnyWgslData>\n  implements TgpuAccessor<T>, SelfResolvable {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'accessor';\n  public readonly slot: TgpuSlot<\n    TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>\n  >;\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<T>;\n  declare readonly [$gpuRepr]: InferGPU<T>;\n  declare readonly [$getNameForward]: unknown;\n  // ---\n\n  constructor(\n    public readonly schema: T,\n    public readonly defaultValue:\n      | TgpuFn<() => T>\n      | TgpuBufferUsage<T>\n      | Infer<T>\n      | undefined = undefined,\n  ) {\n    this.slot = slot(defaultValue);\n    this[$getNameForward] = this.slot;\n  }\n\n  $name(label: string) {\n    this.slot.$name(label);\n    return this;\n  }\n\n  toString(): string {\n    return `accessor:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): InferGPU<T> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this.schema,\n      },\n      valueProxyHandler,\n    ) as InferGPU<T>;\n  }\n\n  get value(): InferGPU<T> {\n    if (!inGPUMode()) {\n      throw new Error('`tgpu.accessor` values are only accessible on the GPU');\n    }\n\n    return this[$gpuValueOf]();\n  }\n\n  get $(): InferGPU<T> {\n    return this.value;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const value = ctx.unwrap(this.slot);\n\n    if (isBufferUsage(value) || isBufferShorthand(value)) {\n      return ctx.resolve(value);\n    }\n\n    if (isTgpuFn(value)) {\n      return `${ctx.resolve(value)}()`;\n    }\n\n    return ctx.resolveValue(value as Infer<T>, this.schema);\n  }\n}\n", "import { getResolutionCtx } from '../../gpuMode.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $gpuRepr,\n  $gpuValueOf,\n  $providing,\n  $repr,\n} from '../../shared/symbols.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport { getGpuValueRecursively } from '../valueProxyUtils.ts';\nimport type {\n  Eventual,\n  SlotValuePair,\n  TgpuDerived,\n  TgpuSlot,\n} from './slotTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport function derived<T>(compute: () => T): TgpuDerived<T> {\n  return createDerived(compute);\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction stringifyPair([slot, value]: SlotValuePair): string {\n  return `${getName(slot) ?? '<unnamed>'}=${value}`;\n}\n\nfunction createDerived<T>(compute: () => T): TgpuDerived<T> {\n  if (getResolutionCtx()) {\n    throw new Error(\n      'Cannot create tgpu.derived objects at the resolution stage.',\n    );\n  }\n\n  const result = {\n    resourceType: 'derived' as const,\n    '~compute': compute,\n    [$repr]: undefined as Infer<T>,\n    [$gpuRepr]: undefined as InferGPU<T>,\n\n    [$gpuValueOf](ctx: ResolutionCtx): InferGPU<T> {\n      return getGpuValueRecursively(ctx, ctx.unwrap(this));\n    },\n\n    get value(): InferGPU<T> {\n      const ctx = getResolutionCtx();\n      if (!ctx) {\n        throw new Error(\n          `Cannot access tgpu.derived's value outside of resolution.`,\n        );\n      }\n\n      return this[$gpuValueOf](ctx);\n    },\n\n    get $(): InferGPU<T> {\n      return this.value;\n    },\n\n    with<TValue>(\n      slot: TgpuSlot<TValue>,\n      value: Eventual<TValue>,\n    ): TgpuDerived<T> {\n      return createBoundDerived(this, [[slot, value]]);\n    },\n\n    toString(): string {\n      return 'derived';\n    },\n  };\n\n  return result;\n}\n\nfunction createBoundDerived<T>(\n  innerDerived: TgpuDerived<T>,\n  pairs: SlotValuePair[],\n): TgpuDerived<T> {\n  const result = {\n    resourceType: 'derived' as const,\n    [$repr]: undefined as Infer<T>,\n    [$gpuRepr]: undefined as InferGPU<T>,\n\n    '~compute'() {\n      throw new Error(\n        `'~compute' should never be read on bound derived items.`,\n      );\n    },\n    [$providing]: {\n      inner: innerDerived,\n      pairs,\n    },\n\n    [$gpuValueOf](ctx: ResolutionCtx): InferGPU<T> {\n      return getGpuValueRecursively(ctx, ctx.unwrap(this));\n    },\n\n    get value(): InferGPU<T> {\n      const ctx = getResolutionCtx();\n      if (!ctx) {\n        throw new Error(\n          `Cannot access tgpu.derived's value outside of resolution.`,\n        );\n      }\n\n      return this[$gpuValueOf](ctx);\n    },\n\n    get $(): InferGPU<T> {\n      return this.value;\n    },\n\n    with<TValue>(\n      slot: TgpuSlot<TValue>,\n      value: Eventual<TValue>,\n    ): TgpuDerived<T> {\n      return createBoundDerived(innerDerived, [...pairs, [slot, value]]);\n    },\n\n    toString(): string {\n      return `derived[${pairs.map(stringifyPair).join(', ')}]`;\n    },\n  };\n\n  return result;\n}\n", "import type { AnyData } from '../../data/dataTypes.ts';\nimport { inGPUMode } from '../../gpuMode.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport { $gpuValueOf, $internal, $wgslDataType } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type VariableScope = 'private' | 'workgroup';\n\nexport interface TgpuVar<\n  TScope extends VariableScope = VariableScope,\n  TDataType extends AnyData = AnyData,\n> extends TgpuNamable {\n  value: Infer<TDataType>;\n\n  readonly [$internal]: {\n    readonly scope: TScope;\n  };\n}\n\n/**\n * Defines a variable scoped to each entry function (private).\n *\n * @param dataType The schema of the held data's type\n * @param initialValue If not provided, the variable will be initialized to the dataType's \"zero-value\".\n */\nexport function privateVar<TDataType extends AnyData>(\n  dataType: TDataType,\n  initialValue?: Infer<TDataType>,\n): TgpuVar<'private', TDataType> {\n  return new TgpuVarImpl('private', dataType, initialValue);\n}\n\n/**\n * Defines a variable scoped to the whole workgroup, shared between entry functions\n * of the same invocation.\n *\n * @param dataType The schema of the held data's type\n */\nexport function workgroupVar<TDataType extends AnyData>(\n  dataType: TDataType,\n): TgpuVar<'workgroup', TDataType> {\n  return new TgpuVarImpl('workgroup', dataType);\n}\n\nexport function isVariable<T extends TgpuVar>(\n  value: T | unknown,\n): value is T {\n  return value instanceof TgpuVarImpl;\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuVarImpl<TScope extends VariableScope, TDataType extends AnyData>\n  implements TgpuVar<TScope, TDataType>, SelfResolvable {\n  declare readonly [$internal]: {\n    readonly scope: TScope;\n  };\n\n  constructor(\n    readonly scope: TScope,\n    private readonly _dataType: TDataType,\n    private readonly _initialValue?: Infer<TDataType> | undefined,\n  ) {\n    this[$internal] = { scope };\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n\n    if (this._initialValue) {\n      ctx.addDeclaration(\n        `var<${this.scope}> ${id}: ${ctx.resolve(this._dataType)} = ${\n          ctx.resolveValue(this._initialValue, this._dataType)\n        };`,\n      );\n    } else {\n      ctx.addDeclaration(\n        `var<${this.scope}> ${id}: ${ctx.resolve(this._dataType)};`,\n      );\n    }\n\n    return id;\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  toString() {\n    return `var:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): Infer<TDataType> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this._dataType,\n      },\n      valueProxyHandler,\n    ) as Infer<TDataType>;\n  }\n\n  get value(): Infer<TDataType> {\n    if (!inGPUMode()) {\n      throw new Error('`tgpu.var` values are only accessible on the GPU');\n    }\n\n    return this[$gpuValueOf]();\n  }\n}\n", "/**\n * @module typegpu\n */\n\nimport { constant } from './core/constant/tgpuConstant.ts';\nimport { declare } from './core/declare/tgpuDeclare.ts';\nimport { computeFn } from './core/function/tgpuComputeFn.ts';\nimport { fn } from './core/function/tgpuFn.ts';\nimport { fragmentFn } from './core/function/tgpuFragmentFn.ts';\nimport { vertexFn } from './core/function/tgpuVertexFn.ts';\nimport { resolve, resolveWithContext } from './core/resolve/tgpuResolve.ts';\nimport { init, initFromDevice } from './core/root/init.ts';\nimport { comparisonSampler, sampler } from './core/sampler/sampler.ts';\nimport { accessor } from './core/slot/accessor.ts';\nimport { derived } from './core/slot/derived.ts';\nimport { slot } from './core/slot/slot.ts';\nimport { privateVar, workgroupVar } from './core/variable/tgpuVariable.ts';\nimport { vertexLayout } from './core/vertexLayout/vertexLayout.ts';\nimport { bindGroupLayout } from './tgpuBindGroupLayout.ts';\n\nexport const tgpu = {\n  fn,\n  bindGroupLayout,\n  vertexLayout,\n  slot,\n\n  init,\n  initFromDevice,\n\n  resolve,\n  resolveWithContext,\n\n  '~unstable': {\n    /**\n     * @deprecated This feature is now stable, use tgpu.fn.\n     */\n    fn,\n    fragmentFn,\n    vertexFn,\n    computeFn,\n    /**\n     * @deprecated This feature is now stable, use tgpu.vertexLayout.\n     */\n    vertexLayout,\n    derived,\n    /**\n     * @deprecated This feature is now stable, use tgpu.slot.\n     */\n    slot,\n    accessor,\n    privateVar,\n    workgroupVar,\n    const: constant,\n    declare,\n    sampler,\n    comparisonSampler,\n  },\n};\nexport default tgpu;\n\nexport {\n  MissingBindGroupsError,\n  MissingLinksError,\n  MissingSlotValueError,\n  MissingVertexBuffersError,\n  NotUniformError,\n  ResolutionError,\n} from './errors.ts';\nexport { RandomNameRegistry, StrictNameRegistry } from './nameRegistry.ts';\nexport { isBuffer, isUsableAsVertex } from './core/buffer/buffer.ts';\nexport { isDerived, isSlot } from './core/slot/slotTypes.ts';\nexport { isComparisonSampler, isSampler } from './core/sampler/sampler.ts';\nexport {\n  isSampledTextureView,\n  isStorageTextureView,\n  isTexture,\n} from './core/texture/texture.ts';\nexport {\n  isUsableAsRender,\n  isUsableAsSampled,\n} from './core/texture/usageExtension.ts';\nexport { isUsableAsStorage } from './extension.ts';\nexport {\n  asMutable as unstable_asMutable,\n  asReadonly as unstable_asReadonly,\n  asUniform as unstable_asUniform,\n  isUsableAsUniform,\n} from './core/buffer/bufferUsage.ts';\nexport { isBufferShorthand } from './core/buffer/bufferShorthand.ts';\nexport { isTgpuFn } from './core/function/tgpuFn.ts';\n\n// types\n\nexport type {\n  Configurable,\n  TgpuRoot,\n  WithBinding,\n  WithCompute,\n  WithFragment,\n  WithVertex,\n} from './core/root/rootTypes.ts';\nexport type { Storage, StorageFlag } from './extension.ts';\nexport type { TgpuVertexLayout } from './core/vertexLayout/vertexLayout.ts';\nexport type { TgpuRenderPipeline } from './core/pipeline/renderPipeline.ts';\nexport type { TgpuComputePipeline } from './core/pipeline/computePipeline.ts';\nexport type {\n  IndexFlag,\n  TgpuBuffer,\n  Uniform,\n  UniformFlag,\n  Vertex,\n  VertexFlag,\n} from './core/buffer/buffer.ts';\nexport type {\n  TgpuBufferMutable,\n  TgpuBufferReadonly,\n  TgpuBufferUniform,\n} from './core/buffer/bufferUsage.ts';\nexport type {\n  TgpuMutable,\n  TgpuReadonly,\n  TgpuUniform,\n} from './core/buffer/bufferShorthand.ts';\nexport type {\n  Eventual,\n  TgpuAccessor,\n  TgpuDerived,\n  TgpuSlot,\n} from './core/slot/slotTypes.ts';\nexport type {\n  TgpuAnyTextureView,\n  TgpuMutableTexture,\n  TgpuReadonlyTexture,\n  TgpuSampledTexture,\n  TgpuTexture,\n  TgpuWriteonlyTexture,\n} from './core/texture/texture.ts';\nexport type { TextureProps } from './core/texture/textureProps.ts';\nexport type { Render, Sampled } from './core/texture/usageExtension.ts';\nexport type { InitFromDeviceOptions, InitOptions } from './core/root/init.ts';\nexport type { TgpuConst } from './core/constant/tgpuConstant.ts';\nexport type { TgpuVar, VariableScope } from './core/variable/tgpuVariable.ts';\nexport type { TgpuSampler } from './core/sampler/sampler.ts';\nexport type {\n  BindLayoutEntry,\n  ExtractBindGroupInputFromLayout,\n  LayoutEntryToInput,\n  TgpuBindGroup,\n  TgpuBindGroupLayout,\n  TgpuLayoutComparisonSampler,\n  TgpuLayoutEntry,\n  TgpuLayoutExternalTexture,\n  TgpuLayoutSampler,\n  TgpuLayoutStorage,\n  TgpuLayoutStorageTexture,\n  TgpuLayoutTexture,\n  TgpuLayoutUniform,\n} from './tgpuBindGroupLayout.ts';\nexport type { TgpuFn, TgpuFnShell } from './core/function/tgpuFn.ts';\nexport type {\n  TgpuVertexFn,\n  TgpuVertexFnShell,\n} from './core/function/tgpuVertexFn.ts';\nexport type {\n  TgpuFragmentFn,\n  TgpuFragmentFnShell,\n} from './core/function/tgpuFragmentFn.ts';\nexport type {\n  TgpuComputeFn,\n  TgpuComputeFnShell,\n} from './core/function/tgpuComputeFn.ts';\nexport type { TgpuDeclare } from './core/declare/tgpuDeclare.ts';\n// Exported for being able to track use of these global extensions easier,\n// and to establish a solid contract between tooling using them.\nexport type { INTERNAL_GlobalExt } from './shared/meta.ts';\n"],
  "mappings": "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",
  "names": ["o", "NodeTypeCatalog", "FuncParameterType", "FORMAT_VERSION", "extractGpuValueGetter", "object", "$gpuValueOf", "assertExhaustive", "x", "location", "swizzleLenToType", "f32", "vec2f", "vec3f", "vec4f", "f16", "vec2h", "vec3h", "vec4h", "i32", "vec2i", "vec3i", "vec4i", "u32", "vec2u", "vec3u", "vec4u", "bool", "vec2b", "vec3b", "vec4b", "kindToSchema", "mat2x2f", "mat3x3f", "mat4x4f", "indexableTypeToResult", "getTypeForPropAccess", "targetType", "propName", "isWgslStruct", "isUnstruct", "UnknownData", "isNumericSchema", "propLength", "isVec", "swizzleTypeChar", "swizzleType", "getTypeForIndexAccess", "dataType", "isWgslArray", "isDisarray", "numericLiteralToSnippet", "value", "snip", "abstractInt", "abstractFloat", "INFINITE_RANK", "unwrapDecorated", "data", "getVectorComponent", "type", "vecTypeToPrimitive", "getAutoConversionRank", "src", "dest", "trueSrc", "trueDst", "compSrc", "compDest", "isMat", "getImplicitConversionRank", "primitivePreference", "srcType", "destType", "srcPref", "getConversionRank", "allowImplicit", "autoRank", "findBestType", "types", "uniqueTypes", "bestType", "minSum", "conversionDetails", "currentSum", "currentDetails", "possible", "sourceType", "conversion", "actions", "detail", "index", "hasCasts", "action", "concretize", "getBestConversion", "targetTypes", "uniqueTargetTypes", "explicitResult", "implicitResult", "applyActionToSnippet", "ctx", "resolvedValue", "convertToCommonType", "values", "restrictTo", "v", "invariant", "convertStructValues", "structType", "key", "val", "coerceToSnippet", "isSnippet", "hasInternalDataType", "$wgslDataType", "isVecInstance", "isMatInstance", "coerced", "context", "getResolutionCtx", "converted", "commonType", "arrayOf", "valueProxyHandler", "target", "prop", "$providing", "getName", "getGpuValueRecursively", "unwrapped", "valueGetter", "constant", "TgpuConstImpl", "_value", "$internal", "label", "setName", "id", "resolvedDataType", "inGPUMode", "isSlot", "isDerived", "isProviding", "isAccessor", "isSelfResolvable", "isWgsl", "isWgslData", "isGPUBuffer", "isBufferUsage", "isMarkedInternal", "applyExternals", "existing", "newExternals", "isNamable", "addArgTypesToExternals", "implementation", "argTypes", "argTypeNames", "found", "argType", "i", "argTypeName", "addReturnTypeToExternals", "returnType", "matched", "outputName", "identifierRegex", "name", "replaceExternalsInWgsl", "externalMap", "wgsl", "acc", "externalName", "external", "isLooseData", "innerAcc", "declare", "declaration", "TgpuDeclareImpl", "dependencyMap", "externals", "replacedDeclaration", "extractArgs", "rawCode", "strippedCode", "range", "strip", "code", "ParsableString", "args", "attributes", "closingParenthesis", "parentheses", "identifierEndSymbols", "identifier", "maybeType", "typeEndSymbols", "angleBrackets", "maybeRet", "argsStart", "blankSpaces", "lineBreaks", "openingCommentBlock", "commentBlocks", "str", "#pos", "#parseStartPos", "substr", "elem", "toFind", "brackets", "openedBrackets", "steps", "createFnCore", "fnAttribute", "externalsToApply", "core", "replacedImpl", "header", "body", "input", "getAttributesString", "output", "Void", "providedArgs", "argInfo", "checkAndReturnType", "pluginData", "getMetaData", "missing", "ast", "missingExternals", "MissingLinksError", "head", "arg", "FuncParameterType", "param", "alias", "maybeName", "wgslType", "jsType", "resolvedJsType", "resolvedWgslType", "withLocations", "members", "locations", "nextLocation", "usedCustomLocations", "member", "customLocation", "getCustomLocation", "isBuiltin", "createIoSchema", "layout", "isData", "isVoid", "struct", "stripTemplate", "isTemplateStringsArray", "templateLiteralIdentity", "item", "strings", "computeFn", "options", "shell", "call", "createComputeFn", "workgroupSize", "inputType", "$getNameForward", "newLabel", "fn", "createFn", "isTgpuFn", "stringifyPair", "slot", "fnBase", "createBoundFunction", "generationCtx", "createDualImpl", "castAndCopiedArgs", "schemaCallWrapper", "FnCall", "innerFn", "pairs", "_fn", "_params", "fragmentFn", "createFragmentFn", "outputType", "inputWithLocation", "vertexFn", "createVertexFn", "outputWithLocation", "RandomNameRegistry", "primer", "StrictNameRegistry", "unusedName", "isAttribute", "connectAttributesToShader", "shaderInputLayout", "usedVertexLayouts", "bufferDefinitions", "layoutToAttribListMap", "nextShaderLocation", "matchingAttribute", "attribList", "identityTypes", "isIdentityType", "resolveStructProperty", "property", "resolveStruct", "resolveUnstruct", "unstruct", "formatToWGSLType", "resolveArray", "array", "element", "resolveDisarray", "disarray", "resolveData", "alignIO", "io", "baseAlignment", "currentPos", "bitMask", "offset", "alignIO_default", "cachedOffsets", "offsetsForProps", "cached", "measurer", "Measurer", "offsets", "lastEntry", "beforeAlignment", "customAlignmentOf", "alignmentOf", "propSize", "sizeOf", "roundUp", "EVAL_ALLOWED_IN_ENV", "compiledWriters", "typeToPrimitive", "primitiveToWriteFunction", "buildWriter", "node", "offsetExpr", "valueExpr", "isAtomic", "isDecorated", "propOffsets", "sortedProps", "a", "b", "propOffset", "subSchema", "arrSchema", "elementSize", "primitive", "writeFunc", "components", "count", "isVec2", "isVec3", "matSize", "isMat2x2f", "isMat3x3f", "elementCount", "rowStride", "colIndex", "rowIndex", "byteOffset", "getCompiledWriterForSchema", "schema", "dataWriters", "_schema", "_", "alignment", "writeData", "beginning", "packed", "writer", "dataReaders", "skipOneAfter", "result", "readData", "elements", "elementType", "r", "g", "reader", "getWriteInstructions", "totalSize", "bigBuffer", "BufferWriter", "segments", "gatherAndWrite", "partialValue", "padding", "childValue", "arrayPartialValue", "idx", "leafSize", "instructions", "current", "next", "isUsableAsStorage", "NotStorageError", "_NotStorageError", "isUsableAsUniform", "buffer", "usageToVarTemplateMap", "TgpuFixedBufferImpl", "usage", "group", "binding", "TgpuLaidOutBufferImpl", "_membership", "mutableUsageMap", "asMutable", "readonlyUsageMap", "asReadonly", "uniformUsageMap", "asUniform", "usageToUsageConstructor", "INTERNAL_createBuffer", "typeSchema", "initialOrBuffer", "TgpuBufferImpl", "isBuffer", "isUsableAsVertex", "endianness", "getSystemEndianness", "_group", "_disallowedUsages", "device", "usages", "flags", "gpuBuffer", "mapped", "size", "mappedRange", "mappedView", "instruction", "srcBuffer", "BufferReader", "res", "stagingBuffer", "commandEncoder", "sampler", "props", "TgpuFixedSamplerImpl", "comparisonSampler", "TgpuFixedComparisonSamplerImpl", "isSampler", "resource", "maybe", "isComparisonSampler", "TgpuLaidOutSamplerImpl", "TgpuLaidOutComparisonSamplerImpl", "_props", "branch", "TgpuExternalTextureImpl", "texelFormatToChannelType", "texelFormatToDataType", "channelKindToFormat", "channelFormatToSchema", "INTERNAL_createTexture", "TgpuTextureImpl", "isTexture", "isStorageTextureView", "isSampledTextureView", "accessMap", "_branch", "hasStorage", "hasSampled", "hasRender", "access", "params", "storageParams", "format", "TgpuFixedStorageTextureImpl", "TgpuFixedSampledTextureImpl", "dimensionToCodeMap", "_texture", "TgpuLaidOutStorageTextureImpl", "_format", "dimension", "multisampled", "TgpuLaidOutSampledTextureImpl", "sampleType", "_multisampled", "isUsableAsSampled", "isUsableAsRender", "NotSampledError", "_NotSampledError", "bindGroupLayout", "entries", "TgpuBindGroupLayoutImpl", "isBindGroupLayout", "isBindGroup", "MissingBindingError", "_MissingBindingError", "groupLabel", "DEFAULT_MUTABLE_VISIBILITY", "DEFAULT_READONLY_VISIBILITY", "entry", "membership", "unwrapper", "visibility", "TgpuBindGroupImpl", "NotUniformError", "NODE", "tinyest", "parenthesizedOps", "binaryLogicalOps", "operatorToType", "lhs", "op", "rhs", "generateBlock", "statements", "statement", "generateStatement", "registerBlockVariable", "generateIdentifier", "generateExpression", "expression", "lhsExpr", "rhsExpr", "forcedType", "convLhs", "convRhs", "lhsStr", "rhsStr", "argExpr", "argStr", "targetNode", "propValue", "isPtr", "propertyNode", "targetStr", "propertyStr", "callee", "resolvedSnippets", "argValues", "sn", "resolvedId", "convertedResources", "conv", "ResolutionError", "fnRes", "error", "obj", "propKeys", "convertedValues", "snippets", "expr", "valuesRaw", "arrayType", "arrayValues", "blockifySingleStatement", "returnNode", "returnValue", "resolvedStruct", "cond", "cons", "alt", "condExpr", "condSnippet", "condition", "consequent", "alternate", "rawId", "rawValue", "eq", "init", "update", "initStatement", "initStr", "conditionExpr", "conditionStr", "updateStatement", "updateStr", "bodyStr", "generateFunction", "CATCHALL_BIND_GROUP_IDX_MARKER", "ItemStateStackImpl", "state", "argAliases", "layer", "boundValue", "declarationType", "INDENT", "N", "IndentController", "ResolutionCtxImpl", "opts", "resolveFunctionHeader", "memoMap", "placeholderKey", "layoutEntry", "MissingSlotValueError", "callback", "eventual", "maybeEventual", "derived", "instances", "instance", "expectedValue", "pushMode", "RuntimeMode", "popMode", "slotToValueMap", "usedSlot", "err", "provideCtx", "type_", "resolve", "usedBindGroupLayouts", "takenIndices", "automaticIds", "naturalsExcept", "layoutEntries", "createCatchallGroup", "catchallIdx", "catchallLayout", "catchall", "placeholder", "argList", "resolveWithContext", "template", "names", "dependencies", "INTERNAL_createQuerySet", "rawQuerySet", "TgpuQuerySetImpl", "isQuerySet", "self", "readBuffer", "WeakMemo", "_make", "createWithPerformanceCallback", "currentPriors", "root", "createWithTimestampWrites", "timestampWrites", "setupTimestampWrites", "priors", "querySet", "beginningOfPassWriteIndex", "endOfPassWriteIndex", "triggerPerformanceCallback", "start", "end", "INTERNAL_createComputePipeline", "slotBindings", "entryFn", "TgpuComputePipelineImpl", "ComputePipelineCore", "isComputePipeline", "_TgpuComputePipelineImpl", "_core", "_priors", "bindGroup", "newPriors", "y", "z", "memo", "passDescriptor", "pass", "missingBindGroups", "MissingBindGroupsError", "_slotBindings", "_entryFn", "resolutionResult", "resolveMeasure", "PERF", "resolveStart", "module", "l", "compileMeasure", "vertexLayout", "schemaForCount", "stepMode", "TgpuVertexLayoutImpl", "isVertexLayout", "defaultAttribEntry", "dataToContainedAttribs", "customLocationMap", "isLooseDecorated", "memberOffset", "attrib", "vertexFormats", "kindToDefaultFormatMap", "arraySchema", "isColorAttachment", "connectAttachmentToShader", "shaderOutputLayout", "attachment", "matching", "isColorTargetState", "connectTargetsToShader", "targets", "matchingTarget", "INTERNAL_createRenderPipeline", "TgpuRenderPipelineImpl", "RenderPipelineCore", "isRenderPipeline", "_TgpuRenderPipelineImpl", "definition", "internals", "indexFormatOrOffset", "offsetElementsOrSizeBytes", "sizeElementsOrUndefined", "dataTypeToIndexFormat", "PUBLIC_sizeOf", "colorAttachments", "renderPassDescriptor", "missingVertexLayouts", "MissingVertexBuffersError", "vertexCount", "instanceCount", "firstVertex", "firstInstance", "indexCount", "firstIndex", "baseVertex", "indexFormat", "offsetBytes", "sizeBytes", "connectedAttribs", "matchUpVaryingLocations", "primitiveState", "depthStencilState", "multisampleState", "descriptor", "vertexOut", "fragmentIn", "vertexFnName", "fragmentFnName", "usedLocations", "saveLocation", "isBufferShorthand", "TgpuBufferShorthandImpl", "resourceType", "#usage", "ConfigurableImpl", "_ConfigurableImpl", "bindings", "transform", "newCfg", "WithBindingImpl", "_WithBindingImpl", "_getRoot", "WithComputeImpl", "attribs", "WithVertexImpl", "_root", "_options", "_mismatch", "WithFragmentImpl", "_WithFragmentImpl", "TgpuRootImpl", "nameRegistry", "_ownDevice", "disposable", "texture", "bindGroups", "vertexBuffers", "currentPipeline", "setupPassBeforeDraw", "priorBuffer", "pipeline", "adapterOpt", "deviceOpt", "adapter", "availableFeatures", "feature", "initFromDevice", "defaultValue", "TgpuSlotImpl", "accessor", "TgpuAccessorImpl", "compute", "createDerived", "$repr", "$gpuRepr", "createBoundDerived", "innerDerived", "privateVar", "initialValue", "TgpuVarImpl", "workgroupVar", "scope", "_dataType", "_initialValue", "tgpu", "index_default"]
}
