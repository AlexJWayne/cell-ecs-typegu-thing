import {
  De,
  H,
  Lt,
  Ot,
  Ve,
  X,
  Z,
  at,
  c,
  ct,
  et,
  ht,
  it,
  nt,
  o,
  ot,
  p,
  r,
  rt,
  st,
  tt,
  u,
  ut,
  ve,
  yt
} from "./chunk-VTSB6TYK.js";

// node_modules/typegpu/chunk-RK6TMFVW.js
var S = (e) => Math.sqrt(e.x ** 2 + e.y ** 2);
var D = (e) => Math.sqrt(e.x ** 2 + e.y ** 2 + e.z ** 2);
var E = (e) => Math.sqrt(e.x ** 2 + e.y ** 2 + e.z ** 2 + e.w ** 2);
var ae = (e, n) => e.x * n.x + e.y * n.y;
var re = (e, n) => e.x * n.x + e.y * n.y + e.z * n.z;
var ve2 = (e, n) => e.x * n.x + e.y * n.y + e.z * n.z + e.w * n.w;
var r2 = (e, n, s) => Math.min(Math.max(n, e), s);
var u2 = (e) => (n) => H(e(n.x), e(n.y));
var w = (e) => (n) => et(e(n.x), e(n.y));
var R = (e) => (n) => tt(e(n.x), e(n.y));
var K = (e) => (n) => nt(e(n.x), e(n.y));
var y = (e) => (n) => X(e(n.x), e(n.y), e(n.z));
var l = (e) => (n) => st(e(n.x), e(n.y), e(n.z));
var $ = (e) => (n) => it(e(n.x), e(n.y), e(n.z));
var k = (e) => (n) => at(e(n.x), e(n.y), e(n.z));
var x = (e) => (n) => Z(e(n.x), e(n.y), e(n.z), e(n.w));
var o2 = (e) => (n) => ht(e(n.x), e(n.y), e(n.z), e(n.w));
var N = (e) => (n) => ut(e(n.x), e(n.y), e(n.z), e(n.w));
var O = (e) => (n) => yt(e(n.x), e(n.y), e(n.z), e(n.w));
var ue = (e) => (n) => {
  let s = n.columns;
  return Ve(u2(e)(s[0]), u2(e)(s[1]));
};
var we = (e) => (n) => {
  let s = n.columns;
  return ve(y(e)(s[0]), y(e)(s[1]), y(e)(s[2]));
};
var le = (e) => (n) => {
  let s = n.columns;
  return c(x(e)(s[0]), x(e)(s[1]), x(e)(s[2]), x(e)(s[3]));
};
var F = (e) => (n, s) => H(e(n.x, s.x), e(n.y, s.y));
var j = (e) => (n, s) => et(e(n.x, s.x), e(n.y, s.y));
var J = (e) => (n, s) => tt(e(n.x, s.x), e(n.y, s.y));
var Q = (e) => (n, s) => nt(e(n.x, s.x), e(n.y, s.y));
var A = (e) => (n, s) => X(e(n.x, s.x), e(n.y, s.y), e(n.z, s.z));
var P = (e) => (n, s) => st(e(n.x, s.x), e(n.y, s.y), e(n.z, s.z));
var X2 = (e) => (n, s) => it(e(n.x, s.x), e(n.y, s.y), e(n.z, s.z));
var Y = (e) => (n, s) => at(e(n.x, s.x), e(n.y, s.y), e(n.z, s.z));
var p2 = (e) => (n, s) => Z(e(n.x, s.x), e(n.y, s.y), e(n.z, s.z), e(n.w, s.w));
var Z2 = (e) => (n, s) => ht(e(n.x, s.x), e(n.y, s.y), e(n.z, s.z), e(n.w, s.w));
var ee = (e) => (n, s) => ut(e(n.x, s.x), e(n.y, s.y), e(n.z, s.z), e(n.w, s.w));
var ne = (e) => (n, s) => yt(e(n.x, s.x), e(n.y, s.y), e(n.z, s.z), e(n.w, s.w));
var fe = (e) => (n, s) => {
  let t = n.columns, T = s.columns;
  return Ve(F(e)(t[0], T[0]), F(e)(t[1], T[1]));
};
var ge = (e) => (n, s) => {
  let t = n.columns, T = s.columns;
  return ve(A(e)(t[0], T[0]), A(e)(t[1], T[1]), A(e)(t[2], T[2]));
};
var he = (e) => (n, s) => {
  let t = n.columns, T = s.columns;
  return c(p2(e)(t[0], T[0]), p2(e)(t[1], T[1]), p2(e)(t[2], T[2]), p2(e)(t[3], T[3]));
};
var d = { divInteger: (e, n) => n === 0 ? e : Math.trunc(e / n) };
var c2 = { eq: { vec2f: (e, n) => rt(e.x === n.x, e.y === n.y), vec2h: (e, n) => rt(e.x === n.x, e.y === n.y), vec2i: (e, n) => rt(e.x === n.x, e.y === n.y), vec2u: (e, n) => rt(e.x === n.x, e.y === n.y), "vec2<bool>": (e, n) => rt(e.x === n.x, e.y === n.y), vec3f: (e, n) => ot(e.x === n.x, e.y === n.y, e.z === n.z), vec3h: (e, n) => ot(e.x === n.x, e.y === n.y, e.z === n.z), vec3i: (e, n) => ot(e.x === n.x, e.y === n.y, e.z === n.z), vec3u: (e, n) => ot(e.x === n.x, e.y === n.y, e.z === n.z), "vec3<bool>": (e, n) => ot(e.x === n.x, e.y === n.y, e.z === n.z), vec4f: (e, n) => ct(e.x === n.x, e.y === n.y, e.z === n.z, e.w === n.w), vec4h: (e, n) => ct(e.x === n.x, e.y === n.y, e.z === n.z, e.w === n.w), vec4i: (e, n) => ct(e.x === n.x, e.y === n.y, e.z === n.z, e.w === n.w), vec4u: (e, n) => ct(e.x === n.x, e.y === n.y, e.z === n.z, e.w === n.w), "vec4<bool>": (e, n) => ct(e.x === n.x, e.y === n.y, e.z === n.z, e.w === n.w) }, lt: { vec2f: (e, n) => rt(e.x < n.x, e.y < n.y), vec2h: (e, n) => rt(e.x < n.x, e.y < n.y), vec2i: (e, n) => rt(e.x < n.x, e.y < n.y), vec2u: (e, n) => rt(e.x < n.x, e.y < n.y), vec3f: (e, n) => ot(e.x < n.x, e.y < n.y, e.z < n.z), vec3h: (e, n) => ot(e.x < n.x, e.y < n.y, e.z < n.z), vec3i: (e, n) => ot(e.x < n.x, e.y < n.y, e.z < n.z), vec3u: (e, n) => ot(e.x < n.x, e.y < n.y, e.z < n.z), vec4f: (e, n) => ct(e.x < n.x, e.y < n.y, e.z < n.z, e.w < n.w), vec4h: (e, n) => ct(e.x < n.x, e.y < n.y, e.z < n.z, e.w < n.w), vec4i: (e, n) => ct(e.x < n.x, e.y < n.y, e.z < n.z, e.w < n.w), vec4u: (e, n) => ct(e.x < n.x, e.y < n.y, e.z < n.z, e.w < n.w) }, or: { "vec2<bool>": (e, n) => rt(e.x || n.x, e.y || n.y), "vec3<bool>": (e, n) => ot(e.x || n.x, e.y || n.y, e.z || n.z), "vec4<bool>": (e, n) => ct(e.x || n.x, e.y || n.y, e.z || n.z, e.w || n.w) }, all: { "vec2<bool>": (e) => e.x && e.y, "vec3<bool>": (e) => e.x && e.y && e.z, "vec4<bool>": (e) => e.x && e.y && e.z && e.w }, abs: { vec2f: u2(Math.abs), vec2h: w(Math.abs), vec2i: R(Math.abs), vec2u: K(Math.abs), vec3f: y(Math.abs), vec3h: l(Math.abs), vec3i: $(Math.abs), vec3u: k(Math.abs), vec4f: x(Math.abs), vec4h: o2(Math.abs), vec4i: N(Math.abs), vec4u: O(Math.abs) }, atan2: { vec2f: F(Math.atan2), vec2h: j(Math.atan2), vec3f: A(Math.atan2), vec3h: P(Math.atan2), vec4f: p2(Math.atan2), vec4h: Z2(Math.atan2) }, acos: { vec2f: u2(Math.acos), vec2h: w(Math.acos), vec2i: R(Math.acos), vec2u: K(Math.acos), vec3f: y(Math.acos), vec3h: l(Math.acos), vec3i: $(Math.acos), vec3u: k(Math.acos), vec4f: x(Math.acos), vec4h: o2(Math.acos), vec4i: N(Math.acos), vec4u: O(Math.acos) }, acosh: { vec2f: u2(Math.acosh), vec2h: w(Math.acosh), vec3f: y(Math.acosh), vec3h: l(Math.acosh), vec4f: x(Math.acosh), vec4h: o2(Math.acosh) }, asin: { vec2f: u2(Math.asin), vec2h: w(Math.asin), vec2i: R(Math.asin), vec2u: K(Math.asin), vec3f: y(Math.asin), vec3h: l(Math.asin), vec3i: $(Math.asin), vec3u: k(Math.asin), vec4f: x(Math.asin), vec4h: o2(Math.asin), vec4i: N(Math.asin), vec4u: O(Math.asin) }, ceil: { vec2f: u2(Math.ceil), vec2h: w(Math.ceil), vec3f: y(Math.ceil), vec3h: l(Math.ceil), vec4f: x(Math.ceil), vec4h: o2(Math.ceil) }, clamp: { vec2f: (e, n, s) => H(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y)), vec2h: (e, n, s) => et(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y)), vec2i: (e, n, s) => tt(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y)), vec2u: (e, n, s) => nt(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y)), vec3f: (e, n, s) => X(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y), r2(e.z, n.z, s.z)), vec3h: (e, n, s) => st(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y), r2(e.z, n.z, s.z)), vec3i: (e, n, s) => it(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y), r2(e.z, n.z, s.z)), vec3u: (e, n, s) => at(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y), r2(e.z, n.z, s.z)), vec4f: (e, n, s) => Z(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y), r2(e.z, n.z, s.z), r2(e.w, n.w, s.w)), vec4h: (e, n, s) => ht(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y), r2(e.z, n.z, s.z), r2(e.w, n.w, s.w)), vec4i: (e, n, s) => ut(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y), r2(e.z, n.z, s.z), r2(e.w, n.w, s.w)), vec4u: (e, n, s) => yt(r2(e.x, n.x, s.x), r2(e.y, n.y, s.y), r2(e.z, n.z, s.z), r2(e.w, n.w, s.w)) }, length: { vec2f: S, vec2h: S, vec3f: D, vec3h: D, vec4f: E, vec4h: E }, add: { vec2f: F((e, n) => e + n), vec2h: j((e, n) => e + n), vec2i: J((e, n) => e + n), vec2u: Q((e, n) => e + n), vec3f: A((e, n) => e + n), vec3h: P((e, n) => e + n), vec3i: X2((e, n) => e + n), vec3u: Y((e, n) => e + n), vec4f: p2((e, n) => e + n), vec4h: Z2((e, n) => e + n), vec4i: ee((e, n) => e + n), vec4u: ne((e, n) => e + n), mat2x2f: fe((e, n) => e + n), mat3x3f: ge((e, n) => e + n), mat4x4f: he((e, n) => e + n) }, addMixed: { vec2f: (e, n) => u2((s) => s + n)(e), vec2h: (e, n) => w((s) => s + n)(e), vec2i: (e, n) => R((s) => s + n)(e), vec2u: (e, n) => K((s) => s + n)(e), vec3f: (e, n) => y((s) => s + n)(e), vec3h: (e, n) => l((s) => s + n)(e), vec3i: (e, n) => $((s) => s + n)(e), vec3u: (e, n) => k((s) => s + n)(e), vec4f: (e, n) => x((s) => s + n)(e), vec4h: (e, n) => o2((s) => s + n)(e), vec4i: (e, n) => N((s) => s + n)(e), vec4u: (e, n) => O((s) => s + n)(e), mat2x2f: (e, n) => ue((s) => s + n)(e), mat3x3f: (e, n) => we((s) => s + n)(e), mat4x4f: (e, n) => le((s) => s + n)(e) }, mulSxV: { vec2f: (e, n) => u2((s) => e * s)(n), vec2h: (e, n) => w((s) => e * s)(n), vec2i: (e, n) => R((s) => e * s)(n), vec2u: (e, n) => K((s) => e * s)(n), vec3f: (e, n) => y((s) => e * s)(n), vec3h: (e, n) => l((s) => e * s)(n), vec3i: (e, n) => $((s) => e * s)(n), vec3u: (e, n) => k((s) => e * s)(n), vec4f: (e, n) => x((s) => e * s)(n), vec4h: (e, n) => o2((s) => e * s)(n), vec4i: (e, n) => N((s) => e * s)(n), vec4u: (e, n) => O((s) => e * s)(n), mat2x2f: (e, n) => ue((s) => e * s)(n), mat3x3f: (e, n) => we((s) => e * s)(n), mat4x4f: (e, n) => le((s) => e * s)(n) }, mulVxV: { vec2f: F((e, n) => e * n), vec2h: j((e, n) => e * n), vec2i: J((e, n) => e * n), vec2u: Q((e, n) => e * n), vec3f: A((e, n) => e * n), vec3h: P((e, n) => e * n), vec3i: X2((e, n) => e * n), vec3u: Y((e, n) => e * n), vec4f: p2((e, n) => e * n), vec4h: Z2((e, n) => e * n), vec4i: ee((e, n) => e * n), vec4u: ne((e, n) => e * n), mat2x2f: (e, n) => {
  let s = e.columns, t = n.columns;
  return Ve(s[0].x * t[0].x + s[1].x * t[0].y, s[0].y * t[0].x + s[1].y * t[0].y, s[0].x * t[1].x + s[1].x * t[1].y, s[0].y * t[1].x + s[1].y * t[1].y);
}, mat3x3f: (e, n) => {
  let s = e.columns, t = n.columns;
  return ve(s[0].x * t[0].x + s[1].x * t[0].y + s[2].x * t[0].z, s[0].y * t[0].x + s[1].y * t[0].y + s[2].y * t[0].z, s[0].z * t[0].x + s[1].z * t[0].y + s[2].z * t[0].z, s[0].x * t[1].x + s[1].x * t[1].y + s[2].x * t[1].z, s[0].y * t[1].x + s[1].y * t[1].y + s[2].y * t[1].z, s[0].z * t[1].x + s[1].z * t[1].y + s[2].z * t[1].z, s[0].x * t[2].x + s[1].x * t[2].y + s[2].x * t[2].z, s[0].y * t[2].x + s[1].y * t[2].y + s[2].y * t[2].z, s[0].z * t[2].x + s[1].z * t[2].y + s[2].z * t[2].z);
}, mat4x4f: (e, n) => {
  let s = e.columns, t = n.columns;
  return c(s[0].x * t[0].x + s[1].x * t[0].y + s[2].x * t[0].z + s[3].x * t[0].w, s[0].y * t[0].x + s[1].y * t[0].y + s[2].y * t[0].z + s[3].y * t[0].w, s[0].z * t[0].x + s[1].z * t[0].y + s[2].z * t[0].z + s[3].z * t[0].w, s[0].w * t[0].x + s[1].w * t[0].y + s[2].w * t[0].z + s[3].w * t[0].w, s[0].x * t[1].x + s[1].x * t[1].y + s[2].x * t[1].z + s[3].x * t[1].w, s[0].y * t[1].x + s[1].y * t[1].y + s[2].y * t[1].z + s[3].y * t[1].w, s[0].z * t[1].x + s[1].z * t[1].y + s[2].z * t[1].z + s[3].z * t[1].w, s[0].w * t[1].x + s[1].w * t[1].y + s[2].w * t[1].z + s[3].w * t[1].w, s[0].x * t[2].x + s[1].x * t[2].y + s[2].x * t[2].z + s[3].x * t[2].w, s[0].y * t[2].x + s[1].y * t[2].y + s[2].y * t[2].z + s[3].y * t[2].w, s[0].z * t[2].x + s[1].z * t[2].y + s[2].z * t[2].z + s[3].z * t[2].w, s[0].w * t[2].x + s[1].w * t[2].y + s[2].w * t[2].z + s[3].w * t[2].w, s[0].x * t[3].x + s[1].x * t[3].y + s[2].x * t[3].z + s[3].x * t[3].w, s[0].y * t[3].x + s[1].y * t[3].y + s[2].y * t[3].z + s[3].y * t[3].w, s[0].z * t[3].x + s[1].z * t[3].y + s[2].z * t[3].z + s[3].z * t[3].w, s[0].w * t[3].x + s[1].w * t[3].y + s[2].w * t[3].z + s[3].w * t[3].w);
} }, mulMxV: { mat2x2f: (e, n) => {
  let s = e.columns;
  return H(s[0].x * n.x + s[1].x * n.y, s[0].y * n.x + s[1].y * n.y);
}, mat3x3f: (e, n) => {
  let s = e.columns;
  return X(s[0].x * n.x + s[1].x * n.y + s[2].x * n.z, s[0].y * n.x + s[1].y * n.y + s[2].y * n.z, s[0].z * n.x + s[1].z * n.y + s[2].z * n.z);
}, mat4x4f: (e, n) => {
  let s = e.columns;
  return Z(s[0].x * n.x + s[1].x * n.y + s[2].x * n.z + s[3].x * n.w, s[0].y * n.x + s[1].y * n.y + s[2].y * n.z + s[3].y * n.w, s[0].z * n.x + s[1].z * n.y + s[2].z * n.z + s[3].z * n.w, s[0].w * n.x + s[1].w * n.y + s[2].w * n.z + s[3].w * n.w);
} }, mulVxM: { mat2x2f: (e, n) => {
  let s = n.columns;
  return H(e.x * s[0].x + e.y * s[0].y, e.x * s[1].x + e.y * s[1].y);
}, mat3x3f: (e, n) => {
  let s = n.columns;
  return X(e.x * s[0].x + e.y * s[0].y + e.z * s[0].z, e.x * s[1].x + e.y * s[1].y + e.z * s[1].z, e.x * s[2].x + e.y * s[2].y + e.z * s[2].z);
}, mat4x4f: (e, n) => {
  let s = n.columns;
  return Z(e.x * s[0].x + e.y * s[0].y + e.z * s[0].z + e.w * s[0].w, e.x * s[1].x + e.y * s[1].y + e.z * s[1].z + e.w * s[1].w, e.x * s[2].x + e.y * s[2].y + e.z * s[2].z + e.w * s[2].w, e.x * s[3].x + e.y * s[3].y + e.z * s[3].z + e.w * s[3].w);
} }, div: { vec2f: F((e, n) => e / n), vec2h: j((e, n) => e / n), vec2i: J(d.divInteger), vec2u: Q(d.divInteger), vec3f: A((e, n) => e / n), vec3h: P((e, n) => e / n), vec3i: X2(d.divInteger), vec3u: Y(d.divInteger), vec4f: p2((e, n) => e / n), vec4h: Z2((e, n) => e / n), vec4i: ee(d.divInteger), vec4u: ne(d.divInteger) }, divMixed: { vec2f: (e, n) => u2((s) => s / n)(e), vec2h: (e, n) => w((s) => s / n)(e), vec2i: (e, n) => R((s) => d.divInteger(s, n))(e), vec2u: (e, n) => K((s) => d.divInteger(s, n))(e), vec3f: (e, n) => y((s) => s / n)(e), vec3h: (e, n) => l((s) => s / n)(e), vec3i: (e, n) => $((s) => d.divInteger(s, n))(e), vec3u: (e, n) => k((s) => d.divInteger(s, n))(e), vec4f: (e, n) => x((s) => s / n)(e), vec4h: (e, n) => o2((s) => s / n)(e), vec4i: (e, n) => N((s) => d.divInteger(s, n))(e), vec4u: (e, n) => O((s) => d.divInteger(s, n))(e) }, dot: { vec2f: ae, vec2h: ae, vec2i: ae, vec2u: ae, vec3f: re, vec3h: re, vec3i: re, vec3u: re, vec4f: ve2, vec4h: ve2, vec4i: ve2, vec4u: ve2 }, normalize: { vec2f: (e) => {
  let n = S(e);
  return H(e.x / n, e.y / n);
}, vec2h: (e) => {
  let n = S(e);
  return et(e.x / n, e.y / n);
}, vec2i: (e) => {
  let n = S(e);
  return tt(e.x / n, e.y / n);
}, vec2u: (e) => {
  let n = S(e);
  return nt(e.x / n, e.y / n);
}, vec3f: (e) => {
  let n = D(e);
  return X(e.x / n, e.y / n, e.z / n);
}, vec3h: (e) => {
  let n = D(e);
  return st(e.x / n, e.y / n, e.z / n);
}, vec3i: (e) => {
  let n = D(e);
  return it(e.x / n, e.y / n, e.z / n);
}, vec3u: (e) => {
  let n = D(e);
  return at(e.x / n, e.y / n, e.z / n);
}, vec4f: (e) => {
  let n = E(e);
  return Z(e.x / n, e.y / n, e.z / n, e.w / n);
}, vec4h: (e) => {
  let n = E(e);
  return ht(e.x / n, e.y / n, e.z / n, e.w / n);
}, vec4i: (e) => {
  let n = E(e);
  return ut(e.x / n, e.y / n, e.z / n, e.w / n);
}, vec4u: (e) => {
  let n = E(e);
  return yt(e.x / n, e.y / n, e.z / n, e.w / n);
} }, cross: { vec3f: (e, n) => X(e.y * n.z - e.z * n.y, e.z * n.x - e.x * n.z, e.x * n.y - e.y * n.x), vec3h: (e, n) => st(e.y * n.z - e.z * n.y, e.z * n.x - e.x * n.z, e.x * n.y - e.y * n.x) }, floor: { vec2f: u2(Math.floor), vec2h: w(Math.floor), vec3f: y(Math.floor), vec3h: l(Math.floor), vec4f: x(Math.floor), vec4h: o2(Math.floor) }, max: { vec2f: F(Math.max), vec2h: j(Math.max), vec2i: J(Math.max), vec2u: Q(Math.max), vec3f: A(Math.max), vec3h: P(Math.max), vec3i: X2(Math.max), vec3u: Y(Math.max), vec4f: p2(Math.max), vec4h: Z2(Math.max), vec4i: ee(Math.max), vec4u: ne(Math.max) }, min: { vec2f: F(Math.min), vec2h: j(Math.min), vec2i: J(Math.min), vec2u: Q(Math.min), vec3f: A(Math.min), vec3h: P(Math.min), vec3i: X2(Math.min), vec3u: Y(Math.min), vec4f: p2(Math.min), vec4h: Z2(Math.min), vec4i: ee(Math.min), vec4u: ne(Math.min) }, pow: { vec2f: (e, n) => H(e.x ** n.x, e.y ** n.y), vec2h: (e, n) => et(e.x ** n.x, e.y ** n.y), vec3f: (e, n) => X(e.x ** n.x, e.y ** n.y, e.z ** n.z), vec3h: (e, n) => st(e.x ** n.x, e.y ** n.y, e.z ** n.z), vec4f: (e, n) => Z(e.x ** n.x, e.y ** n.y, e.z ** n.z, e.w ** n.w), vec4h: (e, n) => ht(e.x ** n.x, e.y ** n.y, e.z ** n.z, e.w ** n.w) }, sign: { vec2f: u2(Math.sign), vec2h: w(Math.sign), vec2i: R(Math.sign), vec3f: y(Math.sign), vec3h: l(Math.sign), vec3i: $(Math.sign), vec4f: x(Math.sign), vec4h: o2(Math.sign), vec4i: N(Math.sign) }, sqrt: { vec2f: u2(Math.sqrt), vec2h: w(Math.sqrt), vec3f: y(Math.sqrt), vec3h: l(Math.sqrt), vec4f: x(Math.sqrt), vec4h: o2(Math.sqrt) }, mix: { vec2f: (e, n, s) => typeof s == "number" ? H(e.x * (1 - s) + n.x * s, e.y * (1 - s) + n.y * s) : H(e.x * (1 - s.x) + n.x * s.x, e.y * (1 - s.y) + n.y * s.y), vec2h: (e, n, s) => typeof s == "number" ? et(e.x * (1 - s) + n.x * s, e.y * (1 - s) + n.y * s) : et(e.x * (1 - s.x) + n.x * s.x, e.y * (1 - s.y) + n.y * s.y), vec3f: (e, n, s) => typeof s == "number" ? X(e.x * (1 - s) + n.x * s, e.y * (1 - s) + n.y * s, e.z * (1 - s) + n.z * s) : X(e.x * (1 - s.x) + n.x * s.x, e.y * (1 - s.y) + n.y * s.y, e.z * (1 - s.z) + n.z * s.z), vec3h: (e, n, s) => typeof s == "number" ? st(e.x * (1 - s) + n.x * s, e.y * (1 - s) + n.y * s, e.z * (1 - s) + n.z * s) : st(e.x * (1 - s.x) + n.x * s.x, e.y * (1 - s.y) + n.y * s.y, e.z * (1 - s.z) + n.z * s.z), vec4f: (e, n, s) => typeof s == "number" ? Z(e.x * (1 - s) + n.x * s, e.y * (1 - s) + n.y * s, e.z * (1 - s) + n.z * s, e.w * (1 - s) + n.w * s) : Z(e.x * (1 - s.x) + n.x * s.x, e.y * (1 - s.y) + n.y * s.y, e.z * (1 - s.z) + n.z * s.z, e.w * (1 - s.w) + n.w * s.w), vec4h: (e, n, s) => typeof s == "number" ? ht(e.x * (1 - s) + n.x * s, e.y * (1 - s) + n.y * s, e.z * (1 - s) + n.z * s, e.w * (1 - s) + n.w * s) : ht(e.x * (1 - s.x) + n.x * s.x, e.y * (1 - s.y) + n.y * s.y, e.z * (1 - s.z) + n.z * s.z, e.w * (1 - s.w) + n.w * s.w) }, sin: { vec2f: u2(Math.sin), vec2h: w(Math.sin), vec3f: y(Math.sin), vec3h: l(Math.sin), vec4f: x(Math.sin), vec4h: o2(Math.sin) }, cos: { vec2f: u2(Math.cos), vec2h: w(Math.cos), vec3f: y(Math.cos), vec3h: l(Math.cos), vec4f: x(Math.cos), vec4h: o2(Math.cos) }, cosh: { vec2f: u2(Math.cosh), vec2h: w(Math.cosh), vec3f: y(Math.cosh), vec3h: l(Math.cosh), vec4f: x(Math.cosh), vec4h: o2(Math.cosh) }, exp: { vec2f: u2(Math.exp), vec2h: w(Math.exp), vec3f: y(Math.exp), vec3h: l(Math.exp), vec4f: x(Math.exp), vec4h: o2(Math.exp) }, exp2: { vec2f: u2((e) => 2 ** e), vec2h: w((e) => 2 ** e), vec3f: y((e) => 2 ** e), vec3h: l((e) => 2 ** e), vec4f: x((e) => 2 ** e), vec4h: o2((e) => 2 ** e) }, log: { vec2f: u2(Math.log), vec2h: w(Math.log), vec3f: y(Math.log), vec3h: l(Math.log), vec4f: x(Math.log), vec4h: o2(Math.log) }, log2: { vec2f: u2(Math.log2), vec2h: w(Math.log2), vec3f: y(Math.log2), vec3h: l(Math.log2), vec4f: x(Math.log2), vec4h: o2(Math.log2) }, fract: { vec2f: u2((e) => e - Math.floor(e)), vec2h: w((e) => e - Math.floor(e)), vec3f: y((e) => e - Math.floor(e)), vec3h: l((e) => e - Math.floor(e)), vec4f: x((e) => e - Math.floor(e)), vec4h: o2((e) => e - Math.floor(e)) }, isCloseToZero: { vec2f: (e, n) => Math.abs(e.x) <= n && Math.abs(e.y) <= n, vec2h: (e, n) => Math.abs(e.x) <= n && Math.abs(e.y) <= n, vec3f: (e, n) => Math.abs(e.x) <= n && Math.abs(e.y) <= n && Math.abs(e.z) <= n, vec3h: (e, n) => Math.abs(e.x) <= n && Math.abs(e.y) <= n && Math.abs(e.z) <= n, vec4f: (e, n) => Math.abs(e.x) <= n && Math.abs(e.y) <= n && Math.abs(e.z) <= n && Math.abs(e.w) <= n, vec4h: (e, n) => Math.abs(e.x) <= n && Math.abs(e.y) <= n && Math.abs(e.z) <= n && Math.abs(e.w) <= n }, neg: { vec2f: u2((e) => -e), vec2h: w((e) => -e), vec2i: R((e) => -e), vec2u: K((e) => -e), "vec2<bool>": (e) => rt(!e.x, !e.y), vec3f: y((e) => -e), vec3h: l((e) => -e), vec3i: $((e) => -e), vec3u: k((e) => -e), "vec3<bool>": (e) => ot(!e.x, !e.y, !e.z), vec4f: x((e) => -e), vec4h: o2((e) => -e), vec4i: N((e) => -e), vec4u: O((e) => -e), "vec4<bool>": (e) => ct(!e.x, !e.y, !e.z, !e.w) }, select: { vec2f: (e, n, s) => H(s.x ? n.x : e.x, s.y ? n.y : e.y), vec2h: (e, n, s) => et(s.x ? n.x : e.x, s.y ? n.y : e.y), vec2i: (e, n, s) => tt(s.x ? n.x : e.x, s.y ? n.y : e.y), vec2u: (e, n, s) => nt(s.x ? n.x : e.x, s.y ? n.y : e.y), "vec2<bool>": (e, n, s) => rt(s.x ? n.x : e.x, s.y ? n.y : e.y), vec3f: (e, n, s) => X(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z), vec3h: (e, n, s) => st(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z), vec3i: (e, n, s) => it(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z), vec3u: (e, n, s) => at(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z), "vec3<bool>": (e, n, s) => ot(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z), vec4f: (e, n, s) => Z(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z, s.w ? n.w : e.w), vec4h: (e, n, s) => ht(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z, s.w ? n.w : e.w), vec4i: (e, n, s) => ut(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z, s.w ? n.w : e.w), vec4u: (e, n, s) => yt(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z, s.w ? n.w : e.w), "vec4<bool>": (e, n, s) => ct(s.x ? n.x : e.x, s.y ? n.y : e.y, s.z ? n.z : e.z, s.w ? n.w : e.w) }, tanh: { vec2f: u2(Math.tanh), vec2h: w(Math.tanh), vec3f: y(Math.tanh), vec3h: l(Math.tanh), vec4f: x(Math.tanh), vec4h: o2(Math.tanh) } };
function G(e) {
  return de(e.dataType);
}
function de(e) {
  let n = e?.type;
  return !!e?.[r] && (n === "abstractInt" || n === "abstractFloat" || n === "f32" || n === "f16" || n === "i32" || n === "u32");
}
function oe(e, n) {
  if (typeof e == "number" && typeof n == "number") return e + n;
  if (typeof e == "number" && De(n)) return c2.addMixed[n.kind](n, e);
  if (De(e) && typeof n == "number") return c2.addMixed[e.kind](e, n);
  if (De(e) && De(n) || Lt(e) && Lt(n)) return c2.add[e.kind](e, n);
  throw new Error("Add/Sub called with invalid arguments.");
}
var ke = o(oe, (e, n) => u(`(${e.value} + ${n.value})`, G(e) ? n.dataType : e.dataType), "coerce");
function Te(e, n) {
  return oe(e, me(-1, n));
}
var ie = o(Te, (e, n) => u(`(${e.value} - ${n.value})`, G(e) ? n.dataType : e.dataType), "sub", "coerce");
function be(e, n) {
  if (typeof e == "number" && typeof n == "number") return e * n;
  if (typeof e == "number" && (De(n) || Lt(n))) return c2.mulSxV[n.kind](e, n);
  if ((De(e) || Lt(e)) && typeof n == "number") return c2.mulSxV[e.kind](n, e);
  if (De(e) && De(n)) return c2.mulVxV[e.kind](e, n);
  if (Ot(e) && Lt(n)) return c2.mulVxM[n.kind](e, n);
  if (Lt(e) && Ot(n)) return c2.mulMxV[e.kind](e, n);
  if (Lt(e) && Lt(n)) return c2.mulVxV[e.kind](e, n);
  throw new Error("Mul called with invalid arguments.");
}
var me = o(be, (e, n) => {
  let s = G(e) ? n.dataType : G(n) || e.dataType.type.startsWith("vec") ? e.dataType : n.dataType.type.startsWith("vec") ? n.dataType : e.dataType;
  return u(`(${e.value} * ${n.value})`, s);
}, "mul");
function Me(e, n) {
  if (typeof e == "number" && typeof n == "number") return e / n;
  if (typeof e == "number" && De(n)) return c2.divMixed[n.kind](n, e);
  if (De(e) && typeof n == "number") return c2.divMixed[e.kind](e, n);
  if (De(e) && De(n)) return c2.div[e.kind](e, n);
  throw new Error("Div called with invalid arguments.");
}
var Oe = o(Me, (e, n) => G(e) && G(n) ? u(`(f32(${e.value}) / ${n.value})`, p) : u(`(${e.value} / ${n.value})`, e.dataType), "div");
var Le = o((e) => typeof e == "number" ? Math.abs(e) : c2.abs[e.kind](e), (e) => u(`abs(${e.value})`, e.dataType), "abs");
var _e = o((e, n) => typeof e == "number" && typeof n == "number" ? Math.atan2(e, n) : c2.atan2[e.kind](e, n), (e, n) => u(`atan2(${e.value}, ${n.value})`, e.dataType), "atan2");
var Ue = o((e) => typeof e == "number" ? Math.acos(e) : c2.acos[e.kind](e), (e) => u(`acos(${e.value})`, e.dataType), "acos");
var We = o((e) => typeof e == "number" ? Math.acosh(e) : c2.acosh[e.kind](e), (e) => u(`acosh(${e.value})`, e.dataType), "acosh");
var qe = o((e) => typeof e == "number" ? Math.asin(e) : c2.asin[e.kind](e), (e) => u(`asin(${e.value})`, e.dataType), "asin");
var Ce = o((e) => typeof e == "number" ? Math.ceil(e) : c2.ceil[e.kind](e), (e) => u(`ceil(${e.value})`, e.dataType), "ceil");
var Se = o((e, n, s) => typeof e == "number" ? Math.min(Math.max(n, e), s) : c2.clamp[e.kind](e, n, s), (e, n, s) => u(`clamp(${e.value}, ${n.value}, ${s.value})`, e.dataType), "clamp");
var De2 = o((e) => typeof e == "number" ? Math.cos(e) : c2.cos[e.kind](e), (e) => u(`cos(${e.value})`, e.dataType), "cos");
var Ee = o((e) => typeof e == "number" ? Math.cosh(e) : c2.cosh[e.kind](e), (e) => u(`cosh(${e.value})`, e.dataType), "cosh");
var je = o((e, n) => c2.cross[e.kind](e, n), (e, n) => u(`cross(${e.value}, ${n.value})`, e.dataType), "cross");
var ze = o((e, n) => c2.dot[e.kind](e, n), (e, n) => u(`dot(${e.value}, ${n.value})`, p), "dot");
var Pe = o((e) => c2.normalize[e.kind](e), (e) => u(`normalize(${e.value})`, e.dataType), "normalize");
var Ze = o((e) => typeof e == "number" ? Math.floor(e) : c2.floor[e.kind](e), (e) => u(`floor(${e.value})`, e.dataType), "floor");
var Ge = o((e) => typeof e == "number" ? e - Math.floor(e) : c2.fract[e.kind](e), (e) => u(`fract(${e.value})`, e.dataType), "fract");
var pe = o((e) => typeof e == "number" ? Math.abs(e) : c2.length[e.kind](e), (e) => u(`length(${e.value})`, p), "length");
var He = o((e) => typeof e == "number" ? Math.log(e) : c2.log[e.kind](e), (e) => u(`log(${e.value})`, e.dataType), "log");
var Je = o((e) => typeof e == "number" ? Math.log2(e) : c2.log2[e.kind](e), (e) => u(`log2(${e.value})`, e.dataType), "log2");
var Qe = o((e, n) => typeof e == "number" ? Math.max(e, n) : c2.max[e.kind](e, n), (e, n) => u(`max(${e.value}, ${n.value})`, e.dataType), "max", "coerce");
var Xe = o((e, n) => typeof e == "number" ? Math.min(e, n) : c2.min[e.kind](e, n), (e, n) => u(`min(${e.value}, ${n.value})`, e.dataType), "min", "coerce");
var Ye = o((e) => typeof e == "number" ? Math.sign(e) : c2.sign[e.kind](e), (e) => u(`sign(${e.value})`, e.dataType), "sign");
var en = o((e) => typeof e == "number" ? Math.sin(e) : c2.sin[e.kind](e), (e) => u(`sin(${e.value})`, e.dataType), "sin");
var nn = o((e) => typeof e == "number" ? Math.exp(e) : c2.exp[e.kind](e), (e) => u(`exp(${e.value})`, e.dataType), "exp");
var sn = o((e) => typeof e == "number" ? 2 ** e : c2.exp2[e.kind](e), (e) => u(`exp2(${e.value})`, e.dataType), "exp2");
var tn = o((e, n) => {
  if (typeof e == "number" && typeof n == "number") return e ** n;
  if (typeof e == "object" && typeof n == "object" && "kind" in e && "kind" in n) return c2.pow[e.kind](e, n);
  throw new Error("Invalid arguments to pow()");
}, (e, n) => u(`pow(${e.value}, ${n.value})`, e.dataType), "pow");
var cn = o((e, n, s) => {
  if (typeof e == "number") {
    if (typeof s != "number" || typeof n != "number") throw new Error("When e1 and e2 are numbers, the blend factor must be a number.");
    return e * (1 - s) + n * s;
  }
  if (typeof e == "number" || typeof n == "number") throw new Error("e1 and e2 need to both be vectors of the same kind.");
  return c2.mix[e.kind](e, n, s);
}, (e, n, s) => u(`mix(${e.value}, ${n.value}, ${s.value})`, e.dataType), "mix");
var an = o((e, n) => ie(e, me(2 * ze(n, e), n)), (e, n) => u(`reflect(${e.value}, ${n.value})`, e.dataType), "reflect");
var rn = o((e, n) => typeof e == "number" && typeof n == "number" ? Math.abs(e - n) : pe(ie(e, n)), (e, n) => u(`distance(${e.value}, ${n.value})`, p), "distance");
var vn = o((e) => typeof e == "number" ? -e : c2.neg[e.kind](e), (e) => u(`-(${e.value})`, e.dataType), "neg");
var xn = o((e) => typeof e == "number" ? Math.sqrt(e) : c2.sqrt[e.kind](e), (e) => u(`sqrt(${e.value})`, e.dataType), "sqrt");
var yn = o((e) => typeof e == "number" ? Math.tanh(e) : c2.tanh[e.kind](e), (e) => u(`tanh(${e.value})`, e.dataType), "tanh");

// node_modules/typed-binary/dist/index.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var main_api_exports = {};
__export(main_api_exports, {
  BufferReader: () => BufferReader,
  BufferWriter: () => BufferWriter,
  MaxValue: () => MaxValue,
  Measurer: () => Measurer,
  UnresolvedReferenceError: () => UnresolvedReferenceError,
  ValidationError: () => ValidationError,
  arrayOf: () => arrayOf,
  bool: () => bool,
  byte: () => byte,
  chars: () => chars,
  concat: () => concat,
  dynamicArrayOf: () => dynamicArrayOf,
  f16: () => f16,
  f32: () => f32,
  f32Array: () => f32Array,
  f64Array: () => f64Array,
  generic: () => generic,
  genericEnum: () => genericEnum,
  i16: () => i16,
  i16Array: () => i16Array,
  i32: () => i32,
  i32Array: () => i32Array,
  i8: () => i8,
  i8Array: () => i8Array,
  keyed: () => keyed,
  object: () => object,
  optional: () => optional,
  string: () => string,
  tupleOf: () => tupleOf,
  u16: () => u16,
  u16Array: () => u16Array,
  u32: () => u32,
  u32Array: () => u32Array,
  u8: () => u8,
  u8Array: () => u8Array,
  u8ClampedArray: () => u8ClampedArray
});
var UnresolvedReferenceError = class _UnresolvedReferenceError extends Error {
  constructor(msg) {
    super(msg);
    Object.setPrototypeOf(this, _UnresolvedReferenceError.prototype);
  }
};
var ValidationError = class _ValidationError extends Error {
  constructor(msg) {
    super(msg);
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
};
var UnboundedMeasurer = class {
  constructor() {
    __publicField(this, "size", Number.NaN);
    __publicField(this, "unbounded", this);
    __publicField(this, "isUnbounded", true);
  }
  add() {
    return this;
  }
  fork() {
    return this;
  }
};
var unboundedMeasurer = new UnboundedMeasurer();
var Measurer = class _Measurer {
  constructor() {
    __publicField(this, "size", 0);
    __publicField(this, "unbounded", unboundedMeasurer);
    __publicField(this, "isUnbounded", false);
  }
  add(bytes) {
    this.size += bytes;
    return this;
  }
  fork() {
    const forked = new _Measurer();
    forked.size = this.size;
    return forked;
  }
};
var MaxValue = Symbol(
  "The biggest (in amount of bytes needed) value a schema can represent"
);
var Schema = class {
  constructor() {
    __publicField(this, "__unwrapped");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  resolveReferences(ctx) {
  }
  seekProperty(_reference, _prop) {
    return null;
  }
};
var Ref = class {
  constructor(key) {
    this.key = key;
  }
};
var SubTypeKey = {
  STRING: "string",
  ENUM: "enum"
};
var ArraySchema = class extends Schema {
  constructor(_unstableElementSchema, length) {
    super();
    this._unstableElementSchema = _unstableElementSchema;
    this.length = length;
    __publicField(this, "elementSchema");
    this.elementSchema = _unstableElementSchema;
  }
  resolveReferences(ctx) {
    this.elementSchema = ctx.resolve(this._unstableElementSchema);
  }
  write(output, values) {
    if (values.length !== this.length) {
      throw new ValidationError(
        `Expected array of length ${this.length}, got ${values.length}`
      );
    }
    for (const value of values) {
      this.elementSchema.write(output, value);
    }
  }
  read(input) {
    const array = [];
    for (let i = 0; i < this.length; ++i) {
      array.push(this.elementSchema.read(input));
    }
    return array;
  }
  /**
   * Returns the maximum number of bytes this schema can take up.
   *
   * Returns `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.elementSchema.measure(MaxValue).size * this.length;
  }
  measure(values, measurer = new Measurer()) {
    for (let i = 0; i < this.length; ++i) {
      this.elementSchema.measure(
        values === MaxValue ? MaxValue : values[i],
        measurer
      );
    }
    return measurer;
  }
};
function arrayOf(elementSchema, length) {
  return new ArraySchema(elementSchema, length);
}
var BoolSchema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 1);
  }
  read(input) {
    return input.readBool();
  }
  write(output, value) {
    output.writeBool(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(1);
  }
};
var bool = new BoolSchema();
var _StringSchema = class _StringSchema2 extends Schema {
  static get _encoder() {
    if (!_StringSchema2._cachedEncoder) {
      _StringSchema2._cachedEncoder = new TextEncoder();
    }
    return _StringSchema2._cachedEncoder;
  }
  read(input) {
    return input.readString();
  }
  write(output, value) {
    output.writeString(value);
  }
  measure(value, measurer = new Measurer()) {
    if (value === MaxValue) {
      return measurer.unbounded;
    }
    const encoded = _StringSchema2._encoder.encode(value);
    return measurer.add(encoded.byteLength + 1);
  }
};
__publicField(_StringSchema, "_cachedEncoder");
var StringSchema = _StringSchema;
var string = new StringSchema();
var Int8Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 1);
  }
  read(input) {
    return input.readInt8();
  }
  write(output, value) {
    output.writeInt8(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(1);
  }
};
var i8 = new Int8Schema();
var Uint8Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 1);
  }
  read(input) {
    return input.readUint8();
  }
  write(output, value) {
    output.writeUint8(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(1);
  }
};
var u8 = new Uint8Schema();
var byte = u8;
var Int16Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 2);
  }
  read(input) {
    return input.readInt16();
  }
  write(output, value) {
    output.writeInt16(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(2);
  }
};
var i16 = new Int16Schema();
var Uint16Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 2);
  }
  read(input) {
    return input.readUint16();
  }
  write(output, value) {
    output.writeUint16(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(2);
  }
};
var u16 = new Uint16Schema();
var Int32Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 4);
  }
  read(input) {
    return input.readInt32();
  }
  write(output, value) {
    output.writeInt32(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(4);
  }
};
var i32 = new Int32Schema();
var Uint32Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 4);
  }
  read(input) {
    return input.readUint32();
  }
  write(output, value) {
    output.writeUint32(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(4);
  }
};
var u32 = new Uint32Schema();
var Float16Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 2);
  }
  read(input) {
    return input.readFloat16();
  }
  write(output, value) {
    output.writeFloat16(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(2);
  }
};
var f16 = new Float16Schema();
var Float32Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 4);
  }
  read(input) {
    return input.readFloat32();
  }
  write(output, value) {
    output.writeFloat32(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(4);
  }
};
var f32 = new Float32Schema();
var CharsSchema = class extends Schema {
  constructor(length) {
    super();
    this.length = length;
  }
  write(output, value) {
    if (value.length !== this.length) {
      throw new ValidationError(
        `Expected char-string of length ${this.length}, got ${value.length}`
      );
    }
    for (let i = 0; i < value.length; ++i) {
      output.writeUint8(value.charCodeAt(i));
    }
  }
  read(input) {
    let content = "";
    for (let i = 0; i < this.length; ++i) {
      content += String.fromCharCode(input.readByte());
    }
    return content;
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(this.length);
  }
};
function chars(length) {
  return new CharsSchema(length);
}
function exactEntries(record) {
  return Object.entries(record);
}
function resolveMap(ctx, refs) {
  const props = {};
  for (const [key, ref] of exactEntries(refs)) {
    props[key] = ctx.resolve(ref);
  }
  return props;
}
var ObjectSchema = class extends Schema {
  constructor(_properties) {
    super();
    this._properties = _properties;
    __publicField(this, "properties");
    this.properties = _properties;
  }
  resolveReferences(ctx) {
    this.properties = resolveMap(ctx, this._properties);
  }
  write(output, value) {
    for (const [key, property] of exactEntries(this.properties)) {
      property.write(output, value[key]);
    }
  }
  read(input) {
    const result = {};
    for (const [key, property] of exactEntries(this.properties)) {
      result[key] = property.read(input);
    }
    return result;
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    const measurer = new Measurer();
    for (const property of Object.values(this.properties)) {
      property.measure(MaxValue, measurer);
    }
    return measurer.size;
  }
  measure(value, measurer = new Measurer()) {
    for (const [key, property] of exactEntries(this.properties)) {
      property.measure(
        value === MaxValue ? MaxValue : value[key],
        measurer
      );
    }
    return measurer;
  }
  seekProperty(reference, prop) {
    let bufferOffset = 0;
    for (const [key, property] of exactEntries(this.properties)) {
      if (key === prop) {
        return {
          bufferOffset,
          schema: property
        };
      }
      bufferOffset += property.measure(reference).size;
    }
    return null;
  }
};
function object(properties) {
  return new ObjectSchema(properties);
}
var GenericObjectSchema = class extends Schema {
  constructor(keyedBy, properties, _subTypeMap) {
    super();
    this.keyedBy = keyedBy;
    this._subTypeMap = _subTypeMap;
    __publicField(this, "_baseObject");
    __publicField(this, "subTypeMap");
    this._baseObject = new ObjectSchema(properties);
    this.subTypeMap = _subTypeMap;
  }
  resolveReferences(ctx) {
    this._baseObject.resolveReferences(ctx);
    this.subTypeMap = resolveMap(ctx, this._subTypeMap);
  }
  write(output, value) {
    const subTypeKey = value.type;
    const subTypeDescription = this.subTypeMap[subTypeKey] || null;
    if (subTypeDescription === null) {
      throw new Error(
        `Unknown sub-type '${subTypeKey.toString()}' in among '${JSON.stringify(
          Object.keys(this.subTypeMap)
        )}'`
      );
    }
    if (this.keyedBy === SubTypeKey.ENUM) {
      output.writeUint8(value.type);
    } else {
      output.writeString(value.type);
    }
    this._baseObject.write(output, value);
    for (const [key, extraProp] of exactEntries(
      subTypeDescription.properties
    )) {
      extraProp.write(output, value[key]);
    }
  }
  read(input) {
    const subTypeKey = this.keyedBy === SubTypeKey.ENUM ? input.readByte() : input.readString();
    const subTypeDescription = this.subTypeMap[subTypeKey] || null;
    if (subTypeDescription === null) {
      throw new Error(
        `Unknown sub-type '${subTypeKey}' in among '${JSON.stringify(
          Object.keys(this.subTypeMap)
        )}'`
      );
    }
    const result = this._baseObject.read(input);
    result.type = subTypeKey;
    if (subTypeDescription !== null) {
      for (const [key, extraProp] of exactEntries(
        subTypeDescription.properties
      )) {
        result[key] = extraProp.read(input);
      }
    }
    return result;
  }
  measure(value, measurer = new Measurer()) {
    this._baseObject.measure(
      value,
      measurer
    );
    if (this.keyedBy === SubTypeKey.ENUM) {
      measurer.add(1);
    } else if (value !== MaxValue) {
      measurer.add(value.type.length + 1);
    } else {
      return measurer.unbounded;
    }
    if (value === MaxValue) {
      const biggestSubType = Object.values(this.subTypeMap).map((subType) => {
        const forkedMeasurer = measurer.fork();
        for (const prop of Object.values(subType.properties)) {
          prop.measure(MaxValue, forkedMeasurer);
        }
        return [subType, forkedMeasurer.size];
      }).reduce((a, b) => a[1] > b[1] ? a : b)[0];
      for (const prop of Object.values(biggestSubType.properties)) {
        prop.measure(MaxValue, measurer);
      }
    } else {
      const subTypeKey = value.type;
      const subTypeDescription = this.subTypeMap[subTypeKey] || null;
      if (subTypeDescription === null) {
        throw new Error(
          `Unknown sub-type '${subTypeKey.toString()}', expected one of '${JSON.stringify(
            Object.keys(this.subTypeMap)
          )}'`
        );
      }
      for (const [key, prop] of exactEntries(subTypeDescription.properties)) {
        prop.measure(value[key], measurer);
      }
    }
    return measurer;
  }
};
function generic(properties, subTypeMap) {
  return new GenericObjectSchema(SubTypeKey.STRING, properties, subTypeMap);
}
function genericEnum(properties, subTypeMap) {
  return new GenericObjectSchema(SubTypeKey.ENUM, properties, subTypeMap);
}
function concat(objs) {
  return new ObjectSchema(
    Object.fromEntries(
      objs.flatMap(({ properties }) => Object.entries(properties))
    )
  );
}
var DynamicArraySchema = class extends Schema {
  constructor(_unstableElementType) {
    super();
    this._unstableElementType = _unstableElementType;
    __publicField(this, "elementType");
    this.elementType = _unstableElementType;
  }
  resolveReferences(ctx) {
    this.elementType = ctx.resolve(this._unstableElementType);
  }
  write(output, values) {
    output.writeUint32(values.length);
    for (const value of values) {
      this.elementType.write(output, value);
    }
  }
  read(input) {
    const array = [];
    const len = input.readUint32();
    for (let i = 0; i < len; ++i) {
      array.push(this.elementType.read(input));
    }
    return array;
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.measure(MaxValue).size;
  }
  measure(values, measurer = new Measurer()) {
    if (values === MaxValue) {
      return measurer.unbounded;
    }
    measurer.add(4);
    for (const value of values) {
      this.elementType.measure(value, measurer);
    }
    return measurer;
  }
  seekProperty(reference, prop) {
    if (typeof prop === "symbol") {
      return null;
    }
    const indexProp = Number.parseInt(String(prop), 10);
    if (Number.isNaN(indexProp)) {
      return null;
    }
    if (reference === MaxValue) {
      return {
        bufferOffset: this.elementType.measure(MaxValue).size * indexProp,
        schema: this.elementType
      };
    }
    if (indexProp >= reference.length) {
      return null;
    }
    const measurer = new Measurer();
    for (let i = 0; i < indexProp; ++i) {
      this.elementType.measure(reference[i], measurer);
    }
    return {
      bufferOffset: measurer.size,
      schema: this.elementType
    };
  }
};
function dynamicArrayOf(elementSchema) {
  return new DynamicArraySchema(elementSchema);
}
var RefSchema = class {
  constructor(key) {
    __publicField(this, "__unwrapped");
    __publicField(this, "ref");
    this.ref = new Ref(key);
  }
  resolveReferences() {
    throw new UnresolvedReferenceError(
      "Tried to resolve a reference directly. Do it through a RefResolver instead."
    );
  }
  read() {
    throw new UnresolvedReferenceError(
      "Tried to read a reference directly. Resolve it instead."
    );
  }
  write() {
    throw new UnresolvedReferenceError(
      "Tried to write a reference directly. Resolve it instead."
    );
  }
  measure() {
    throw new UnresolvedReferenceError(
      "Tried to measure size of a reference directly. Resolve it instead."
    );
  }
  seekProperty() {
    throw new UnresolvedReferenceError(
      "Tried to seek property of a reference directly. Resolve it instead."
    );
  }
};
var RefResolve = class {
  constructor() {
    __publicField(this, "registry", {});
  }
  hasKey(key) {
    return this.registry[key] !== void 0;
  }
  register(key, schema) {
    this.registry[key] = schema;
  }
  resolve(unstableSchema) {
    if (unstableSchema instanceof RefSchema) {
      const ref = unstableSchema.ref;
      const key = ref.key;
      if (this.registry[key] !== void 0) {
        return this.registry[key];
      }
      throw new UnresolvedReferenceError(
        `Couldn't resolve reference to ${key}. Unknown key.`
      );
    }
    unstableSchema.resolveReferences(this);
    return unstableSchema;
  }
};
var KeyedSchema = class {
  constructor(key, innerResolver) {
    this.key = key;
    __publicField(this, "__unwrapped");
    __publicField(this, "__keyDefinition");
    __publicField(this, "innerType");
    this.innerType = innerResolver(new RefSchema(key));
    this.resolveReferences(new RefResolve());
  }
  resolveReferences(ctx) {
    if (!ctx.hasKey(this.key)) {
      ctx.register(this.key, this.innerType);
      this.innerType.resolveReferences(ctx);
    }
  }
  read(input) {
    return this.innerType.read(input);
  }
  write(output, value) {
    this.innerType.write(output, value);
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.measure(MaxValue).size;
  }
  measure(value, measurer = new Measurer()) {
    return this.innerType.measure(value, measurer);
  }
  seekProperty(reference, prop) {
    return this.innerType.seekProperty(reference, prop);
  }
};
function keyed(key, inner) {
  return new KeyedSchema(key, inner);
}
var OptionalSchema = class extends Schema {
  constructor(_innerUnstableSchema) {
    super();
    this._innerUnstableSchema = _innerUnstableSchema;
    __publicField(this, "innerSchema");
    this.innerSchema = _innerUnstableSchema;
  }
  resolveReferences(ctx) {
    this.innerSchema = ctx.resolve(this._innerUnstableSchema);
  }
  write(output, value) {
    if (value !== void 0 && value !== null) {
      output.writeBool(true);
      this.innerSchema.write(output, value);
    } else {
      output.writeBool(false);
    }
  }
  read(input) {
    const valueExists = input.readBool();
    if (valueExists) {
      return this.innerSchema.read(input);
    }
    return void 0;
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.measure(MaxValue).size;
  }
  measure(value, measurer = new Measurer()) {
    if (value !== void 0) {
      this.innerSchema.measure(value, measurer);
    }
    return measurer.add(1);
  }
};
function optional(innerType) {
  return new OptionalSchema(innerType);
}
function resolveArray(ctx, refs) {
  return refs.map((ref) => ctx.resolve(ref));
}
var TupleSchema = class extends Schema {
  constructor(_unstableSchemas) {
    super();
    this._unstableSchemas = _unstableSchemas;
    __publicField(this, "schemas");
    this.schemas = _unstableSchemas;
  }
  resolveReferences(ctx) {
    this.schemas = resolveArray(ctx, this._unstableSchemas);
  }
  write(output, values) {
    if (values.length !== this.schemas.length) {
      throw new ValidationError(
        `Expected tuple of length ${this.schemas.length}, got ${values.length}`
      );
    }
    for (let i = 0; i < this.schemas.length; ++i) {
      this.schemas[i].write(output, values[i]);
    }
  }
  read(input) {
    const array = [];
    for (let i = 0; i < this.schemas.length; ++i) {
      array.push(
        this.schemas[i].read(input)
      );
    }
    return array;
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.measure(MaxValue).size;
  }
  measure(values, measurer = new Measurer()) {
    for (let i = 0; i < this.schemas.length; ++i) {
      this.schemas[i].measure(
        values === MaxValue ? MaxValue : values[i],
        measurer
      );
    }
    return measurer;
  }
};
function tupleOf(schemas) {
  return new TupleSchema(schemas);
}
var TypedArraySchema = class extends Schema {
  constructor(length, _arrayConstructor) {
    super();
    this.length = length;
    this._arrayConstructor = _arrayConstructor;
    __publicField(this, "byteLength");
    this.byteLength = length * _arrayConstructor.BYTES_PER_ELEMENT;
  }
  write(output, value) {
    output.writeSlice(value);
  }
  read(input) {
    const buffer = new ArrayBuffer(this.byteLength);
    const view = new this._arrayConstructor(buffer, 0, this.length);
    input.readSlice(view, 0, this.byteLength);
    return view;
  }
  measure(_value, measurer = new Measurer()) {
    return measurer.add(this.byteLength);
  }
};
var u8Array = (length) => new TypedArraySchema(length, Uint8Array);
var u8ClampedArray = (length) => new TypedArraySchema(length, Uint8ClampedArray);
var u16Array = (length) => new TypedArraySchema(length, Uint16Array);
var u32Array = (length) => new TypedArraySchema(length, Uint32Array);
var i8Array = (length) => new TypedArraySchema(length, Int8Array);
var i16Array = (length) => new TypedArraySchema(length, Int16Array);
var i32Array = (length) => new TypedArraySchema(length, Int32Array);
var f32Array = (length) => new TypedArraySchema(length, Float32Array);
var f64Array = (length) => new TypedArraySchema(length, Float64Array);
function isSystemBigEndian() {
  const array = new Uint8Array(4);
  const view = new Uint32Array(array.buffer);
  view[0] = 1;
  return array[0] === 0;
}
function getSystemEndianness() {
  return isSystemBigEndian() ? "big" : "little";
}
function unwrapBuffer(buffer) {
  let byteOffset = 0;
  let innerBuffer = buffer;
  if (!!innerBuffer && "buffer" in innerBuffer && "byteOffset" in innerBuffer) {
    byteOffset += innerBuffer.byteOffset;
    innerBuffer = innerBuffer.buffer;
  }
  return { buffer: innerBuffer, byteOffset, byteLength: buffer.byteLength };
}
var BufferIOBase = class {
  constructor(buffer, options) {
    __publicField(this, "dataView");
    __publicField(this, "littleEndian");
    __publicField(this, "byteOffset", 0);
    __publicField(this, "endianness");
    const { byteOffset = 0, endianness = "system" } = options != null ? options : {};
    this.byteOffset = byteOffset;
    const systemEndianness = getSystemEndianness();
    this.endianness = endianness === "system" ? systemEndianness : endianness;
    this.littleEndian = this.endianness === "little";
    const unwrapped = unwrapBuffer(buffer);
    this.byteOffset += unwrapped.byteOffset;
    this.dataView = new DataView(unwrapped.buffer);
  }
  get currentByteOffset() {
    return this.byteOffset;
  }
  seekTo(offset) {
    this.byteOffset = offset;
  }
  skipBytes(bytes) {
    this.byteOffset += bytes;
  }
};
function numberToFloat16(value) {
  if (value === 0) return 0;
  if (Number.isNaN(value)) return 32256;
  if (!Number.isFinite(value)) return value > 0 ? 31744 : 64512;
  const sign = value < 0 ? 1 : 0;
  const absValue = Math.abs(value);
  const exponent = Math.floor(Math.log2(absValue));
  const mantissa = absValue / 2 ** exponent - 1;
  const biasedExponent = exponent + 15;
  const mantissaBits = Math.floor(mantissa * 1024);
  return sign << 15 | biasedExponent << 10 | mantissaBits;
}
function float16ToNumber(uint16Encoding) {
  const sign = (uint16Encoding & 32768) >> 15;
  const exponent = (uint16Encoding & 31744) >> 10;
  const mantissa = uint16Encoding & 1023;
  if (exponent === 0) {
    return sign === 0 ? mantissa / 1024 : -mantissa / 1024;
  }
  if (exponent === 31) {
    return mantissa === 0 ? sign === 0 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : Number.NaN;
  }
  return (sign === 0 ? 1 : -1) * (1 + mantissa / 1024) * 2 ** (exponent - 15);
}
var BufferReader = class extends BufferIOBase {
  constructor() {
    super(...arguments);
    __publicField(this, "_cachedTextDecoder");
  }
  get _textDecoder() {
    if (!this._cachedTextDecoder) {
      this._cachedTextDecoder = new TextDecoder(void 0, { fatal: true });
    }
    return this._cachedTextDecoder;
  }
  readBool() {
    return this.dataView.getUint8(this.byteOffset++) !== 0;
  }
  readByte() {
    return this.dataView.getUint8(this.byteOffset++);
  }
  readInt8() {
    return this.dataView.getInt8(this.byteOffset++);
  }
  readUint8() {
    return this.dataView.getUint8(this.byteOffset++);
  }
  readInt16() {
    const value = this.dataView.getInt16(this.byteOffset, this.littleEndian);
    this.byteOffset += 2;
    return value;
  }
  readUint16() {
    const value = this.dataView.getUint16(this.byteOffset, this.littleEndian);
    this.byteOffset += 2;
    return value;
  }
  readInt32() {
    const value = this.dataView.getInt32(this.byteOffset, this.littleEndian);
    this.byteOffset += 4;
    return value;
  }
  readUint32() {
    const value = this.dataView.getUint32(this.byteOffset, this.littleEndian);
    this.byteOffset += 4;
    return value;
  }
  readFloat16() {
    const value = this.dataView.getUint16(this.byteOffset, this.littleEndian);
    this.byteOffset += 2;
    return float16ToNumber(value);
  }
  readFloat32() {
    const value = this.dataView.getFloat32(this.byteOffset, this.littleEndian);
    this.byteOffset += 4;
    return value;
  }
  readString() {
    let strLength = 0;
    while (this.byteOffset + strLength < this.dataView.byteLength) {
      if (this.dataView.getUint8(this.byteOffset + strLength++) === 0) {
        break;
      }
    }
    const result = this._textDecoder.decode(
      new Uint8Array(this.dataView.buffer, this.byteOffset, strLength - 1)
    );
    this.byteOffset += strLength;
    return result;
  }
  readSlice(bufferView, offset, byteLength) {
    const unwrapped = unwrapBuffer(bufferView);
    const destU8 = new Uint8Array(
      unwrapped.buffer,
      unwrapped.byteOffset + offset
    );
    for (let i = 0; i < byteLength; ++i) {
      destU8[i] = this.dataView.getUint8(this.byteOffset++);
    }
  }
};
var BufferWriter = class extends BufferIOBase {
  constructor() {
    super(...arguments);
    __publicField(this, "_cachedTextEncoder");
  }
  get _textEncoder() {
    if (!this._cachedTextEncoder) {
      this._cachedTextEncoder = new TextEncoder();
    }
    return this._cachedTextEncoder;
  }
  writeBool(value) {
    this.dataView.setUint8(this.byteOffset++, value ? 1 : 0);
  }
  writeByte(value) {
    this.dataView.setUint8(this.byteOffset++, value);
  }
  writeInt8(value) {
    this.dataView.setInt8(this.byteOffset++, value);
  }
  writeUint8(value) {
    this.dataView.setUint8(this.byteOffset++, value);
  }
  writeInt16(value) {
    this.dataView.setInt16(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 2;
  }
  writeUint16(value) {
    this.dataView.setUint16(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 2;
  }
  writeInt32(value) {
    this.dataView.setInt32(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 4;
  }
  writeUint32(value) {
    this.dataView.setUint32(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 4;
  }
  writeFloat16(value) {
    this.dataView.setUint16(
      this.byteOffset,
      numberToFloat16(value),
      this.littleEndian
    );
    this.byteOffset += 2;
  }
  writeFloat32(value) {
    this.dataView.setFloat32(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 4;
  }
  writeString(value) {
    const result = this._textEncoder.encodeInto(
      value,
      new Uint8Array(this.dataView.buffer, this.byteOffset)
    );
    this.byteOffset += result.written;
    this.dataView.setUint8(this.byteOffset++, 0);
  }
  writeSlice(bufferView) {
    const unwrapped = unwrapBuffer(bufferView);
    const srcU8 = new Uint8Array(
      unwrapped.buffer,
      unwrapped.byteOffset,
      unwrapped.byteLength
    );
    for (const srcByte of srcU8) {
      this.dataView.setUint8(this.byteOffset++, srcByte);
    }
  }
};

export {
  c2 as c,
  G,
  de,
  ke,
  ie,
  me,
  Oe,
  Le,
  _e,
  Ue,
  We,
  qe,
  Ce,
  Se,
  De2 as De,
  Ee,
  je,
  ze,
  Pe,
  Ze,
  Ge,
  pe,
  He,
  Je,
  Qe,
  Xe,
  Ye,
  en,
  nn,
  sn,
  tn,
  cn,
  an,
  rn,
  vn,
  xn,
  yn,
  Measurer,
  getSystemEndianness,
  BufferReader,
  BufferWriter
};
//# sourceMappingURL=chunk-ORN3T3RZ.js.map
