import {
  BufferReader,
  BufferWriter,
  Measurer,
  de as de2,
  getSystemEndianness
} from "./chunk-ORN3T3RZ.js";
import {
  Dt,
  I,
  J,
  Me as Me2,
  Tt,
  Z as Z2,
  b,
  et as et2,
  j,
  l,
  lt,
  u as u2
} from "./chunk-BT7NLTCF.js";
import {
  $e,
  $n,
  At,
  Ce,
  De,
  Ee,
  Ft,
  G,
  Gt,
  H,
  Ht,
  Ie,
  In,
  It,
  Jt,
  K,
  Kt,
  Lt,
  Me,
  Pe,
  Re,
  Rt,
  Te,
  Ve,
  Wt,
  X,
  Yt,
  Z,
  _t,
  at,
  be,
  c,
  ce,
  cn,
  ct,
  d,
  de,
  dn,
  et,
  f,
  fe,
  he,
  hn,
  ht,
  ie,
  it,
  je,
  jt,
  le,
  m,
  mn,
  nn,
  nt,
  o,
  oe,
  ot,
  p,
  pn,
  qt,
  r,
  rn,
  rt,
  se,
  sn,
  st,
  tt,
  u,
  ue,
  un,
  ut,
  ve,
  w,
  we,
  wn,
  x,
  xe,
  xt,
  ye,
  yn,
  yt,
  zn
} from "./chunk-VTSB6TYK.js";
import {
  __export
} from "./chunk-PZ5AY32C.js";

// node_modules/tinyest/index.js
var tinyest_exports = {};
__export(tinyest_exports, {
  FORMAT_VERSION: () => o2,
  FuncParameterType: () => t,
  NodeTypeCatalog: () => e
});
var e = { block: 0, binaryExpr: 1, assignmentExpr: 2, logicalExpr: 3, unaryExpr: 4, numericLiteral: 5, call: 6, memberAccess: 7, indexAccess: 8, return: 10, if: 11, let: 12, const: 13, for: 14, while: 15, continue: 16, break: 17, arrayExpr: 100, preUpdate: 101, postUpdate: 102, stringLiteral: 103, objectExpr: 104 };
var t = { identifier: "i", destructuredObject: "d" };
var o2 = 1;

// node_modules/typegpu/index.js
function Un(e10) {
  if (typeof e10?.[_t] == "function") return e10[_t].bind(e10);
}
function ht2(e10, t2) {
  throw new Error(`Failed to handle ${e10} at ${t2}`);
}
var Fa = { f: { 1: p, 2: H, 3: X, 4: Z }, h: { 1: m, 2: et, 3: st, 4: ht }, i: { 1: w, 2: tt, 3: it, 4: ut }, u: { 1: d, 2: nt, 3: at, 4: yt }, b: { 1: x, 2: rt, 3: ot, 4: ct } };
var Pa = { vec2f: H, vec2h: et, vec2i: tt, vec2u: nt, "vec2<bool>": rt, vec3f: X, vec3h: st, vec3i: it, vec3u: at, "vec3<bool>": ot, vec4f: Z, vec4h: ht, vec4i: ut, vec4u: yt, "vec4<bool>": ct, mat2x2f: Ve, mat3x3f: ve, mat4x4f: c };
var Fn = { vec2f: p, vec2h: m, vec2i: w, vec2u: d, "vec2<bool>": x, vec3f: p, vec3h: m, vec3i: w, vec3u: d, "vec3<bool>": x, vec4f: p, vec4h: m, vec4i: w, vec4u: d, "vec4<bool>": x, mat2x2f: H, mat3x3f: X, mat4x4f: Z };
function Qe(e10, t2) {
  if (Yt(e10) || rn(e10)) return e10.propTypes[t2] ?? yn;
  if (e10 === x || de2(e10)) return yn;
  let r2 = t2.length;
  if (de(e10) && r2 >= 1 && r2 <= 4) {
    let n = e10.type.includes("bool") ? "b" : e10.type[4], a = Fa[n][r2];
    if (a) return a;
  }
  return yn;
}
function pr(e10) {
  return Gt(e10) || nn(e10) ? e10.elementType : e10.type in Fn ? Fn[e10.type] : yn;
}
function lr(e10) {
  if (/^0x[0-9a-f]+$/i.test(e10)) return u(e10, In);
  if (/^0b[01]+$/i.test(e10)) return u(`${Number.parseInt(e10.slice(2), 2)}`, In);
  if (/^-?(?:\d+\.\d*|\d*\.\d+)$/i.test(e10)) return u(e10, $n);
  if (/^-?\d+(?:\.\d+)?e-?\d+$/i.test(e10)) return u(e10, $n);
  if (/^-?\d+$/i.test(e10)) return u(e10, In);
}
var mr = { rank: Number.POSITIVE_INFINITY, action: "none" };
function $e2(e10) {
  return e10.type === "decorated" ? e10.inner : e10;
}
function Pn(e10) {
  return de(e10) ? xt[e10.type] : void 0;
}
function bt(e10, t2) {
  let r2 = $e2(e10), n = $e2(t2);
  if (r2.type === n.type) return { rank: 0, action: "none" };
  if (r2.type === "abstractFloat") {
    if (n.type === "f32") return { rank: 1, action: "none" };
    if (n.type === "f16") return { rank: 2, action: "none" };
  }
  if (r2.type === "abstractInt") {
    if (n.type === "i32") return { rank: 3, action: "none" };
    if (n.type === "u32") return { rank: 4, action: "none" };
    if (n.type === "abstractFloat") return { rank: 5, action: "none" };
    if (n.type === "f32") return { rank: 6, action: "none" };
    if (n.type === "f16") return { rank: 7, action: "none" };
  }
  if (de(r2) && de(n)) {
    let a = Pn(r2), o3 = Pn(n);
    if (a && o3) return bt(a, o3);
  }
  return jt(r2) && jt(n) ? { rank: 0, action: "none" } : mr;
}
function Ba(e10, t2) {
  let r2 = $e2(e10), n = $e2(t2);
  if (r2.type === "ptr" && bt(r2.inner, n).rank < Number.POSITIVE_INFINITY) return { rank: 0, action: "deref" };
  if (n.type === "ptr" && bt(r2, n.inner).rank < Number.POSITIVE_INFINITY) return { rank: 1, action: "ref" };
  let a = { f32: 0, f16: 1, i32: 2, u32: 3, bool: 4 };
  if (r2.type in a && n.type in a) {
    let o3 = r2.type, i = n.type;
    if (o3 !== i) {
      let s = a[o3];
      return { rank: a[i] < s ? 10 : 20, action: "cast", targetType: n };
    }
  }
  return mr;
}
function Aa(e10, t2, r2) {
  let n = bt(e10, t2);
  return n.rank < Number.POSITIVE_INFINITY ? n : r2 ? Ba(e10, t2) : mr;
}
function Bn(e10, t2, r2) {
  let n, a = Number.POSITIVE_INFINITY, o3 = /* @__PURE__ */ new Map();
  for (let u3 of t2) {
    let f2 = 0, m2 = [], g = true;
    for (let y of e10) {
      let x2 = Aa(y, u3, r2);
      if (x2.rank === Number.POSITIVE_INFINITY) {
        g = false;
        break;
      }
      f2 += x2.rank, m2.push(x2);
    }
    g && f2 < a && (a = f2, n = u3, o3.set(n, m2));
  }
  if (!n) return;
  let s = o3.get(n).map((u3, f2) => ({ sourceIndex: f2, action: u3.action, ...u3.action === "cast" && { targetType: u3.targetType } })), p2 = s.some((u3) => u3.action === "cast");
  return { targetType: n, actions: s, hasImplicitConversions: p2 };
}
function dr(e10) {
  return e10.type === "abstractFloat" ? p : e10.type === "abstractInt" ? w : e10;
}
function An(e10, t2) {
  if (e10.length === 0) return;
  let r2 = [...new Set(e10.map($e2))], n = t2 ? [...new Set(t2.map($e2))] : r2, a = Bn(e10, n, false);
  if (a) return a;
  let o3 = Bn(e10, n, true);
  if (o3) return o3.hasImplicitConversions = o3.actions.some((i) => i.action === "cast"), o3;
}
function Ca(e10, t2, r2, n) {
  if (r2.action === "none") return u(t2.value, n);
  let a = e10.resolve(t2.value);
  switch (r2.action) {
    case "ref":
      return u(`&${a}`, n);
    case "deref":
      return u(`*${a}`, n);
    case "cast":
      return u(`${e10.resolve(n)}(${a})`, n);
    default:
      ht2(r2.action, "applyActionToSnippet");
  }
}
function z(e10, t2, r2) {
  let n = t2.map((o3) => o3.dataType);
  if (n.some((o3) => o3 === yn)) return;
  let a = An(n, r2);
  if (a) return a.hasImplicitConversions && console.warn(`Implicit conversions from [
${t2.map((o3) => `  ${o3.value}: ${o3.dataType.type}`).join(`,
`)}
] to ${a.targetType.type} are supported, but not recommended.
Consider using explicit conversions instead.`), t2.map((o3, i) => {
    let s = a.actions[i];
    return K(s, "Action should not be undefined"), Ca(e10, o3, s, a.targetType);
  });
}
function fr(e10, t2, r2) {
  return Object.keys(t2.propTypes).map((a) => {
    let o3 = r2[a];
    if (!o3) throw new Error(`Missing property ${a}`);
    let i = t2.propTypes[a];
    return z(e10, [o3], [i])?.[0] ?? o3;
  });
}
function he2(e10) {
  if (cn(e10)) return e10;
  if (Rt(e10)) return u(e10, e10[se]);
  if (De(e10) || Lt(e10)) return u(e10, Pa[e10.kind]);
  if (Array.isArray(e10)) {
    let t2 = e10.map(he2).filter(Boolean), r2 = wn();
    if (!r2) throw new Error("Tried to coerce array without a context");
    let n = z(r2, t2), a = An(t2.map((o3) => o3.dataType))?.targetType;
    return !n || !a ? u(e10, yn) : u(n.map((o3) => o3.value).join(", "), j(dr(a), e10.length));
  }
  return typeof e10 == "string" || typeof e10 == "function" || typeof e10 == "object" || typeof e10 == "symbol" || typeof e10 > "u" || e10 === null ? u(e10, yn) : typeof e10 == "number" || typeof e10 == "bigint" ? u(e10, lr(String(e10))?.dataType ?? yn) : typeof e10 == "boolean" ? u(e10, x) : u(e10, yn);
}
var H2 = { get(e10, t2) {
  if (t2 in e10) return Reflect.get(e10, t2);
  if (t2 !== At) return t2 === "toString" || t2 === Symbol.toStringTag || t2 === Symbol.toPrimitive ? () => e10.toString() : new Proxy({ "~resolve": (r2) => `${r2.resolve(e10)}.${String(t2)}`, toString: () => `.value(...).${String(t2)}:${f(e10) ?? "<unnamed>"}`, [se]: Qe(e10[se], String(t2)) }, H2);
} };
function Ke(e10, t2) {
  let r2 = t2, n;
  for (; n = Un(r2); ) r2 = n(e10);
  return r2;
}
function Cn(e10, t2) {
  return new cr(e10, t2);
}
var cr = class {
  constructor(t2, r2) {
    this.dataType = t2;
    this._value = r2;
    this[r] = { dataType: t2 };
  }
  [r];
  $name(t2) {
    return oe(this, t2), this;
  }
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), n = t2.resolveValue(this._value, this.dataType), a = t2.resolve(this.dataType);
    return t2.addDeclaration(`const ${r2}: ${a} = ${n};`), r2;
  }
  toString() {
    return `const:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this.dataType }, H2);
  }
  get value() {
    return fe() ? this[_t]() : this._value;
  }
  get $() {
    return this.value;
  }
};
function Ge(e10) {
  return e10?.resourceType === "slot";
}
function Ve2(e10) {
  return e10?.resourceType === "derived";
}
function He(e10) {
  return e10?.[At] !== void 0;
}
function Ee2(e10) {
  return e10?.resourceType === "accessor";
}
function gr(e10) {
  return typeof e10?.["~resolve"] == "function";
}
function wt(e10) {
  return typeof e10 == "number" || typeof e10 == "boolean" || typeof e10 == "string" || gr(e10) || we(e10) || Ge(e10) || Ve2(e10) || He(e10);
}
function Ye(e10) {
  return !!e10 && typeof e10 == "object" && "getMappedRange" in e10 && "mapAsync" in e10;
}
function Rn(e10) {
  return e10?.resourceType === "buffer-usage";
}
function yr(e10) {
  return !!e10?.[r];
}
function be2(e10, t2) {
  for (let [r2, n] of Object.entries(t2)) e10[r2] = n, Ie(n) && f(n) === void 0 && n.$name(r2);
}
function $n2(e10, t2, r2) {
  let n = [...e10.matchAll(/:\s*(?<arg>.*?)\s*[,)]/g)].map((a) => a ? a[1] : void 0);
  r2(Object.fromEntries(t2.flatMap((a, o3) => {
    let i = n ? n[o3] : void 0;
    return Yt(a) && i !== void 0 ? [[i, a]] : [];
  })));
}
function St(e10, t2, r2) {
  let n = e10.match(/->\s(?<output>[\w\d_]+)\s{/), a = n ? n[1]?.trim() : void 0;
  Yt(t2) && a && !/\s/g.test(a) && r2({ [a]: t2 });
}
function Ra(e10) {
  return new RegExp(`(?<![\\w\\$_.])${e10.replaceAll(".", "\\.").replaceAll("$", "\\$")}(?![\\w\\$_])`, "g");
}
function we2(e10, t2, r2) {
  return Object.entries(t2).reduce((n, [a, o3]) => wt(o3) || Re(o3) ? n.replaceAll(Ra(a), e10.resolve(o3)) : o3 !== null && typeof o3 == "object" ? ([...r2.matchAll(new RegExp(`${a.replaceAll(".", "\\.").replaceAll("$", "\\$")}\\.(?<prop>.*?)(?![\\w\\$_])`, "g"))].map((s) => s[1]) ?? []).reduce((s, p2) => p2 && p2 in o3 ? we2(e10, { [`${a}.${p2}`]: o3[p2] }, s) : s, n) : n, r2);
}
function Gn(e10) {
  return new Tr(e10);
}
var Tr = class {
  constructor(t2) {
    this.declaration = t2;
  }
  externalsToApply = [];
  $uses(t2) {
    return this.externalsToApply.push(t2), this;
  }
  "~resolve"(t2) {
    let r2 = {};
    for (let a of this.externalsToApply) be2(r2, a);
    let n = we2(t2, r2, this.declaration);
    return t2.addDeclaration(n), "";
  }
  toString() {
    return `declare: ${this.declaration}`;
  }
};
function _n(e10) {
  let { strippedCode: t2, argRange: r2 } = $a(e10), n = new vt(t2);
  n.consume("(");
  let a = [];
  for (; !n.isAt(")"); ) {
    let i = [];
    for (; n.isAt("@"); ) n.parseUntil(Vn, En), n.consume(")"), i.push(n.lastParsed);
    n.parseUntil(Va);
    let s = n.lastParsed, p2;
    n.isAt(":") && (n.consume(":"), n.parseUntil(Ea, ka), p2 = n.lastParsed), a.push({ identifier: s, attributes: i, type: p2 }), n.isAt(",") && n.consume(",");
  }
  n.consume(")");
  let o3;
  if (n.isAt("->")) {
    n.consume("->");
    let i = [];
    for (; n.isAt("@"); ) n.parseUntil(Vn, En), n.consume(")"), i.push(n.lastParsed);
    o3 = { type: n.str.slice(n.pos), attributes: i };
  }
  return { args: a, ret: o3, range: { begin: r2[0], end: r2[1] } };
}
function $a(e10) {
  let t2 = new vt(e10), r2 = "", n;
  for (; !t2.isFinished(); ) {
    if (t2.isAt(Ga)) {
      t2.advanceBy(1);
      continue;
    }
    if (t2.isAt("//")) {
      t2.consume("//"), t2.parseUntil(kn), t2.advanceBy(1);
      continue;
    }
    if (t2.isAt("/*")) {
      t2.parseUntil(_a, La), t2.consume("*/");
      continue;
    }
    if (t2.isAt("{")) return { strippedCode: r2, argRange: [n, t2.pos] };
    t2.isAt("(") && n === void 0 && (n = t2.pos), n !== void 0 && (r2 += t2.str[t2.pos]), t2.advanceBy(1);
  }
  throw new Error("Invalid wgsl code!");
}
var vt = class {
  constructor(t2) {
    this.str = t2;
    this.#e = 0;
  }
  #t;
  #e;
  get pos() {
    return this.#e;
  }
  get lastParsed() {
    if (this.#t === void 0) throw new Error("Parse was not called yet!");
    return this.str.slice(this.#t, this.pos);
  }
  isFinished() {
    return this.#e >= this.str.length;
  }
  isAt(t2) {
    if (typeof t2 == "string") {
      for (let r2 = 0; r2 < t2.length; r2++) if (this.str[this.#e + r2] !== t2[r2]) return false;
      return true;
    }
    for (let r2 of t2) if (this.isAt(r2)) return true;
    return false;
  }
  parseUntil(t2, r2) {
    this.#t = this.#e;
    let n = 0;
    for (; this.#e < this.str.length; ) {
      if (r2 && this.isAt(r2[0]) && (n += 1), r2 && this.isAt(r2[1]) && (n -= 1), n === 0 && this.isAt(t2)) return this.#e;
      this.#e += 1;
    }
    throw new Error("Reached the end of the string without finding a match!");
  }
  advanceBy(t2) {
    this.#e += t2;
  }
  consume(t2) {
    if (!this.isAt(t2)) throw new Error(`Expected '${t2}' at position ${this.#e}, but found '${this.str.slice(this.#e, this.#e + t2.length)}'`);
    this.advanceBy(t2.length);
  }
};
var kn = /* @__PURE__ */ new Set([`
`, "\v", "\f", "\r", "", "\u2028", "\u2029"]);
var Ga = /* @__PURE__ */ new Set([...kn, " ", "	", "‎", "‏"]);
var Vn = /* @__PURE__ */ new Set([")"]);
var Va = /* @__PURE__ */ new Set([":", ",", ")"]);
var Ea = /* @__PURE__ */ new Set([",", ")"]);
var _a = /* @__PURE__ */ new Set(["*/"]);
var En = ["(", ")"];
var ka = ["<", ">"];
var La = ["/*", "*/"];
function ie2(e10, t2 = "") {
  let r2 = [], n = { applyExternals(o3) {
    r2.push(o3);
  }, resolve(o3, i, s) {
    let p2 = {};
    for (let f2 of r2) be2(p2, f2);
    let u3 = o3.names.makeUnique(f(this));
    if (typeof e10 == "string") {
      let f2 = we2(o3, p2, e10), m2 = "", g = "";
      if (t2 !== "") {
        let y = Yt(i[0]) ? `(in: ${o3.resolve(i[0])})` : "()", x2 = we(s) ? Me2(s) : "", b2 = s !== Wt ? Yt(s) ? `-> ${o3.resolve(s)}` : `-> ${x2 !== "" ? x2 : "@location(0)"} ${o3.resolve(s)}` : "";
        m2 = `${y} ${b2} `, g = f2;
      } else {
        let y = _n(f2);
        if (y.args.length !== i.length) throw new Error(`WGSL implementation has ${y.args.length} arguments, while the shell has ${i.length} arguments.`);
        let x2 = y.args.map((I2, P) => `${I2.identifier}: ${On(o3, `parameter ${I2.identifier}`, I2.type, i[P])}`).join(", "), b2 = s === Wt ? "" : `-> ${On(o3, "return type", y.ret?.type, s)}`;
        m2 = `(${x2}) ${b2}`, g = f2.slice(y.range.end);
      }
      o3.addDeclaration(`${t2}fn ${u3}${m2}${g}`);
    } else {
      let f2 = $e(e10);
      if (f2?.externals) {
        let b2 = Object.fromEntries(Object.entries(f2.externals).filter(([I2]) => !(I2 in p2)));
        be2(p2, b2);
      }
      let m2 = f2?.ast;
      if (!m2) throw new Error("Missing metadata for tgpu.fn function body (either missing 'kernel' directive, or misconfigured `unplugin-typegpu`)");
      let g = m2.externalNames.filter((b2) => !(b2 in p2));
      if (g.length > 0) throw new ce(f(this), g);
      let { head: y, body: x2 } = o3.fnToWgsl({ args: i.map((b2, I2) => u(m2.params[I2]?.type === t.identifier ? m2.params[I2].name : `_arg_${I2}`, b2)), argAliases: Object.fromEntries(m2.params.flatMap((b2, I2) => b2.type === t.destructuredObject ? b2.props.map(({ name: P, alias: Ua }) => [Ua, u(`_arg_${I2}.${P}`, i[I2].propTypes[P])]) : [])), returnType: s, body: m2.body, externalMap: p2 });
      o3.addDeclaration(`${t2}fn ${u3}${o3.resolve(y)}${o3.resolve(x2)}`);
    }
    return u3;
  } }, a = f(e10);
  return a !== void 0 && oe(n, a), n;
}
function On(e10, t2, r2, n) {
  let a = e10.resolve(n).replace(/\s/g, "");
  if (!r2) return a;
  let o3 = r2.replace(/\s/g, "");
  if (o3 !== a) throw new Error(`Type mismatch between TGPU shell and WGSL code string: ${t2}, JS type "${a}", WGSL type "${o3}".`);
  return r2;
}
function Oa(e10, t2 = {}) {
  let r2 = 0, n = /* @__PURE__ */ new Set();
  return Object.fromEntries(Object.entries(e10 ?? {}).map(([a, o3]) => {
    let i = hn(o3);
    if (i !== void 0) {
      if (n.has(i)) throw new Error("Duplicate custom location attributes found");
      n.add(i);
    }
    return [a, o3];
  }).map(([a, o3]) => {
    if (Dt(o3)) return [a, o3];
    if (hn(o3) !== void 0) return [a, o3];
    if (t2[a]) return [a, Tt(t2[a], o3)];
    for (; n.has(r2); ) r2++;
    return [a, Tt(r2++, o3)];
  }));
}
function se2(e10, t2 = {}) {
  return un(e10) ? Jt(e10) || hn(e10) !== void 0 ? e10 : Tt(0, e10) : Z2(Oa(e10, t2));
}
function ue2(e10, ...t2) {
  return Wa(e10) ? Ma(e10, ...t2) : e10;
}
function Wa(e10) {
  return Array.isArray(e10) && "raw" in e10 && Array.isArray(e10.raw) && e10.raw.every((t2) => typeof t2 == "string");
}
function Ma(e10, ...t2) {
  return e10.slice(1).reduce((r2, n, a) => `${r2}${t2[a]}${n}`, e10[0]);
}
function Wn(e10) {
  let t2 = { argTypes: e10.in && Object.keys(e10.in).length !== 0 ? [se2(e10.in)] : [], returnType: Wt, workgroupSize: [e10.workgroupSize[0] ?? 1, e10.workgroupSize[1] ?? 1, e10.workgroupSize[2] ?? 1], isEntry: true }, r2 = (n, ...a) => Na(t2, e10.workgroupSize, ue2(n, ...a));
  return Object.assign(Object.assign(r2, t2), { does: r2 });
}
function Na(e10, t2, r2) {
  let n = ie2(r2, `@compute @workgroup_size(${t2.join(", ")}) `), a = e10.argTypes[0];
  return { shell: e10, $uses(i) {
    return n.applyExternals(i), this;
  }, [r]: true, [G]: n, $name(i) {
    return oe(n, i), Ie(a) && a.$name(`${i}_Input`), this;
  }, "~resolve"(i) {
    return n.resolve(i, e10.argTypes, e10.returnType);
  }, toString() {
    return `computeFn:${f(n) ?? "<unnamed>"}`;
  } };
}
function xr(e10, t2) {
  let r2 = { [r]: true, argTypes: e10, returnType: t2 ?? Wt, isEntry: false };
  return Object.assign((a, ...o3) => ja(r2, ue2(a, ...o3)), r2);
}
function hr(e10) {
  return !!e10?.[r] && e10?.resourceType === "function";
}
function za([e10, t2]) {
  return `${f(e10) ?? "<unnamed>"}=${t2}`;
}
function ja(e10, t2) {
  let r2 = ie2(t2, ""), n = { [r]: { implementation: t2, argTypes: e10.argTypes }, shell: e10, resourceType: "function", $uses(i) {
    return r2.applyExternals(i), this;
  }, [G]: r2, $name(i) {
    return oe(r2, i), this;
  }, with(i, s) {
    return Mn(o3, [[Ee2(i) ? i.slot : i, s]]);
  }, "~resolve"(i) {
    if (typeof t2 == "string") return $n2(t2, e10.argTypes, r2.applyExternals), St(t2, e10.returnType, r2.applyExternals), r2.resolve(i, e10.argTypes, e10.returnType);
    let s = i;
    if (s.callStack === void 0) throw new Error("Cannot resolve a TGSL function outside of a generation context");
    try {
      return s.callStack.push(e10.returnType), r2.resolve(i, e10.argTypes, e10.returnType);
    } finally {
      s.callStack.pop();
    }
  } }, a = o((...i) => {
    if (typeof t2 == "string") throw new Error("Cannot execute on the CPU functions constructed with raw WGSL");
    let s = i.map((p2, u3) => J(e10.argTypes[u3], p2));
    return t2(...s);
  }, (...i) => u(new Dt2(o3, i.map((s) => s.value)), e10.returnType ?? yn), "tgpuFnCall", e10.argTypes);
  a[r].implementation = t2;
  let o3 = Object.assign(a, n);
  return Object.defineProperty(o3, "toString", { value() {
    return `fn:${f(r2) ?? "<unnamed>"}`;
  } }), o3;
}
function Mn(e10, t2) {
  let r2 = { [r]: { implementation: e10[r].implementation, argTypes: e10[r].argTypes }, resourceType: "function", shell: e10.shell, [At]: { inner: e10, pairs: t2 }, $uses(o3) {
    return e10.$uses(o3), this;
  }, [G]: e10, $name(o3) {
    return e10.$name(o3), this;
  }, with(o3, i) {
    return Mn(a, [...t2, [Ee2(o3) ? o3.slot : o3, i]]);
  } }, n = o((...o3) => e10(...o3), (...o3) => u(new Dt2(a, o3.map((i) => i.value)), e10.shell.returnType ?? yn), "tgpuFnCall", e10.shell.argTypes), a = Object.assign(n, r2);
  return Object.defineProperty(a, "toString", { value() {
    return `fn:${f(e10) ?? "<unnamed>"}[${t2.map(za).join(", ")}]`;
  } }), a[r].implementation = e10[r].implementation, a;
}
var Dt2 = class {
  constructor(t2, r2) {
    this._fn = t2;
    this._params = r2;
    this[G] = t2;
  }
  [G];
  "~resolve"(t2) {
    return t2.resolve(`${t2.resolve(this._fn)}(${this._params.map((r2) => t2.resolve(r2)).join(", ")})`);
  }
  toString() {
    return `call:${f(this) ?? "<unnamed>"}`;
  }
};
function Nn(e10) {
  let t2 = { in: e10.in, out: e10.out, returnType: se2(e10.out), isEntry: true }, r2 = (n, ...a) => qa(t2, ue2(n, ...a));
  return Object.assign(Object.assign(r2, t2), { does: r2 });
}
function qa(e10, t2) {
  let r2 = ie2(t2, "@fragment "), n = e10.returnType;
  return typeof t2 == "string" && St(t2, n, (o3) => r2.applyExternals(o3)), { shell: e10, outputType: n, $uses(o3) {
    return r2.applyExternals(o3), this;
  }, [r]: true, [G]: r2, $name(o3) {
    return oe(r2, o3), Ie(n) && n.$name(`${o3}_Output`), this;
  }, "~resolve"(o3) {
    let i = e10.in ? se2(e10.in, o3.varyingLocations).$name(`${f(this) ?? ""}_Input`) : void 0;
    if (i && r2.applyExternals({ In: i }), r2.applyExternals({ Out: n }), typeof t2 == "string") return r2.resolve(o3, i ? [i] : [], e10.returnType);
    let s = o3;
    if (s.callStack === void 0) throw new Error("Cannot resolve a TGSL function outside of a generation context");
    try {
      return s.callStack.push(n), r2.resolve(o3, i ? [i] : [], e10.returnType);
    } finally {
      s.callStack.pop();
    }
  }, toString() {
    return `fragmentFn:${f(r2) ?? "<unnamed>"}`;
  } };
}
function zn2(e10) {
  if (Object.keys(e10.out).length === 0) throw new Error("A vertexFn output cannot be empty since it must include the 'position' builtin.");
  let t2 = { in: e10.in, out: e10.out, argTypes: e10.in && Object.keys(e10.in).length !== 0 ? [se2(e10.in)] : [], isEntry: true }, r2 = (n, ...a) => Qa(t2, ue2(n, ...a));
  return Object.assign(Object.assign(r2, t2), { does: r2 });
}
function Qa(e10, t2) {
  let r2 = ie2(t2, "@vertex "), n = e10.argTypes[0];
  return { shell: e10, $uses(o3) {
    return r2.applyExternals(o3), this;
  }, [r]: true, [G]: r2, $name(o3) {
    return oe(r2, o3), Ie(n) && n.$name(`${o3}_Input`), this;
  }, "~resolve"(o3) {
    let i = se2(e10.out, o3.varyingLocations).$name(`${f(this) ?? ""}_Output`);
    if (typeof t2 == "string") return n && r2.applyExternals({ In: n }), r2.applyExternals({ Out: i }), r2.resolve(o3, e10.argTypes, i);
    let s = o3;
    if (s.callStack === void 0) throw new Error("Cannot resolve a TGSL function outside of a generation context");
    try {
      return s.callStack.push(i), r2.resolve(o3, e10.argTypes, i);
    } finally {
      s.callStack.pop();
    }
  }, toString() {
    return `vertexFn:${f(r2) ?? "<unnamed>"}`;
  } };
}
var pe = class {
  lastUniqueId = 0;
  makeUnique(t2) {
    let r2;
    return t2 ? (r2 = t2.replaceAll(/\s/g, "_"), r2 = r2.replaceAll(/[^\w\d]/g, "")) : r2 = "item", `${r2}_${this.lastUniqueId++}`;
  }
};
var le2 = class {
  _usedNames = /* @__PURE__ */ new Set();
  makeUnique(t2) {
    if (t2 === void 0) throw new Error("Unnamed item found when using a strict name registry");
    let r2 = 0, n = t2;
    for (; this._usedNames.has(n); ) r2++, n = `${t2}_${r2}`;
    return this._usedNames.add(n), n;
  }
};
function Je(e10) {
  return typeof e10?.format == "string";
}
function jn(e10, t2) {
  let r2 = [];
  if (un(e10)) {
    if (!Je(t2)) throw new Error("Shader expected a single attribute, not a record of attributes to be passed in.");
    return r2.push(t2._layout), { usedVertexLayouts: r2, bufferDefinitions: [{ arrayStride: t2._layout.stride, stepMode: t2._layout.stepMode, attributes: [{ format: t2.format, offset: t2.offset, shaderLocation: hn(e10) ?? 0 }] }] };
  }
  let n = [], a = /* @__PURE__ */ new WeakMap(), o3 = 0;
  for (let [i, s] of Object.entries(e10)) {
    if (Dt(s)) continue;
    let p2 = t2[i];
    if (!p2) throw new Error(`An attribute by the name of '${i}' was not provided to the shader.`);
    let u3 = p2._layout, f2 = a.get(u3);
    f2 || (r2.push(u3), f2 = [], n.push({ arrayStride: u3.stride, stepMode: u3.stepMode, attributes: f2 }), a.set(u3, f2)), o3 = hn(s) ?? o3, f2.push({ format: p2.format, offset: p2.offset, shaderLocation: o3++ });
  }
  return { usedVertexLayouts: r2, bufferDefinitions: n };
}
var Ka = ["bool", "f32", "f16", "i32", "u32", "vec2f", "vec3f", "vec4f", "vec2h", "vec3h", "vec4h", "vec2i", "vec3i", "vec4i", "vec2u", "vec3u", "vec4u", "vec2<bool>", "vec3<bool>", "vec4<bool>", "mat2x2f", "mat3x3f", "mat4x4f"];
function Ha(e10) {
  return Ka.includes(e10.type);
}
function br(e10, [t2, r2]) {
  return `  ${Me2(r2)}${t2}: ${e10.resolve(r2)},
`;
}
function Ya(e10, t2) {
  let r2 = e10.names.makeUnique(f(t2));
  return e10.addDeclaration(`
struct ${r2} {
${Object.entries(t2.propTypes).map((n) => br(e10, n)).join("")}}
`), r2;
}
function Ja(e10, t2) {
  let r2 = e10.names.makeUnique(f(t2));
  return e10.addDeclaration(`
struct ${r2} {
${Object.entries(t2.propTypes).map((n) => Je(n[1]) ? br(e10, [n[0], et2[n[1].format]]) : br(e10, n)).join("")}
}
`), r2;
}
function Xa(e10, t2) {
  let r2 = e10.resolve(t2.elementType);
  return t2.elementCount === 0 ? `array<${r2}>` : `array<${r2}, ${t2.elementCount}>`;
}
function Za(e10, t2) {
  let r2 = e10.resolve(Je(t2.elementType) ? et2[t2.elementType.format] : t2.elementType);
  return t2.elementCount === 0 ? `array<${r2}>` : `array<${r2}, ${t2.elementCount}>`;
}
function wr(e10, t2) {
  if (Re(t2)) return t2.type === "unstruct" ? Ja(e10, t2) : t2.type === "disarray" ? Za(e10, t2) : t2.type === "loose-decorated" ? e10.resolve(Je(t2.inner) ? et2[t2.inner.format] : t2.inner) : e10.resolve(et2[t2.type]);
  if (Ha(t2)) return t2.type;
  if (t2.type === "struct") return Ya(e10, t2);
  if (t2.type === "array") return Xa(e10, t2);
  if (t2.type === "atomic") return `atomic<${wr(e10, t2.inner)}>`;
  if (t2.type === "decorated") return e10.resolve(t2.inner);
  if (t2.type === "ptr") return t2.addressSpace === "storage" ? `ptr<storage, ${e10.resolve(t2.inner)}, ${t2.access === "read-write" ? "read_write" : t2.access}>` : `ptr<${t2.addressSpace}, ${e10.resolve(t2.inner)}>`;
  if (t2.type === "abstractInt" || t2.type === "abstractFloat" || t2.type === "void" || t2.type === "u16") throw new Error(`${t2.type} has no representation in WGSL`);
  ht2(t2, "resolveData");
}
function eo(e10, t2) {
  let r2 = "size" in e10 ? e10.size : e10.currentByteOffset, n = t2 - 1, a = r2 & n;
  "skipBytes" in e10 ? e10.skipBytes(t2 - a & n) : e10.add(t2 - a & n);
}
var A = eo;
var qn = /* @__PURE__ */ new WeakMap();
function It2(e10) {
  let t2 = qn.get(e10);
  if (t2) return t2;
  let r2 = new Measurer(), n = {}, a;
  for (let o3 in e10.propTypes) {
    let i = e10.propTypes[o3];
    if (i === void 0) throw new Error(`Property ${o3} is undefined in struct`);
    let s = r2.size;
    A(r2, rn(e10) ? I(i) : u2(i)), a && (a.padding = r2.size - s);
    let p2 = l(i);
    n[o3] = { offset: r2.size, size: p2 }, a = n[o3], r2.add(p2);
  }
  return a && (a.padding = b(l(e10), u2(e10)) - r2.size), qn.set(e10, n), n;
}
var Ft2 = (() => {
  try {
    return new Function("return true"), true;
  } catch {
    return false;
  }
})();
var Sr = /* @__PURE__ */ new WeakMap();
var vr = { u32: "u32", vec2u: "u32", vec3u: "u32", vec4u: "u32", u16: "u16", i32: "i32", vec2i: "i32", vec3i: "i32", vec4i: "i32", f32: "f32", vec2f: "f32", vec3f: "f32", vec4f: "f32", vec2h: "f32", vec3h: "f32", vec4h: "f32", mat2x2f: "f32", mat3x3f: "f32", mat4x4f: "f32" };
var Dr = { u32: "setUint32", i32: "setInt32", f32: "setFloat32", u16: "setUint16" };
function Ut(e10, t2, r2) {
  if (Ht(e10) || Te(e10)) return Ut(e10.inner, t2, r2);
  if (Yt(e10) || rn(e10)) {
    let a = It2(e10), o3 = Object.entries(a).sort((s, p2) => s[1].offset - p2[1].offset), i = "";
    for (let [s, p2] of o3) {
      let u3 = e10.propTypes[s];
      u3 && (i += Ut(u3, `(${t2} + ${p2.offset})`, `${r2}.${s}`));
    }
    return i;
  }
  if (Gt(e10) || nn(e10)) {
    let a = e10, o3 = b(l(a.elementType), u2(a.elementType)), i = "";
    return i += `for (let i = 0; i < ${a.elementCount}; i++) {
`, i += Ut(a.elementType, `(${t2} + i * ${o3})`, `${r2}[i]`), i += `}
`, i;
  }
  if (de(e10)) {
    let a = vr[e10.type], o3 = "", i = Dr[a], s = ["x", "y", "z", "w"], p2 = Pe(e10) ? 2 : Ce(e10) ? 3 : 4;
    for (let u3 = 0; u3 < p2; u3++) o3 += `output.${i}((${t2} + ${u3 * 4}), ${r2}.${s[u3]}, littleEndian);
`;
    return o3;
  }
  if (jt(e10)) {
    let a = vr[e10.type], o3 = Dr[a], i = Ee(e10) ? 2 : Me(e10) ? 3 : 4, s = i * i, p2 = b(i * 4, 8), u3 = "";
    for (let f2 = 0; f2 < s; f2++) {
      let m2 = Math.floor(f2 / i), g = f2 % i, y = m2 * p2 + g * 4;
      u3 += `output.${o3}((${t2} + ${y}), ${r2}.columns[${m2}].${["x", "y", "z", "w"][g]}, littleEndian);
`;
    }
    return u3;
  }
  let n = vr[e10.type];
  return `output.${Dr[n]}(${t2}, ${r2}, littleEndian);
`;
}
function Pt(e10) {
  if (Sr.has(e10)) return Sr.get(e10);
  let t2 = Ut(e10, "offset", "value"), r2 = new Function("output", "offset", "value", "littleEndian=true", t2);
  return Sr.set(e10, r2), r2;
}
var _e = { bool() {
  throw new Error("Booleans are not host-shareable");
}, f32(e10, t2, r2) {
  e10.writeFloat32(r2);
}, f16(e10, t2, r2) {
  e10.writeFloat16(r2);
}, i32(e10, t2, r2) {
  e10.writeInt32(r2);
}, u32(e10, t2, r2) {
  e10.writeUint32(r2);
}, u16(e10, t2, r2) {
  e10.writeUint16(r2);
}, vec2f(e10, t2, r2) {
  e10.writeFloat32(r2.x), e10.writeFloat32(r2.y);
}, vec2h(e10, t2, r2) {
  e10.writeFloat16(r2.x), e10.writeFloat16(r2.y);
}, vec2i(e10, t2, r2) {
  e10.writeInt32(r2.x), e10.writeInt32(r2.y);
}, vec2u(e10, t2, r2) {
  e10.writeUint32(r2.x), e10.writeUint32(r2.y);
}, "vec2<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, vec3f(e10, t2, r2) {
  e10.writeFloat32(r2.x), e10.writeFloat32(r2.y), e10.writeFloat32(r2.z);
}, vec3h(e10, t2, r2) {
  e10.writeFloat16(r2.x), e10.writeFloat16(r2.y), e10.writeFloat16(r2.z);
}, vec3i(e10, t2, r2) {
  e10.writeInt32(r2.x), e10.writeInt32(r2.y), e10.writeInt32(r2.z);
}, vec3u(e10, t2, r2) {
  e10.writeUint32(r2.x), e10.writeUint32(r2.y), e10.writeUint32(r2.z);
}, "vec3<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, vec4f(e10, t2, r2) {
  e10.writeFloat32(r2.x), e10.writeFloat32(r2.y), e10.writeFloat32(r2.z), e10.writeFloat32(r2.w);
}, vec4h(e10, t2, r2) {
  e10.writeFloat16(r2.x), e10.writeFloat16(r2.y), e10.writeFloat16(r2.z), e10.writeFloat16(r2.w);
}, vec4i(e10, t2, r2) {
  e10.writeInt32(r2.x), e10.writeInt32(r2.y), e10.writeInt32(r2.z), e10.writeInt32(r2.w);
}, vec4u(e10, t2, r2) {
  e10.writeUint32(r2.x), e10.writeUint32(r2.y), e10.writeUint32(r2.z), e10.writeUint32(r2.w);
}, "vec4<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, mat2x2f(e10, t2, r2) {
  for (let n = 0; n < r2.length; ++n) e10.writeFloat32(r2[n]);
}, mat3x3f(e10, t2, r2) {
  for (let n = 0; n < r2.length; ++n) e10.writeFloat32(r2[n]);
}, mat4x4f(e10, t2, r2) {
  for (let n = 0; n < r2.length; ++n) e10.writeFloat32(r2[n]);
}, struct(e10, t2, r2) {
  let n = u2(t2);
  A(e10, n);
  for (let [a, o3] of Object.entries(t2.propTypes)) A(e10, u2(o3)), me(e10, o3, r2[a]);
  A(e10, n);
}, array(e10, t2, r2) {
  if (t2.elementCount === 0) throw new Error("Cannot write using a runtime-sized schema.");
  let n = u2(t2);
  A(e10, n);
  let a = e10.currentByteOffset;
  for (let o3 = 0; o3 < Math.min(t2.elementCount, r2.length); o3++) A(e10, n), me(e10, t2.elementType, r2[o3]);
  e10.seekTo(a + l(t2));
}, ptr() {
  throw new Error("Pointers are not host-shareable");
}, atomic(e10, t2, r2) {
  _e[t2.inner.type]?.(e10, t2, r2);
}, decorated(e10, t2, r2) {
  let n = I(t2);
  A(e10, n);
  let a = e10.currentByteOffset;
  _e[t2.inner?.type]?.(e10, t2.inner, r2), e10.seekTo(a + l(t2));
}, uint8(e10, t2, r2) {
  e10.writeUint8(r2);
}, uint8x2(e10, t2, r2) {
  e10.writeUint8(r2.x), e10.writeUint8(r2.y);
}, uint8x4(e10, t2, r2) {
  e10.writeUint8(r2.x), e10.writeUint8(r2.y), e10.writeUint8(r2.z), e10.writeUint8(r2.w);
}, sint8(e10, t2, r2) {
  e10.writeInt8(r2);
}, sint8x2(e10, t2, r2) {
  e10.writeInt8(r2.x), e10.writeInt8(r2.y);
}, sint8x4(e10, t2, r2) {
  e10.writeInt8(r2.x), e10.writeInt8(r2.y), e10.writeInt8(r2.z), e10.writeInt8(r2.w);
}, unorm8(e10, t2, r2) {
  e10.writeUint8(r2 * 255);
}, unorm8x2(e10, t2, r2) {
  e10.writeUint8(r2.x * 255), e10.writeUint8(r2.y * 255);
}, unorm8x4(e10, t2, r2) {
  e10.writeUint8(r2.x * 255), e10.writeUint8(r2.y * 255), e10.writeUint8(r2.z * 255), e10.writeUint8(r2.w * 255);
}, snorm8(e10, t2, r2) {
  e10.writeUint8(r2 * 127 + 128);
}, snorm8x2(e10, t2, r2) {
  e10.writeUint8(r2.x * 127 + 128), e10.writeUint8(r2.y * 127 + 128);
}, snorm8x4(e10, t2, r2) {
  e10.writeUint8(r2.x * 127 + 128), e10.writeUint8(r2.y * 127 + 128), e10.writeUint8(r2.z * 127 + 128), e10.writeUint8(r2.w * 127 + 128);
}, uint16(e10, t2, r2) {
  e10.writeUint16(r2);
}, uint16x2(e10, t2, r2) {
  e10.writeUint16(r2.x), e10.writeUint16(r2.y);
}, uint16x4(e10, t2, r2) {
  e10.writeUint16(r2.x), e10.writeUint16(r2.y), e10.writeUint16(r2.z), e10.writeUint16(r2.w);
}, sint16(e10, t2, r2) {
  e10.writeInt16(r2);
}, sint16x2(e10, t2, r2) {
  e10.writeInt16(r2.x), e10.writeInt16(r2.y);
}, sint16x4(e10, t2, r2) {
  e10.writeInt16(r2.x), e10.writeInt16(r2.y), e10.writeInt16(r2.z), e10.writeInt16(r2.w);
}, unorm16(e10, t2, r2) {
  e10.writeUint16(r2 * 65535);
}, unorm16x2(e10, t2, r2) {
  e10.writeUint16(r2.x * 65535), e10.writeUint16(r2.y * 65535);
}, unorm16x4(e10, t2, r2) {
  e10.writeUint16(r2.x * 65535), e10.writeUint16(r2.y * 65535), e10.writeUint16(r2.z * 65535), e10.writeUint16(r2.w * 65535);
}, snorm16(e10, t2, r2) {
  e10.writeUint16(r2 * 32767 + 32768);
}, snorm16x2(e10, t2, r2) {
  e10.writeUint16(r2.x * 32767 + 32768), e10.writeUint16(r2.y * 32767 + 32768);
}, snorm16x4(e10, t2, r2) {
  e10.writeUint16(r2.x * 32767 + 32768), e10.writeUint16(r2.y * 32767 + 32768), e10.writeUint16(r2.z * 32767 + 32768), e10.writeUint16(r2.w * 32767 + 32768);
}, float16(e10, t2, r2) {
  e10.writeFloat16(r2);
}, float16x2(e10, t2, r2) {
  e10.writeFloat16(r2.x), e10.writeFloat16(r2.y);
}, float16x4(e10, t2, r2) {
  e10.writeFloat16(r2.x), e10.writeFloat16(r2.y), e10.writeFloat16(r2.z), e10.writeFloat16(r2.w);
}, float32(e10, t2, r2) {
  e10.writeFloat32(r2);
}, float32x2(e10, t2, r2) {
  e10.writeFloat32(r2.x), e10.writeFloat32(r2.y);
}, float32x3(e10, t2, r2) {
  e10.writeFloat32(r2.x), e10.writeFloat32(r2.y), e10.writeFloat32(r2.z);
}, float32x4(e10, t2, r2) {
  e10.writeFloat32(r2.x), e10.writeFloat32(r2.y), e10.writeFloat32(r2.z), e10.writeFloat32(r2.w);
}, uint32(e10, t2, r2) {
  e10.writeUint32(r2);
}, uint32x2(e10, t2, r2) {
  e10.writeUint32(r2.x), e10.writeUint32(r2.y);
}, uint32x3(e10, t2, r2) {
  e10.writeUint32(r2.x), e10.writeUint32(r2.y), e10.writeUint32(r2.z);
}, uint32x4(e10, t2, r2) {
  e10.writeUint32(r2.x), e10.writeUint32(r2.y), e10.writeUint32(r2.z), e10.writeUint32(r2.w);
}, sint32(e10, t2, r2) {
  e10.writeInt32(r2);
}, sint32x2(e10, t2, r2) {
  e10.writeInt32(r2.x), e10.writeInt32(r2.y);
}, sint32x3(e10, t2, r2) {
  e10.writeInt32(r2.x), e10.writeInt32(r2.y), e10.writeInt32(r2.z);
}, sint32x4(e10, t2, r2) {
  e10.writeInt32(r2.x), e10.writeInt32(r2.y), e10.writeInt32(r2.z), e10.writeInt32(r2.w);
}, "unorm10-10-10-2"(e10, t2, r2) {
  let n = 0;
  n |= (r2.x * 1023 & 1023) << 22, n |= (r2.x * 1023 & 1023) << 12, n |= (r2.y * 1023 & 1023) << 2, n |= r2.z * 3 & 3, e10.writeUint32(n);
}, "unorm8x4-bgra"(e10, t2, r2) {
  e10.writeUint8(r2.z * 255), e10.writeUint8(r2.y * 255), e10.writeUint8(r2.x * 255), e10.writeUint8(r2.w * 255);
}, disarray(e10, t2, r2) {
  let n = u2(t2);
  A(e10, n);
  let a = e10.currentByteOffset;
  for (let o3 = 0; o3 < Math.min(t2.elementCount, r2.length); o3++) A(e10, n), _e[t2.elementType?.type]?.(e10, t2.elementType, r2[o3]);
  e10.seekTo(a + l(t2));
}, unstruct(e10, t2, r2) {
  for (let [n, a] of Object.entries(t2.propTypes)) _e[a.type]?.(e10, a, r2[n]);
}, "loose-decorated"(e10, t2, r2) {
  let n = I(t2);
  A(e10, n);
  let a = e10.currentByteOffset, o3 = _e[t2.inner?.type];
  return o3?.(e10, t2.inner, r2), e10.seekTo(a + l(t2)), r2;
} };
function me(e10, t2, r2) {
  let n = _e[t2.type];
  if (!n) throw new Error(`Cannot write data of type '${t2.type}'.`);
  n(e10, t2, r2);
}
var Se = { bool() {
  throw new Error("Booleans are not host-shareable");
}, f32(e10) {
  return e10.readFloat32();
}, f16(e10) {
  return e10.readFloat16();
}, i32(e10) {
  return e10.readInt32();
}, u32(e10) {
  return e10.readUint32();
}, u16(e10) {
  return e10.readUint16();
}, vec2f(e10) {
  return H(e10.readFloat32(), e10.readFloat32());
}, vec3f(e10) {
  return X(e10.readFloat32(), e10.readFloat32(), e10.readFloat32());
}, vec4f(e10) {
  return Z(e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32());
}, vec2h(e10) {
  return et(e10.readFloat16(), e10.readFloat16());
}, vec3h(e10) {
  return st(e10.readFloat16(), e10.readFloat16(), e10.readFloat16());
}, vec4h(e10) {
  return ht(e10.readFloat16(), e10.readFloat16(), e10.readFloat16(), e10.readFloat16());
}, vec2i(e10) {
  return tt(e10.readInt32(), e10.readInt32());
}, vec3i(e10) {
  return it(e10.readInt32(), e10.readInt32(), e10.readInt32());
}, vec4i(e10) {
  return ut(e10.readInt32(), e10.readInt32(), e10.readInt32(), e10.readInt32());
}, vec2u(e10) {
  return nt(e10.readUint32(), e10.readUint32());
}, vec3u(e10) {
  return at(e10.readUint32(), e10.readUint32(), e10.readUint32());
}, vec4u(e10) {
  return yt(e10.readUint32(), e10.readUint32(), e10.readUint32(), e10.readUint32());
}, "vec2<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, "vec3<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, "vec4<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, mat2x2f(e10) {
  return Ve(e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32());
}, mat3x3f(e10) {
  let t2 = () => {
    let r2 = e10.readFloat32();
    return e10.readFloat32(), r2;
  };
  return ve(e10.readFloat32(), e10.readFloat32(), t2(), e10.readFloat32(), e10.readFloat32(), t2(), e10.readFloat32(), e10.readFloat32(), t2());
}, mat4x4f(e10) {
  return c(e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32());
}, struct(e10, t2) {
  let r2 = u2(t2);
  A(e10, r2);
  let n = {};
  for (let [a, o3] of Object.entries(t2.propTypes)) A(e10, u2(o3)), n[a] = j2(e10, o3);
  return A(e10, r2), n;
}, array(e10, t2) {
  if (t2.elementCount === 0) throw new Error("Cannot read using a runtime-sized schema.");
  let r2 = u2(t2), n = [];
  for (let a = 0; a < t2.elementCount; a++) {
    A(e10, r2);
    let o3 = t2.elementType, i = j2(e10, o3);
    n.push(i);
  }
  return A(e10, r2), n;
}, ptr() {
  throw new Error("Pointers are not host-shareable");
}, atomic(e10, t2) {
  return j2(e10, t2.inner);
}, decorated(e10, t2) {
  let r2 = I(t2);
  A(e10, r2);
  let n = e10.currentByteOffset, a = j2(e10, t2.inner);
  return e10.seekTo(n + l(t2)), a;
}, uint8: (e10) => e10.readUint8(), uint8x2: (e10) => nt(e10.readUint8(), e10.readUint8()), uint8x4: (e10) => yt(e10.readUint8(), e10.readUint8(), e10.readUint8(), e10.readUint8()), sint8: (e10) => e10.readInt8(), sint8x2: (e10) => tt(e10.readInt8(), e10.readInt8()), sint8x4: (e10) => ut(e10.readInt8(), e10.readInt8(), e10.readInt8(), e10.readInt8()), unorm8: (e10) => e10.readUint8() / 255, unorm8x2: (e10) => H(e10.readUint8() / 255, e10.readUint8() / 255), unorm8x4: (e10) => Z(e10.readUint8() / 255, e10.readUint8() / 255, e10.readUint8() / 255, e10.readUint8() / 255), snorm8: (e10) => (e10.readUint8() - 128) / 127, snorm8x2: (e10) => H((e10.readUint8() - 128) / 127, (e10.readUint8() - 128) / 127), snorm8x4: (e10) => Z((e10.readUint8() - 128) / 127, (e10.readUint8() - 128) / 127, (e10.readUint8() - 128) / 127, (e10.readUint8() - 128) / 127), uint16: (e10) => e10.readUint16(), uint16x2: (e10) => nt(e10.readUint16(), e10.readUint16()), uint16x4: (e10) => yt(e10.readUint16(), e10.readUint16(), e10.readUint16(), e10.readUint16()), sint16: (e10) => e10.readInt16(), sint16x2: (e10) => tt(e10.readInt16(), e10.readInt16()), sint16x4: (e10) => ut(e10.readInt16(), e10.readInt16(), e10.readInt16(), e10.readInt16()), unorm16: (e10) => e10.readUint16() / 65535, unorm16x2: (e10) => H(e10.readUint16() / 65535, e10.readUint16() / 65535), unorm16x4: (e10) => Z(e10.readUint16() / 65535, e10.readUint16() / 65535, e10.readUint16() / 65535, e10.readUint16() / 65535), snorm16: (e10) => (e10.readUint16() - 32768) / 32767, snorm16x2: (e10) => H(Se.snorm16(e10), Se.snorm16(e10)), snorm16x4: (e10) => Z(Se.snorm16(e10), Se.snorm16(e10), Se.snorm16(e10), Se.snorm16(e10)), float16(e10) {
  return e10.readFloat16();
}, float16x2: (e10) => H(e10.readFloat16(), e10.readFloat16()), float16x4: (e10) => Z(e10.readFloat16(), e10.readFloat16(), e10.readFloat16(), e10.readFloat16()), float32: (e10) => e10.readFloat32(), float32x2: (e10) => H(e10.readFloat32(), e10.readFloat32()), float32x3: (e10) => X(e10.readFloat32(), e10.readFloat32(), e10.readFloat32()), float32x4: (e10) => Z(e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32()), uint32: (e10) => e10.readUint32(), uint32x2: (e10) => nt(e10.readUint32(), e10.readUint32()), uint32x3: (e10) => at(e10.readUint32(), e10.readUint32(), e10.readUint32()), uint32x4: (e10) => yt(e10.readUint32(), e10.readUint32(), e10.readUint32(), e10.readUint32()), sint32: (e10) => e10.readInt32(), sint32x2: (e10) => tt(e10.readInt32(), e10.readInt32()), sint32x3: (e10) => it(e10.readInt32(), e10.readInt32(), e10.readInt32()), sint32x4: (e10) => ut(e10.readInt32(), e10.readInt32(), e10.readInt32(), e10.readInt32()), "unorm10-10-10-2"(e10) {
  let t2 = e10.readUint32(), r2 = (t2 >> 22) / 1023, n = (t2 >> 12 & 1023) / 1023, a = (t2 >> 2 & 1023) / 1023, o3 = (t2 & 3) / 3;
  return Z(r2, n, a, o3);
}, "unorm8x4-bgra"(e10) {
  let t2 = e10.readByte() / 255, r2 = e10.readByte() / 255, n = e10.readByte() / 255, a = e10.readByte() / 255;
  return Z(n, r2, t2, a);
}, unstruct(e10, t2) {
  let r2 = {};
  for (let [n, a] of Object.entries(t2.propTypes)) r2[n] = j2(e10, a);
  return r2;
}, disarray(e10, t2) {
  let r2 = u2(t2), n = [];
  for (let a = 0; a < t2.elementCount; a++) A(e10, r2), n.push(j2(e10, t2.elementType));
  return A(e10, r2), n;
}, "loose-decorated"(e10, t2) {
  A(e10, I(t2));
  let r2 = e10.currentByteOffset, n = j2(e10, t2.inner);
  return e10.seekTo(r2 + l(t2)), n;
} };
function j2(e10, t2) {
  let r2 = Se[t2.type];
  if (!r2) throw new Error(`Cannot read data of type '${t2.type}'.`);
  return r2(e10, t2);
}
function Qn(e10, t2) {
  let r2 = l(e10);
  if (r2 === 0 || t2 === void 0 || t2 === null) return [];
  let n = new ArrayBuffer(r2), a = new BufferWriter(n), o3 = [];
  function i(u3, f2, m2, g) {
    if (f2 != null) {
      if (Yt(u3) || rn(u3)) {
        let y = It2(u3);
        for (let [x2, b2] of Object.entries(y)) {
          let I2 = u3.propTypes[x2];
          if (!I2) continue;
          let P = f2[x2];
          P !== void 0 && i(I2, P, m2 + b2.offset, b2.padding ?? g);
        }
        return;
      }
      if (Gt(u3) || nn(u3)) {
        let y = u3, x2 = b(l(y.elementType), u2(y.elementType));
        if (!Array.isArray(f2)) throw new Error("Partial value for array must be an array");
        let b2 = f2 ?? [];
        b2.sort((I2, P) => I2.idx - P.idx);
        for (let { idx: I2, value: P } of b2) i(y.elementType, P, m2 + I2 * x2, x2 - l(y.elementType));
      } else {
        let y = l(u3);
        a.seekTo(m2), me(a, u3, f2), o3.push({ start: m2, end: m2 + y, padding: g });
      }
    }
  }
  if (i(e10, t2, 0), o3.length === 0) return [];
  let s = [], p2 = o3[0];
  for (let u3 = 1; u3 < o3.length; u3++) {
    let f2 = o3[u3];
    if (!f2 || !p2) throw new Error("Internal error: missing segment");
    f2.start === p2.end + (p2.padding ?? 0) ? (p2.end = f2.end, p2.padding = f2.padding) : (s.push({ data: new Uint8Array(n, p2.start, p2.end - p2.start) }), p2 = f2);
  }
  if (!p2) throw new Error("Internal error: missing segment");
  return s.push({ data: new Uint8Array(n, p2.start, p2.end - p2.start) }), s;
}
function ve2(e10) {
  return !!e10?.usableAsStorage;
}
var Xe = class e2 extends Error {
  constructor(t2) {
    super(`Resource '${f(t2) ?? "<unnamed>"}' cannot be bound as 'storage'. Use .$usage('storage') to allow it.`), Object.setPrototypeOf(this, e2.prototype);
  }
};
function Bt(e10) {
  return !!e10.usableAsUniform;
}
var Jn = { uniform: "uniform", mutable: "storage, read_write", readonly: "storage, read" };
var Ze = class {
  constructor(t2, r2) {
    this.usage = t2;
    this.buffer = r2;
    this[r] = { dataType: r2.dataType }, this[G] = r2;
  }
  resourceType = "buffer-usage";
  [r];
  [G];
  $name(t2) {
    return this.buffer.$name(t2), this;
  }
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), { group: n, binding: a } = t2.allocateFixedEntry(this.usage === "uniform" ? { uniform: this.buffer.dataType } : { storage: this.buffer.dataType, access: this.usage }, this.buffer), o3 = Jn[this.usage];
    return t2.addDeclaration(`@group(${n}) @binding(${a}) var<${o3}> ${r2}: ${t2.resolve(this.buffer.dataType)};`), r2;
  }
  toString() {
    return `${this.usage}:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this.buffer.dataType }, H2);
  }
  get value() {
    if (!fe()) throw new Error("Cannot access buffer's value directly in JS.");
    return this[_t]();
  }
  get $() {
    return this.value;
  }
};
var et3 = class {
  constructor(t2, r2, n) {
    this.usage = t2;
    this.dataType = r2;
    this._membership = n;
    this[r] = { dataType: r2 }, oe(this, n.key);
  }
  resourceType = "buffer-usage";
  [r];
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout), a = Jn[this.usage];
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var<${a}> ${r2}: ${t2.resolve(this.dataType)};`), r2;
  }
  toString() {
    return `${this.usage}:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this.dataType }, H2);
  }
  get value() {
    if (!fe()) throw new Error("Cannot access buffer's value directly in JS.");
    return this[_t]();
  }
  get $() {
    return this.value;
  }
};
var Kn = /* @__PURE__ */ new WeakMap();
function Ir(e10) {
  if (!ve2(e10)) throw new Error(`Cannot pass ${e10} to asMutable, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`);
  let t2 = Kn.get(e10);
  return t2 || (t2 = new Ze("mutable", e10), Kn.set(e10, t2)), t2;
}
var Hn = /* @__PURE__ */ new WeakMap();
function Ur(e10) {
  if (!ve2(e10)) throw new Error(`Cannot pass ${e10} to asReadonly, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`);
  let t2 = Hn.get(e10);
  return t2 || (t2 = new Ze("readonly", e10), Hn.set(e10, t2)), t2;
}
var Yn = /* @__PURE__ */ new WeakMap();
function Fr(e10) {
  if (!Bt(e10)) throw new Error(`Cannot pass ${e10} to asUniform, as it is not allowed to be used as a uniform. To allow it, call .$usage('uniform') when creating the buffer.`);
  let t2 = Yn.get(e10);
  return t2 || (t2 = new Ze("uniform", e10), Yn.set(e10, t2)), t2;
}
var oo = { uniform: Fr, mutable: Ir, readonly: Ur };
function tt2(e10, t2, r2) {
  return we(t2) ? new At2(e10, t2, r2) : new At2(e10, t2, r2, ["storage", "uniform"]);
}
function de3(e10) {
  return e10.resourceType === "buffer";
}
function io(e10) {
  return !!e10.usableAsVertex;
}
var Xn = getSystemEndianness();
var At2 = class {
  constructor(t2, r2, n, a) {
    this._group = t2;
    this.dataType = r2;
    this.initialOrBuffer = n;
    this._disallowedUsages = a;
    Ye(n) ? (this._ownBuffer = false, this._buffer = n) : (this._ownBuffer = true, this.initial = n);
  }
  [r] = true;
  resourceType = "buffer";
  flags = GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;
  _buffer = null;
  _ownBuffer;
  _destroyed = false;
  _hostBuffer;
  initial;
  usableAsUniform = false;
  usableAsStorage = false;
  usableAsVertex = false;
  usableAsIndex = false;
  get buffer() {
    let t2 = this._group.device;
    if (this._destroyed) throw new Error("This buffer has been destroyed");
    if (!this._buffer && (this._buffer = t2.createBuffer({ size: l(this.dataType), usage: this.flags, mappedAtCreation: !!this.initial, label: f(this) ?? "<unnamed>" }), this.initial)) {
      let r2 = new BufferWriter(this._buffer.getMappedRange());
      me(r2, this.dataType, this.initial), this._buffer.unmap();
    }
    return this._buffer;
  }
  get destroyed() {
    return this._destroyed;
  }
  $name(t2) {
    return oe(this, t2), this._buffer && (this._buffer.label = t2), this;
  }
  $usage(...t2) {
    for (let r2 of t2) {
      if (this._disallowedUsages?.includes(r2)) throw new Error(`Buffer of type ${this.dataType.type} cannot be used as ${r2}`);
      this.flags |= r2 === "uniform" ? GPUBufferUsage.UNIFORM : 0, this.flags |= r2 === "storage" ? GPUBufferUsage.STORAGE : 0, this.flags |= r2 === "vertex" ? GPUBufferUsage.VERTEX : 0, this.flags |= r2 === "index" ? GPUBufferUsage.INDEX : 0, this.usableAsUniform = this.usableAsUniform || r2 === "uniform", this.usableAsStorage = this.usableAsStorage || r2 === "storage", this.usableAsVertex = this.usableAsVertex || r2 === "vertex", this.usableAsIndex = this.usableAsIndex || r2 === "index";
    }
    return this;
  }
  $addFlags(t2) {
    if (!this._ownBuffer) throw new Error("Cannot add flags to a buffer that is not managed by TypeGPU.");
    return t2 & GPUBufferUsage.MAP_READ ? (this.flags = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ, this) : t2 & GPUBufferUsage.MAP_WRITE ? (this.flags = GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE, this) : (this.flags |= t2, this);
  }
  compileWriter() {
    if (Ft2) Pt(this.dataType);
    else throw new Error("This environment does not allow eval");
  }
  write(t2) {
    let r2 = this.buffer, n = this._group.device;
    if (r2.mapState === "mapped") {
      let o3 = r2.getMappedRange();
      if (Ft2) {
        Pt(this.dataType)(new DataView(o3), 0, t2, Xn === "little");
        return;
      }
      me(new BufferWriter(o3), this.dataType, t2);
      return;
    }
    let a = l(this.dataType);
    this._hostBuffer || (this._hostBuffer = new ArrayBuffer(a)), this._group.flush(), Ft2 ? Pt(this.dataType)(new DataView(this._hostBuffer), 0, t2, Xn === "little") : me(new BufferWriter(this._hostBuffer), this.dataType, t2), n.queue.writeBuffer(r2, 0, this._hostBuffer, 0, a);
  }
  writePartial(t2) {
    let r2 = this.buffer, n = this._group.device, a = Qn(this.dataType, t2);
    if (r2.mapState === "mapped") {
      let o3 = r2.getMappedRange(), i = new Uint8Array(o3);
      for (let s of a) i.set(s.data, s.data.byteOffset);
    } else for (let o3 of a) n.queue.writeBuffer(r2, o3.data.byteOffset, o3.data, 0, o3.data.byteLength);
  }
  copyFrom(t2) {
    if (this.buffer.mapState === "mapped") throw new Error("Cannot copy to a mapped buffer.");
    let r2 = l(this.dataType);
    this._group.commandEncoder.copyBufferToBuffer(t2.buffer, 0, this.buffer, 0, r2);
  }
  async read() {
    this._group.flush();
    let t2 = this.buffer, r2 = this._group.device;
    if (t2.mapState === "mapped") {
      let i = t2.getMappedRange();
      return j2(new BufferReader(i), this.dataType);
    }
    if (t2.usage & GPUBufferUsage.MAP_READ) {
      await t2.mapAsync(GPUMapMode.READ);
      let i = t2.getMappedRange(), s = j2(new BufferReader(i), this.dataType);
      return t2.unmap(), s;
    }
    let n = r2.createBuffer({ size: l(this.dataType), usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }), a = r2.createCommandEncoder();
    a.copyBufferToBuffer(t2, 0, n, 0, l(this.dataType)), r2.queue.submit([a.finish()]), await r2.queue.onSubmittedWorkDone(), await n.mapAsync(GPUMapMode.READ, 0, l(this.dataType));
    let o3 = j2(new BufferReader(n.getMappedRange()), this.dataType);
    return n.unmap(), n.destroy(), o3;
  }
  as(t2) {
    return oo[t2]?.(this);
  }
  destroy() {
    this._destroyed || (this._destroyed = true, this._ownBuffer && this._buffer?.destroy());
  }
  toString() {
    return `buffer:${f(this) ?? "<unnamed>"}`;
  }
};
function Zn(e10) {
  return new Ar(e10);
}
function ea(e10) {
  return new Cr(e10);
}
function rt2(e10) {
  let t2 = e10;
  return t2?.resourceType === "sampler" && !!t2[r];
}
function nt2(e10) {
  let t2 = e10;
  return t2?.resourceType === "sampler-comparison" && !!t2[r];
}
var Ct = class {
  constructor(t2) {
    this._membership = t2;
    this[se] = this, this[r] = {}, oe(this, t2.key);
  }
  [se];
  [r];
  resourceType = "sampler";
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout);
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r2}: sampler;`), r2;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Rt2 = class {
  constructor(t2) {
    this._membership = t2;
    this[se] = this, this[r] = {}, oe(this, t2.key);
  }
  [se];
  [r];
  resourceType = "sampler-comparison";
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout);
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r2}: sampler_comparison;`), r2;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Ar = class {
  constructor(t2) {
    this._props = t2;
    this[se] = this, this[r] = { unwrap: (r2) => (this._sampler || (this._sampler = r2.device.createSampler({ ...this._props, label: f(this) ?? "<unnamed>" })), this._sampler) }, this._filtering = t2.minFilter === "linear" || t2.magFilter === "linear" || t2.mipmapFilter === "linear";
  }
  [se];
  [r];
  resourceType = "sampler";
  _filtering;
  _sampler = null;
  $name(t2) {
    return oe(this, t2), this;
  }
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), { group: n, binding: a } = t2.allocateFixedEntry({ sampler: this._filtering ? "filtering" : "non-filtering" }, this);
    return t2.addDeclaration(`@group(${n}) @binding(${a}) var ${r2}: sampler;`), r2;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Cr = class {
  constructor(t2) {
    this._props = t2;
    this[se] = this, this[r] = { unwrap: (r2) => (this._sampler || (this._sampler = r2.device.createSampler({ ...this._props, label: f(this) ?? "<unnamed>" })), this._sampler) };
  }
  [se];
  [r];
  resourceType = "sampler-comparison";
  _sampler = null;
  $name(t2) {
    return oe(this, t2), this;
  }
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), { group: n, binding: a } = t2.allocateFixedEntry({ sampler: "comparison" }, this);
    return t2.addDeclaration(`@group(${n}) @binding(${a}) var ${r2}: sampler_comparison;`), r2;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var $t = class {
  constructor(t2) {
    this._membership = t2;
    oe(this, t2.key);
  }
  resourceType = "external-texture";
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout);
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r2}: texture_external;`), r2;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var ta = { r8unorm: p, r8snorm: p, r8uint: d, r8sint: w, r16uint: d, r16sint: w, r16float: p, rg8unorm: p, rg8snorm: p, rg8uint: d, rg8sint: w, r32uint: d, r32sint: w, r32float: p, rg16uint: d, rg16sint: w, rg16float: p, rgba8unorm: p, "rgba8unorm-srgb": p, rgba8snorm: p, rgba8uint: d, rgba8sint: w, bgra8unorm: p, "bgra8unorm-srgb": p, rgb9e5ufloat: p, rgb10a2uint: d, rgb10a2unorm: p, rg11b10ufloat: p, rg32uint: d, rg32sint: w, rg32float: p, rgba16uint: d, rgba16sint: w, rgba16float: p, rgba32uint: d, rgba32sint: w, rgba32float: p, stencil8: p, depth16unorm: p, depth24plus: p, "depth24plus-stencil8": p, depth32float: p, "depth32float-stencil8": p, "bc1-rgba-unorm": p, "bc1-rgba-unorm-srgb": p, "bc2-rgba-unorm": p, "bc2-rgba-unorm-srgb": p, "bc3-rgba-unorm": p, "bc3-rgba-unorm-srgb": p, "bc4-r-unorm": p, "bc4-r-snorm": p, "bc5-rg-unorm": p, "bc5-rg-snorm": p, "bc6h-rgb-ufloat": p, "bc6h-rgb-float": p, "bc7-rgba-unorm": p, "bc7-rgba-unorm-srgb": p, "etc2-rgb8unorm": p, "etc2-rgb8unorm-srgb": p, "etc2-rgb8a1unorm": p, "etc2-rgb8a1unorm-srgb": p, "etc2-rgba8unorm": p, "etc2-rgba8unorm-srgb": p, "eac-r11unorm": p, "eac-r11snorm": p, "eac-rg11unorm": p, "eac-rg11snorm": p, "astc-4x4-unorm": p, "astc-4x4-unorm-srgb": p, "astc-5x4-unorm": p, "astc-5x4-unorm-srgb": p, "astc-5x5-unorm": p, "astc-5x5-unorm-srgb": p, "astc-6x5-unorm": p, "astc-6x5-unorm-srgb": p, "astc-6x6-unorm": p, "astc-6x6-unorm-srgb": p, "astc-8x5-unorm": p, "astc-8x5-unorm-srgb": p, "astc-8x6-unorm": p, "astc-8x6-unorm-srgb": p, "astc-8x8-unorm": p, "astc-8x8-unorm-srgb": p, "astc-10x5-unorm": p, "astc-10x5-unorm-srgb": p, "astc-10x6-unorm": p, "astc-10x6-unorm-srgb": p, "astc-10x8-unorm": p, "astc-10x8-unorm-srgb": p, "astc-10x10-unorm": p, "astc-10x10-unorm-srgb": p, "astc-12x10-unorm": p, "astc-12x10-unorm-srgb": p, "astc-12x12-unorm": p, "astc-12x12-unorm-srgb": p, r16snorm: p, r16unorm: p, rg16unorm: p, rg16snorm: p, rgba16unorm: p, rgba16snorm: p };
var at2 = { rgba8unorm: Z, rgba8snorm: Z, rgba8uint: yt, rgba8sint: ut, rgba16uint: yt, rgba16sint: ut, rgba16float: Z, r32uint: yt, r32sint: ut, r32float: Z, rg32uint: yt, rg32sint: ut, rg32float: Z, rgba32uint: yt, rgba32sint: ut, rgba32float: Z, bgra8unorm: Z };
var ra = { f32: "float", u32: "uint", i32: "sint" };
var na = { float: p, "unfilterable-float": p, uint: d, sint: w, depth: p };
function aa(e10, t2) {
  return new Rr(e10, t2);
}
function Z3(e10) {
  return e10?.resourceType === "texture" && !!e10[r];
}
function ot2(e10) {
  return e10?.resourceType === "texture-storage-view" && !!e10[r];
}
function it2(e10) {
  return e10?.resourceType === "texture-sampled-view" && !!e10[r];
}
var oa = { mutable: "read_write", readonly: "read", writeonly: "write" };
var Rr = class {
  constructor(t2, r2) {
    this.props = t2;
    this._branch = r2;
    this[r] = { unwrap: () => {
      if (this._destroyed) throw new Error("This texture has been destroyed");
      return this._texture || (this._texture = this._branch.device.createTexture({ label: f(this) ?? "<unnamed>", format: this.props.format, size: this.props.size, usage: this._flags, dimension: this.props.dimension ?? "2d", viewFormats: this.props.viewFormats ?? [], mipLevelCount: this.props.mipLevelCount ?? 1, sampleCount: this.props.sampleCount ?? 1 })), this._texture;
    } };
  }
  [r];
  resourceType = "texture";
  usableAsSampled = false;
  usableAsStorage = false;
  usableAsRender = false;
  _destroyed = false;
  _flags = GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
  _texture = null;
  $name(t2) {
    return oe(this, t2), this;
  }
  $usage(...t2) {
    let r2 = t2.includes("storage"), n = t2.includes("sampled"), a = t2.includes("render");
    return this._flags |= n ? GPUTextureUsage.TEXTURE_BINDING : 0, this._flags |= r2 ? GPUTextureUsage.STORAGE_BINDING : 0, this._flags |= a ? GPUTextureUsage.RENDER_ATTACHMENT : 0, this.usableAsStorage ||= r2, this.usableAsSampled ||= n, this.usableAsRender ||= a, this;
  }
  createView(t2, r2) {
    if (t2 === "sampled") return this._asSampled(r2);
    let n = r2;
    switch (t2) {
      case "mutable":
        return this._asMutable(n);
      case "readonly":
        return this._asReadonly(n);
      case "writeonly":
        return this._asWriteonly(n);
    }
  }
  _asStorage(t2, r2) {
    if (!this.usableAsStorage) throw new Error("Unusable as storage");
    let n = t2?.format ?? this.props.format, a = at2[n];
    return K(!!a, `Unsupported storage texture format: ${n}`), new $r(t2 ?? {}, r2, this);
  }
  _asReadonly(t2) {
    return this._asStorage(t2, "readonly");
  }
  _asWriteonly(t2) {
    return this._asStorage(t2, "writeonly");
  }
  _asMutable(t2) {
    return this._asStorage(t2, "mutable");
  }
  _asSampled(t2) {
    if (!this.usableAsSampled) throw new Error("Unusable as sampled");
    let r2 = t2?.format ?? this.props.format;
    if (!at2[r2]) throw new Error(`Unsupported storage texture format: ${r2}`);
    return new Gr(t2, this);
  }
  destroy() {
    this._destroyed || (this._destroyed = true, this._texture?.destroy());
  }
};
var Et = { "1d": "1d", "2d": "2d", "2d-array": "2d_array", cube: "cube", "cube-array": "cube_array", "3d": "3d" };
var $r = class {
  constructor(t2, r2, n) {
    this.access = r2;
    this._texture = n;
    this[se] = this, this[r] = { unwrap: () => (this._view || (this._view = this._texture[r].unwrap().createView({ label: `${f(this) ?? "<unnamed>"} - View`, format: this._format, dimension: this.dimension })), this._view) }, this[G] = n, this.dimension = t2?.dimension ?? n.props.dimension ?? "2d", this._format = t2?.format ?? n.props.format, this.texelDataType = at2[this._format];
  }
  [se];
  [r];
  [G];
  resourceType = "texture-storage-view";
  texelDataType;
  dimension;
  _view;
  _format;
  $name(t2) {
    return this._texture.$name(t2), this;
  }
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), { group: n, binding: a } = t2.allocateFixedEntry({ storageTexture: this._format, access: this.access, viewDimension: this.dimension }, this), o3 = `texture_storage_${Et[this.dimension]}`;
    return t2.addDeclaration(`@group(${n}) @binding(${a}) var ${r2}: ${o3}<${this._format}, ${oa[this.access]}>;`), r2;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Gt2 = class {
  constructor(t2, r2, n, a) {
    this._format = t2;
    this.dimension = r2;
    this.access = n;
    this._membership = a;
    this[se] = this, this[r] = {}, this.texelDataType = at2[this._format], oe(this, a.key);
  }
  [se];
  [r];
  resourceType = "texture-storage-view";
  texelDataType;
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout), a = `texture_storage_${Et[this.dimension]}`;
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r2}: ${a}<${this._format}, ${oa[this.access]}>;`), r2;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Gr = class {
  constructor(t2, r2) {
    this._props = t2;
    this._texture = r2;
    this[se] = this, this[r] = { unwrap: () => (this._view || (this._view = this._texture[r].unwrap().createView({ label: `${f(this) ?? "<unnamed>"} - View`, ...this._props })), this._view) }, this[G] = r2, this.dimension = t2?.dimension ?? r2.props.dimension ?? "2d", this._format = t2?.format ?? r2.props.format, this.channelDataType = ta[this._format];
  }
  [se];
  [r];
  [G];
  resourceType = "texture-sampled-view";
  channelDataType;
  dimension;
  _format;
  _view;
  $name(t2) {
    return this._texture.$name(t2), this;
  }
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), n = (this._texture.props.sampleCount ?? 1) > 1, { group: a, binding: o3 } = t2.allocateFixedEntry({ texture: ra[this.channelDataType.type], viewDimension: this.dimension, multisampled: n }, this), i = n ? "texture_multisampled_2d" : `texture_${Et[this.dimension]}`;
    return t2.addDeclaration(`@group(${a}) @binding(${o3}) var ${r2}: ${i}<${t2.resolve(this.channelDataType)}>;`), r2;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Vt = class {
  constructor(t2, r2, n, a) {
    this.dimension = r2;
    this._multisampled = n;
    this._membership = a;
    this[se] = this, this[r] = {}, oe(this, a.key), this.channelDataType = na[t2];
  }
  [se];
  [r];
  resourceType = "texture-sampled-view";
  channelDataType;
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout), a = this._multisampled ? "texture_multisampled_2d" : `texture_${Et[this.dimension]}`;
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r2}: ${a}<${t2.resolve(this.channelDataType)}>;`), r2;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
function Vr(e10) {
  return !!e10?.usableAsSampled;
}
function so(e10) {
  return !!e10?.usableAsRender;
}
var _t2 = class e3 extends Error {
  constructor(t2) {
    super(`Resource '${f(t2) ?? "<unnamed>"}' cannot be bound as 'sampled'. Use .$usage('sampled') to allow it.`), Object.setPrototypeOf(this, e3.prototype);
  }
};
function kt(e10) {
  return new _r(e10);
}
function Lt2(e10) {
  return !!e10 && e10.resourceType === "bind-group-layout";
}
function kr(e10) {
  return !!e10 && e10.resourceType === "bind-group";
}
var Er = class e4 extends Error {
  constructor(t2, r2) {
    super(`Bind group '${t2 ?? "<unnamed>"}' is missing a required binding '${r2}'`), Object.setPrototypeOf(this, e4.prototype);
  }
};
var ia = ["compute"];
var ke = ["compute", "vertex", "fragment"];
var _r = class {
  constructor(t2) {
    this.entries = t2;
    let r2 = 0;
    for (let [n, a] of Object.entries(t2)) {
      if (a === null) {
        r2++;
        continue;
      }
      let o3 = { layout: this, key: n, idx: r2 };
      if ("uniform" in a && (this.bound[n] = new et3("uniform", a.uniform, o3)), "storage" in a) {
        let i = "type" in a.storage ? a.storage : a.storage(0);
        this.bound[n] = new et3(a.access ?? "readonly", i, o3);
      }
      "texture" in a && (this.bound[n] = new Vt(a.texture, a.viewDimension ?? "2d", a.multisampled ?? false, o3)), "storageTexture" in a && (this.bound[n] = new Gt2(a.storageTexture, a.viewDimension ?? "2d", a.access ?? "writeonly", o3)), "externalTexture" in a && (this.bound[n] = new $t(o3)), "sampler" in a && (a.sampler === "comparison" ? this.bound[n] = new Rt2(o3) : this.bound[n] = new Ct(o3)), "texture" in a || "storageTexture" in a || "externalTexture" in a || "sampler" in a ? this.value[n] = this.bound[n] : Object.defineProperty(this.value, n, { get: () => this.bound[n].value }), r2++;
    }
  }
  [r] = true;
  _index;
  resourceType = "bind-group-layout";
  bound = {};
  value = {};
  $ = this.value;
  toString() {
    return `bindGroupLayout:${f(this) ?? "<unnamed>"}`;
  }
  get index() {
    return this._index;
  }
  $name(t2) {
    return oe(this, t2), this;
  }
  $idx(t2) {
    return this._index = t2, this;
  }
  unwrap(t2) {
    return t2.device.createBindGroupLayout({ label: f(this) ?? "<unnamed>", entries: Object.values(this.entries).map((n, a) => {
      if (n === null) return null;
      let o3 = n.visibility, i = { binding: a, visibility: 0 };
      if ("uniform" in n) o3 = o3 ?? ke, i.buffer = { type: "uniform" };
      else if ("storage" in n) o3 = o3 ?? (n.access === "mutable" ? ia : ke), i.buffer = { type: n.access === "mutable" ? "storage" : "read-only-storage" };
      else if ("sampler" in n) o3 = o3 ?? ke, i.sampler = { type: n.sampler };
      else if ("texture" in n) o3 = o3 ?? ke, i.texture = { sampleType: n.texture, viewDimension: n.viewDimension ?? "2d", multisampled: n.multisampled ?? false };
      else if ("storageTexture" in n) {
        let s = n.access ?? "writeonly";
        o3 = o3 ?? (s === "readonly" ? ke : ia), i.storageTexture = { format: n.storageTexture, access: { mutable: "read-write", readonly: "read-only", writeonly: "write-only" }[s], viewDimension: n.viewDimension ?? "2d" };
      } else "externalTexture" in n && (o3 = o3 ?? ke, i.externalTexture = {});
      return o3?.includes("compute") && (i.visibility |= GPUShaderStage.COMPUTE), o3?.includes("vertex") && (i.visibility |= GPUShaderStage.VERTEX), o3?.includes("fragment") && (i.visibility |= GPUShaderStage.FRAGMENT), i;
    }).filter((n) => n !== null) });
  }
};
var Le = class {
  constructor(t2, r2) {
    this.layout = t2;
    this.entries = r2;
    for (let n of Object.keys(t2.entries)) if (t2.entries[n] !== null && !(n in r2)) throw new Er(f(t2), n);
  }
  resourceType = "bind-group";
  unwrap(t2) {
    return t2.device.createBindGroup({ label: f(this.layout) ?? "<unnamed>", layout: t2.unwrap(this.layout), entries: Object.entries(this.layout.entries).map(([n, a], o3) => {
      if (a === null) return null;
      let i = this.entries[n];
      if (i === void 0) throw new Error(`'${n}' is a resource required to populate bind group layout '${f(this.layout) ?? "<unnamed>"}'.`);
      if ("uniform" in a) {
        let s;
        if (de3(i)) {
          if (!Bt(i)) throw new ye(i);
          s = { buffer: t2.unwrap(i) };
        } else s = { buffer: i };
        return { binding: o3, resource: s };
      }
      if ("storage" in a) {
        let s;
        if (de3(i)) {
          if (!ve2(i)) throw new Xe(i);
          s = { buffer: t2.unwrap(i) };
        } else s = { buffer: i };
        return { binding: o3, resource: s };
      }
      if ("texture" in a) {
        let s;
        if (Z3(i)) {
          if (!Vr(i)) throw new _t2(i);
          s = t2.unwrap(i.createView("sampled"));
        } else it2(i) ? s = t2.unwrap(i) : s = i;
        return { binding: o3, resource: s };
      }
      if ("storageTexture" in a) {
        let s;
        if (Z3(i)) {
          if (!ve2(i)) throw new Xe(i);
          a.access === "readonly" ? s = t2.unwrap(i.createView("readonly")) : a.access === "mutable" ? s = t2.unwrap(i.createView("mutable")) : s = t2.unwrap(i.createView("writeonly"));
        } else ot2(i) ? s = t2.unwrap(i) : s = i;
        return { binding: o3, resource: s };
      }
      if ("sampler" in a) return rt2(i) || nt2(i) ? { binding: o3, resource: t2.unwrap(i) } : { binding: o3, resource: i };
      if ("externalTexture" in a) return { binding: o3, resource: i };
      throw new Error(`Malformed bind group entry: ${i} (${JSON.stringify(i)})`);
    }).filter((n) => n !== null) });
  }
};
var { NodeTypeCatalog: D } = tinyest_exports;
var po = ["==", "!=", "<", "<=", ">", ">=", "<<", ">>", "+", "-", "*", "/", "%", "|", "^", "&", "&&", "||"];
var lo = ["&&", "||", "==", "!=", "<", "<=", ">", ">="];
function sa(e10, t2, r2) {
  return r2 ? lo.includes(t2) ? x : t2 === "=" ? r2 : e10 : t2 === "!" || t2 === "~" ? x : e10;
}
function mo(e10) {
  throw new Error(`'${JSON.stringify(e10)}' was not handled by the WGSL generator.`);
}
function ua(e10, [t2, r2]) {
  e10.pushBlockScope();
  try {
    return `${e10.indent()}{
${r2.map((n) => De2(e10, n)).join(`
`)}
${e10.dedent()}}`;
  } finally {
    e10.popBlockScope();
  }
}
function fo(e10, t2, r2) {
  return e10.defineVariable(t2, r2);
}
function Lr(e10, t2) {
  let r2 = e10.getById(t2);
  if (!r2) throw new Error(`Identifier ${t2} not found`);
  return r2;
}
function G2(e10, t2) {
  if (typeof t2 == "string") return Lr(e10, t2);
  if (typeof t2 == "boolean") return u(t2 ? "true" : "false", x);
  if (t2[0] === D.logicalExpr || t2[0] === D.binaryExpr || t2[0] === D.assignmentExpr) {
    let [r2, n, a, o3] = t2, i = G2(e10, n), s = G2(e10, o3), p2 = t2[0] === D.assignmentExpr ? [i.dataType] : [], u3 = z(e10, [i, s], p2), [f2, m2] = u3 || [i, s], g = e10.resolve(f2.value), y = e10.resolve(m2.value), x2 = sa(f2.dataType, a, m2.dataType);
    return u(po.includes(a) ? `(${g} ${a} ${y})` : `${g} ${a} ${y}`, x2);
  }
  if (t2[0] === D.postUpdate) {
    let [r2, n, a] = t2, o3 = G2(e10, a), i = e10.resolve(o3.value);
    return u(`${i}${n}`, o3.dataType);
  }
  if (t2[0] === D.unaryExpr) {
    let [r2, n, a] = t2, o3 = G2(e10, a), i = e10.resolve(o3.value), s = sa(o3.dataType, n);
    return u(`${n}${i}`, s);
  }
  if (t2[0] === D.memberAccess) {
    let [r2, n, a] = t2, o3 = G2(e10, n);
    if (o3.dataType.type === "unknown") {
      let i = o3.value[a];
      return he2(i);
    }
    return Kt(o3.dataType) ? u(`(*${e10.resolve(o3.value)}).${a}`, Qe(o3.dataType.inner, a)) : Gt(o3.dataType) && a === "length" ? o3.dataType.elementCount === 0 ? u(`arrayLength(&${e10.resolve(o3.value)})`, d) : u(String(o3.dataType.elementCount), In) : jt(o3.dataType) && a === "columns" ? u(o3.value, o3.dataType) : de(o3.dataType) && De(o3.value) ? he2(o3.value[a]) : u(`${e10.resolve(o3.value)}.${a}`, Qe(o3.dataType, a));
  }
  if (t2[0] === D.indexAccess) {
    let [r2, n, a] = t2, o3 = G2(e10, n), i = G2(e10, a), s = e10.resolve(o3.value), p2 = e10.resolve(i.value);
    if (o3.dataType.type === "unknown") {
      if (Array.isArray(a) && a[0] === D.numericLiteral) return he2(o3.value[a[1]]);
      throw new Error(`Cannot index value ${s} of unknown type with index ${p2}`);
    }
    return Kt(o3.dataType) ? u(`(*${s})[${p2}]`, pr(o3.dataType.inner)) : u(`${s}[${p2}]`, un(o3.dataType) ? pr(o3.dataType) : yn);
  }
  if (t2[0] === D.numericLiteral) {
    let r2 = lr(t2[1]);
    if (!r2) throw new Error(`Invalid numeric literal ${t2[1]}`);
    return r2;
  }
  if (t2[0] === D.call) {
    let [r2, n, a] = t2, o3 = G2(e10, n);
    e10.callStack.push(o3.value);
    let s = a.map((m2) => G2(e10, m2)).map((m2) => u(e10.resolve(m2.value), m2.dataType)), p2 = s.map((m2) => m2.value);
    if (e10.callStack.pop(), s.forEach((m2, g) => {
      if (m2.dataType === yn) throw new Error(`Tried to pass '${m2.value}' of unknown type as argument #${g} to '${typeof o3.value == "string" ? o3.value : f(o3.value) ?? "<unnamed>"}()'`);
    }), typeof o3.value == "string") return u(`${o3.value}(${p2.join(", ")})`, o3.dataType);
    if (Yt(o3.value)) {
      let m2 = e10.resolve(o3.value);
      return u(`${m2}(${p2.join(", ")})`, o3.value);
    }
    if (!yr(o3.value)) throw new Error(`Function ${String(o3.value)} ${f(o3.value)} has not been created using TypeGPU APIs. Did you mean to wrap the function with tgpu.fn(args, return)(...) ?`);
    let u3 = o3.value[r]?.argTypes, f2;
    try {
      !u3 || u3 === "keep" ? f2 = s : u3 === "coerce" ? f2 = z(e10, s) ?? s : f2 = (Array.isArray(u3) ? u3 : u3(...s)).map((y, x2) => [y, s[x2]]).map(([y, x2]) => {
        if (x2.dataType.type === "unknown") return console.warn(`Internal error: unknown type when generating expression: ${t2}`), x2;
        let b2 = z(e10, [x2], [y])?.[0];
        if (!b2) throw new he(`Cannot convert argument of type '${x2.dataType.type}' to '${y.type}' for function ${f(o3.value)}`, [{ function: o3.value, callStack: e10.callStack, error: `Cannot convert argument of type '${x2.dataType.type}' to '${y.type}'`, toString: () => f(o3.value) }]);
        return b2;
      });
      let m2 = o3.value(...f2);
      return u(e10.resolve(m2.value), m2.dataType);
    } catch (m2) {
      throw new he(m2, [{ toString: () => f(o3.value) }]);
    }
  }
  if (t2[0] === D.objectExpr) {
    let r2 = t2[1], n = e10.callStack[e10.callStack.length - 1];
    if (Yt(n)) {
      let a = Object.keys(n.propTypes), o3 = Object.fromEntries(a.map((s) => {
        let p2 = r2[s];
        if (p2 === void 0) throw new Error(`Missing property ${s} in object literal for struct ${n}`);
        return [s, G2(e10, p2)];
      })), i = fr(e10, n, o3);
      return u(i.map((s) => e10.resolve(s.value)).join(", "), n);
    }
    if (yr(n)) {
      let a = n[r]?.argTypes;
      if (typeof a == "object" && a !== null) {
        let o3 = Object.keys(a), i = {};
        for (let s of o3) {
          let p2 = r2[s];
          if (p2 === void 0) throw new Error(`Missing property ${s} in object literal for function ${n}`);
          let u3 = G2(e10, p2), f2 = a[s], m2 = z(e10, [u3], [f2]);
          i[s] = m2?.[0] ?? u3;
        }
        return u(i, yn);
      }
    }
    throw new Error("Object expressions are only allowed as return values of functions or as arguments to structs.");
  }
  if (t2[0] === D.arrayExpr) {
    let [r2, n] = t2, a = n.map((m2) => G2(e10, m2));
    if (a.length === 0) throw new Error("Cannot create empty array literal.");
    let o3 = z(e10, a);
    if (!o3) throw new Error("The given values cannot be automatically converted to a common type. Consider explicitly casting them.");
    let i = o3[0]?.dataType, s = i.type === "abstractFloat" ? p : i.type === "abstractInt" ? w : i, u3 = `array<${e10.resolve(s)}, ${a.length}>`, f2 = o3.map((m2) => e10.resolve(m2.value));
    return u(`${u3}( ${f2.join(", ")} )`, j(s, a.length));
  }
  if (t2[0] === D.stringLiteral) throw new Error("Cannot use string literals in TGSL.");
  if (t2[0] === D.preUpdate) throw new Error("Cannot use pre-updates in TGSL.");
  mo(t2);
}
function Ot(e10) {
  return typeof e10 != "object" || e10[0] !== D.block ? [D.block, [e10]] : e10;
}
function De2(e10, t2) {
  if (typeof t2 == "string") return `${e10.pre}${e10.resolve(Lr(e10, t2).value)};`;
  if (typeof t2 == "boolean") return `${e10.pre}${t2 ? "true" : "false"};`;
  if (t2[0] === D.return) {
    let r2 = t2[1], n = r2 !== void 0 ? e10.resolve(G2(e10, r2).value) : void 0;
    if (Yt(e10.callStack[e10.callStack.length - 1]) && typeof r2 == "object" && r2[0] === D.objectExpr) {
      let a = e10.resolve(e10.callStack[e10.callStack.length - 1]);
      return `${e10.pre}return ${a}(${n});`;
    }
    return n ? `${e10.pre}return ${n};` : `${e10.pre}return;`;
  }
  if (t2[0] === D.if) {
    let [r2, n, a, o3] = t2, i = G2(e10, n), s = i, p2 = z(e10, [i], [x]);
    p2?.[0] && ([s] = p2);
    let u3 = e10.resolve(s.value);
    e10.indent();
    let f2 = De2(e10, Ot(a));
    e10.dedent(), e10.indent();
    let m2 = o3 ? De2(e10, Ot(o3)) : void 0;
    return e10.dedent(), m2 ? `${e10.pre}if (${u3})
${f2}
${e10.pre}else
${m2}` : `${e10.pre}if (${u3})
${f2}`;
  }
  if (t2[0] === D.let || t2[0] === D.const) {
    let [r2, n, a] = t2, o3 = a !== void 0 ? G2(e10, a) : void 0;
    if (!o3) throw new Error(`Cannot create variable '${n}' without an initial value.`);
    if (Re(o3.dataType)) throw new Error(`Cannot create variable '${n}' with loose data type.`);
    fo(e10, n, dr(o3.dataType));
    let i = e10.resolve(Lr(e10, n).value);
    if (typeof a == "object" && a[0] === D.objectExpr && Yt(e10.callStack[e10.callStack.length - 1])) {
      let s = e10.callStack[e10.callStack.length - 1], p2 = a[1], u3 = {};
      for (let [g, y] of Object.entries(p2)) {
        if (!y) throw new Error(`Missing property ${g} in object literal`);
        u3[g] = G2(e10, y);
      }
      let f2 = fr(e10, s, u3), m2 = e10.resolve(s);
      return `${e10.pre}var ${i} = ${m2}(${f2.map((g) => e10.resolve(g.value)).join(", ")});`;
    }
    return `${e10.pre}var ${i} = ${e10.resolve(o3.value)};`;
  }
  if (t2[0] === D.block) return ua(e10, t2);
  if (t2[0] === D.for) {
    let [r2, n, a, o3, i] = t2, s = n ? De2(e10, n) : void 0, p2 = s ? s.slice(0, -1) : "", u3 = a ? G2(e10, a) : void 0, f2 = u3;
    if (u3) {
      let b2 = z(e10, [u3], [x]);
      b2?.[0] && ([f2] = b2);
    }
    let m2 = f2 ? e10.resolve(f2.value) : "", g = o3 ? De2(e10, o3) : void 0, y = g ? g.slice(0, -1) : "";
    e10.indent();
    let x2 = De2(e10, Ot(i));
    return e10.dedent(), `${e10.pre}for (${p2}; ${m2}; ${y})
${x2}`;
  }
  if (t2[0] === D.while) {
    let [r2, n, a] = t2, o3 = G2(e10, n), i = o3;
    if (o3) {
      let u3 = z(e10, [o3], [x]);
      u3?.[0] && ([i] = u3);
    }
    let s = e10.resolve(i.value);
    e10.indent();
    let p2 = De2(e10, Ot(a));
    return e10.dedent(), `${e10.pre}while (${s})
${p2}`;
  }
  return t2[0] === D.continue ? `${e10.pre}continue;` : t2[0] === D.break ? `${e10.pre}break;` : `${e10.pre}${e10.resolve(G2(e10, t2).value)};`;
}
function pa(e10, t2) {
  return ua(e10, t2);
}
var la = "#CATCHALL#";
var Wr = class {
  _stack = [];
  _itemDepth = 0;
  get itemDepth() {
    return this._itemDepth;
  }
  get topItem() {
    let t2 = this._stack[this._stack.length - 1];
    if (!t2 || t2.type !== "item") throw new Error("Internal error, expected item layer to be on top.");
    return t2;
  }
  pushItem() {
    this._itemDepth++, this._stack.push({ type: "item", usedSlots: /* @__PURE__ */ new Set() });
  }
  popItem() {
    this.pop("item");
  }
  pushSlotBindings(t2) {
    this._stack.push({ type: "slotBinding", bindingMap: new WeakMap(t2) });
  }
  popSlotBindings() {
    this.pop("slotBinding");
  }
  pushFunctionScope(t2, r2, n, a) {
    this._stack.push({ type: "functionScope", args: t2, argAliases: r2, returnType: n, externalMap: a });
  }
  popFunctionScope() {
    this.pop("functionScope");
  }
  pushBlockScope() {
    this._stack.push({ type: "blockScope", declarations: /* @__PURE__ */ new Map() });
  }
  popBlockScope() {
    this.pop("blockScope");
  }
  pop(t2) {
    let r2 = this._stack[this._stack.length - 1];
    if (!r2 || t2 && r2.type !== t2) throw new Error(`Internal error, expected a ${t2} layer to be on top.`);
    this._stack.pop(), t2 === "item" && this._itemDepth--;
  }
  readSlot(t2) {
    for (let r2 = this._stack.length - 1; r2 >= 0; --r2) {
      let n = this._stack[r2];
      if (n?.type === "item") n.usedSlots.add(t2);
      else if (n?.type === "slotBinding") {
        let a = n.bindingMap.get(t2);
        if (a !== void 0) return a;
      } else if (!(n?.type === "functionScope" || n?.type === "blockScope")) throw new Error("Unknown layer type.");
    }
    return t2.defaultValue;
  }
  getSnippetById(t2) {
    for (let r2 = this._stack.length - 1; r2 >= 0; --r2) {
      let n = this._stack[r2];
      if (n?.type === "functionScope") {
        let a = n.args.find((i) => i.value === t2);
        if (a !== void 0) return a;
        if (n.argAliases[t2]) return n.argAliases[t2];
        let o3 = n.externalMap[t2];
        return o3 != null ? he2(o3) : void 0;
      }
      if (n?.type === "blockScope") {
        let a = n.declarations.get(t2);
        if (a !== void 0) return u(t2, a);
      }
    }
  }
  defineBlockVariable(t2, r2) {
    if (r2.type === "unknown") throw Error(`Tried to define variable '${t2}' of unknown type`);
    for (let n = this._stack.length - 1; n >= 0; --n) {
      let a = this._stack[n];
      if (a?.type === "blockScope") return a.declarations.set(t2, r2), u(t2, r2);
    }
    throw new Error("No block scope found to define a variable in.");
  }
};
var Wt2 = ["", "  ", "    ", "      ", "        ", "          ", "            ", "              ", "                "];
var Or = Wt2.length - 1;
var Mr = class {
  identLevel = 0;
  get pre() {
    return Wt2[this.identLevel] ?? Wt2[Or].repeat(this.identLevel / Or) + Wt2[this.identLevel % Or];
  }
  indent() {
    let t2 = this.pre;
    return this.identLevel++, t2;
  }
  dedent() {
    return this.identLevel--, this.pre;
  }
};
var Nr = class {
  _memoizedResolves = /* @__PURE__ */ new WeakMap();
  _memoizedDerived = /* @__PURE__ */ new WeakMap();
  _indentController = new Mr();
  _itemStateStack = new Wr();
  _declarations = [];
  _varyingLocations;
  get varyingLocations() {
    return this._varyingLocations;
  }
  [r] = { itemStateStack: this._itemStateStack };
  bindGroupLayoutsToPlaceholderMap = /* @__PURE__ */ new Map();
  _nextFreeLayoutPlaceholderIdx = 0;
  fixedBindings = [];
  callStack = [];
  names;
  constructor(t2) {
    this.names = t2.names;
  }
  get pre() {
    return this._indentController.pre;
  }
  indent() {
    return this._indentController.indent();
  }
  dedent() {
    return this._indentController.dedent();
  }
  getById(t2) {
    let r2 = this._itemStateStack.getSnippetById(t2);
    return r2 === void 0 ? null : r2;
  }
  defineVariable(t2, r2) {
    return this._itemStateStack.defineBlockVariable(t2, r2);
  }
  pushBlockScope() {
    this._itemStateStack.pushBlockScope();
  }
  popBlockScope() {
    this._itemStateStack.popBlockScope();
  }
  fnToWgsl(t2) {
    this._itemStateStack.pushFunctionScope(t2.args, t2.argAliases, t2.returnType, t2.externalMap);
    try {
      return { head: co(this, t2.args, t2.returnType), body: pa(this, t2.body) };
    } finally {
      this._itemStateStack.popFunctionScope();
    }
  }
  addDeclaration(t2) {
    this._declarations.push(t2);
  }
  allocateLayoutEntry(t2) {
    let r2 = this.bindGroupLayoutsToPlaceholderMap, n = r2.get(t2);
    return n || (n = `#BIND_GROUP_LAYOUT_${this._nextFreeLayoutPlaceholderIdx++}#`, r2.set(t2, n)), n;
  }
  allocateFixedEntry(t2, r2) {
    let n = this.fixedBindings.length;
    return this.fixedBindings.push({ layoutEntry: t2, resource: r2 }), { group: la, binding: n };
  }
  readSlot(t2) {
    let r2 = this._itemStateStack.readSlot(t2);
    if (r2 === void 0) throw new ue(t2);
    return r2;
  }
  withSlots(t2, r2) {
    this._itemStateStack.pushSlotBindings(t2);
    try {
      return r2();
    } finally {
      this._itemStateStack.popSlotBindings();
    }
  }
  withVaryingLocations(t2, r2) {
    this._varyingLocations = t2;
    try {
      return r2();
    } finally {
      this._varyingLocations = void 0;
    }
  }
  unwrap(t2) {
    if (He(t2)) return this.withSlots(t2[At].pairs, () => this.unwrap(t2[At].inner));
    let r2 = t2;
    for (; ; ) if (Ge(r2)) r2 = this.readSlot(r2);
    else if (Ve2(r2)) r2 = this._getOrCompute(r2);
    else break;
    return r2;
  }
  _getOrCompute(t2) {
    let r2 = this._memoizedDerived.get(t2) ?? [];
    this._itemStateStack.pushItem();
    try {
      for (let o3 of r2) if ([...o3.slotToValueMap.entries()].every(([s, p2]) => s.areEqual(this._itemStateStack.readSlot(s), p2))) return o3.result;
      pn(je.CPU);
      let n;
      try {
        n = t2["~compute"]();
      } finally {
        mn(je.CPU);
      }
      let a = /* @__PURE__ */ new Map();
      for (let o3 of this._itemStateStack.topItem.usedSlots) a.set(o3, this._itemStateStack.readSlot(o3));
      return r2.push({ slotToValueMap: a, result: n }), this._memoizedDerived.set(t2, r2), n;
    } catch (n) {
      throw n instanceof he ? n.appendToTrace(t2) : new he(n, [t2]);
    } finally {
      this._itemStateStack.popItem();
    }
  }
  _getOrInstantiate(t2) {
    let r2 = this._memoizedResolves.get(t2) ?? [];
    this._itemStateStack.pushItem();
    try {
      for (let o3 of r2) if ([...o3.slotToValueMap.entries()].every(([s, p2]) => s.areEqual(this._itemStateStack.readSlot(s), p2))) return o3.result;
      let n;
      un(t2) ? n = wr(this, t2) : Ve2(t2) || Ge(t2) ? n = this.resolve(this.unwrap(t2)) : gr(t2) ? n = t2["~resolve"](this) : n = this.resolveValue(t2);
      let a = /* @__PURE__ */ new Map();
      for (let o3 of this._itemStateStack.topItem.usedSlots) a.set(o3, this._itemStateStack.readSlot(o3));
      return r2.push({ slotToValueMap: a, result: n }), this._memoizedResolves.set(t2, r2), n;
    } catch (n) {
      throw n instanceof he ? n.appendToTrace(t2) : new he(n, [t2]);
    } finally {
      this._itemStateStack.popItem();
    }
  }
  resolve(t2) {
    if (He(t2)) return this.withSlots(t2[At].pairs, () => this.resolve(t2[At].inner));
    if (t2 && typeof t2 == "object" || typeof t2 == "function") {
      if (this._itemStateStack.itemDepth === 0) try {
        pn(je.GPU);
        let r2 = dn(this, () => this._getOrInstantiate(t2));
        return `${[...this._declarations].join(`

`)}${r2}`;
      } finally {
        mn(je.GPU);
      }
      return this._getOrInstantiate(t2);
    }
    return String(t2);
  }
  resolveValue(t2, r2) {
    if (wt(t2)) return this.resolve(t2);
    if (r2 && Gt(r2)) return `array(${t2.map((n) => this.resolveValue(n, r2.elementType))})`;
    if (Array.isArray(t2)) return `array(${t2.map((n) => this.resolveValue(n))})`;
    if (r2 && Yt(r2)) return `${this.resolve(r2)}(${Object.entries(r2.propTypes).map(([n, a]) => this.resolveValue(t2[n], a))})`;
    throw new Error(`Value ${t2} (as json: ${JSON.stringify(t2)}) of schema ${r2} is not resolvable to WGSL`);
  }
};
function fe2(e10, t2) {
  let r2 = new Nr(t2), n = r2.resolve(e10), a = r2.bindGroupLayoutsToPlaceholderMap, o3 = [], i = new Set([...a.keys()].map((m2) => m2.index).filter((m2) => m2 !== void 0)), s = zn(i), p2 = r2.fixedBindings.map((m2, g) => [String(g), m2.layoutEntry]), u3 = () => {
    let m2 = s.next().value, g = kt(Object.fromEntries(p2));
    return o3[m2] = g, n = n.replaceAll(la, String(m2)), [m2, new Le(g, Object.fromEntries(r2.fixedBindings.map((y, x2) => [String(x2), y.resource])))];
  }, f2 = p2.length > 0 ? u3() : void 0;
  for (let [m2, g] of a.entries()) {
    let y = m2.index ?? s.next().value;
    o3[y] = m2, n = n.replaceAll(g, String(y));
  }
  return { code: n, usedBindGroupLayouts: o3, catchall: f2 };
}
function co(e10, t2, r2) {
  let n = t2.map((a) => `${a.value}: ${e10.resolve(a.dataType)}`).join(", ");
  return r2.type !== "void" ? `(${n}) -> ${Me2(r2)} ${e10.resolve(r2)}` : `(${n})`;
}
function zr(e10) {
  let { externals: t2, template: r2, names: n } = e10, a = {};
  return be2(a, t2 ?? {}), fe2({ "~resolve"(i) {
    return we2(i, a, r2 ?? "");
  }, toString: () => "<root>" }, { names: n === "strict" ? new le2() : new pe() });
}
function ma(e10) {
  return zr(e10).code;
}
function da(e10, t2, r2, n) {
  return new jr(e10, t2, r2, n);
}
function st2(e10) {
  let t2 = e10;
  return t2?.resourceType === "query-set" && !!t2[r];
}
var jr = class {
  constructor(t2, r2, n, a) {
    this._group = t2;
    this.type = r2;
    this.count = n;
    this.rawQuerySet = a;
    this._ownQuerySet = !a, this._querySet = a || null;
  }
  resourceType = "query-set";
  _querySet = null;
  _ownQuerySet;
  _destroyed = false;
  _available = true;
  _readBuffer = null;
  _resolveBuffer = null;
  get querySet() {
    if (this._destroyed) throw new Error("This QuerySet has been destroyed.");
    return this.rawQuerySet ? this.rawQuerySet : this._querySet ? this._querySet : (this._querySet = this._group.device.createQuerySet({ type: this.type, count: this.count }), this._querySet);
  }
  get destroyed() {
    return this._destroyed;
  }
  get available() {
    return this._available;
  }
  get [r]() {
    let t2 = this;
    return { get readBuffer() {
      return t2._readBuffer || (t2._readBuffer = t2._group.device.createBuffer({ size: t2.count * BigUint64Array.BYTES_PER_ELEMENT, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ })), t2._readBuffer;
    }, get resolveBuffer() {
      return t2._resolveBuffer || (t2._resolveBuffer = t2._group.device.createBuffer({ size: t2.count * BigUint64Array.BYTES_PER_ELEMENT, usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC })), t2._resolveBuffer;
    } };
  }
  $name(t2) {
    return oe(this, t2), this._querySet && (this._querySet.label = t2), this;
  }
  resolve() {
    if (this._destroyed) throw new Error("This QuerySet has been destroyed.");
    if (!this._available) throw new Error("This QuerySet is busy resolving or reading.");
    let t2 = this._group.device.createCommandEncoder();
    t2.resolveQuerySet(this.querySet, 0, this.count, this[r].resolveBuffer, 0), this._group.device.queue.submit([t2.finish()]);
  }
  async read() {
    if (this._group.flush(), !this._resolveBuffer) throw new Error("QuerySet must be resolved before reading.");
    this._available = false;
    try {
      let t2 = this._group.device.createCommandEncoder();
      t2.copyBufferToBuffer(this[r].resolveBuffer, 0, this[r].readBuffer, 0, this.count * BigUint64Array.BYTES_PER_ELEMENT), this._group.device.queue.submit([t2.finish()]), await this._group.device.queue.onSubmittedWorkDone();
      let r2 = this[r].readBuffer;
      await r2.mapAsync(GPUMapMode.READ);
      let n = new BigUint64Array(r2.getMappedRange().slice());
      return r2.unmap(), Array.from(n);
    } finally {
      this._available = true;
    }
  }
  destroy() {
    this._destroyed || (this._destroyed = true, this._querySet && this._ownQuerySet && this._querySet.destroy(), this._readBuffer?.destroy(), this._resolveBuffer?.destroy(), this._readBuffer = this._resolveBuffer = null);
  }
};
var ut2 = class {
  constructor(t2) {
    this._make = t2;
  }
  _map = /* @__PURE__ */ new WeakMap();
  getOrMake(t2, ...r2) {
    if (this._map.has(t2)) return this._map.get(t2);
    let n = this._make(t2, ...r2);
    return this._map.set(t2, n), n;
  }
};
function Mt(e10, t2, r2) {
  if (!r2.enabledFeatures.has("timestamp-query")) throw new Error('Performance callback requires the "timestamp-query" feature to be enabled on GPU device.');
  return e10.timestampWrites ? { ...e10, performanceCallback: t2 } : { ...e10, performanceCallback: t2, hasAutoQuerySet: true, timestampWrites: { querySet: r2.createQuerySet("timestamp", 2), beginningOfPassWriteIndex: 0, endOfPassWriteIndex: 1 } };
}
function Nt(e10, t2, r2) {
  if (!r2.enabledFeatures.has("timestamp-query")) throw new Error('Timestamp writes require the "timestamp-query" feature to be enabled on GPU device.');
  e10.hasAutoQuerySet && e10.timestampWrites && e10.timestampWrites.querySet.destroy();
  let n = { querySet: t2.querySet };
  return t2.beginningOfPassWriteIndex !== void 0 && (n.beginningOfPassWriteIndex = t2.beginningOfPassWriteIndex), t2.endOfPassWriteIndex !== void 0 && (n.endOfPassWriteIndex = t2.endOfPassWriteIndex), { ...e10, hasAutoQuerySet: false, timestampWrites: n };
}
function zt(e10, t2) {
  if (!e10.timestampWrites) return {};
  let { querySet: r2, beginningOfPassWriteIndex: n, endOfPassWriteIndex: a } = e10.timestampWrites, o3 = { querySet: st2(r2) ? t2.unwrap(r2) : r2 };
  return n !== void 0 && (o3.beginningOfPassWriteIndex = n), a !== void 0 && (o3.endOfPassWriteIndex = a), { timestampWrites: o3 };
}
function pt({ root: e10, priors: t2 }) {
  let r2 = t2.timestampWrites?.querySet, n = t2.performanceCallback;
  if (!r2) throw new Error("Cannot dispatch workgroups with performance callback without a query set.");
  if (!st2(r2)) throw new Error("Performance callback with raw GPUQuerySet is not supported. Use TgpuQuerySet instead.");
  e10.commandEncoder.resolveQuerySet(e10.unwrap(r2), 0, r2.count, r2[r].resolveBuffer, 0), e10.flush(), e10.device.queue.onSubmittedWorkDone().then(async () => {
    if (!r2.available) return;
    let a = await r2.read(), o3 = a[t2.timestampWrites?.beginningOfPassWriteIndex ?? 0], i = a[t2.timestampWrites?.endOfPassWriteIndex ?? 1];
    if (o3 === void 0 || i === void 0) throw new Error("QuerySet did not return valid timestamps.");
    await n(o3, i);
  });
}
function fa(e10, t2, r2) {
  return new qr(new Qr(e10, t2, r2), {});
}
function ca(e10) {
  let t2 = e10;
  return t2?.resourceType === "compute-pipeline" && !!t2[r];
}
var qr = class e5 {
  constructor(t2, r2) {
    this._core = t2;
    this._priors = r2;
    this[r] = { get rawPipeline() {
      return t2.unwrap().pipeline;
    }, get priors() {
      return r2;
    } }, this[G] = t2;
  }
  [r];
  resourceType = "compute-pipeline";
  [G];
  "~resolve"(t2) {
    return t2.resolve(this._core);
  }
  toString() {
    return `computePipeline:${f(this) ?? "<unnamed>"}`;
  }
  get rawPipeline() {
    return this._core.unwrap().pipeline;
  }
  with(t2, r2) {
    return new e5(this._core, { ...this._priors, bindGroupLayoutMap: new Map([...this._priors.bindGroupLayoutMap ?? [], [t2, r2]]) });
  }
  withPerformanceCallback(t2) {
    let r2 = Mt(this._priors, t2, this._core.branch);
    return new e5(this._core, r2);
  }
  withTimestampWrites(t2) {
    let r2 = Nt(this._priors, t2, this._core.branch);
    return new e5(this._core, r2);
  }
  dispatchWorkgroups(t2, r2, n) {
    let a = this._core.unwrap(), { branch: o3 } = this._core, i = { label: f(this._core) ?? "<unnamed>", ...zt(this._priors, o3) }, s = o3.commandEncoder.beginComputePass(i);
    s.setPipeline(a.pipeline);
    let p2 = new Set(a.usedBindGroupLayouts);
    if (a.usedBindGroupLayouts.forEach((u3, f2) => {
      if (a.catchall && f2 === a.catchall[0]) s.setBindGroup(f2, o3.unwrap(a.catchall[1])), p2.delete(u3);
      else {
        let m2 = this._priors.bindGroupLayoutMap?.get(u3);
        m2 !== void 0 && (p2.delete(u3), s.setBindGroup(f2, o3.unwrap(m2)));
      }
    }), p2.size > 0) throw new le(p2);
    s.dispatchWorkgroups(t2, r2, n), s.end(), this._priors.performanceCallback && pt({ root: o3, priors: this._priors });
  }
  $name(t2) {
    return oe(this._core, t2), this;
  }
};
var Qr = class {
  constructor(t2, r2, n) {
    this.branch = t2;
    this._slotBindings = r2;
    this._entryFn = n;
  }
  _memo;
  "~resolve"(t2) {
    return t2.withSlots(this._slotBindings, () => (t2.resolve(this._entryFn), ""));
  }
  toString() {
    return "computePipelineCore";
  }
  unwrap() {
    if (this._memo === void 0) {
      let t2 = this.branch.device, r2, n;
      if (Ft?.enabled) {
        let p2 = performance.mark("typegpu:resolution:start");
        r2 = fe2(this, { names: this.branch.nameRegistry }), n = performance.measure("typegpu:resolution", { start: p2.name });
      } else r2 = fe2(this, { names: this.branch.nameRegistry });
      let { code: a, usedBindGroupLayouts: o3, catchall: i } = r2;
      i !== void 0 && o3[i[0]]?.$name(`${f(this) ?? "<unnamed>"} - Automatic Bind Group & Layout`);
      let s = t2.createShaderModule({ label: `${f(this) ?? "<unnamed>"} - Shader`, code: a });
      this._memo = { pipeline: t2.createComputePipeline({ label: f(this) ?? "<unnamed>", layout: t2.createPipelineLayout({ label: `${f(this) ?? "<unnamed>"} - Pipeline Layout`, bindGroupLayouts: o3.map((p2) => this.branch.unwrap(p2)) }), compute: { module: s } }), usedBindGroupLayouts: o3, catchall: i }, Ft?.enabled && (async () => {
        let p2 = performance.mark("typegpu:compile-start");
        await t2.queue.onSubmittedWorkDone();
        let u3 = performance.measure("typegpu:compiled", { start: p2.name });
        Ft?.record("resolution", { resolveDuration: n?.duration, compileDuration: u3.duration, wgslSize: a.length });
      })();
    }
    return this._memo;
  }
};
function Yr(e10, t2 = "vertex") {
  return new Hr(e10, t2);
}
function qt2(e10) {
  return e10?.resourceType === "vertex-layout";
}
var Kr = Symbol("defaultAttribEntry");
function jt2(e10, t2, r2, n, a) {
  if (Te(t2) || sn(t2)) {
    let o3 = hn(t2);
    return o3 !== void 0 && (n[a ?? Kr] = o3), jt2(e10, t2.inner, b(r2, I(t2)), n);
  }
  if (Yt(t2)) {
    let o3 = r2;
    return Object.fromEntries(Object.entries(t2.propTypes).map(([i, s]) => {
      o3 = b(o3, u2(s));
      let p2 = [i, jt2(e10, s, o3, n, i)];
      return o3 += l(s), p2;
    }));
  }
  if (rn(t2)) {
    let o3 = r2;
    return Object.fromEntries(Object.entries(t2.propTypes).map(([i, s]) => {
      o3 = b(o3, I(s));
      let p2 = [i, jt2(e10, s, o3, n, i)];
      return o3 += l(s), p2;
    }));
  }
  if ("type" in t2 && typeof t2.type == "string") {
    if (be.includes(t2.type)) return { _layout: e10, format: t2.type, offset: r2 };
    let o3 = qt[t2.type];
    if (o3) return { _layout: e10, format: o3, offset: r2 };
  }
  throw new Error(`Unsupported data used in vertex layout: ${String(t2)}`);
}
var Hr = class {
  constructor(t2, r2) {
    this.schemaForCount = t2;
    this.stepMode = r2;
    let n = t2(0);
    this.stride = b(l(n.elementType), u2(n)), this.attrib = jt2(this, n.elementType, 0, this._customLocationMap);
  }
  [r] = true;
  resourceType = "vertex-layout";
  stride;
  attrib;
  _customLocationMap = {};
  get vertexLayout() {
    if (this._customLocationMap[Kr] !== void 0) {
      if (typeof this.attrib.format != "string" || typeof this.attrib.offset != "number") throw new Error("Single attribute vertex layouts must have a format and offset.");
      return { arrayStride: this.stride, stepMode: this.stepMode, attributes: [{ format: this.attrib.format, offset: this.attrib.offset, shaderLocation: this._customLocationMap[Kr] }] };
    }
    if (!Object.keys(this.attrib).every((r2) => this._customLocationMap[r2] !== void 0)) throw new Error("All attributes must have custom locations in order to unwrap a vertex layout.");
    return { arrayStride: this.stride, stepMode: this.stepMode, attributes: [...Object.entries(this.attrib).map(([r2, n]) => ({ format: n.format, offset: n.offset, shaderLocation: this._customLocationMap[r2] }))] };
  }
  $name(t2) {
    return oe(this, t2), this;
  }
};
function go(e10) {
  return typeof e10?.loadOp == "string";
}
function ga(e10, t2) {
  if (un(e10)) {
    if (!go(t2)) throw new Error("Expected a single color attachment, not a record.");
    return [t2];
  }
  let r2 = [];
  for (let n of Object.keys(e10)) {
    let a = t2[n];
    if (!a) throw new Error(`A color attachment by the name of '${n}' was not provided to the shader.`);
    r2.push(a);
  }
  return r2;
}
function yo(e10) {
  return typeof e10?.format == "string";
}
function ya(e10, t2) {
  if (un(e10)) {
    if (Jt(e10)) return [];
    if (!yo(t2)) throw new Error("Expected a single color target configuration, not a record.");
    return [t2];
  }
  let r2 = [];
  for (let n of Object.keys(e10)) {
    let a = t2[n];
    if (!a) throw new Error(`A color target by the name of '${n}' was not provided to the shader.`);
    r2.push(a);
  }
  return r2;
}
function Ta(e10) {
  return new Jr(new Xr(e10), {});
}
function xa(e10) {
  let t2 = e10;
  return t2?.resourceType === "render-pipeline" && !!t2[r];
}
var Jr = class e6 {
  [r];
  resourceType = "render-pipeline";
  [G];
  hasIndexBuffer = false;
  constructor(t2, r2) {
    this[r] = { core: t2, priors: r2 }, this[G] = t2;
  }
  "~resolve"(t2) {
    return t2.resolve(this[r].core);
  }
  toString() {
    return `renderPipeline:${f(this) ?? "<unnamed>"}`;
  }
  $name(t2) {
    return oe(this[r].core, t2), this;
  }
  with(t2, r2) {
    let n = this[r];
    if (Lt2(t2)) return new e6(n.core, { ...n.priors, bindGroupLayoutMap: new Map([...n.priors.bindGroupLayoutMap ?? [], [t2, r2]]) });
    if (qt2(t2)) return new e6(n.core, { ...n.priors, vertexLayoutMap: new Map([...n.priors.vertexLayoutMap ?? [], [t2, r2]]) });
    throw new Error("Unsupported value passed into .with()");
  }
  withPerformanceCallback(t2) {
    let r2 = this[r], n = Mt(r2.priors, t2, r2.core.options.branch);
    return new e6(r2.core, n);
  }
  withTimestampWrites(t2) {
    let r2 = this[r], n = Nt(r2.priors, t2, r2.core.options.branch);
    return new e6(r2.core, n);
  }
  withColorAttachment(t2) {
    let r2 = this[r];
    return new e6(r2.core, { ...r2.priors, colorAttachment: t2 });
  }
  withDepthStencilAttachment(t2) {
    let r2 = this[r];
    return new e6(r2.core, { ...r2.priors, depthStencilAttachment: t2 });
  }
  withIndexBuffer(t2, r2, n, a) {
    let o3 = this[r];
    if (Ye(t2)) {
      if (typeof r2 != "string") throw new Error("If a GPUBuffer is passed, indexFormat must be provided.");
      return new e6(o3.core, { ...o3.priors, indexBuffer: { buffer: t2, indexFormat: r2, offsetBytes: n, sizeBytes: a } });
    }
    let i = { u32: "uint32", u16: "uint16" }, s = t2.dataType.elementType;
    return new e6(o3.core, { ...o3.priors, indexBuffer: { buffer: t2, indexFormat: i[s.type], offsetBytes: r2 !== void 0 ? r2 * lt(s) : void 0, sizeBytes: a !== void 0 ? a * lt(s) : void 0 } });
  }
  setupRenderPass() {
    let t2 = this[r], r2 = t2.core.unwrap(), { branch: n, fragmentFn: a } = t2.core.options, o3 = ga(a.shell.out, t2.priors.colorAttachment ?? {}).map((m2) => Z3(m2.view) ? { ...m2, view: n.unwrap(m2.view).createView() } : m2), i = { label: f(t2.core) ?? "<unnamed>", colorAttachments: o3, ...zt(t2.priors, n) };
    if (t2.priors.depthStencilAttachment !== void 0) {
      let m2 = t2.priors.depthStencilAttachment;
      Z3(m2.view) ? i.depthStencilAttachment = { ...m2, view: n.unwrap(m2.view).createView() } : i.depthStencilAttachment = m2;
    }
    let s = n.commandEncoder.beginRenderPass(i);
    s.setPipeline(r2.pipeline);
    let p2 = new Set(r2.usedBindGroupLayouts);
    r2.usedBindGroupLayouts.forEach((m2, g) => {
      if (r2.catchall && g === r2.catchall[0]) s.setBindGroup(g, n.unwrap(r2.catchall[1])), p2.delete(m2);
      else {
        let y = t2.priors.bindGroupLayoutMap?.get(m2);
        y !== void 0 && (p2.delete(m2), s.setBindGroup(g, n.unwrap(y)));
      }
    });
    let u3 = new Set(t2.core.usedVertexLayouts);
    if (t2.core.usedVertexLayouts.forEach((m2, g) => {
      let y = t2.priors.vertexLayoutMap?.get(m2);
      y && (u3.delete(m2), s.setVertexBuffer(g, n.unwrap(y)));
    }), p2.size > 0) throw new le(p2);
    if (u3.size > 0) throw new xe(u3);
    return s;
  }
  draw(t2, r2, n, a) {
    let o3 = this[r], i = this.setupRenderPass(), { branch: s } = o3.core.options;
    i.draw(t2, r2, n, a), i.end(), o3.priors.performanceCallback ? pt({ root: s, priors: o3.priors }) : s.flush();
  }
  drawIndexed(t2, r2, n, a, o3) {
    let i = this[r];
    if (!i.priors.indexBuffer) throw new Error("No index buffer set for this render pipeline.");
    let { buffer: s, indexFormat: p2, offsetBytes: u3, sizeBytes: f2 } = i.priors.indexBuffer, m2 = this.setupRenderPass(), { branch: g } = i.core.options;
    Ye(s) ? m2.setIndexBuffer(s, p2, u3, f2) : m2.setIndexBuffer(g.unwrap(s), p2, u3, f2), m2.drawIndexed(t2, r2, n, a, o3), m2.end(), i.priors.performanceCallback ? pt({ root: g, priors: i.priors }) : g.flush();
  }
};
var Xr = class {
  constructor(t2) {
    this.options = t2;
    let r2 = jn(t2.vertexFn.shell.in ?? {}, t2.vertexAttribs);
    this._vertexBufferLayouts = r2.bufferDefinitions, this.usedVertexLayouts = r2.usedVertexLayouts, this._targets = ya(t2.fragmentFn.shell.out, t2.targets);
  }
  usedVertexLayouts;
  _memo;
  _vertexBufferLayouts;
  _targets;
  "~resolve"(t2) {
    let { vertexFn: r2, fragmentFn: n, slotBindings: a } = this.options, o3 = To(r2.shell.out, n.shell.in, f(r2) ?? "<unnamed>", f(n) ?? "<unnamed>");
    return t2.withVaryingLocations(o3, () => t2.withSlots(a, () => (t2.resolve(r2), t2.resolve(n), "")));
  }
  toString() {
    return "renderPipelineCore";
  }
  unwrap() {
    if (this._memo === void 0) {
      let { branch: t2, primitiveState: r2, depthStencilState: n, multisampleState: a } = this.options, o3 = t2.device, i, s;
      if (Ft?.enabled) {
        let x2 = performance.mark("typegpu:resolution:start");
        i = fe2(this, { names: t2.nameRegistry }), s = performance.measure("typegpu:resolution", { start: x2.name });
      } else i = fe2(this, { names: t2.nameRegistry });
      let { code: p2, usedBindGroupLayouts: u3, catchall: f2 } = i;
      f2 !== void 0 && u3[f2[0]]?.$name(`${f(this) ?? "<unnamed>"} - Automatic Bind Group & Layout`);
      let m2 = o3.createShaderModule({ label: `${f(this) ?? "<unnamed>"} - Shader`, code: p2 }), g = { layout: o3.createPipelineLayout({ label: `${f(this) ?? "<unnamed>"} - Pipeline Layout`, bindGroupLayouts: u3.map((x2) => t2.unwrap(x2)) }), vertex: { module: m2, buffers: this._vertexBufferLayouts }, fragment: { module: m2, targets: this._targets } }, y = f(this);
      y !== void 0 && (g.label = y), r2 && (we(r2.stripIndexFormat) ? g.primitive = { ...r2, stripIndexFormat: { u32: "uint32", u16: "uint16" }[r2.stripIndexFormat.type] } : g.primitive = r2), n && (g.depthStencil = n), a && (g.multisample = a), this._memo = { pipeline: o3.createRenderPipeline(g), usedBindGroupLayouts: u3, catchall: f2 }, Ft?.enabled && (async () => {
        let x2 = performance.mark("typegpu:compile-start");
        await o3.queue.onSubmittedWorkDone();
        let b2 = performance.measure("typegpu:compiled", { start: x2.name });
        Ft?.record("resolution", { resolveDuration: s?.duration, compileDuration: b2.duration, wgslSize: p2.length });
      })();
    }
    return this._memo;
  }
};
function To(e10, t2, r2, n) {
  let a = {}, o3 = /* @__PURE__ */ new Set();
  function i(p2, u3) {
    a[p2] = u3, o3.add(u3);
  }
  for (let [p2, u3] of Object.entries(e10)) {
    let f2 = hn(u3);
    f2 !== void 0 && i(p2, f2);
  }
  for (let [p2, u3] of Object.entries(t2 ?? {})) {
    let f2 = hn(u3);
    f2 !== void 0 && (a[p2] === void 0 ? i(p2, f2) : a[p2] !== f2 && console.warn(`Mismatched location between vertexFn (${r2}) output (${a[p2]}) and fragmentFn (${n}) input (${f2}) for the key "${p2}", using the location set on vertex output.`));
  }
  let s = 0;
  for (let p2 of Object.keys(e10 ?? {})) if (!(Dt(e10[p2]) || a[p2] !== void 0)) {
    for (; o3.has(s); ) s++;
    i(p2, s);
  }
  return a;
}
function Zr(e10) {
  return e10 instanceof Ie2;
}
var Ie2 = class {
  constructor(t2, r2) {
    this.resourceType = t2;
    this.buffer = r2;
    this[G] = r2, this.#t = this.buffer.as(this.resourceType);
  }
  [r] = true;
  [G];
  #t;
  $name(t2) {
    return oe(this[G], t2), this;
  }
  write(t2) {
    this.buffer.write(t2);
  }
  writePartial(t2) {
    this.buffer.writePartial(t2);
  }
  read() {
    return this.buffer.read();
  }
  get value() {
    return this.#t.value;
  }
  "~resolve"(t2) {
    return t2.resolve(this.#t);
  }
  get $() {
    return this.value;
  }
};
var en = class e7 {
  constructor(t2) {
    this.bindings = t2;
  }
  with(t2, r2) {
    return new e7([...this.bindings, [Ee2(t2) ? t2.slot : t2, r2]]);
  }
  pipe(t2) {
    let r2 = t2(this);
    return new e7([...this.bindings, ...r2.bindings]);
  }
};
var tn = class e8 {
  constructor(t2, r2) {
    this._getRoot = t2;
    this._slotBindings = r2;
  }
  with(t2, r2) {
    return new e8(this._getRoot, [...this._slotBindings, [Ee2(t2) ? t2.slot : t2, r2]]);
  }
  withCompute(t2) {
    return new rn2(this._getRoot(), this._slotBindings, t2);
  }
  withVertex(t2, r2) {
    return new nn2({ branch: this._getRoot(), primitiveState: void 0, depthStencilState: void 0, slotBindings: this._slotBindings, vertexFn: t2, vertexAttribs: r2, multisampleState: void 0 });
  }
  pipe(t2) {
    let r2 = t2(new en([]));
    return new e8(this._getRoot, [...this._slotBindings, ...r2.bindings]);
  }
};
var rn2 = class {
  constructor(t2, r2, n) {
    this._root = t2;
    this._slotBindings = r2;
    this._entryFn = n;
  }
  createPipeline() {
    return fa(this._root, this._slotBindings, this._entryFn);
  }
};
var nn2 = class {
  constructor(t2) {
    this._options = t2;
  }
  withFragment(t2, r2, n) {
    return K(typeof t2 != "string", "Just type mismatch validation"), K(typeof r2 != "string", "Just type mismatch validation"), new an({ ...this._options, fragmentFn: t2, targets: r2 });
  }
};
var an = class e9 {
  constructor(t2) {
    this._options = t2;
  }
  withPrimitive(t2) {
    return new e9({ ...this._options, primitiveState: t2 });
  }
  withDepthStencil(t2) {
    return new e9({ ...this._options, depthStencilState: t2 });
  }
  withMultisample(t2) {
    return new e9({ ...this._options, multisampleState: t2 });
  }
  createPipeline() {
    return Ta(this._options);
  }
};
var Qt = class extends tn {
  constructor(r2, n, a) {
    super(() => this, []);
    this.device = r2;
    this.nameRegistry = n;
    this._ownDevice = a;
    this["~unstable"] = this;
  }
  "~unstable";
  _disposables = [];
  _unwrappedBindGroupLayouts = new ut2((r2) => r2.unwrap(this));
  _unwrappedBindGroups = new ut2((r2) => r2.unwrap(this));
  _commandEncoder = null;
  get commandEncoder() {
    return this._commandEncoder || (this._commandEncoder = this.device.createCommandEncoder()), this._commandEncoder;
  }
  get enabledFeatures() {
    return new Set(this.device.features);
  }
  createBuffer(r2, n) {
    let a = tt2(this, r2, n);
    return this._disposables.push(a), a;
  }
  createUniform(r2, n) {
    let a = tt2(this, r2, n).$usage("uniform");
    return this._disposables.push(a), new Ie2("uniform", a);
  }
  createMutable(r2, n) {
    let a = tt2(this, r2, n).$usage("storage");
    return this._disposables.push(a), new Ie2("mutable", a);
  }
  createReadonly(r2, n) {
    let a = tt2(this, r2, n).$usage("storage");
    return this._disposables.push(a), new Ie2("readonly", a);
  }
  createQuerySet(r2, n, a) {
    return da(this, r2, n, a);
  }
  createBindGroup(r2, n) {
    return new Le(r2, n);
  }
  destroy() {
    for (let r2 of this._disposables) r2.destroy();
    this._ownDevice && this.device.destroy();
  }
  createTexture(r2) {
    let n = aa(r2, this);
    return this._disposables.push(n), n;
  }
  unwrap(r2) {
    if (ca(r2)) return r2[r].rawPipeline;
    if (xa(r2)) return r2[r].core.unwrap().pipeline;
    if (Lt2(r2)) return this._unwrappedBindGroupLayouts.getOrMake(r2);
    if (kr(r2)) return this._unwrappedBindGroups.getOrMake(r2);
    if (de3(r2)) return r2.buffer;
    if (Z3(r2)) return r2[r].unwrap();
    if (ot2(r2)) {
      if (r2[r].unwrap) return r2[r].unwrap();
      throw new Error("Cannot unwrap laid-out texture view.");
    }
    if (it2(r2)) {
      if (r2[r].unwrap) return r2[r].unwrap();
      throw new Error("Cannot unwrap laid-out texture view.");
    }
    if (qt2(r2)) return r2.vertexLayout;
    if (rt2(r2)) {
      if (r2[r].unwrap) return r2[r].unwrap(this);
      throw new Error("Cannot unwrap laid-out sampler.");
    }
    if (nt2(r2)) {
      if (r2[r].unwrap) return r2[r].unwrap(this);
      throw new Error("Cannot unwrap laid-out comparison sampler.");
    }
    if (st2(r2)) return r2.querySet;
    throw new Error(`Unknown resource type: ${r2}`);
  }
  beginRenderPass(r2, n) {
    let a = this.commandEncoder.beginRenderPass(r2), o3 = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s, p2 = () => {
      if (!s) throw new Error("Cannot draw without a call to pass.setPipeline");
      let { core: u3, priors: f2 } = s[r], m2 = u3.unwrap();
      a.setPipeline(m2.pipeline);
      let g = new Set(m2.usedBindGroupLayouts);
      m2.usedBindGroupLayouts.forEach((x2, b2) => {
        if (m2.catchall && b2 === m2.catchall[0]) a.setBindGroup(b2, this.unwrap(m2.catchall[1])), g.delete(x2);
        else {
          let I2 = f2.bindGroupLayoutMap?.get(x2) ?? o3.get(x2);
          I2 !== void 0 && (g.delete(x2), kr(I2) ? a.setBindGroup(b2, this.unwrap(I2)) : a.setBindGroup(b2, I2));
        }
      });
      let y = /* @__PURE__ */ new Set();
      if (u3.usedVertexLayouts.forEach((x2, b2) => {
        let I2 = f2.vertexLayoutMap?.get(x2), P = I2 ? { buffer: I2, offset: void 0, size: void 0 } : i.get(x2);
        !P || !P.buffer ? y.add(x2) : de3(P.buffer) ? a.setVertexBuffer(b2, this.unwrap(P.buffer), P.offset, P.size) : a.setVertexBuffer(b2, P.buffer, P.offset, P.size);
      }), g.size > 0) throw new le(g);
      if (y.size > 0) throw new xe(y);
    };
    n({ setViewport(...u3) {
      a.setViewport(...u3);
    }, setScissorRect(...u3) {
      a.setScissorRect(...u3);
    }, setBlendConstant(...u3) {
      a.setBlendConstant(...u3);
    }, setStencilReference(...u3) {
      a.setStencilReference(...u3);
    }, beginOcclusionQuery(...u3) {
      a.beginOcclusionQuery(...u3);
    }, endOcclusionQuery(...u3) {
      a.endOcclusionQuery(...u3);
    }, executeBundles(...u3) {
      a.executeBundles(...u3);
    }, setPipeline(u3) {
      s = u3;
    }, setIndexBuffer: (u3, f2, m2, g) => {
      de3(u3) ? a.setIndexBuffer(this.unwrap(u3), f2, m2, g) : a.setIndexBuffer(u3, f2, m2, g);
    }, setVertexBuffer(u3, f2, m2, g) {
      i.set(u3, { buffer: f2, offset: m2, size: g });
    }, setBindGroup(u3, f2) {
      o3.set(u3, f2);
    }, draw(u3, f2, m2, g) {
      p2(), a.draw(u3, f2, m2, g);
    }, drawIndexed(...u3) {
      p2(), a.drawIndexed(...u3);
    }, drawIndirect(...u3) {
      p2(), a.drawIndirect(...u3);
    }, drawIndexedIndirect(...u3) {
      p2(), a.drawIndexedIndirect(...u3);
    } }), a.end();
  }
  flush() {
    this._commandEncoder && (this.device.queue.submit([this._commandEncoder.finish()]), this._commandEncoder = null);
  }
};
async function ha(e10) {
  let { adapter: t2, device: r2, unstable_names: n = "random" } = e10 ?? {};
  if (!navigator.gpu) throw new Error("WebGPU is not supported by this browser.");
  let a = await navigator.gpu.requestAdapter(t2);
  if (!a) throw new Error("Could not find a compatible GPU");
  let o3 = [];
  for (let i of r2?.requiredFeatures ?? []) {
    if (!a.features.has(i)) throw new Error(`Requested feature "${i}" is not supported by the adapter.`);
    o3.push(i);
  }
  for (let i of r2?.optionalFeatures ?? []) a.features.has(i) ? o3.push(i) : console.warn(`Optional feature "${i}" is not supported by the adapter.`);
  return new Qt(await a.requestDevice({ ...r2, requiredFeatures: o3 }), n === "random" ? new pe() : new le2(), true);
}
function ba(e10) {
  let { device: t2, unstable_names: r2 = "random" } = e10 ?? {};
  return new Qt(t2, r2 === "random" ? new pe() : new le2(), false);
}
function lt2(e10) {
  return new on(e10);
}
var on = class {
  constructor(t2 = void 0) {
    this.defaultValue = t2;
  }
  [r] = true;
  resourceType = "slot";
  $name(t2) {
    return oe(this, t2), this;
  }
  areEqual(t2, r2) {
    return Object.is(t2, r2);
  }
  toString() {
    return `slot:${f(this) ?? "<unnamed>"}`;
  }
  [_t](t2) {
    return Ke(t2, t2.unwrap(this));
  }
  get value() {
    let t2 = wn();
    if (!t2) throw new Error("Cannot access tgpu.slot's value outside of resolution.");
    return this[_t](t2);
  }
  get $() {
    return this.value;
  }
};
function wa(e10, t2) {
  return new sn2(e10, t2);
}
var sn2 = class {
  constructor(t2, r2 = void 0) {
    this.schema = t2;
    this.defaultValue = r2;
    this.slot = lt2(r2), this[G] = this.slot;
  }
  [r] = true;
  resourceType = "accessor";
  slot;
  $name(t2) {
    return this.slot.$name(t2), this;
  }
  toString() {
    return `accessor:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this.schema }, H2);
  }
  get value() {
    if (!fe()) throw new Error("`tgpu.accessor` values are only accessible on the GPU");
    return this[_t]();
  }
  get $() {
    return this.value;
  }
  "~resolve"(t2) {
    let r2 = t2.unwrap(this.slot);
    return Rn(r2) || Zr(r2) ? t2.resolve(r2) : hr(r2) ? `${t2.resolve(r2)}()` : t2.resolveValue(r2, this.schema);
  }
};
function Sa(e10) {
  return ho(e10);
}
function xo([e10, t2]) {
  return `${f(e10) ?? "<unnamed>"}=${t2}`;
}
function ho(e10) {
  if (wn()) throw new Error("Cannot create tgpu.derived objects at the resolution stage.");
  return { resourceType: "derived", "~compute": e10, [ie]: void 0, [It]: void 0, [_t](r2) {
    return Ke(r2, r2.unwrap(this));
  }, get value() {
    let r2 = wn();
    if (!r2) throw new Error("Cannot access tgpu.derived's value outside of resolution.");
    return this[_t](r2);
  }, get $() {
    return this.value;
  }, with(r2, n) {
    return va(this, [[r2, n]]);
  }, toString() {
    return "derived";
  } };
}
function va(e10, t2) {
  return { resourceType: "derived", [ie]: void 0, [It]: void 0, "~compute"() {
    throw new Error("'~compute' should never be read on bound derived items.");
  }, [At]: { inner: e10, pairs: t2 }, [_t](n) {
    return Ke(n, n.unwrap(this));
  }, get value() {
    let n = wn();
    if (!n) throw new Error("Cannot access tgpu.derived's value outside of resolution.");
    return this[_t](n);
  }, get $() {
    return this.value;
  }, with(n, a) {
    return va(e10, [...t2, [n, a]]);
  }, toString() {
    return `derived[${t2.map(xo).join(", ")}]`;
  } };
}
function Da(e10, t2) {
  return new Kt2("private", e10, t2);
}
function Ia(e10) {
  return new Kt2("workgroup", e10);
}
var Kt2 = class {
  constructor(t2, r2, n) {
    this.scope = t2;
    this._dataType = r2;
    this._initialValue = n;
    this[r] = { scope: t2 };
  }
  "~resolve"(t2) {
    let r2 = t2.names.makeUnique(f(this));
    return this._initialValue ? t2.addDeclaration(`var<${this.scope}> ${r2}: ${t2.resolve(this._dataType)} = ${t2.resolveValue(this._initialValue, this._dataType)};`) : t2.addDeclaration(`var<${this.scope}> ${r2}: ${t2.resolve(this._dataType)};`), r2;
  }
  $name(t2) {
    return oe(this, t2), this;
  }
  toString() {
    return `var:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this._dataType }, H2);
  }
  get value() {
    if (!fe()) throw new Error("`tgpu.var` values are only accessible on the GPU");
    return this[_t]();
  }
};
var bo = { fn: xr, bindGroupLayout: kt, vertexLayout: Yr, slot: lt2, init: ha, initFromDevice: ba, resolve: ma, resolveWithContext: zr, "~unstable": { fn: xr, fragmentFn: Nn, vertexFn: zn2, computeFn: Wn, vertexLayout: Yr, derived: Sa, slot: lt2, accessor: wa, privateVar: Da, workgroupVar: Ia, const: Cn, declare: Gn, sampler: Zn, comparisonSampler: ea } };
var um = bo;
export {
  le as MissingBindGroupsError,
  ce as MissingLinksError,
  ue as MissingSlotValueError,
  xe as MissingVertexBuffersError,
  ye as NotUniformError,
  pe as RandomNameRegistry,
  he as ResolutionError,
  le2 as StrictNameRegistry,
  um as default,
  de3 as isBuffer,
  Zr as isBufferShorthand,
  nt2 as isComparisonSampler,
  Ve2 as isDerived,
  it2 as isSampledTextureView,
  rt2 as isSampler,
  Ge as isSlot,
  ot2 as isStorageTextureView,
  Z3 as isTexture,
  hr as isTgpuFn,
  so as isUsableAsRender,
  Vr as isUsableAsSampled,
  ve2 as isUsableAsStorage,
  Bt as isUsableAsUniform,
  io as isUsableAsVertex,
  bo as tgpu,
  Ir as unstable_asMutable,
  Ur as unstable_asReadonly,
  Fr as unstable_asUniform
};
//# sourceMappingURL=typegpu.js.map
