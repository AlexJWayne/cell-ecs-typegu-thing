import {
  $e,
  $n,
  At,
  Ce,
  De,
  Dt,
  Ee,
  Ft,
  G,
  Gt,
  H,
  Ht,
  I,
  Ie,
  In,
  It,
  J,
  Jt,
  K,
  Kt,
  Lt,
  Me,
  Me2,
  Ot,
  Pe,
  Re,
  Rt,
  Te,
  Tt,
  Ve,
  Wt,
  X,
  Yt,
  Z,
  Z2,
  _t,
  at,
  b,
  be,
  c,
  ce,
  cn,
  ct,
  d,
  de,
  dn,
  et,
  et2,
  f,
  fe,
  he,
  hn,
  ht,
  ie,
  it,
  j,
  je,
  jt,
  l,
  le,
  lt,
  m,
  mn,
  nn,
  nt,
  o,
  oe,
  ot,
  p,
  pn,
  qt,
  r,
  rn,
  rt,
  se,
  sn,
  st,
  tt,
  u,
  u2,
  ue,
  un,
  ut,
  ve,
  w,
  we,
  wn,
  x,
  xe,
  xt,
  ye,
  yn,
  yt,
  zn
} from "./chunk-O5X7DGPH.js";
import {
  __export
} from "./chunk-PZ5AY32C.js";

// node_modules/typegpu/chunk-RK6TMFVW.js
var S = (e10) => Math.sqrt(e10.x ** 2 + e10.y ** 2);
var D = (e10) => Math.sqrt(e10.x ** 2 + e10.y ** 2 + e10.z ** 2);
var E = (e10) => Math.sqrt(e10.x ** 2 + e10.y ** 2 + e10.z ** 2 + e10.w ** 2);
var ae = (e10, n) => e10.x * n.x + e10.y * n.y;
var re = (e10, n) => e10.x * n.x + e10.y * n.y + e10.z * n.z;
var ve2 = (e10, n) => e10.x * n.x + e10.y * n.y + e10.z * n.z + e10.w * n.w;
var r2 = (e10, n, s) => Math.min(Math.max(n, e10), s);
var u3 = (e10) => (n) => H(e10(n.x), e10(n.y));
var w2 = (e10) => (n) => et(e10(n.x), e10(n.y));
var R = (e10) => (n) => tt(e10(n.x), e10(n.y));
var K2 = (e10) => (n) => nt(e10(n.x), e10(n.y));
var y = (e10) => (n) => X(e10(n.x), e10(n.y), e10(n.z));
var l2 = (e10) => (n) => st(e10(n.x), e10(n.y), e10(n.z));
var $ = (e10) => (n) => it(e10(n.x), e10(n.y), e10(n.z));
var k = (e10) => (n) => at(e10(n.x), e10(n.y), e10(n.z));
var x2 = (e10) => (n) => Z(e10(n.x), e10(n.y), e10(n.z), e10(n.w));
var o2 = (e10) => (n) => ht(e10(n.x), e10(n.y), e10(n.z), e10(n.w));
var N = (e10) => (n) => ut(e10(n.x), e10(n.y), e10(n.z), e10(n.w));
var O = (e10) => (n) => yt(e10(n.x), e10(n.y), e10(n.z), e10(n.w));
var ue2 = (e10) => (n) => {
  let s = n.columns;
  return Ve(u3(e10)(s[0]), u3(e10)(s[1]));
};
var we2 = (e10) => (n) => {
  let s = n.columns;
  return ve(y(e10)(s[0]), y(e10)(s[1]), y(e10)(s[2]));
};
var le2 = (e10) => (n) => {
  let s = n.columns;
  return c(x2(e10)(s[0]), x2(e10)(s[1]), x2(e10)(s[2]), x2(e10)(s[3]));
};
var F = (e10) => (n, s) => H(e10(n.x, s.x), e10(n.y, s.y));
var j2 = (e10) => (n, s) => et(e10(n.x, s.x), e10(n.y, s.y));
var J2 = (e10) => (n, s) => tt(e10(n.x, s.x), e10(n.y, s.y));
var Q = (e10) => (n, s) => nt(e10(n.x, s.x), e10(n.y, s.y));
var A = (e10) => (n, s) => X(e10(n.x, s.x), e10(n.y, s.y), e10(n.z, s.z));
var P = (e10) => (n, s) => st(e10(n.x, s.x), e10(n.y, s.y), e10(n.z, s.z));
var X2 = (e10) => (n, s) => it(e10(n.x, s.x), e10(n.y, s.y), e10(n.z, s.z));
var Y = (e10) => (n, s) => at(e10(n.x, s.x), e10(n.y, s.y), e10(n.z, s.z));
var p2 = (e10) => (n, s) => Z(e10(n.x, s.x), e10(n.y, s.y), e10(n.z, s.z), e10(n.w, s.w));
var Z3 = (e10) => (n, s) => ht(e10(n.x, s.x), e10(n.y, s.y), e10(n.z, s.z), e10(n.w, s.w));
var ee = (e10) => (n, s) => ut(e10(n.x, s.x), e10(n.y, s.y), e10(n.z, s.z), e10(n.w, s.w));
var ne = (e10) => (n, s) => yt(e10(n.x, s.x), e10(n.y, s.y), e10(n.z, s.z), e10(n.w, s.w));
var fe2 = (e10) => (n, s) => {
  let t2 = n.columns, T = s.columns;
  return Ve(F(e10)(t2[0], T[0]), F(e10)(t2[1], T[1]));
};
var ge = (e10) => (n, s) => {
  let t2 = n.columns, T = s.columns;
  return ve(A(e10)(t2[0], T[0]), A(e10)(t2[1], T[1]), A(e10)(t2[2], T[2]));
};
var he2 = (e10) => (n, s) => {
  let t2 = n.columns, T = s.columns;
  return c(p2(e10)(t2[0], T[0]), p2(e10)(t2[1], T[1]), p2(e10)(t2[2], T[2]), p2(e10)(t2[3], T[3]));
};
var d2 = { divInteger: (e10, n) => n === 0 ? e10 : Math.trunc(e10 / n) };
var c2 = { eq: { vec2f: (e10, n) => rt(e10.x === n.x, e10.y === n.y), vec2h: (e10, n) => rt(e10.x === n.x, e10.y === n.y), vec2i: (e10, n) => rt(e10.x === n.x, e10.y === n.y), vec2u: (e10, n) => rt(e10.x === n.x, e10.y === n.y), "vec2<bool>": (e10, n) => rt(e10.x === n.x, e10.y === n.y), vec3f: (e10, n) => ot(e10.x === n.x, e10.y === n.y, e10.z === n.z), vec3h: (e10, n) => ot(e10.x === n.x, e10.y === n.y, e10.z === n.z), vec3i: (e10, n) => ot(e10.x === n.x, e10.y === n.y, e10.z === n.z), vec3u: (e10, n) => ot(e10.x === n.x, e10.y === n.y, e10.z === n.z), "vec3<bool>": (e10, n) => ot(e10.x === n.x, e10.y === n.y, e10.z === n.z), vec4f: (e10, n) => ct(e10.x === n.x, e10.y === n.y, e10.z === n.z, e10.w === n.w), vec4h: (e10, n) => ct(e10.x === n.x, e10.y === n.y, e10.z === n.z, e10.w === n.w), vec4i: (e10, n) => ct(e10.x === n.x, e10.y === n.y, e10.z === n.z, e10.w === n.w), vec4u: (e10, n) => ct(e10.x === n.x, e10.y === n.y, e10.z === n.z, e10.w === n.w), "vec4<bool>": (e10, n) => ct(e10.x === n.x, e10.y === n.y, e10.z === n.z, e10.w === n.w) }, lt: { vec2f: (e10, n) => rt(e10.x < n.x, e10.y < n.y), vec2h: (e10, n) => rt(e10.x < n.x, e10.y < n.y), vec2i: (e10, n) => rt(e10.x < n.x, e10.y < n.y), vec2u: (e10, n) => rt(e10.x < n.x, e10.y < n.y), vec3f: (e10, n) => ot(e10.x < n.x, e10.y < n.y, e10.z < n.z), vec3h: (e10, n) => ot(e10.x < n.x, e10.y < n.y, e10.z < n.z), vec3i: (e10, n) => ot(e10.x < n.x, e10.y < n.y, e10.z < n.z), vec3u: (e10, n) => ot(e10.x < n.x, e10.y < n.y, e10.z < n.z), vec4f: (e10, n) => ct(e10.x < n.x, e10.y < n.y, e10.z < n.z, e10.w < n.w), vec4h: (e10, n) => ct(e10.x < n.x, e10.y < n.y, e10.z < n.z, e10.w < n.w), vec4i: (e10, n) => ct(e10.x < n.x, e10.y < n.y, e10.z < n.z, e10.w < n.w), vec4u: (e10, n) => ct(e10.x < n.x, e10.y < n.y, e10.z < n.z, e10.w < n.w) }, or: { "vec2<bool>": (e10, n) => rt(e10.x || n.x, e10.y || n.y), "vec3<bool>": (e10, n) => ot(e10.x || n.x, e10.y || n.y, e10.z || n.z), "vec4<bool>": (e10, n) => ct(e10.x || n.x, e10.y || n.y, e10.z || n.z, e10.w || n.w) }, all: { "vec2<bool>": (e10) => e10.x && e10.y, "vec3<bool>": (e10) => e10.x && e10.y && e10.z, "vec4<bool>": (e10) => e10.x && e10.y && e10.z && e10.w }, abs: { vec2f: u3(Math.abs), vec2h: w2(Math.abs), vec2i: R(Math.abs), vec2u: K2(Math.abs), vec3f: y(Math.abs), vec3h: l2(Math.abs), vec3i: $(Math.abs), vec3u: k(Math.abs), vec4f: x2(Math.abs), vec4h: o2(Math.abs), vec4i: N(Math.abs), vec4u: O(Math.abs) }, atan2: { vec2f: F(Math.atan2), vec2h: j2(Math.atan2), vec3f: A(Math.atan2), vec3h: P(Math.atan2), vec4f: p2(Math.atan2), vec4h: Z3(Math.atan2) }, acos: { vec2f: u3(Math.acos), vec2h: w2(Math.acos), vec2i: R(Math.acos), vec2u: K2(Math.acos), vec3f: y(Math.acos), vec3h: l2(Math.acos), vec3i: $(Math.acos), vec3u: k(Math.acos), vec4f: x2(Math.acos), vec4h: o2(Math.acos), vec4i: N(Math.acos), vec4u: O(Math.acos) }, acosh: { vec2f: u3(Math.acosh), vec2h: w2(Math.acosh), vec3f: y(Math.acosh), vec3h: l2(Math.acosh), vec4f: x2(Math.acosh), vec4h: o2(Math.acosh) }, asin: { vec2f: u3(Math.asin), vec2h: w2(Math.asin), vec2i: R(Math.asin), vec2u: K2(Math.asin), vec3f: y(Math.asin), vec3h: l2(Math.asin), vec3i: $(Math.asin), vec3u: k(Math.asin), vec4f: x2(Math.asin), vec4h: o2(Math.asin), vec4i: N(Math.asin), vec4u: O(Math.asin) }, ceil: { vec2f: u3(Math.ceil), vec2h: w2(Math.ceil), vec3f: y(Math.ceil), vec3h: l2(Math.ceil), vec4f: x2(Math.ceil), vec4h: o2(Math.ceil) }, clamp: { vec2f: (e10, n, s) => H(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y)), vec2h: (e10, n, s) => et(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y)), vec2i: (e10, n, s) => tt(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y)), vec2u: (e10, n, s) => nt(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y)), vec3f: (e10, n, s) => X(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y), r2(e10.z, n.z, s.z)), vec3h: (e10, n, s) => st(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y), r2(e10.z, n.z, s.z)), vec3i: (e10, n, s) => it(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y), r2(e10.z, n.z, s.z)), vec3u: (e10, n, s) => at(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y), r2(e10.z, n.z, s.z)), vec4f: (e10, n, s) => Z(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y), r2(e10.z, n.z, s.z), r2(e10.w, n.w, s.w)), vec4h: (e10, n, s) => ht(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y), r2(e10.z, n.z, s.z), r2(e10.w, n.w, s.w)), vec4i: (e10, n, s) => ut(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y), r2(e10.z, n.z, s.z), r2(e10.w, n.w, s.w)), vec4u: (e10, n, s) => yt(r2(e10.x, n.x, s.x), r2(e10.y, n.y, s.y), r2(e10.z, n.z, s.z), r2(e10.w, n.w, s.w)) }, length: { vec2f: S, vec2h: S, vec3f: D, vec3h: D, vec4f: E, vec4h: E }, add: { vec2f: F((e10, n) => e10 + n), vec2h: j2((e10, n) => e10 + n), vec2i: J2((e10, n) => e10 + n), vec2u: Q((e10, n) => e10 + n), vec3f: A((e10, n) => e10 + n), vec3h: P((e10, n) => e10 + n), vec3i: X2((e10, n) => e10 + n), vec3u: Y((e10, n) => e10 + n), vec4f: p2((e10, n) => e10 + n), vec4h: Z3((e10, n) => e10 + n), vec4i: ee((e10, n) => e10 + n), vec4u: ne((e10, n) => e10 + n), mat2x2f: fe2((e10, n) => e10 + n), mat3x3f: ge((e10, n) => e10 + n), mat4x4f: he2((e10, n) => e10 + n) }, addMixed: { vec2f: (e10, n) => u3((s) => s + n)(e10), vec2h: (e10, n) => w2((s) => s + n)(e10), vec2i: (e10, n) => R((s) => s + n)(e10), vec2u: (e10, n) => K2((s) => s + n)(e10), vec3f: (e10, n) => y((s) => s + n)(e10), vec3h: (e10, n) => l2((s) => s + n)(e10), vec3i: (e10, n) => $((s) => s + n)(e10), vec3u: (e10, n) => k((s) => s + n)(e10), vec4f: (e10, n) => x2((s) => s + n)(e10), vec4h: (e10, n) => o2((s) => s + n)(e10), vec4i: (e10, n) => N((s) => s + n)(e10), vec4u: (e10, n) => O((s) => s + n)(e10), mat2x2f: (e10, n) => ue2((s) => s + n)(e10), mat3x3f: (e10, n) => we2((s) => s + n)(e10), mat4x4f: (e10, n) => le2((s) => s + n)(e10) }, mulSxV: { vec2f: (e10, n) => u3((s) => e10 * s)(n), vec2h: (e10, n) => w2((s) => e10 * s)(n), vec2i: (e10, n) => R((s) => e10 * s)(n), vec2u: (e10, n) => K2((s) => e10 * s)(n), vec3f: (e10, n) => y((s) => e10 * s)(n), vec3h: (e10, n) => l2((s) => e10 * s)(n), vec3i: (e10, n) => $((s) => e10 * s)(n), vec3u: (e10, n) => k((s) => e10 * s)(n), vec4f: (e10, n) => x2((s) => e10 * s)(n), vec4h: (e10, n) => o2((s) => e10 * s)(n), vec4i: (e10, n) => N((s) => e10 * s)(n), vec4u: (e10, n) => O((s) => e10 * s)(n), mat2x2f: (e10, n) => ue2((s) => e10 * s)(n), mat3x3f: (e10, n) => we2((s) => e10 * s)(n), mat4x4f: (e10, n) => le2((s) => e10 * s)(n) }, mulVxV: { vec2f: F((e10, n) => e10 * n), vec2h: j2((e10, n) => e10 * n), vec2i: J2((e10, n) => e10 * n), vec2u: Q((e10, n) => e10 * n), vec3f: A((e10, n) => e10 * n), vec3h: P((e10, n) => e10 * n), vec3i: X2((e10, n) => e10 * n), vec3u: Y((e10, n) => e10 * n), vec4f: p2((e10, n) => e10 * n), vec4h: Z3((e10, n) => e10 * n), vec4i: ee((e10, n) => e10 * n), vec4u: ne((e10, n) => e10 * n), mat2x2f: (e10, n) => {
  let s = e10.columns, t2 = n.columns;
  return Ve(s[0].x * t2[0].x + s[1].x * t2[0].y, s[0].y * t2[0].x + s[1].y * t2[0].y, s[0].x * t2[1].x + s[1].x * t2[1].y, s[0].y * t2[1].x + s[1].y * t2[1].y);
}, mat3x3f: (e10, n) => {
  let s = e10.columns, t2 = n.columns;
  return ve(s[0].x * t2[0].x + s[1].x * t2[0].y + s[2].x * t2[0].z, s[0].y * t2[0].x + s[1].y * t2[0].y + s[2].y * t2[0].z, s[0].z * t2[0].x + s[1].z * t2[0].y + s[2].z * t2[0].z, s[0].x * t2[1].x + s[1].x * t2[1].y + s[2].x * t2[1].z, s[0].y * t2[1].x + s[1].y * t2[1].y + s[2].y * t2[1].z, s[0].z * t2[1].x + s[1].z * t2[1].y + s[2].z * t2[1].z, s[0].x * t2[2].x + s[1].x * t2[2].y + s[2].x * t2[2].z, s[0].y * t2[2].x + s[1].y * t2[2].y + s[2].y * t2[2].z, s[0].z * t2[2].x + s[1].z * t2[2].y + s[2].z * t2[2].z);
}, mat4x4f: (e10, n) => {
  let s = e10.columns, t2 = n.columns;
  return c(s[0].x * t2[0].x + s[1].x * t2[0].y + s[2].x * t2[0].z + s[3].x * t2[0].w, s[0].y * t2[0].x + s[1].y * t2[0].y + s[2].y * t2[0].z + s[3].y * t2[0].w, s[0].z * t2[0].x + s[1].z * t2[0].y + s[2].z * t2[0].z + s[3].z * t2[0].w, s[0].w * t2[0].x + s[1].w * t2[0].y + s[2].w * t2[0].z + s[3].w * t2[0].w, s[0].x * t2[1].x + s[1].x * t2[1].y + s[2].x * t2[1].z + s[3].x * t2[1].w, s[0].y * t2[1].x + s[1].y * t2[1].y + s[2].y * t2[1].z + s[3].y * t2[1].w, s[0].z * t2[1].x + s[1].z * t2[1].y + s[2].z * t2[1].z + s[3].z * t2[1].w, s[0].w * t2[1].x + s[1].w * t2[1].y + s[2].w * t2[1].z + s[3].w * t2[1].w, s[0].x * t2[2].x + s[1].x * t2[2].y + s[2].x * t2[2].z + s[3].x * t2[2].w, s[0].y * t2[2].x + s[1].y * t2[2].y + s[2].y * t2[2].z + s[3].y * t2[2].w, s[0].z * t2[2].x + s[1].z * t2[2].y + s[2].z * t2[2].z + s[3].z * t2[2].w, s[0].w * t2[2].x + s[1].w * t2[2].y + s[2].w * t2[2].z + s[3].w * t2[2].w, s[0].x * t2[3].x + s[1].x * t2[3].y + s[2].x * t2[3].z + s[3].x * t2[3].w, s[0].y * t2[3].x + s[1].y * t2[3].y + s[2].y * t2[3].z + s[3].y * t2[3].w, s[0].z * t2[3].x + s[1].z * t2[3].y + s[2].z * t2[3].z + s[3].z * t2[3].w, s[0].w * t2[3].x + s[1].w * t2[3].y + s[2].w * t2[3].z + s[3].w * t2[3].w);
} }, mulMxV: { mat2x2f: (e10, n) => {
  let s = e10.columns;
  return H(s[0].x * n.x + s[1].x * n.y, s[0].y * n.x + s[1].y * n.y);
}, mat3x3f: (e10, n) => {
  let s = e10.columns;
  return X(s[0].x * n.x + s[1].x * n.y + s[2].x * n.z, s[0].y * n.x + s[1].y * n.y + s[2].y * n.z, s[0].z * n.x + s[1].z * n.y + s[2].z * n.z);
}, mat4x4f: (e10, n) => {
  let s = e10.columns;
  return Z(s[0].x * n.x + s[1].x * n.y + s[2].x * n.z + s[3].x * n.w, s[0].y * n.x + s[1].y * n.y + s[2].y * n.z + s[3].y * n.w, s[0].z * n.x + s[1].z * n.y + s[2].z * n.z + s[3].z * n.w, s[0].w * n.x + s[1].w * n.y + s[2].w * n.z + s[3].w * n.w);
} }, mulVxM: { mat2x2f: (e10, n) => {
  let s = n.columns;
  return H(e10.x * s[0].x + e10.y * s[0].y, e10.x * s[1].x + e10.y * s[1].y);
}, mat3x3f: (e10, n) => {
  let s = n.columns;
  return X(e10.x * s[0].x + e10.y * s[0].y + e10.z * s[0].z, e10.x * s[1].x + e10.y * s[1].y + e10.z * s[1].z, e10.x * s[2].x + e10.y * s[2].y + e10.z * s[2].z);
}, mat4x4f: (e10, n) => {
  let s = n.columns;
  return Z(e10.x * s[0].x + e10.y * s[0].y + e10.z * s[0].z + e10.w * s[0].w, e10.x * s[1].x + e10.y * s[1].y + e10.z * s[1].z + e10.w * s[1].w, e10.x * s[2].x + e10.y * s[2].y + e10.z * s[2].z + e10.w * s[2].w, e10.x * s[3].x + e10.y * s[3].y + e10.z * s[3].z + e10.w * s[3].w);
} }, div: { vec2f: F((e10, n) => e10 / n), vec2h: j2((e10, n) => e10 / n), vec2i: J2(d2.divInteger), vec2u: Q(d2.divInteger), vec3f: A((e10, n) => e10 / n), vec3h: P((e10, n) => e10 / n), vec3i: X2(d2.divInteger), vec3u: Y(d2.divInteger), vec4f: p2((e10, n) => e10 / n), vec4h: Z3((e10, n) => e10 / n), vec4i: ee(d2.divInteger), vec4u: ne(d2.divInteger) }, divMixed: { vec2f: (e10, n) => u3((s) => s / n)(e10), vec2h: (e10, n) => w2((s) => s / n)(e10), vec2i: (e10, n) => R((s) => d2.divInteger(s, n))(e10), vec2u: (e10, n) => K2((s) => d2.divInteger(s, n))(e10), vec3f: (e10, n) => y((s) => s / n)(e10), vec3h: (e10, n) => l2((s) => s / n)(e10), vec3i: (e10, n) => $((s) => d2.divInteger(s, n))(e10), vec3u: (e10, n) => k((s) => d2.divInteger(s, n))(e10), vec4f: (e10, n) => x2((s) => s / n)(e10), vec4h: (e10, n) => o2((s) => s / n)(e10), vec4i: (e10, n) => N((s) => d2.divInteger(s, n))(e10), vec4u: (e10, n) => O((s) => d2.divInteger(s, n))(e10) }, dot: { vec2f: ae, vec2h: ae, vec2i: ae, vec2u: ae, vec3f: re, vec3h: re, vec3i: re, vec3u: re, vec4f: ve2, vec4h: ve2, vec4i: ve2, vec4u: ve2 }, normalize: { vec2f: (e10) => {
  let n = S(e10);
  return H(e10.x / n, e10.y / n);
}, vec2h: (e10) => {
  let n = S(e10);
  return et(e10.x / n, e10.y / n);
}, vec2i: (e10) => {
  let n = S(e10);
  return tt(e10.x / n, e10.y / n);
}, vec2u: (e10) => {
  let n = S(e10);
  return nt(e10.x / n, e10.y / n);
}, vec3f: (e10) => {
  let n = D(e10);
  return X(e10.x / n, e10.y / n, e10.z / n);
}, vec3h: (e10) => {
  let n = D(e10);
  return st(e10.x / n, e10.y / n, e10.z / n);
}, vec3i: (e10) => {
  let n = D(e10);
  return it(e10.x / n, e10.y / n, e10.z / n);
}, vec3u: (e10) => {
  let n = D(e10);
  return at(e10.x / n, e10.y / n, e10.z / n);
}, vec4f: (e10) => {
  let n = E(e10);
  return Z(e10.x / n, e10.y / n, e10.z / n, e10.w / n);
}, vec4h: (e10) => {
  let n = E(e10);
  return ht(e10.x / n, e10.y / n, e10.z / n, e10.w / n);
}, vec4i: (e10) => {
  let n = E(e10);
  return ut(e10.x / n, e10.y / n, e10.z / n, e10.w / n);
}, vec4u: (e10) => {
  let n = E(e10);
  return yt(e10.x / n, e10.y / n, e10.z / n, e10.w / n);
} }, cross: { vec3f: (e10, n) => X(e10.y * n.z - e10.z * n.y, e10.z * n.x - e10.x * n.z, e10.x * n.y - e10.y * n.x), vec3h: (e10, n) => st(e10.y * n.z - e10.z * n.y, e10.z * n.x - e10.x * n.z, e10.x * n.y - e10.y * n.x) }, floor: { vec2f: u3(Math.floor), vec2h: w2(Math.floor), vec3f: y(Math.floor), vec3h: l2(Math.floor), vec4f: x2(Math.floor), vec4h: o2(Math.floor) }, max: { vec2f: F(Math.max), vec2h: j2(Math.max), vec2i: J2(Math.max), vec2u: Q(Math.max), vec3f: A(Math.max), vec3h: P(Math.max), vec3i: X2(Math.max), vec3u: Y(Math.max), vec4f: p2(Math.max), vec4h: Z3(Math.max), vec4i: ee(Math.max), vec4u: ne(Math.max) }, min: { vec2f: F(Math.min), vec2h: j2(Math.min), vec2i: J2(Math.min), vec2u: Q(Math.min), vec3f: A(Math.min), vec3h: P(Math.min), vec3i: X2(Math.min), vec3u: Y(Math.min), vec4f: p2(Math.min), vec4h: Z3(Math.min), vec4i: ee(Math.min), vec4u: ne(Math.min) }, pow: { vec2f: (e10, n) => H(e10.x ** n.x, e10.y ** n.y), vec2h: (e10, n) => et(e10.x ** n.x, e10.y ** n.y), vec3f: (e10, n) => X(e10.x ** n.x, e10.y ** n.y, e10.z ** n.z), vec3h: (e10, n) => st(e10.x ** n.x, e10.y ** n.y, e10.z ** n.z), vec4f: (e10, n) => Z(e10.x ** n.x, e10.y ** n.y, e10.z ** n.z, e10.w ** n.w), vec4h: (e10, n) => ht(e10.x ** n.x, e10.y ** n.y, e10.z ** n.z, e10.w ** n.w) }, sign: { vec2f: u3(Math.sign), vec2h: w2(Math.sign), vec2i: R(Math.sign), vec3f: y(Math.sign), vec3h: l2(Math.sign), vec3i: $(Math.sign), vec4f: x2(Math.sign), vec4h: o2(Math.sign), vec4i: N(Math.sign) }, sqrt: { vec2f: u3(Math.sqrt), vec2h: w2(Math.sqrt), vec3f: y(Math.sqrt), vec3h: l2(Math.sqrt), vec4f: x2(Math.sqrt), vec4h: o2(Math.sqrt) }, mix: { vec2f: (e10, n, s) => typeof s == "number" ? H(e10.x * (1 - s) + n.x * s, e10.y * (1 - s) + n.y * s) : H(e10.x * (1 - s.x) + n.x * s.x, e10.y * (1 - s.y) + n.y * s.y), vec2h: (e10, n, s) => typeof s == "number" ? et(e10.x * (1 - s) + n.x * s, e10.y * (1 - s) + n.y * s) : et(e10.x * (1 - s.x) + n.x * s.x, e10.y * (1 - s.y) + n.y * s.y), vec3f: (e10, n, s) => typeof s == "number" ? X(e10.x * (1 - s) + n.x * s, e10.y * (1 - s) + n.y * s, e10.z * (1 - s) + n.z * s) : X(e10.x * (1 - s.x) + n.x * s.x, e10.y * (1 - s.y) + n.y * s.y, e10.z * (1 - s.z) + n.z * s.z), vec3h: (e10, n, s) => typeof s == "number" ? st(e10.x * (1 - s) + n.x * s, e10.y * (1 - s) + n.y * s, e10.z * (1 - s) + n.z * s) : st(e10.x * (1 - s.x) + n.x * s.x, e10.y * (1 - s.y) + n.y * s.y, e10.z * (1 - s.z) + n.z * s.z), vec4f: (e10, n, s) => typeof s == "number" ? Z(e10.x * (1 - s) + n.x * s, e10.y * (1 - s) + n.y * s, e10.z * (1 - s) + n.z * s, e10.w * (1 - s) + n.w * s) : Z(e10.x * (1 - s.x) + n.x * s.x, e10.y * (1 - s.y) + n.y * s.y, e10.z * (1 - s.z) + n.z * s.z, e10.w * (1 - s.w) + n.w * s.w), vec4h: (e10, n, s) => typeof s == "number" ? ht(e10.x * (1 - s) + n.x * s, e10.y * (1 - s) + n.y * s, e10.z * (1 - s) + n.z * s, e10.w * (1 - s) + n.w * s) : ht(e10.x * (1 - s.x) + n.x * s.x, e10.y * (1 - s.y) + n.y * s.y, e10.z * (1 - s.z) + n.z * s.z, e10.w * (1 - s.w) + n.w * s.w) }, sin: { vec2f: u3(Math.sin), vec2h: w2(Math.sin), vec3f: y(Math.sin), vec3h: l2(Math.sin), vec4f: x2(Math.sin), vec4h: o2(Math.sin) }, cos: { vec2f: u3(Math.cos), vec2h: w2(Math.cos), vec3f: y(Math.cos), vec3h: l2(Math.cos), vec4f: x2(Math.cos), vec4h: o2(Math.cos) }, cosh: { vec2f: u3(Math.cosh), vec2h: w2(Math.cosh), vec3f: y(Math.cosh), vec3h: l2(Math.cosh), vec4f: x2(Math.cosh), vec4h: o2(Math.cosh) }, exp: { vec2f: u3(Math.exp), vec2h: w2(Math.exp), vec3f: y(Math.exp), vec3h: l2(Math.exp), vec4f: x2(Math.exp), vec4h: o2(Math.exp) }, exp2: { vec2f: u3((e10) => 2 ** e10), vec2h: w2((e10) => 2 ** e10), vec3f: y((e10) => 2 ** e10), vec3h: l2((e10) => 2 ** e10), vec4f: x2((e10) => 2 ** e10), vec4h: o2((e10) => 2 ** e10) }, log: { vec2f: u3(Math.log), vec2h: w2(Math.log), vec3f: y(Math.log), vec3h: l2(Math.log), vec4f: x2(Math.log), vec4h: o2(Math.log) }, log2: { vec2f: u3(Math.log2), vec2h: w2(Math.log2), vec3f: y(Math.log2), vec3h: l2(Math.log2), vec4f: x2(Math.log2), vec4h: o2(Math.log2) }, fract: { vec2f: u3((e10) => e10 - Math.floor(e10)), vec2h: w2((e10) => e10 - Math.floor(e10)), vec3f: y((e10) => e10 - Math.floor(e10)), vec3h: l2((e10) => e10 - Math.floor(e10)), vec4f: x2((e10) => e10 - Math.floor(e10)), vec4h: o2((e10) => e10 - Math.floor(e10)) }, isCloseToZero: { vec2f: (e10, n) => Math.abs(e10.x) <= n && Math.abs(e10.y) <= n, vec2h: (e10, n) => Math.abs(e10.x) <= n && Math.abs(e10.y) <= n, vec3f: (e10, n) => Math.abs(e10.x) <= n && Math.abs(e10.y) <= n && Math.abs(e10.z) <= n, vec3h: (e10, n) => Math.abs(e10.x) <= n && Math.abs(e10.y) <= n && Math.abs(e10.z) <= n, vec4f: (e10, n) => Math.abs(e10.x) <= n && Math.abs(e10.y) <= n && Math.abs(e10.z) <= n && Math.abs(e10.w) <= n, vec4h: (e10, n) => Math.abs(e10.x) <= n && Math.abs(e10.y) <= n && Math.abs(e10.z) <= n && Math.abs(e10.w) <= n }, neg: { vec2f: u3((e10) => -e10), vec2h: w2((e10) => -e10), vec2i: R((e10) => -e10), vec2u: K2((e10) => -e10), "vec2<bool>": (e10) => rt(!e10.x, !e10.y), vec3f: y((e10) => -e10), vec3h: l2((e10) => -e10), vec3i: $((e10) => -e10), vec3u: k((e10) => -e10), "vec3<bool>": (e10) => ot(!e10.x, !e10.y, !e10.z), vec4f: x2((e10) => -e10), vec4h: o2((e10) => -e10), vec4i: N((e10) => -e10), vec4u: O((e10) => -e10), "vec4<bool>": (e10) => ct(!e10.x, !e10.y, !e10.z, !e10.w) }, select: { vec2f: (e10, n, s) => H(s.x ? n.x : e10.x, s.y ? n.y : e10.y), vec2h: (e10, n, s) => et(s.x ? n.x : e10.x, s.y ? n.y : e10.y), vec2i: (e10, n, s) => tt(s.x ? n.x : e10.x, s.y ? n.y : e10.y), vec2u: (e10, n, s) => nt(s.x ? n.x : e10.x, s.y ? n.y : e10.y), "vec2<bool>": (e10, n, s) => rt(s.x ? n.x : e10.x, s.y ? n.y : e10.y), vec3f: (e10, n, s) => X(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z), vec3h: (e10, n, s) => st(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z), vec3i: (e10, n, s) => it(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z), vec3u: (e10, n, s) => at(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z), "vec3<bool>": (e10, n, s) => ot(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z), vec4f: (e10, n, s) => Z(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z, s.w ? n.w : e10.w), vec4h: (e10, n, s) => ht(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z, s.w ? n.w : e10.w), vec4i: (e10, n, s) => ut(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z, s.w ? n.w : e10.w), vec4u: (e10, n, s) => yt(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z, s.w ? n.w : e10.w), "vec4<bool>": (e10, n, s) => ct(s.x ? n.x : e10.x, s.y ? n.y : e10.y, s.z ? n.z : e10.z, s.w ? n.w : e10.w) }, tanh: { vec2f: u3(Math.tanh), vec2h: w2(Math.tanh), vec3f: y(Math.tanh), vec3h: l2(Math.tanh), vec4f: x2(Math.tanh), vec4h: o2(Math.tanh) } };
function G2(e10) {
  return de2(e10.dataType);
}
function de2(e10) {
  let n = e10?.type;
  return !!e10?.[r] && (n === "abstractInt" || n === "abstractFloat" || n === "f32" || n === "f16" || n === "i32" || n === "u32");
}
function oe2(e10, n) {
  if (typeof e10 == "number" && typeof n == "number") return e10 + n;
  if (typeof e10 == "number" && De(n)) return c2.addMixed[n.kind](n, e10);
  if (De(e10) && typeof n == "number") return c2.addMixed[e10.kind](e10, n);
  if (De(e10) && De(n) || Lt(e10) && Lt(n)) return c2.add[e10.kind](e10, n);
  throw new Error("Add/Sub called with invalid arguments.");
}
var ke = o(oe2, (e10, n) => u(`(${e10.value} + ${n.value})`, G2(e10) ? n.dataType : e10.dataType), "coerce");
function Te2(e10, n) {
  return oe2(e10, me(-1, n));
}
var ie2 = o(Te2, (e10, n) => u(`(${e10.value} - ${n.value})`, G2(e10) ? n.dataType : e10.dataType), "sub", "coerce");
function be2(e10, n) {
  if (typeof e10 == "number" && typeof n == "number") return e10 * n;
  if (typeof e10 == "number" && (De(n) || Lt(n))) return c2.mulSxV[n.kind](e10, n);
  if ((De(e10) || Lt(e10)) && typeof n == "number") return c2.mulSxV[e10.kind](n, e10);
  if (De(e10) && De(n)) return c2.mulVxV[e10.kind](e10, n);
  if (Ot(e10) && Lt(n)) return c2.mulVxM[n.kind](e10, n);
  if (Lt(e10) && Ot(n)) return c2.mulMxV[e10.kind](e10, n);
  if (Lt(e10) && Lt(n)) return c2.mulVxV[e10.kind](e10, n);
  throw new Error("Mul called with invalid arguments.");
}
var me = o(be2, (e10, n) => {
  let s = G2(e10) ? n.dataType : G2(n) || e10.dataType.type.startsWith("vec") ? e10.dataType : n.dataType.type.startsWith("vec") ? n.dataType : e10.dataType;
  return u(`(${e10.value} * ${n.value})`, s);
}, "mul");
function Me3(e10, n) {
  if (typeof e10 == "number" && typeof n == "number") return e10 / n;
  if (typeof e10 == "number" && De(n)) return c2.divMixed[n.kind](n, e10);
  if (De(e10) && typeof n == "number") return c2.divMixed[e10.kind](e10, n);
  if (De(e10) && De(n)) return c2.div[e10.kind](e10, n);
  throw new Error("Div called with invalid arguments.");
}
var Oe = o(Me3, (e10, n) => G2(e10) && G2(n) ? u(`(f32(${e10.value}) / ${n.value})`, p) : u(`(${e10.value} / ${n.value})`, e10.dataType), "div");
var Le = o((e10) => typeof e10 == "number" ? Math.abs(e10) : c2.abs[e10.kind](e10), (e10) => u(`abs(${e10.value})`, e10.dataType), "abs");
var _e = o((e10, n) => typeof e10 == "number" && typeof n == "number" ? Math.atan2(e10, n) : c2.atan2[e10.kind](e10, n), (e10, n) => u(`atan2(${e10.value}, ${n.value})`, e10.dataType), "atan2");
var Ue = o((e10) => typeof e10 == "number" ? Math.acos(e10) : c2.acos[e10.kind](e10), (e10) => u(`acos(${e10.value})`, e10.dataType), "acos");
var We = o((e10) => typeof e10 == "number" ? Math.acosh(e10) : c2.acosh[e10.kind](e10), (e10) => u(`acosh(${e10.value})`, e10.dataType), "acosh");
var qe = o((e10) => typeof e10 == "number" ? Math.asin(e10) : c2.asin[e10.kind](e10), (e10) => u(`asin(${e10.value})`, e10.dataType), "asin");
var Ce2 = o((e10) => typeof e10 == "number" ? Math.ceil(e10) : c2.ceil[e10.kind](e10), (e10) => u(`ceil(${e10.value})`, e10.dataType), "ceil");
var Se = o((e10, n, s) => typeof e10 == "number" ? Math.min(Math.max(n, e10), s) : c2.clamp[e10.kind](e10, n, s), (e10, n, s) => u(`clamp(${e10.value}, ${n.value}, ${s.value})`, e10.dataType), "clamp");
var De2 = o((e10) => typeof e10 == "number" ? Math.cos(e10) : c2.cos[e10.kind](e10), (e10) => u(`cos(${e10.value})`, e10.dataType), "cos");
var Ee2 = o((e10) => typeof e10 == "number" ? Math.cosh(e10) : c2.cosh[e10.kind](e10), (e10) => u(`cosh(${e10.value})`, e10.dataType), "cosh");
var je2 = o((e10, n) => c2.cross[e10.kind](e10, n), (e10, n) => u(`cross(${e10.value}, ${n.value})`, e10.dataType), "cross");
var ze = o((e10, n) => c2.dot[e10.kind](e10, n), (e10, n) => u(`dot(${e10.value}, ${n.value})`, p), "dot");
var Pe2 = o((e10) => c2.normalize[e10.kind](e10), (e10) => u(`normalize(${e10.value})`, e10.dataType), "normalize");
var Ze = o((e10) => typeof e10 == "number" ? Math.floor(e10) : c2.floor[e10.kind](e10), (e10) => u(`floor(${e10.value})`, e10.dataType), "floor");
var Ge = o((e10) => typeof e10 == "number" ? e10 - Math.floor(e10) : c2.fract[e10.kind](e10), (e10) => u(`fract(${e10.value})`, e10.dataType), "fract");
var pe = o((e10) => typeof e10 == "number" ? Math.abs(e10) : c2.length[e10.kind](e10), (e10) => u(`length(${e10.value})`, p), "length");
var He = o((e10) => typeof e10 == "number" ? Math.log(e10) : c2.log[e10.kind](e10), (e10) => u(`log(${e10.value})`, e10.dataType), "log");
var Je = o((e10) => typeof e10 == "number" ? Math.log2(e10) : c2.log2[e10.kind](e10), (e10) => u(`log2(${e10.value})`, e10.dataType), "log2");
var Qe = o((e10, n) => typeof e10 == "number" ? Math.max(e10, n) : c2.max[e10.kind](e10, n), (e10, n) => u(`max(${e10.value}, ${n.value})`, e10.dataType), "max", "coerce");
var Xe = o((e10, n) => typeof e10 == "number" ? Math.min(e10, n) : c2.min[e10.kind](e10, n), (e10, n) => u(`min(${e10.value}, ${n.value})`, e10.dataType), "min", "coerce");
var Ye = o((e10) => typeof e10 == "number" ? Math.sign(e10) : c2.sign[e10.kind](e10), (e10) => u(`sign(${e10.value})`, e10.dataType), "sign");
var en = o((e10) => typeof e10 == "number" ? Math.sin(e10) : c2.sin[e10.kind](e10), (e10) => u(`sin(${e10.value})`, e10.dataType), "sin");
var nn2 = o((e10) => typeof e10 == "number" ? Math.exp(e10) : c2.exp[e10.kind](e10), (e10) => u(`exp(${e10.value})`, e10.dataType), "exp");
var sn2 = o((e10) => typeof e10 == "number" ? 2 ** e10 : c2.exp2[e10.kind](e10), (e10) => u(`exp2(${e10.value})`, e10.dataType), "exp2");
var tn = o((e10, n) => {
  if (typeof e10 == "number" && typeof n == "number") return e10 ** n;
  if (typeof e10 == "object" && typeof n == "object" && "kind" in e10 && "kind" in n) return c2.pow[e10.kind](e10, n);
  throw new Error("Invalid arguments to pow()");
}, (e10, n) => u(`pow(${e10.value}, ${n.value})`, e10.dataType), "pow");
var cn2 = o((e10, n, s) => {
  if (typeof e10 == "number") {
    if (typeof s != "number" || typeof n != "number") throw new Error("When e1 and e2 are numbers, the blend factor must be a number.");
    return e10 * (1 - s) + n * s;
  }
  if (typeof e10 == "number" || typeof n == "number") throw new Error("e1 and e2 need to both be vectors of the same kind.");
  return c2.mix[e10.kind](e10, n, s);
}, (e10, n, s) => u(`mix(${e10.value}, ${n.value}, ${s.value})`, e10.dataType), "mix");
var an = o((e10, n) => ie2(e10, me(2 * ze(n, e10), n)), (e10, n) => u(`reflect(${e10.value}, ${n.value})`, e10.dataType), "reflect");
var rn2 = o((e10, n) => typeof e10 == "number" && typeof n == "number" ? Math.abs(e10 - n) : pe(ie2(e10, n)), (e10, n) => u(`distance(${e10.value}, ${n.value})`, p), "distance");
var vn = o((e10) => typeof e10 == "number" ? -e10 : c2.neg[e10.kind](e10), (e10) => u(`-(${e10.value})`, e10.dataType), "neg");
var xn = o((e10) => typeof e10 == "number" ? Math.sqrt(e10) : c2.sqrt[e10.kind](e10), (e10) => u(`sqrt(${e10.value})`, e10.dataType), "sqrt");
var yn2 = o((e10) => typeof e10 == "number" ? Math.tanh(e10) : c2.tanh[e10.kind](e10), (e10) => u(`tanh(${e10.value})`, e10.dataType), "tanh");

// node_modules/tinyest/index.js
var tinyest_exports = {};
__export(tinyest_exports, {
  FORMAT_VERSION: () => o3,
  FuncParameterType: () => t,
  NodeTypeCatalog: () => e
});
var e = { block: 0, binaryExpr: 1, assignmentExpr: 2, logicalExpr: 3, unaryExpr: 4, numericLiteral: 5, call: 6, memberAccess: 7, indexAccess: 8, return: 10, if: 11, let: 12, const: 13, for: 14, while: 15, continue: 16, break: 17, arrayExpr: 100, preUpdate: 101, postUpdate: 102, stringLiteral: 103, objectExpr: 104 };
var t = { identifier: "i", destructuredObject: "d" };
var o3 = 1;

// node_modules/typed-binary/dist/index.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var main_api_exports = {};
__export2(main_api_exports, {
  BufferReader: () => BufferReader,
  BufferWriter: () => BufferWriter,
  MaxValue: () => MaxValue,
  Measurer: () => Measurer,
  UnresolvedReferenceError: () => UnresolvedReferenceError,
  ValidationError: () => ValidationError,
  arrayOf: () => arrayOf,
  bool: () => bool,
  byte: () => byte,
  chars: () => chars,
  concat: () => concat,
  dynamicArrayOf: () => dynamicArrayOf,
  f16: () => f16,
  f32: () => f32,
  f32Array: () => f32Array,
  f64Array: () => f64Array,
  generic: () => generic,
  genericEnum: () => genericEnum,
  i16: () => i16,
  i16Array: () => i16Array,
  i32: () => i32,
  i32Array: () => i32Array,
  i8: () => i8,
  i8Array: () => i8Array,
  keyed: () => keyed,
  object: () => object,
  optional: () => optional,
  string: () => string,
  tupleOf: () => tupleOf,
  u16: () => u16,
  u16Array: () => u16Array,
  u32: () => u32,
  u32Array: () => u32Array,
  u8: () => u8,
  u8Array: () => u8Array,
  u8ClampedArray: () => u8ClampedArray
});
var UnresolvedReferenceError = class _UnresolvedReferenceError extends Error {
  constructor(msg) {
    super(msg);
    Object.setPrototypeOf(this, _UnresolvedReferenceError.prototype);
  }
};
var ValidationError = class _ValidationError extends Error {
  constructor(msg) {
    super(msg);
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
};
var UnboundedMeasurer = class {
  constructor() {
    __publicField(this, "size", Number.NaN);
    __publicField(this, "unbounded", this);
    __publicField(this, "isUnbounded", true);
  }
  add() {
    return this;
  }
  fork() {
    return this;
  }
};
var unboundedMeasurer = new UnboundedMeasurer();
var Measurer = class _Measurer {
  constructor() {
    __publicField(this, "size", 0);
    __publicField(this, "unbounded", unboundedMeasurer);
    __publicField(this, "isUnbounded", false);
  }
  add(bytes) {
    this.size += bytes;
    return this;
  }
  fork() {
    const forked = new _Measurer();
    forked.size = this.size;
    return forked;
  }
};
var MaxValue = Symbol(
  "The biggest (in amount of bytes needed) value a schema can represent"
);
var Schema = class {
  constructor() {
    __publicField(this, "__unwrapped");
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  resolveReferences(ctx) {
  }
  seekProperty(_reference, _prop) {
    return null;
  }
};
var Ref = class {
  constructor(key) {
    this.key = key;
  }
};
var SubTypeKey = {
  STRING: "string",
  ENUM: "enum"
};
var ArraySchema = class extends Schema {
  constructor(_unstableElementSchema, length) {
    super();
    this._unstableElementSchema = _unstableElementSchema;
    this.length = length;
    __publicField(this, "elementSchema");
    this.elementSchema = _unstableElementSchema;
  }
  resolveReferences(ctx) {
    this.elementSchema = ctx.resolve(this._unstableElementSchema);
  }
  write(output, values) {
    if (values.length !== this.length) {
      throw new ValidationError(
        `Expected array of length ${this.length}, got ${values.length}`
      );
    }
    for (const value of values) {
      this.elementSchema.write(output, value);
    }
  }
  read(input) {
    const array = [];
    for (let i = 0; i < this.length; ++i) {
      array.push(this.elementSchema.read(input));
    }
    return array;
  }
  /**
   * Returns the maximum number of bytes this schema can take up.
   *
   * Returns `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.elementSchema.measure(MaxValue).size * this.length;
  }
  measure(values, measurer = new Measurer()) {
    for (let i = 0; i < this.length; ++i) {
      this.elementSchema.measure(
        values === MaxValue ? MaxValue : values[i],
        measurer
      );
    }
    return measurer;
  }
};
function arrayOf(elementSchema, length) {
  return new ArraySchema(elementSchema, length);
}
var BoolSchema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 1);
  }
  read(input) {
    return input.readBool();
  }
  write(output, value) {
    output.writeBool(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(1);
  }
};
var bool = new BoolSchema();
var _StringSchema = class _StringSchema2 extends Schema {
  static get _encoder() {
    if (!_StringSchema2._cachedEncoder) {
      _StringSchema2._cachedEncoder = new TextEncoder();
    }
    return _StringSchema2._cachedEncoder;
  }
  read(input) {
    return input.readString();
  }
  write(output, value) {
    output.writeString(value);
  }
  measure(value, measurer = new Measurer()) {
    if (value === MaxValue) {
      return measurer.unbounded;
    }
    const encoded = _StringSchema2._encoder.encode(value);
    return measurer.add(encoded.byteLength + 1);
  }
};
__publicField(_StringSchema, "_cachedEncoder");
var StringSchema = _StringSchema;
var string = new StringSchema();
var Int8Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 1);
  }
  read(input) {
    return input.readInt8();
  }
  write(output, value) {
    output.writeInt8(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(1);
  }
};
var i8 = new Int8Schema();
var Uint8Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 1);
  }
  read(input) {
    return input.readUint8();
  }
  write(output, value) {
    output.writeUint8(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(1);
  }
};
var u8 = new Uint8Schema();
var byte = u8;
var Int16Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 2);
  }
  read(input) {
    return input.readInt16();
  }
  write(output, value) {
    output.writeInt16(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(2);
  }
};
var i16 = new Int16Schema();
var Uint16Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 2);
  }
  read(input) {
    return input.readUint16();
  }
  write(output, value) {
    output.writeUint16(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(2);
  }
};
var u16 = new Uint16Schema();
var Int32Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 4);
  }
  read(input) {
    return input.readInt32();
  }
  write(output, value) {
    output.writeInt32(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(4);
  }
};
var i32 = new Int32Schema();
var Uint32Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 4);
  }
  read(input) {
    return input.readUint32();
  }
  write(output, value) {
    output.writeUint32(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(4);
  }
};
var u32 = new Uint32Schema();
var Float16Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 2);
  }
  read(input) {
    return input.readFloat16();
  }
  write(output, value) {
    output.writeFloat16(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(2);
  }
};
var f16 = new Float16Schema();
var Float32Schema = class extends Schema {
  constructor() {
    super(...arguments);
    __publicField(this, "maxSize", 4);
  }
  read(input) {
    return input.readFloat32();
  }
  write(output, value) {
    output.writeFloat32(value);
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(4);
  }
};
var f32 = new Float32Schema();
var CharsSchema = class extends Schema {
  constructor(length) {
    super();
    this.length = length;
  }
  write(output, value) {
    if (value.length !== this.length) {
      throw new ValidationError(
        `Expected char-string of length ${this.length}, got ${value.length}`
      );
    }
    for (let i = 0; i < value.length; ++i) {
      output.writeUint8(value.charCodeAt(i));
    }
  }
  read(input) {
    let content = "";
    for (let i = 0; i < this.length; ++i) {
      content += String.fromCharCode(input.readByte());
    }
    return content;
  }
  measure(_, measurer = new Measurer()) {
    return measurer.add(this.length);
  }
};
function chars(length) {
  return new CharsSchema(length);
}
function exactEntries(record) {
  return Object.entries(record);
}
function resolveMap(ctx, refs) {
  const props = {};
  for (const [key, ref] of exactEntries(refs)) {
    props[key] = ctx.resolve(ref);
  }
  return props;
}
var ObjectSchema = class extends Schema {
  constructor(_properties) {
    super();
    this._properties = _properties;
    __publicField(this, "properties");
    this.properties = _properties;
  }
  resolveReferences(ctx) {
    this.properties = resolveMap(ctx, this._properties);
  }
  write(output, value) {
    for (const [key, property] of exactEntries(this.properties)) {
      property.write(output, value[key]);
    }
  }
  read(input) {
    const result = {};
    for (const [key, property] of exactEntries(this.properties)) {
      result[key] = property.read(input);
    }
    return result;
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    const measurer = new Measurer();
    for (const property of Object.values(this.properties)) {
      property.measure(MaxValue, measurer);
    }
    return measurer.size;
  }
  measure(value, measurer = new Measurer()) {
    for (const [key, property] of exactEntries(this.properties)) {
      property.measure(
        value === MaxValue ? MaxValue : value[key],
        measurer
      );
    }
    return measurer;
  }
  seekProperty(reference, prop) {
    let bufferOffset = 0;
    for (const [key, property] of exactEntries(this.properties)) {
      if (key === prop) {
        return {
          bufferOffset,
          schema: property
        };
      }
      bufferOffset += property.measure(reference).size;
    }
    return null;
  }
};
function object(properties) {
  return new ObjectSchema(properties);
}
var GenericObjectSchema = class extends Schema {
  constructor(keyedBy, properties, _subTypeMap) {
    super();
    this.keyedBy = keyedBy;
    this._subTypeMap = _subTypeMap;
    __publicField(this, "_baseObject");
    __publicField(this, "subTypeMap");
    this._baseObject = new ObjectSchema(properties);
    this.subTypeMap = _subTypeMap;
  }
  resolveReferences(ctx) {
    this._baseObject.resolveReferences(ctx);
    this.subTypeMap = resolveMap(ctx, this._subTypeMap);
  }
  write(output, value) {
    const subTypeKey = value.type;
    const subTypeDescription = this.subTypeMap[subTypeKey] || null;
    if (subTypeDescription === null) {
      throw new Error(
        `Unknown sub-type '${subTypeKey.toString()}' in among '${JSON.stringify(
          Object.keys(this.subTypeMap)
        )}'`
      );
    }
    if (this.keyedBy === SubTypeKey.ENUM) {
      output.writeUint8(value.type);
    } else {
      output.writeString(value.type);
    }
    this._baseObject.write(output, value);
    for (const [key, extraProp] of exactEntries(
      subTypeDescription.properties
    )) {
      extraProp.write(output, value[key]);
    }
  }
  read(input) {
    const subTypeKey = this.keyedBy === SubTypeKey.ENUM ? input.readByte() : input.readString();
    const subTypeDescription = this.subTypeMap[subTypeKey] || null;
    if (subTypeDescription === null) {
      throw new Error(
        `Unknown sub-type '${subTypeKey}' in among '${JSON.stringify(
          Object.keys(this.subTypeMap)
        )}'`
      );
    }
    const result = this._baseObject.read(input);
    result.type = subTypeKey;
    if (subTypeDescription !== null) {
      for (const [key, extraProp] of exactEntries(
        subTypeDescription.properties
      )) {
        result[key] = extraProp.read(input);
      }
    }
    return result;
  }
  measure(value, measurer = new Measurer()) {
    this._baseObject.measure(
      value,
      measurer
    );
    if (this.keyedBy === SubTypeKey.ENUM) {
      measurer.add(1);
    } else if (value !== MaxValue) {
      measurer.add(value.type.length + 1);
    } else {
      return measurer.unbounded;
    }
    if (value === MaxValue) {
      const biggestSubType = Object.values(this.subTypeMap).map((subType) => {
        const forkedMeasurer = measurer.fork();
        for (const prop of Object.values(subType.properties)) {
          prop.measure(MaxValue, forkedMeasurer);
        }
        return [subType, forkedMeasurer.size];
      }).reduce((a, b2) => a[1] > b2[1] ? a : b2)[0];
      for (const prop of Object.values(biggestSubType.properties)) {
        prop.measure(MaxValue, measurer);
      }
    } else {
      const subTypeKey = value.type;
      const subTypeDescription = this.subTypeMap[subTypeKey] || null;
      if (subTypeDescription === null) {
        throw new Error(
          `Unknown sub-type '${subTypeKey.toString()}', expected one of '${JSON.stringify(
            Object.keys(this.subTypeMap)
          )}'`
        );
      }
      for (const [key, prop] of exactEntries(subTypeDescription.properties)) {
        prop.measure(value[key], measurer);
      }
    }
    return measurer;
  }
};
function generic(properties, subTypeMap) {
  return new GenericObjectSchema(SubTypeKey.STRING, properties, subTypeMap);
}
function genericEnum(properties, subTypeMap) {
  return new GenericObjectSchema(SubTypeKey.ENUM, properties, subTypeMap);
}
function concat(objs) {
  return new ObjectSchema(
    Object.fromEntries(
      objs.flatMap(({ properties }) => Object.entries(properties))
    )
  );
}
var DynamicArraySchema = class extends Schema {
  constructor(_unstableElementType) {
    super();
    this._unstableElementType = _unstableElementType;
    __publicField(this, "elementType");
    this.elementType = _unstableElementType;
  }
  resolveReferences(ctx) {
    this.elementType = ctx.resolve(this._unstableElementType);
  }
  write(output, values) {
    output.writeUint32(values.length);
    for (const value of values) {
      this.elementType.write(output, value);
    }
  }
  read(input) {
    const array = [];
    const len = input.readUint32();
    for (let i = 0; i < len; ++i) {
      array.push(this.elementType.read(input));
    }
    return array;
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.measure(MaxValue).size;
  }
  measure(values, measurer = new Measurer()) {
    if (values === MaxValue) {
      return measurer.unbounded;
    }
    measurer.add(4);
    for (const value of values) {
      this.elementType.measure(value, measurer);
    }
    return measurer;
  }
  seekProperty(reference, prop) {
    if (typeof prop === "symbol") {
      return null;
    }
    const indexProp = Number.parseInt(String(prop), 10);
    if (Number.isNaN(indexProp)) {
      return null;
    }
    if (reference === MaxValue) {
      return {
        bufferOffset: this.elementType.measure(MaxValue).size * indexProp,
        schema: this.elementType
      };
    }
    if (indexProp >= reference.length) {
      return null;
    }
    const measurer = new Measurer();
    for (let i = 0; i < indexProp; ++i) {
      this.elementType.measure(reference[i], measurer);
    }
    return {
      bufferOffset: measurer.size,
      schema: this.elementType
    };
  }
};
function dynamicArrayOf(elementSchema) {
  return new DynamicArraySchema(elementSchema);
}
var RefSchema = class {
  constructor(key) {
    __publicField(this, "__unwrapped");
    __publicField(this, "ref");
    this.ref = new Ref(key);
  }
  resolveReferences() {
    throw new UnresolvedReferenceError(
      "Tried to resolve a reference directly. Do it through a RefResolver instead."
    );
  }
  read() {
    throw new UnresolvedReferenceError(
      "Tried to read a reference directly. Resolve it instead."
    );
  }
  write() {
    throw new UnresolvedReferenceError(
      "Tried to write a reference directly. Resolve it instead."
    );
  }
  measure() {
    throw new UnresolvedReferenceError(
      "Tried to measure size of a reference directly. Resolve it instead."
    );
  }
  seekProperty() {
    throw new UnresolvedReferenceError(
      "Tried to seek property of a reference directly. Resolve it instead."
    );
  }
};
var RefResolve = class {
  constructor() {
    __publicField(this, "registry", {});
  }
  hasKey(key) {
    return this.registry[key] !== void 0;
  }
  register(key, schema) {
    this.registry[key] = schema;
  }
  resolve(unstableSchema) {
    if (unstableSchema instanceof RefSchema) {
      const ref = unstableSchema.ref;
      const key = ref.key;
      if (this.registry[key] !== void 0) {
        return this.registry[key];
      }
      throw new UnresolvedReferenceError(
        `Couldn't resolve reference to ${key}. Unknown key.`
      );
    }
    unstableSchema.resolveReferences(this);
    return unstableSchema;
  }
};
var KeyedSchema = class {
  constructor(key, innerResolver) {
    this.key = key;
    __publicField(this, "__unwrapped");
    __publicField(this, "__keyDefinition");
    __publicField(this, "innerType");
    this.innerType = innerResolver(new RefSchema(key));
    this.resolveReferences(new RefResolve());
  }
  resolveReferences(ctx) {
    if (!ctx.hasKey(this.key)) {
      ctx.register(this.key, this.innerType);
      this.innerType.resolveReferences(ctx);
    }
  }
  read(input) {
    return this.innerType.read(input);
  }
  write(output, value) {
    this.innerType.write(output, value);
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.measure(MaxValue).size;
  }
  measure(value, measurer = new Measurer()) {
    return this.innerType.measure(value, measurer);
  }
  seekProperty(reference, prop) {
    return this.innerType.seekProperty(reference, prop);
  }
};
function keyed(key, inner) {
  return new KeyedSchema(key, inner);
}
var OptionalSchema = class extends Schema {
  constructor(_innerUnstableSchema) {
    super();
    this._innerUnstableSchema = _innerUnstableSchema;
    __publicField(this, "innerSchema");
    this.innerSchema = _innerUnstableSchema;
  }
  resolveReferences(ctx) {
    this.innerSchema = ctx.resolve(this._innerUnstableSchema);
  }
  write(output, value) {
    if (value !== void 0 && value !== null) {
      output.writeBool(true);
      this.innerSchema.write(output, value);
    } else {
      output.writeBool(false);
    }
  }
  read(input) {
    const valueExists = input.readBool();
    if (valueExists) {
      return this.innerSchema.read(input);
    }
    return void 0;
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.measure(MaxValue).size;
  }
  measure(value, measurer = new Measurer()) {
    if (value !== void 0) {
      this.innerSchema.measure(value, measurer);
    }
    return measurer.add(1);
  }
};
function optional(innerType) {
  return new OptionalSchema(innerType);
}
function resolveArray(ctx, refs) {
  return refs.map((ref) => ctx.resolve(ref));
}
var TupleSchema = class extends Schema {
  constructor(_unstableSchemas) {
    super();
    this._unstableSchemas = _unstableSchemas;
    __publicField(this, "schemas");
    this.schemas = _unstableSchemas;
  }
  resolveReferences(ctx) {
    this.schemas = resolveArray(ctx, this._unstableSchemas);
  }
  write(output, values) {
    if (values.length !== this.schemas.length) {
      throw new ValidationError(
        `Expected tuple of length ${this.schemas.length}, got ${values.length}`
      );
    }
    for (let i = 0; i < this.schemas.length; ++i) {
      this.schemas[i].write(output, values[i]);
    }
  }
  read(input) {
    const array = [];
    for (let i = 0; i < this.schemas.length; ++i) {
      array.push(
        this.schemas[i].read(input)
      );
    }
    return array;
  }
  /**
   * The maximum number of bytes this schema can take up.
   *
   * Is `NaN` if the schema is unbounded. If you would like to know
   * how many bytes a particular value encoding will take up, use `.measure(value)`.
   *
   * Alias for `.measure(MaxValue).size`
   */
  get maxSize() {
    return this.measure(MaxValue).size;
  }
  measure(values, measurer = new Measurer()) {
    for (let i = 0; i < this.schemas.length; ++i) {
      this.schemas[i].measure(
        values === MaxValue ? MaxValue : values[i],
        measurer
      );
    }
    return measurer;
  }
};
function tupleOf(schemas) {
  return new TupleSchema(schemas);
}
var TypedArraySchema = class extends Schema {
  constructor(length, _arrayConstructor) {
    super();
    this.length = length;
    this._arrayConstructor = _arrayConstructor;
    __publicField(this, "byteLength");
    this.byteLength = length * _arrayConstructor.BYTES_PER_ELEMENT;
  }
  write(output, value) {
    output.writeSlice(value);
  }
  read(input) {
    const buffer = new ArrayBuffer(this.byteLength);
    const view = new this._arrayConstructor(buffer, 0, this.length);
    input.readSlice(view, 0, this.byteLength);
    return view;
  }
  measure(_value, measurer = new Measurer()) {
    return measurer.add(this.byteLength);
  }
};
var u8Array = (length) => new TypedArraySchema(length, Uint8Array);
var u8ClampedArray = (length) => new TypedArraySchema(length, Uint8ClampedArray);
var u16Array = (length) => new TypedArraySchema(length, Uint16Array);
var u32Array = (length) => new TypedArraySchema(length, Uint32Array);
var i8Array = (length) => new TypedArraySchema(length, Int8Array);
var i16Array = (length) => new TypedArraySchema(length, Int16Array);
var i32Array = (length) => new TypedArraySchema(length, Int32Array);
var f32Array = (length) => new TypedArraySchema(length, Float32Array);
var f64Array = (length) => new TypedArraySchema(length, Float64Array);
function isSystemBigEndian() {
  const array = new Uint8Array(4);
  const view = new Uint32Array(array.buffer);
  view[0] = 1;
  return array[0] === 0;
}
function getSystemEndianness() {
  return isSystemBigEndian() ? "big" : "little";
}
function unwrapBuffer(buffer) {
  let byteOffset = 0;
  let innerBuffer = buffer;
  if (!!innerBuffer && "buffer" in innerBuffer && "byteOffset" in innerBuffer) {
    byteOffset += innerBuffer.byteOffset;
    innerBuffer = innerBuffer.buffer;
  }
  return { buffer: innerBuffer, byteOffset, byteLength: buffer.byteLength };
}
var BufferIOBase = class {
  constructor(buffer, options) {
    __publicField(this, "dataView");
    __publicField(this, "littleEndian");
    __publicField(this, "byteOffset", 0);
    __publicField(this, "endianness");
    const { byteOffset = 0, endianness = "system" } = options != null ? options : {};
    this.byteOffset = byteOffset;
    const systemEndianness = getSystemEndianness();
    this.endianness = endianness === "system" ? systemEndianness : endianness;
    this.littleEndian = this.endianness === "little";
    const unwrapped = unwrapBuffer(buffer);
    this.byteOffset += unwrapped.byteOffset;
    this.dataView = new DataView(unwrapped.buffer);
  }
  get currentByteOffset() {
    return this.byteOffset;
  }
  seekTo(offset) {
    this.byteOffset = offset;
  }
  skipBytes(bytes) {
    this.byteOffset += bytes;
  }
};
function numberToFloat16(value) {
  if (value === 0) return 0;
  if (Number.isNaN(value)) return 32256;
  if (!Number.isFinite(value)) return value > 0 ? 31744 : 64512;
  const sign = value < 0 ? 1 : 0;
  const absValue = Math.abs(value);
  const exponent = Math.floor(Math.log2(absValue));
  const mantissa = absValue / 2 ** exponent - 1;
  const biasedExponent = exponent + 15;
  const mantissaBits = Math.floor(mantissa * 1024);
  return sign << 15 | biasedExponent << 10 | mantissaBits;
}
function float16ToNumber(uint16Encoding) {
  const sign = (uint16Encoding & 32768) >> 15;
  const exponent = (uint16Encoding & 31744) >> 10;
  const mantissa = uint16Encoding & 1023;
  if (exponent === 0) {
    return sign === 0 ? mantissa / 1024 : -mantissa / 1024;
  }
  if (exponent === 31) {
    return mantissa === 0 ? sign === 0 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : Number.NaN;
  }
  return (sign === 0 ? 1 : -1) * (1 + mantissa / 1024) * 2 ** (exponent - 15);
}
var BufferReader = class extends BufferIOBase {
  constructor() {
    super(...arguments);
    __publicField(this, "_cachedTextDecoder");
  }
  get _textDecoder() {
    if (!this._cachedTextDecoder) {
      this._cachedTextDecoder = new TextDecoder(void 0, { fatal: true });
    }
    return this._cachedTextDecoder;
  }
  readBool() {
    return this.dataView.getUint8(this.byteOffset++) !== 0;
  }
  readByte() {
    return this.dataView.getUint8(this.byteOffset++);
  }
  readInt8() {
    return this.dataView.getInt8(this.byteOffset++);
  }
  readUint8() {
    return this.dataView.getUint8(this.byteOffset++);
  }
  readInt16() {
    const value = this.dataView.getInt16(this.byteOffset, this.littleEndian);
    this.byteOffset += 2;
    return value;
  }
  readUint16() {
    const value = this.dataView.getUint16(this.byteOffset, this.littleEndian);
    this.byteOffset += 2;
    return value;
  }
  readInt32() {
    const value = this.dataView.getInt32(this.byteOffset, this.littleEndian);
    this.byteOffset += 4;
    return value;
  }
  readUint32() {
    const value = this.dataView.getUint32(this.byteOffset, this.littleEndian);
    this.byteOffset += 4;
    return value;
  }
  readFloat16() {
    const value = this.dataView.getUint16(this.byteOffset, this.littleEndian);
    this.byteOffset += 2;
    return float16ToNumber(value);
  }
  readFloat32() {
    const value = this.dataView.getFloat32(this.byteOffset, this.littleEndian);
    this.byteOffset += 4;
    return value;
  }
  readString() {
    let strLength = 0;
    while (this.byteOffset + strLength < this.dataView.byteLength) {
      if (this.dataView.getUint8(this.byteOffset + strLength++) === 0) {
        break;
      }
    }
    const result = this._textDecoder.decode(
      new Uint8Array(this.dataView.buffer, this.byteOffset, strLength - 1)
    );
    this.byteOffset += strLength;
    return result;
  }
  readSlice(bufferView, offset, byteLength) {
    const unwrapped = unwrapBuffer(bufferView);
    const destU8 = new Uint8Array(
      unwrapped.buffer,
      unwrapped.byteOffset + offset
    );
    for (let i = 0; i < byteLength; ++i) {
      destU8[i] = this.dataView.getUint8(this.byteOffset++);
    }
  }
};
var BufferWriter = class extends BufferIOBase {
  constructor() {
    super(...arguments);
    __publicField(this, "_cachedTextEncoder");
  }
  get _textEncoder() {
    if (!this._cachedTextEncoder) {
      this._cachedTextEncoder = new TextEncoder();
    }
    return this._cachedTextEncoder;
  }
  writeBool(value) {
    this.dataView.setUint8(this.byteOffset++, value ? 1 : 0);
  }
  writeByte(value) {
    this.dataView.setUint8(this.byteOffset++, value);
  }
  writeInt8(value) {
    this.dataView.setInt8(this.byteOffset++, value);
  }
  writeUint8(value) {
    this.dataView.setUint8(this.byteOffset++, value);
  }
  writeInt16(value) {
    this.dataView.setInt16(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 2;
  }
  writeUint16(value) {
    this.dataView.setUint16(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 2;
  }
  writeInt32(value) {
    this.dataView.setInt32(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 4;
  }
  writeUint32(value) {
    this.dataView.setUint32(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 4;
  }
  writeFloat16(value) {
    this.dataView.setUint16(
      this.byteOffset,
      numberToFloat16(value),
      this.littleEndian
    );
    this.byteOffset += 2;
  }
  writeFloat32(value) {
    this.dataView.setFloat32(this.byteOffset, value, this.littleEndian);
    this.byteOffset += 4;
  }
  writeString(value) {
    const result = this._textEncoder.encodeInto(
      value,
      new Uint8Array(this.dataView.buffer, this.byteOffset)
    );
    this.byteOffset += result.written;
    this.dataView.setUint8(this.byteOffset++, 0);
  }
  writeSlice(bufferView) {
    const unwrapped = unwrapBuffer(bufferView);
    const srcU8 = new Uint8Array(
      unwrapped.buffer,
      unwrapped.byteOffset,
      unwrapped.byteLength
    );
    for (const srcByte of srcU8) {
      this.dataView.setUint8(this.byteOffset++, srcByte);
    }
  }
};

// node_modules/typegpu/index.js
function Un(e10) {
  if (typeof e10?.[_t] == "function") return e10[_t].bind(e10);
}
function ht2(e10, t2) {
  throw new Error(`Failed to handle ${e10} at ${t2}`);
}
var Fa = { f: { 1: p, 2: H, 3: X, 4: Z }, h: { 1: m, 2: et, 3: st, 4: ht }, i: { 1: w, 2: tt, 3: it, 4: ut }, u: { 1: d, 2: nt, 3: at, 4: yt }, b: { 1: x, 2: rt, 3: ot, 4: ct } };
var Pa = { vec2f: H, vec2h: et, vec2i: tt, vec2u: nt, "vec2<bool>": rt, vec3f: X, vec3h: st, vec3i: it, vec3u: at, "vec3<bool>": ot, vec4f: Z, vec4h: ht, vec4i: ut, vec4u: yt, "vec4<bool>": ct, mat2x2f: Ve, mat3x3f: ve, mat4x4f: c };
var Fn = { vec2f: p, vec2h: m, vec2i: w, vec2u: d, "vec2<bool>": x, vec3f: p, vec3h: m, vec3i: w, vec3u: d, "vec3<bool>": x, vec4f: p, vec4h: m, vec4i: w, vec4u: d, "vec4<bool>": x, mat2x2f: H, mat3x3f: X, mat4x4f: Z };
function Qe2(e10, t2) {
  if (Yt(e10) || rn(e10)) return e10.propTypes[t2] ?? yn;
  if (e10 === x || de2(e10)) return yn;
  let r3 = t2.length;
  if (de(e10) && r3 >= 1 && r3 <= 4) {
    let n = e10.type.includes("bool") ? "b" : e10.type[4], a = Fa[n][r3];
    if (a) return a;
  }
  return yn;
}
function pr(e10) {
  return Gt(e10) || nn(e10) ? e10.elementType : e10.type in Fn ? Fn[e10.type] : yn;
}
function lr(e10) {
  if (/^0x[0-9a-f]+$/i.test(e10)) return u(e10, In);
  if (/^0b[01]+$/i.test(e10)) return u(`${Number.parseInt(e10.slice(2), 2)}`, In);
  if (/^-?(?:\d+\.\d*|\d*\.\d+)$/i.test(e10)) return u(e10, $n);
  if (/^-?\d+(?:\.\d+)?e-?\d+$/i.test(e10)) return u(e10, $n);
  if (/^-?\d+$/i.test(e10)) return u(e10, In);
}
var mr = { rank: Number.POSITIVE_INFINITY, action: "none" };
function $e2(e10) {
  return e10.type === "decorated" ? e10.inner : e10;
}
function Pn(e10) {
  return de(e10) ? xt[e10.type] : void 0;
}
function bt(e10, t2) {
  let r3 = $e2(e10), n = $e2(t2);
  if (r3.type === n.type) return { rank: 0, action: "none" };
  if (r3.type === "abstractFloat") {
    if (n.type === "f32") return { rank: 1, action: "none" };
    if (n.type === "f16") return { rank: 2, action: "none" };
  }
  if (r3.type === "abstractInt") {
    if (n.type === "i32") return { rank: 3, action: "none" };
    if (n.type === "u32") return { rank: 4, action: "none" };
    if (n.type === "abstractFloat") return { rank: 5, action: "none" };
    if (n.type === "f32") return { rank: 6, action: "none" };
    if (n.type === "f16") return { rank: 7, action: "none" };
  }
  if (de(r3) && de(n)) {
    let a = Pn(r3), o4 = Pn(n);
    if (a && o4) return bt(a, o4);
  }
  return jt(r3) && jt(n) ? { rank: 0, action: "none" } : mr;
}
function Ba(e10, t2) {
  let r3 = $e2(e10), n = $e2(t2);
  if (r3.type === "ptr" && bt(r3.inner, n).rank < Number.POSITIVE_INFINITY) return { rank: 0, action: "deref" };
  if (n.type === "ptr" && bt(r3, n.inner).rank < Number.POSITIVE_INFINITY) return { rank: 1, action: "ref" };
  let a = { f32: 0, f16: 1, i32: 2, u32: 3, bool: 4 };
  if (r3.type in a && n.type in a) {
    let o4 = r3.type, i = n.type;
    if (o4 !== i) {
      let s = a[o4];
      return { rank: a[i] < s ? 10 : 20, action: "cast", targetType: n };
    }
  }
  return mr;
}
function Aa(e10, t2, r3) {
  let n = bt(e10, t2);
  return n.rank < Number.POSITIVE_INFINITY ? n : r3 ? Ba(e10, t2) : mr;
}
function Bn(e10, t2, r3) {
  let n, a = Number.POSITIVE_INFINITY, o4 = /* @__PURE__ */ new Map();
  for (let u4 of t2) {
    let f2 = 0, m2 = [], g = true;
    for (let y2 of e10) {
      let x3 = Aa(y2, u4, r3);
      if (x3.rank === Number.POSITIVE_INFINITY) {
        g = false;
        break;
      }
      f2 += x3.rank, m2.push(x3);
    }
    g && f2 < a && (a = f2, n = u4, o4.set(n, m2));
  }
  if (!n) return;
  let s = o4.get(n).map((u4, f2) => ({ sourceIndex: f2, action: u4.action, ...u4.action === "cast" && { targetType: u4.targetType } })), p3 = s.some((u4) => u4.action === "cast");
  return { targetType: n, actions: s, hasImplicitConversions: p3 };
}
function dr(e10) {
  return e10.type === "abstractFloat" ? p : e10.type === "abstractInt" ? w : e10;
}
function An(e10, t2) {
  if (e10.length === 0) return;
  let r3 = [...new Set(e10.map($e2))], n = t2 ? [...new Set(t2.map($e2))] : r3, a = Bn(e10, n, false);
  if (a) return a;
  let o4 = Bn(e10, n, true);
  if (o4) return o4.hasImplicitConversions = o4.actions.some((i) => i.action === "cast"), o4;
}
function Ca(e10, t2, r3, n) {
  if (r3.action === "none") return u(t2.value, n);
  let a = e10.resolve(t2.value);
  switch (r3.action) {
    case "ref":
      return u(`&${a}`, n);
    case "deref":
      return u(`*${a}`, n);
    case "cast":
      return u(`${e10.resolve(n)}(${a})`, n);
    default:
      ht2(r3.action, "applyActionToSnippet");
  }
}
function z(e10, t2, r3) {
  let n = t2.map((o4) => o4.dataType);
  if (n.some((o4) => o4 === yn)) return;
  let a = An(n, r3);
  if (a) return a.hasImplicitConversions && console.warn(`Implicit conversions from [
${t2.map((o4) => `  ${o4.value}: ${o4.dataType.type}`).join(`,
`)}
] to ${a.targetType.type} are supported, but not recommended.
Consider using explicit conversions instead.`), t2.map((o4, i) => {
    let s = a.actions[i];
    return K(s, "Action should not be undefined"), Ca(e10, o4, s, a.targetType);
  });
}
function fr(e10, t2, r3) {
  return Object.keys(t2.propTypes).map((a) => {
    let o4 = r3[a];
    if (!o4) throw new Error(`Missing property ${a}`);
    let i = t2.propTypes[a];
    return z(e10, [o4], [i])?.[0] ?? o4;
  });
}
function he3(e10) {
  if (cn(e10)) return e10;
  if (Rt(e10)) return u(e10, e10[se]);
  if (De(e10) || Lt(e10)) return u(e10, Pa[e10.kind]);
  if (Array.isArray(e10)) {
    let t2 = e10.map(he3).filter(Boolean), r3 = wn();
    if (!r3) throw new Error("Tried to coerce array without a context");
    let n = z(r3, t2), a = An(t2.map((o4) => o4.dataType))?.targetType;
    return !n || !a ? u(e10, yn) : u(n.map((o4) => o4.value).join(", "), j(dr(a), e10.length));
  }
  return typeof e10 == "string" || typeof e10 == "function" || typeof e10 == "object" || typeof e10 == "symbol" || typeof e10 > "u" || e10 === null ? u(e10, yn) : typeof e10 == "number" || typeof e10 == "bigint" ? u(e10, lr(String(e10))?.dataType ?? yn) : typeof e10 == "boolean" ? u(e10, x) : u(e10, yn);
}
var H2 = { get(e10, t2) {
  if (t2 in e10) return Reflect.get(e10, t2);
  if (t2 !== At) return t2 === "toString" || t2 === Symbol.toStringTag || t2 === Symbol.toPrimitive ? () => e10.toString() : new Proxy({ "~resolve": (r3) => `${r3.resolve(e10)}.${String(t2)}`, toString: () => `.value(...).${String(t2)}:${f(e10) ?? "<unnamed>"}`, [se]: Qe2(e10[se], String(t2)) }, H2);
} };
function Ke(e10, t2) {
  let r3 = t2, n;
  for (; n = Un(r3); ) r3 = n(e10);
  return r3;
}
function Cn(e10, t2) {
  return new cr(e10, t2);
}
var cr = class {
  constructor(t2, r3) {
    this.dataType = t2;
    this._value = r3;
    this[r] = { dataType: t2 };
  }
  [r];
  $name(t2) {
    return oe(this, t2), this;
  }
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), n = t2.resolveValue(this._value, this.dataType), a = t2.resolve(this.dataType);
    return t2.addDeclaration(`const ${r3}: ${a} = ${n};`), r3;
  }
  toString() {
    return `const:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this.dataType }, H2);
  }
  get value() {
    return fe() ? this[_t]() : this._value;
  }
  get $() {
    return this.value;
  }
};
function Ge2(e10) {
  return e10?.resourceType === "slot";
}
function Ve2(e10) {
  return e10?.resourceType === "derived";
}
function He2(e10) {
  return e10?.[At] !== void 0;
}
function Ee3(e10) {
  return e10?.resourceType === "accessor";
}
function gr(e10) {
  return typeof e10?.["~resolve"] == "function";
}
function wt(e10) {
  return typeof e10 == "number" || typeof e10 == "boolean" || typeof e10 == "string" || gr(e10) || we(e10) || Ge2(e10) || Ve2(e10) || He2(e10);
}
function Ye2(e10) {
  return !!e10 && typeof e10 == "object" && "getMappedRange" in e10 && "mapAsync" in e10;
}
function Rn(e10) {
  return e10?.resourceType === "buffer-usage";
}
function yr(e10) {
  return !!e10?.[r];
}
function be3(e10, t2) {
  for (let [r3, n] of Object.entries(t2)) e10[r3] = n, Ie(n) && f(n) === void 0 && n.$name(r3);
}
function $n2(e10, t2, r3) {
  let n = [...e10.matchAll(/:\s*(?<arg>.*?)\s*[,)]/g)].map((a) => a ? a[1] : void 0);
  r3(Object.fromEntries(t2.flatMap((a, o4) => {
    let i = n ? n[o4] : void 0;
    return Yt(a) && i !== void 0 ? [[i, a]] : [];
  })));
}
function St(e10, t2, r3) {
  let n = e10.match(/->\s(?<output>[\w\d_]+)\s{/), a = n ? n[1]?.trim() : void 0;
  Yt(t2) && a && !/\s/g.test(a) && r3({ [a]: t2 });
}
function Ra(e10) {
  return new RegExp(`(?<![\\w\\$_.])${e10.replaceAll(".", "\\.").replaceAll("$", "\\$")}(?![\\w\\$_])`, "g");
}
function we3(e10, t2, r3) {
  return Object.entries(t2).reduce((n, [a, o4]) => wt(o4) || Re(o4) ? n.replaceAll(Ra(a), e10.resolve(o4)) : o4 !== null && typeof o4 == "object" ? ([...r3.matchAll(new RegExp(`${a.replaceAll(".", "\\.").replaceAll("$", "\\$")}\\.(?<prop>.*?)(?![\\w\\$_])`, "g"))].map((s) => s[1]) ?? []).reduce((s, p3) => p3 && p3 in o4 ? we3(e10, { [`${a}.${p3}`]: o4[p3] }, s) : s, n) : n, r3);
}
function Gn(e10) {
  return new Tr(e10);
}
var Tr = class {
  constructor(t2) {
    this.declaration = t2;
  }
  externalsToApply = [];
  $uses(t2) {
    return this.externalsToApply.push(t2), this;
  }
  "~resolve"(t2) {
    let r3 = {};
    for (let a of this.externalsToApply) be3(r3, a);
    let n = we3(t2, r3, this.declaration);
    return t2.addDeclaration(n), "";
  }
  toString() {
    return `declare: ${this.declaration}`;
  }
};
function _n(e10) {
  let { strippedCode: t2, argRange: r3 } = $a(e10), n = new vt(t2);
  n.consume("(");
  let a = [];
  for (; !n.isAt(")"); ) {
    let i = [];
    for (; n.isAt("@"); ) n.parseUntil(Vn, En), n.consume(")"), i.push(n.lastParsed);
    n.parseUntil(Va);
    let s = n.lastParsed, p3;
    n.isAt(":") && (n.consume(":"), n.parseUntil(Ea, ka), p3 = n.lastParsed), a.push({ identifier: s, attributes: i, type: p3 }), n.isAt(",") && n.consume(",");
  }
  n.consume(")");
  let o4;
  if (n.isAt("->")) {
    n.consume("->");
    let i = [];
    for (; n.isAt("@"); ) n.parseUntil(Vn, En), n.consume(")"), i.push(n.lastParsed);
    o4 = { type: n.str.slice(n.pos), attributes: i };
  }
  return { args: a, ret: o4, range: { begin: r3[0], end: r3[1] } };
}
function $a(e10) {
  let t2 = new vt(e10), r3 = "", n;
  for (; !t2.isFinished(); ) {
    if (t2.isAt(Ga)) {
      t2.advanceBy(1);
      continue;
    }
    if (t2.isAt("//")) {
      t2.consume("//"), t2.parseUntil(kn), t2.advanceBy(1);
      continue;
    }
    if (t2.isAt("/*")) {
      t2.parseUntil(_a, La), t2.consume("*/");
      continue;
    }
    if (t2.isAt("{")) return { strippedCode: r3, argRange: [n, t2.pos] };
    t2.isAt("(") && n === void 0 && (n = t2.pos), n !== void 0 && (r3 += t2.str[t2.pos]), t2.advanceBy(1);
  }
  throw new Error("Invalid wgsl code!");
}
var vt = class {
  constructor(t2) {
    this.str = t2;
    this.#e = 0;
  }
  #t;
  #e;
  get pos() {
    return this.#e;
  }
  get lastParsed() {
    if (this.#t === void 0) throw new Error("Parse was not called yet!");
    return this.str.slice(this.#t, this.pos);
  }
  isFinished() {
    return this.#e >= this.str.length;
  }
  isAt(t2) {
    if (typeof t2 == "string") {
      for (let r3 = 0; r3 < t2.length; r3++) if (this.str[this.#e + r3] !== t2[r3]) return false;
      return true;
    }
    for (let r3 of t2) if (this.isAt(r3)) return true;
    return false;
  }
  parseUntil(t2, r3) {
    this.#t = this.#e;
    let n = 0;
    for (; this.#e < this.str.length; ) {
      if (r3 && this.isAt(r3[0]) && (n += 1), r3 && this.isAt(r3[1]) && (n -= 1), n === 0 && this.isAt(t2)) return this.#e;
      this.#e += 1;
    }
    throw new Error("Reached the end of the string without finding a match!");
  }
  advanceBy(t2) {
    this.#e += t2;
  }
  consume(t2) {
    if (!this.isAt(t2)) throw new Error(`Expected '${t2}' at position ${this.#e}, but found '${this.str.slice(this.#e, this.#e + t2.length)}'`);
    this.advanceBy(t2.length);
  }
};
var kn = /* @__PURE__ */ new Set([`
`, "\v", "\f", "\r", "", "\u2028", "\u2029"]);
var Ga = /* @__PURE__ */ new Set([...kn, " ", "	", "‎", "‏"]);
var Vn = /* @__PURE__ */ new Set([")"]);
var Va = /* @__PURE__ */ new Set([":", ",", ")"]);
var Ea = /* @__PURE__ */ new Set([",", ")"]);
var _a = /* @__PURE__ */ new Set(["*/"]);
var En = ["(", ")"];
var ka = ["<", ">"];
var La = ["/*", "*/"];
function ie3(e10, t2 = "") {
  let r3 = [], n = { applyExternals(o4) {
    r3.push(o4);
  }, resolve(o4, i, s) {
    let p3 = {};
    for (let f2 of r3) be3(p3, f2);
    let u4 = o4.names.makeUnique(f(this));
    if (typeof e10 == "string") {
      let f2 = we3(o4, p3, e10), m2 = "", g = "";
      if (t2 !== "") {
        let y2 = Yt(i[0]) ? `(in: ${o4.resolve(i[0])})` : "()", x3 = we(s) ? Me2(s) : "", b2 = s !== Wt ? Yt(s) ? `-> ${o4.resolve(s)}` : `-> ${x3 !== "" ? x3 : "@location(0)"} ${o4.resolve(s)}` : "";
        m2 = `${y2} ${b2} `, g = f2;
      } else {
        let y2 = _n(f2);
        if (y2.args.length !== i.length) throw new Error(`WGSL implementation has ${y2.args.length} arguments, while the shell has ${i.length} arguments.`);
        let x3 = y2.args.map((I2, P2) => `${I2.identifier}: ${On(o4, `parameter ${I2.identifier}`, I2.type, i[P2])}`).join(", "), b2 = s === Wt ? "" : `-> ${On(o4, "return type", y2.ret?.type, s)}`;
        m2 = `(${x3}) ${b2}`, g = f2.slice(y2.range.end);
      }
      o4.addDeclaration(`${t2}fn ${u4}${m2}${g}`);
    } else {
      let f2 = $e(e10);
      if (f2?.externals) {
        let b2 = Object.fromEntries(Object.entries(f2.externals).filter(([I2]) => !(I2 in p3)));
        be3(p3, b2);
      }
      let m2 = f2?.ast;
      if (!m2) throw new Error("Missing metadata for tgpu.fn function body (either missing 'kernel' directive, or misconfigured `unplugin-typegpu`)");
      let g = m2.externalNames.filter((b2) => !(b2 in p3));
      if (g.length > 0) throw new ce(f(this), g);
      let { head: y2, body: x3 } = o4.fnToWgsl({ args: i.map((b2, I2) => u(m2.params[I2]?.type === t.identifier ? m2.params[I2].name : `_arg_${I2}`, b2)), argAliases: Object.fromEntries(m2.params.flatMap((b2, I2) => b2.type === t.destructuredObject ? b2.props.map(({ name: P2, alias: Ua }) => [Ua, u(`_arg_${I2}.${P2}`, i[I2].propTypes[P2])]) : [])), returnType: s, body: m2.body, externalMap: p3 });
      o4.addDeclaration(`${t2}fn ${u4}${o4.resolve(y2)}${o4.resolve(x3)}`);
    }
    return u4;
  } }, a = f(e10);
  return a !== void 0 && oe(n, a), n;
}
function On(e10, t2, r3, n) {
  let a = e10.resolve(n).replace(/\s/g, "");
  if (!r3) return a;
  let o4 = r3.replace(/\s/g, "");
  if (o4 !== a) throw new Error(`Type mismatch between TGPU shell and WGSL code string: ${t2}, JS type "${a}", WGSL type "${o4}".`);
  return r3;
}
function Oa(e10, t2 = {}) {
  let r3 = 0, n = /* @__PURE__ */ new Set();
  return Object.fromEntries(Object.entries(e10 ?? {}).map(([a, o4]) => {
    let i = hn(o4);
    if (i !== void 0) {
      if (n.has(i)) throw new Error("Duplicate custom location attributes found");
      n.add(i);
    }
    return [a, o4];
  }).map(([a, o4]) => {
    if (Dt(o4)) return [a, o4];
    if (hn(o4) !== void 0) return [a, o4];
    if (t2[a]) return [a, Tt(t2[a], o4)];
    for (; n.has(r3); ) r3++;
    return [a, Tt(r3++, o4)];
  }));
}
function se2(e10, t2 = {}) {
  return un(e10) ? Jt(e10) || hn(e10) !== void 0 ? e10 : Tt(0, e10) : Z2(Oa(e10, t2));
}
function ue3(e10, ...t2) {
  return Wa(e10) ? Ma(e10, ...t2) : e10;
}
function Wa(e10) {
  return Array.isArray(e10) && "raw" in e10 && Array.isArray(e10.raw) && e10.raw.every((t2) => typeof t2 == "string");
}
function Ma(e10, ...t2) {
  return e10.slice(1).reduce((r3, n, a) => `${r3}${t2[a]}${n}`, e10[0]);
}
function Wn(e10) {
  let t2 = { argTypes: e10.in && Object.keys(e10.in).length !== 0 ? [se2(e10.in)] : [], returnType: Wt, workgroupSize: [e10.workgroupSize[0] ?? 1, e10.workgroupSize[1] ?? 1, e10.workgroupSize[2] ?? 1], isEntry: true }, r3 = (n, ...a) => Na(t2, e10.workgroupSize, ue3(n, ...a));
  return Object.assign(Object.assign(r3, t2), { does: r3 });
}
function Na(e10, t2, r3) {
  let n = ie3(r3, `@compute @workgroup_size(${t2.join(", ")}) `), a = e10.argTypes[0];
  return { shell: e10, $uses(i) {
    return n.applyExternals(i), this;
  }, [r]: true, [G]: n, $name(i) {
    return oe(n, i), Ie(a) && a.$name(`${i}_Input`), this;
  }, "~resolve"(i) {
    return n.resolve(i, e10.argTypes, e10.returnType);
  }, toString() {
    return `computeFn:${f(n) ?? "<unnamed>"}`;
  } };
}
function xr(e10, t2) {
  let r3 = { [r]: true, argTypes: e10, returnType: t2 ?? Wt, isEntry: false };
  return Object.assign((a, ...o4) => ja(r3, ue3(a, ...o4)), r3);
}
function hr(e10) {
  return !!e10?.[r] && e10?.resourceType === "function";
}
function za([e10, t2]) {
  return `${f(e10) ?? "<unnamed>"}=${t2}`;
}
function ja(e10, t2) {
  let r3 = ie3(t2, ""), n = { [r]: { implementation: t2, argTypes: e10.argTypes }, shell: e10, resourceType: "function", $uses(i) {
    return r3.applyExternals(i), this;
  }, [G]: r3, $name(i) {
    return oe(r3, i), this;
  }, with(i, s) {
    return Mn(o4, [[Ee3(i) ? i.slot : i, s]]);
  }, "~resolve"(i) {
    if (typeof t2 == "string") return $n2(t2, e10.argTypes, r3.applyExternals), St(t2, e10.returnType, r3.applyExternals), r3.resolve(i, e10.argTypes, e10.returnType);
    let s = i;
    if (s.callStack === void 0) throw new Error("Cannot resolve a TGSL function outside of a generation context");
    try {
      return s.callStack.push(e10.returnType), r3.resolve(i, e10.argTypes, e10.returnType);
    } finally {
      s.callStack.pop();
    }
  } }, a = o((...i) => {
    if (typeof t2 == "string") throw new Error("Cannot execute on the CPU functions constructed with raw WGSL");
    let s = i.map((p3, u4) => J(e10.argTypes[u4], p3));
    return t2(...s);
  }, (...i) => u(new Dt2(o4, i.map((s) => s.value)), e10.returnType ?? yn), "tgpuFnCall", e10.argTypes);
  a[r].implementation = t2;
  let o4 = Object.assign(a, n);
  return Object.defineProperty(o4, "toString", { value() {
    return `fn:${f(r3) ?? "<unnamed>"}`;
  } }), o4;
}
function Mn(e10, t2) {
  let r3 = { [r]: { implementation: e10[r].implementation, argTypes: e10[r].argTypes }, resourceType: "function", shell: e10.shell, [At]: { inner: e10, pairs: t2 }, $uses(o4) {
    return e10.$uses(o4), this;
  }, [G]: e10, $name(o4) {
    return e10.$name(o4), this;
  }, with(o4, i) {
    return Mn(a, [...t2, [Ee3(o4) ? o4.slot : o4, i]]);
  } }, n = o((...o4) => e10(...o4), (...o4) => u(new Dt2(a, o4.map((i) => i.value)), e10.shell.returnType ?? yn), "tgpuFnCall", e10.shell.argTypes), a = Object.assign(n, r3);
  return Object.defineProperty(a, "toString", { value() {
    return `fn:${f(e10) ?? "<unnamed>"}[${t2.map(za).join(", ")}]`;
  } }), a[r].implementation = e10[r].implementation, a;
}
var Dt2 = class {
  constructor(t2, r3) {
    this._fn = t2;
    this._params = r3;
    this[G] = t2;
  }
  [G];
  "~resolve"(t2) {
    return t2.resolve(`${t2.resolve(this._fn)}(${this._params.map((r3) => t2.resolve(r3)).join(", ")})`);
  }
  toString() {
    return `call:${f(this) ?? "<unnamed>"}`;
  }
};
function Nn(e10) {
  let t2 = { in: e10.in, out: e10.out, returnType: se2(e10.out), isEntry: true }, r3 = (n, ...a) => qa(t2, ue3(n, ...a));
  return Object.assign(Object.assign(r3, t2), { does: r3 });
}
function qa(e10, t2) {
  let r3 = ie3(t2, "@fragment "), n = e10.returnType;
  return typeof t2 == "string" && St(t2, n, (o4) => r3.applyExternals(o4)), { shell: e10, outputType: n, $uses(o4) {
    return r3.applyExternals(o4), this;
  }, [r]: true, [G]: r3, $name(o4) {
    return oe(r3, o4), Ie(n) && n.$name(`${o4}_Output`), this;
  }, "~resolve"(o4) {
    let i = e10.in ? se2(e10.in, o4.varyingLocations).$name(`${f(this) ?? ""}_Input`) : void 0;
    if (i && r3.applyExternals({ In: i }), r3.applyExternals({ Out: n }), typeof t2 == "string") return r3.resolve(o4, i ? [i] : [], e10.returnType);
    let s = o4;
    if (s.callStack === void 0) throw new Error("Cannot resolve a TGSL function outside of a generation context");
    try {
      return s.callStack.push(n), r3.resolve(o4, i ? [i] : [], e10.returnType);
    } finally {
      s.callStack.pop();
    }
  }, toString() {
    return `fragmentFn:${f(r3) ?? "<unnamed>"}`;
  } };
}
function zn2(e10) {
  if (Object.keys(e10.out).length === 0) throw new Error("A vertexFn output cannot be empty since it must include the 'position' builtin.");
  let t2 = { in: e10.in, out: e10.out, argTypes: e10.in && Object.keys(e10.in).length !== 0 ? [se2(e10.in)] : [], isEntry: true }, r3 = (n, ...a) => Qa(t2, ue3(n, ...a));
  return Object.assign(Object.assign(r3, t2), { does: r3 });
}
function Qa(e10, t2) {
  let r3 = ie3(t2, "@vertex "), n = e10.argTypes[0];
  return { shell: e10, $uses(o4) {
    return r3.applyExternals(o4), this;
  }, [r]: true, [G]: r3, $name(o4) {
    return oe(r3, o4), Ie(n) && n.$name(`${o4}_Input`), this;
  }, "~resolve"(o4) {
    let i = se2(e10.out, o4.varyingLocations).$name(`${f(this) ?? ""}_Output`);
    if (typeof t2 == "string") return n && r3.applyExternals({ In: n }), r3.applyExternals({ Out: i }), r3.resolve(o4, e10.argTypes, i);
    let s = o4;
    if (s.callStack === void 0) throw new Error("Cannot resolve a TGSL function outside of a generation context");
    try {
      return s.callStack.push(i), r3.resolve(o4, e10.argTypes, i);
    } finally {
      s.callStack.pop();
    }
  }, toString() {
    return `vertexFn:${f(r3) ?? "<unnamed>"}`;
  } };
}
var pe2 = class {
  lastUniqueId = 0;
  makeUnique(t2) {
    let r3;
    return t2 ? (r3 = t2.replaceAll(/\s/g, "_"), r3 = r3.replaceAll(/[^\w\d]/g, "")) : r3 = "item", `${r3}_${this.lastUniqueId++}`;
  }
};
var le3 = class {
  _usedNames = /* @__PURE__ */ new Set();
  makeUnique(t2) {
    if (t2 === void 0) throw new Error("Unnamed item found when using a strict name registry");
    let r3 = 0, n = t2;
    for (; this._usedNames.has(n); ) r3++, n = `${t2}_${r3}`;
    return this._usedNames.add(n), n;
  }
};
function Je2(e10) {
  return typeof e10?.format == "string";
}
function jn(e10, t2) {
  let r3 = [];
  if (un(e10)) {
    if (!Je2(t2)) throw new Error("Shader expected a single attribute, not a record of attributes to be passed in.");
    return r3.push(t2._layout), { usedVertexLayouts: r3, bufferDefinitions: [{ arrayStride: t2._layout.stride, stepMode: t2._layout.stepMode, attributes: [{ format: t2.format, offset: t2.offset, shaderLocation: hn(e10) ?? 0 }] }] };
  }
  let n = [], a = /* @__PURE__ */ new WeakMap(), o4 = 0;
  for (let [i, s] of Object.entries(e10)) {
    if (Dt(s)) continue;
    let p3 = t2[i];
    if (!p3) throw new Error(`An attribute by the name of '${i}' was not provided to the shader.`);
    let u4 = p3._layout, f2 = a.get(u4);
    f2 || (r3.push(u4), f2 = [], n.push({ arrayStride: u4.stride, stepMode: u4.stepMode, attributes: f2 }), a.set(u4, f2)), o4 = hn(s) ?? o4, f2.push({ format: p3.format, offset: p3.offset, shaderLocation: o4++ });
  }
  return { usedVertexLayouts: r3, bufferDefinitions: n };
}
var Ka = ["bool", "f32", "f16", "i32", "u32", "vec2f", "vec3f", "vec4f", "vec2h", "vec3h", "vec4h", "vec2i", "vec3i", "vec4i", "vec2u", "vec3u", "vec4u", "vec2<bool>", "vec3<bool>", "vec4<bool>", "mat2x2f", "mat3x3f", "mat4x4f"];
function Ha(e10) {
  return Ka.includes(e10.type);
}
function br(e10, [t2, r3]) {
  return `  ${Me2(r3)}${t2}: ${e10.resolve(r3)},
`;
}
function Ya(e10, t2) {
  let r3 = e10.names.makeUnique(f(t2));
  return e10.addDeclaration(`
struct ${r3} {
${Object.entries(t2.propTypes).map((n) => br(e10, n)).join("")}}
`), r3;
}
function Ja(e10, t2) {
  let r3 = e10.names.makeUnique(f(t2));
  return e10.addDeclaration(`
struct ${r3} {
${Object.entries(t2.propTypes).map((n) => Je2(n[1]) ? br(e10, [n[0], et2[n[1].format]]) : br(e10, n)).join("")}
}
`), r3;
}
function Xa(e10, t2) {
  let r3 = e10.resolve(t2.elementType);
  return t2.elementCount === 0 ? `array<${r3}>` : `array<${r3}, ${t2.elementCount}>`;
}
function Za(e10, t2) {
  let r3 = e10.resolve(Je2(t2.elementType) ? et2[t2.elementType.format] : t2.elementType);
  return t2.elementCount === 0 ? `array<${r3}>` : `array<${r3}, ${t2.elementCount}>`;
}
function wr(e10, t2) {
  if (Re(t2)) return t2.type === "unstruct" ? Ja(e10, t2) : t2.type === "disarray" ? Za(e10, t2) : t2.type === "loose-decorated" ? e10.resolve(Je2(t2.inner) ? et2[t2.inner.format] : t2.inner) : e10.resolve(et2[t2.type]);
  if (Ha(t2)) return t2.type;
  if (t2.type === "struct") return Ya(e10, t2);
  if (t2.type === "array") return Xa(e10, t2);
  if (t2.type === "atomic") return `atomic<${wr(e10, t2.inner)}>`;
  if (t2.type === "decorated") return e10.resolve(t2.inner);
  if (t2.type === "ptr") return t2.addressSpace === "storage" ? `ptr<storage, ${e10.resolve(t2.inner)}, ${t2.access === "read-write" ? "read_write" : t2.access}>` : `ptr<${t2.addressSpace}, ${e10.resolve(t2.inner)}>`;
  if (t2.type === "abstractInt" || t2.type === "abstractFloat" || t2.type === "void" || t2.type === "u16") throw new Error(`${t2.type} has no representation in WGSL`);
  ht2(t2, "resolveData");
}
function eo(e10, t2) {
  let r3 = "size" in e10 ? e10.size : e10.currentByteOffset, n = t2 - 1, a = r3 & n;
  "skipBytes" in e10 ? e10.skipBytes(t2 - a & n) : e10.add(t2 - a & n);
}
var A2 = eo;
var qn = /* @__PURE__ */ new WeakMap();
function It2(e10) {
  let t2 = qn.get(e10);
  if (t2) return t2;
  let r3 = new Measurer(), n = {}, a;
  for (let o4 in e10.propTypes) {
    let i = e10.propTypes[o4];
    if (i === void 0) throw new Error(`Property ${o4} is undefined in struct`);
    let s = r3.size;
    A2(r3, rn(e10) ? I(i) : u2(i)), a && (a.padding = r3.size - s);
    let p3 = l(i);
    n[o4] = { offset: r3.size, size: p3 }, a = n[o4], r3.add(p3);
  }
  return a && (a.padding = b(l(e10), u2(e10)) - r3.size), qn.set(e10, n), n;
}
var Ft2 = (() => {
  try {
    return new Function("return true"), true;
  } catch {
    return false;
  }
})();
var Sr = /* @__PURE__ */ new WeakMap();
var vr = { u32: "u32", vec2u: "u32", vec3u: "u32", vec4u: "u32", u16: "u16", i32: "i32", vec2i: "i32", vec3i: "i32", vec4i: "i32", f32: "f32", vec2f: "f32", vec3f: "f32", vec4f: "f32", vec2h: "f32", vec3h: "f32", vec4h: "f32", mat2x2f: "f32", mat3x3f: "f32", mat4x4f: "f32" };
var Dr = { u32: "setUint32", i32: "setInt32", f32: "setFloat32", u16: "setUint16" };
function Ut(e10, t2, r3) {
  if (Ht(e10) || Te(e10)) return Ut(e10.inner, t2, r3);
  if (Yt(e10) || rn(e10)) {
    let a = It2(e10), o4 = Object.entries(a).sort((s, p3) => s[1].offset - p3[1].offset), i = "";
    for (let [s, p3] of o4) {
      let u4 = e10.propTypes[s];
      u4 && (i += Ut(u4, `(${t2} + ${p3.offset})`, `${r3}.${s}`));
    }
    return i;
  }
  if (Gt(e10) || nn(e10)) {
    let a = e10, o4 = b(l(a.elementType), u2(a.elementType)), i = "";
    return i += `for (let i = 0; i < ${a.elementCount}; i++) {
`, i += Ut(a.elementType, `(${t2} + i * ${o4})`, `${r3}[i]`), i += `}
`, i;
  }
  if (de(e10)) {
    let a = vr[e10.type], o4 = "", i = Dr[a], s = ["x", "y", "z", "w"], p3 = Pe(e10) ? 2 : Ce(e10) ? 3 : 4;
    for (let u4 = 0; u4 < p3; u4++) o4 += `output.${i}((${t2} + ${u4 * 4}), ${r3}.${s[u4]}, littleEndian);
`;
    return o4;
  }
  if (jt(e10)) {
    let a = vr[e10.type], o4 = Dr[a], i = Ee(e10) ? 2 : Me(e10) ? 3 : 4, s = i * i, p3 = b(i * 4, 8), u4 = "";
    for (let f2 = 0; f2 < s; f2++) {
      let m2 = Math.floor(f2 / i), g = f2 % i, y2 = m2 * p3 + g * 4;
      u4 += `output.${o4}((${t2} + ${y2}), ${r3}.columns[${m2}].${["x", "y", "z", "w"][g]}, littleEndian);
`;
    }
    return u4;
  }
  let n = vr[e10.type];
  return `output.${Dr[n]}(${t2}, ${r3}, littleEndian);
`;
}
function Pt(e10) {
  if (Sr.has(e10)) return Sr.get(e10);
  let t2 = Ut(e10, "offset", "value"), r3 = new Function("output", "offset", "value", "littleEndian=true", t2);
  return Sr.set(e10, r3), r3;
}
var _e2 = { bool() {
  throw new Error("Booleans are not host-shareable");
}, f32(e10, t2, r3) {
  e10.writeFloat32(r3);
}, f16(e10, t2, r3) {
  e10.writeFloat16(r3);
}, i32(e10, t2, r3) {
  e10.writeInt32(r3);
}, u32(e10, t2, r3) {
  e10.writeUint32(r3);
}, u16(e10, t2, r3) {
  e10.writeUint16(r3);
}, vec2f(e10, t2, r3) {
  e10.writeFloat32(r3.x), e10.writeFloat32(r3.y);
}, vec2h(e10, t2, r3) {
  e10.writeFloat16(r3.x), e10.writeFloat16(r3.y);
}, vec2i(e10, t2, r3) {
  e10.writeInt32(r3.x), e10.writeInt32(r3.y);
}, vec2u(e10, t2, r3) {
  e10.writeUint32(r3.x), e10.writeUint32(r3.y);
}, "vec2<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, vec3f(e10, t2, r3) {
  e10.writeFloat32(r3.x), e10.writeFloat32(r3.y), e10.writeFloat32(r3.z);
}, vec3h(e10, t2, r3) {
  e10.writeFloat16(r3.x), e10.writeFloat16(r3.y), e10.writeFloat16(r3.z);
}, vec3i(e10, t2, r3) {
  e10.writeInt32(r3.x), e10.writeInt32(r3.y), e10.writeInt32(r3.z);
}, vec3u(e10, t2, r3) {
  e10.writeUint32(r3.x), e10.writeUint32(r3.y), e10.writeUint32(r3.z);
}, "vec3<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, vec4f(e10, t2, r3) {
  e10.writeFloat32(r3.x), e10.writeFloat32(r3.y), e10.writeFloat32(r3.z), e10.writeFloat32(r3.w);
}, vec4h(e10, t2, r3) {
  e10.writeFloat16(r3.x), e10.writeFloat16(r3.y), e10.writeFloat16(r3.z), e10.writeFloat16(r3.w);
}, vec4i(e10, t2, r3) {
  e10.writeInt32(r3.x), e10.writeInt32(r3.y), e10.writeInt32(r3.z), e10.writeInt32(r3.w);
}, vec4u(e10, t2, r3) {
  e10.writeUint32(r3.x), e10.writeUint32(r3.y), e10.writeUint32(r3.z), e10.writeUint32(r3.w);
}, "vec4<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, mat2x2f(e10, t2, r3) {
  for (let n = 0; n < r3.length; ++n) e10.writeFloat32(r3[n]);
}, mat3x3f(e10, t2, r3) {
  for (let n = 0; n < r3.length; ++n) e10.writeFloat32(r3[n]);
}, mat4x4f(e10, t2, r3) {
  for (let n = 0; n < r3.length; ++n) e10.writeFloat32(r3[n]);
}, struct(e10, t2, r3) {
  let n = u2(t2);
  A2(e10, n);
  for (let [a, o4] of Object.entries(t2.propTypes)) A2(e10, u2(o4)), me2(e10, o4, r3[a]);
  A2(e10, n);
}, array(e10, t2, r3) {
  if (t2.elementCount === 0) throw new Error("Cannot write using a runtime-sized schema.");
  let n = u2(t2);
  A2(e10, n);
  let a = e10.currentByteOffset;
  for (let o4 = 0; o4 < Math.min(t2.elementCount, r3.length); o4++) A2(e10, n), me2(e10, t2.elementType, r3[o4]);
  e10.seekTo(a + l(t2));
}, ptr() {
  throw new Error("Pointers are not host-shareable");
}, atomic(e10, t2, r3) {
  _e2[t2.inner.type]?.(e10, t2, r3);
}, decorated(e10, t2, r3) {
  let n = I(t2);
  A2(e10, n);
  let a = e10.currentByteOffset;
  _e2[t2.inner?.type]?.(e10, t2.inner, r3), e10.seekTo(a + l(t2));
}, uint8(e10, t2, r3) {
  e10.writeUint8(r3);
}, uint8x2(e10, t2, r3) {
  e10.writeUint8(r3.x), e10.writeUint8(r3.y);
}, uint8x4(e10, t2, r3) {
  e10.writeUint8(r3.x), e10.writeUint8(r3.y), e10.writeUint8(r3.z), e10.writeUint8(r3.w);
}, sint8(e10, t2, r3) {
  e10.writeInt8(r3);
}, sint8x2(e10, t2, r3) {
  e10.writeInt8(r3.x), e10.writeInt8(r3.y);
}, sint8x4(e10, t2, r3) {
  e10.writeInt8(r3.x), e10.writeInt8(r3.y), e10.writeInt8(r3.z), e10.writeInt8(r3.w);
}, unorm8(e10, t2, r3) {
  e10.writeUint8(r3 * 255);
}, unorm8x2(e10, t2, r3) {
  e10.writeUint8(r3.x * 255), e10.writeUint8(r3.y * 255);
}, unorm8x4(e10, t2, r3) {
  e10.writeUint8(r3.x * 255), e10.writeUint8(r3.y * 255), e10.writeUint8(r3.z * 255), e10.writeUint8(r3.w * 255);
}, snorm8(e10, t2, r3) {
  e10.writeUint8(r3 * 127 + 128);
}, snorm8x2(e10, t2, r3) {
  e10.writeUint8(r3.x * 127 + 128), e10.writeUint8(r3.y * 127 + 128);
}, snorm8x4(e10, t2, r3) {
  e10.writeUint8(r3.x * 127 + 128), e10.writeUint8(r3.y * 127 + 128), e10.writeUint8(r3.z * 127 + 128), e10.writeUint8(r3.w * 127 + 128);
}, uint16(e10, t2, r3) {
  e10.writeUint16(r3);
}, uint16x2(e10, t2, r3) {
  e10.writeUint16(r3.x), e10.writeUint16(r3.y);
}, uint16x4(e10, t2, r3) {
  e10.writeUint16(r3.x), e10.writeUint16(r3.y), e10.writeUint16(r3.z), e10.writeUint16(r3.w);
}, sint16(e10, t2, r3) {
  e10.writeInt16(r3);
}, sint16x2(e10, t2, r3) {
  e10.writeInt16(r3.x), e10.writeInt16(r3.y);
}, sint16x4(e10, t2, r3) {
  e10.writeInt16(r3.x), e10.writeInt16(r3.y), e10.writeInt16(r3.z), e10.writeInt16(r3.w);
}, unorm16(e10, t2, r3) {
  e10.writeUint16(r3 * 65535);
}, unorm16x2(e10, t2, r3) {
  e10.writeUint16(r3.x * 65535), e10.writeUint16(r3.y * 65535);
}, unorm16x4(e10, t2, r3) {
  e10.writeUint16(r3.x * 65535), e10.writeUint16(r3.y * 65535), e10.writeUint16(r3.z * 65535), e10.writeUint16(r3.w * 65535);
}, snorm16(e10, t2, r3) {
  e10.writeUint16(r3 * 32767 + 32768);
}, snorm16x2(e10, t2, r3) {
  e10.writeUint16(r3.x * 32767 + 32768), e10.writeUint16(r3.y * 32767 + 32768);
}, snorm16x4(e10, t2, r3) {
  e10.writeUint16(r3.x * 32767 + 32768), e10.writeUint16(r3.y * 32767 + 32768), e10.writeUint16(r3.z * 32767 + 32768), e10.writeUint16(r3.w * 32767 + 32768);
}, float16(e10, t2, r3) {
  e10.writeFloat16(r3);
}, float16x2(e10, t2, r3) {
  e10.writeFloat16(r3.x), e10.writeFloat16(r3.y);
}, float16x4(e10, t2, r3) {
  e10.writeFloat16(r3.x), e10.writeFloat16(r3.y), e10.writeFloat16(r3.z), e10.writeFloat16(r3.w);
}, float32(e10, t2, r3) {
  e10.writeFloat32(r3);
}, float32x2(e10, t2, r3) {
  e10.writeFloat32(r3.x), e10.writeFloat32(r3.y);
}, float32x3(e10, t2, r3) {
  e10.writeFloat32(r3.x), e10.writeFloat32(r3.y), e10.writeFloat32(r3.z);
}, float32x4(e10, t2, r3) {
  e10.writeFloat32(r3.x), e10.writeFloat32(r3.y), e10.writeFloat32(r3.z), e10.writeFloat32(r3.w);
}, uint32(e10, t2, r3) {
  e10.writeUint32(r3);
}, uint32x2(e10, t2, r3) {
  e10.writeUint32(r3.x), e10.writeUint32(r3.y);
}, uint32x3(e10, t2, r3) {
  e10.writeUint32(r3.x), e10.writeUint32(r3.y), e10.writeUint32(r3.z);
}, uint32x4(e10, t2, r3) {
  e10.writeUint32(r3.x), e10.writeUint32(r3.y), e10.writeUint32(r3.z), e10.writeUint32(r3.w);
}, sint32(e10, t2, r3) {
  e10.writeInt32(r3);
}, sint32x2(e10, t2, r3) {
  e10.writeInt32(r3.x), e10.writeInt32(r3.y);
}, sint32x3(e10, t2, r3) {
  e10.writeInt32(r3.x), e10.writeInt32(r3.y), e10.writeInt32(r3.z);
}, sint32x4(e10, t2, r3) {
  e10.writeInt32(r3.x), e10.writeInt32(r3.y), e10.writeInt32(r3.z), e10.writeInt32(r3.w);
}, "unorm10-10-10-2"(e10, t2, r3) {
  let n = 0;
  n |= (r3.x * 1023 & 1023) << 22, n |= (r3.x * 1023 & 1023) << 12, n |= (r3.y * 1023 & 1023) << 2, n |= r3.z * 3 & 3, e10.writeUint32(n);
}, "unorm8x4-bgra"(e10, t2, r3) {
  e10.writeUint8(r3.z * 255), e10.writeUint8(r3.y * 255), e10.writeUint8(r3.x * 255), e10.writeUint8(r3.w * 255);
}, disarray(e10, t2, r3) {
  let n = u2(t2);
  A2(e10, n);
  let a = e10.currentByteOffset;
  for (let o4 = 0; o4 < Math.min(t2.elementCount, r3.length); o4++) A2(e10, n), _e2[t2.elementType?.type]?.(e10, t2.elementType, r3[o4]);
  e10.seekTo(a + l(t2));
}, unstruct(e10, t2, r3) {
  for (let [n, a] of Object.entries(t2.propTypes)) _e2[a.type]?.(e10, a, r3[n]);
}, "loose-decorated"(e10, t2, r3) {
  let n = I(t2);
  A2(e10, n);
  let a = e10.currentByteOffset, o4 = _e2[t2.inner?.type];
  return o4?.(e10, t2.inner, r3), e10.seekTo(a + l(t2)), r3;
} };
function me2(e10, t2, r3) {
  let n = _e2[t2.type];
  if (!n) throw new Error(`Cannot write data of type '${t2.type}'.`);
  n(e10, t2, r3);
}
var Se2 = { bool() {
  throw new Error("Booleans are not host-shareable");
}, f32(e10) {
  return e10.readFloat32();
}, f16(e10) {
  return e10.readFloat16();
}, i32(e10) {
  return e10.readInt32();
}, u32(e10) {
  return e10.readUint32();
}, u16(e10) {
  return e10.readUint16();
}, vec2f(e10) {
  return H(e10.readFloat32(), e10.readFloat32());
}, vec3f(e10) {
  return X(e10.readFloat32(), e10.readFloat32(), e10.readFloat32());
}, vec4f(e10) {
  return Z(e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32());
}, vec2h(e10) {
  return et(e10.readFloat16(), e10.readFloat16());
}, vec3h(e10) {
  return st(e10.readFloat16(), e10.readFloat16(), e10.readFloat16());
}, vec4h(e10) {
  return ht(e10.readFloat16(), e10.readFloat16(), e10.readFloat16(), e10.readFloat16());
}, vec2i(e10) {
  return tt(e10.readInt32(), e10.readInt32());
}, vec3i(e10) {
  return it(e10.readInt32(), e10.readInt32(), e10.readInt32());
}, vec4i(e10) {
  return ut(e10.readInt32(), e10.readInt32(), e10.readInt32(), e10.readInt32());
}, vec2u(e10) {
  return nt(e10.readUint32(), e10.readUint32());
}, vec3u(e10) {
  return at(e10.readUint32(), e10.readUint32(), e10.readUint32());
}, vec4u(e10) {
  return yt(e10.readUint32(), e10.readUint32(), e10.readUint32(), e10.readUint32());
}, "vec2<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, "vec3<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, "vec4<bool>"() {
  throw new Error("Booleans are not host-shareable");
}, mat2x2f(e10) {
  return Ve(e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32());
}, mat3x3f(e10) {
  let t2 = () => {
    let r3 = e10.readFloat32();
    return e10.readFloat32(), r3;
  };
  return ve(e10.readFloat32(), e10.readFloat32(), t2(), e10.readFloat32(), e10.readFloat32(), t2(), e10.readFloat32(), e10.readFloat32(), t2());
}, mat4x4f(e10) {
  return c(e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32());
}, struct(e10, t2) {
  let r3 = u2(t2);
  A2(e10, r3);
  let n = {};
  for (let [a, o4] of Object.entries(t2.propTypes)) A2(e10, u2(o4)), n[a] = j3(e10, o4);
  return A2(e10, r3), n;
}, array(e10, t2) {
  if (t2.elementCount === 0) throw new Error("Cannot read using a runtime-sized schema.");
  let r3 = u2(t2), n = [];
  for (let a = 0; a < t2.elementCount; a++) {
    A2(e10, r3);
    let o4 = t2.elementType, i = j3(e10, o4);
    n.push(i);
  }
  return A2(e10, r3), n;
}, ptr() {
  throw new Error("Pointers are not host-shareable");
}, atomic(e10, t2) {
  return j3(e10, t2.inner);
}, decorated(e10, t2) {
  let r3 = I(t2);
  A2(e10, r3);
  let n = e10.currentByteOffset, a = j3(e10, t2.inner);
  return e10.seekTo(n + l(t2)), a;
}, uint8: (e10) => e10.readUint8(), uint8x2: (e10) => nt(e10.readUint8(), e10.readUint8()), uint8x4: (e10) => yt(e10.readUint8(), e10.readUint8(), e10.readUint8(), e10.readUint8()), sint8: (e10) => e10.readInt8(), sint8x2: (e10) => tt(e10.readInt8(), e10.readInt8()), sint8x4: (e10) => ut(e10.readInt8(), e10.readInt8(), e10.readInt8(), e10.readInt8()), unorm8: (e10) => e10.readUint8() / 255, unorm8x2: (e10) => H(e10.readUint8() / 255, e10.readUint8() / 255), unorm8x4: (e10) => Z(e10.readUint8() / 255, e10.readUint8() / 255, e10.readUint8() / 255, e10.readUint8() / 255), snorm8: (e10) => (e10.readUint8() - 128) / 127, snorm8x2: (e10) => H((e10.readUint8() - 128) / 127, (e10.readUint8() - 128) / 127), snorm8x4: (e10) => Z((e10.readUint8() - 128) / 127, (e10.readUint8() - 128) / 127, (e10.readUint8() - 128) / 127, (e10.readUint8() - 128) / 127), uint16: (e10) => e10.readUint16(), uint16x2: (e10) => nt(e10.readUint16(), e10.readUint16()), uint16x4: (e10) => yt(e10.readUint16(), e10.readUint16(), e10.readUint16(), e10.readUint16()), sint16: (e10) => e10.readInt16(), sint16x2: (e10) => tt(e10.readInt16(), e10.readInt16()), sint16x4: (e10) => ut(e10.readInt16(), e10.readInt16(), e10.readInt16(), e10.readInt16()), unorm16: (e10) => e10.readUint16() / 65535, unorm16x2: (e10) => H(e10.readUint16() / 65535, e10.readUint16() / 65535), unorm16x4: (e10) => Z(e10.readUint16() / 65535, e10.readUint16() / 65535, e10.readUint16() / 65535, e10.readUint16() / 65535), snorm16: (e10) => (e10.readUint16() - 32768) / 32767, snorm16x2: (e10) => H(Se2.snorm16(e10), Se2.snorm16(e10)), snorm16x4: (e10) => Z(Se2.snorm16(e10), Se2.snorm16(e10), Se2.snorm16(e10), Se2.snorm16(e10)), float16(e10) {
  return e10.readFloat16();
}, float16x2: (e10) => H(e10.readFloat16(), e10.readFloat16()), float16x4: (e10) => Z(e10.readFloat16(), e10.readFloat16(), e10.readFloat16(), e10.readFloat16()), float32: (e10) => e10.readFloat32(), float32x2: (e10) => H(e10.readFloat32(), e10.readFloat32()), float32x3: (e10) => X(e10.readFloat32(), e10.readFloat32(), e10.readFloat32()), float32x4: (e10) => Z(e10.readFloat32(), e10.readFloat32(), e10.readFloat32(), e10.readFloat32()), uint32: (e10) => e10.readUint32(), uint32x2: (e10) => nt(e10.readUint32(), e10.readUint32()), uint32x3: (e10) => at(e10.readUint32(), e10.readUint32(), e10.readUint32()), uint32x4: (e10) => yt(e10.readUint32(), e10.readUint32(), e10.readUint32(), e10.readUint32()), sint32: (e10) => e10.readInt32(), sint32x2: (e10) => tt(e10.readInt32(), e10.readInt32()), sint32x3: (e10) => it(e10.readInt32(), e10.readInt32(), e10.readInt32()), sint32x4: (e10) => ut(e10.readInt32(), e10.readInt32(), e10.readInt32(), e10.readInt32()), "unorm10-10-10-2"(e10) {
  let t2 = e10.readUint32(), r3 = (t2 >> 22) / 1023, n = (t2 >> 12 & 1023) / 1023, a = (t2 >> 2 & 1023) / 1023, o4 = (t2 & 3) / 3;
  return Z(r3, n, a, o4);
}, "unorm8x4-bgra"(e10) {
  let t2 = e10.readByte() / 255, r3 = e10.readByte() / 255, n = e10.readByte() / 255, a = e10.readByte() / 255;
  return Z(n, r3, t2, a);
}, unstruct(e10, t2) {
  let r3 = {};
  for (let [n, a] of Object.entries(t2.propTypes)) r3[n] = j3(e10, a);
  return r3;
}, disarray(e10, t2) {
  let r3 = u2(t2), n = [];
  for (let a = 0; a < t2.elementCount; a++) A2(e10, r3), n.push(j3(e10, t2.elementType));
  return A2(e10, r3), n;
}, "loose-decorated"(e10, t2) {
  A2(e10, I(t2));
  let r3 = e10.currentByteOffset, n = j3(e10, t2.inner);
  return e10.seekTo(r3 + l(t2)), n;
} };
function j3(e10, t2) {
  let r3 = Se2[t2.type];
  if (!r3) throw new Error(`Cannot read data of type '${t2.type}'.`);
  return r3(e10, t2);
}
function Qn(e10, t2) {
  let r3 = l(e10);
  if (r3 === 0 || t2 === void 0 || t2 === null) return [];
  let n = new ArrayBuffer(r3), a = new BufferWriter(n), o4 = [];
  function i(u4, f2, m2, g) {
    if (f2 != null) {
      if (Yt(u4) || rn(u4)) {
        let y2 = It2(u4);
        for (let [x3, b2] of Object.entries(y2)) {
          let I2 = u4.propTypes[x3];
          if (!I2) continue;
          let P2 = f2[x3];
          P2 !== void 0 && i(I2, P2, m2 + b2.offset, b2.padding ?? g);
        }
        return;
      }
      if (Gt(u4) || nn(u4)) {
        let y2 = u4, x3 = b(l(y2.elementType), u2(y2.elementType));
        if (!Array.isArray(f2)) throw new Error("Partial value for array must be an array");
        let b2 = f2 ?? [];
        b2.sort((I2, P2) => I2.idx - P2.idx);
        for (let { idx: I2, value: P2 } of b2) i(y2.elementType, P2, m2 + I2 * x3, x3 - l(y2.elementType));
      } else {
        let y2 = l(u4);
        a.seekTo(m2), me2(a, u4, f2), o4.push({ start: m2, end: m2 + y2, padding: g });
      }
    }
  }
  if (i(e10, t2, 0), o4.length === 0) return [];
  let s = [], p3 = o4[0];
  for (let u4 = 1; u4 < o4.length; u4++) {
    let f2 = o4[u4];
    if (!f2 || !p3) throw new Error("Internal error: missing segment");
    f2.start === p3.end + (p3.padding ?? 0) ? (p3.end = f2.end, p3.padding = f2.padding) : (s.push({ data: new Uint8Array(n, p3.start, p3.end - p3.start) }), p3 = f2);
  }
  if (!p3) throw new Error("Internal error: missing segment");
  return s.push({ data: new Uint8Array(n, p3.start, p3.end - p3.start) }), s;
}
function ve3(e10) {
  return !!e10?.usableAsStorage;
}
var Xe2 = class e2 extends Error {
  constructor(t2) {
    super(`Resource '${f(t2) ?? "<unnamed>"}' cannot be bound as 'storage'. Use .$usage('storage') to allow it.`), Object.setPrototypeOf(this, e2.prototype);
  }
};
function Bt(e10) {
  return !!e10.usableAsUniform;
}
var Jn = { uniform: "uniform", mutable: "storage, read_write", readonly: "storage, read" };
var Ze2 = class {
  constructor(t2, r3) {
    this.usage = t2;
    this.buffer = r3;
    this[r] = { dataType: r3.dataType }, this[G] = r3;
  }
  resourceType = "buffer-usage";
  [r];
  [G];
  $name(t2) {
    return this.buffer.$name(t2), this;
  }
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), { group: n, binding: a } = t2.allocateFixedEntry(this.usage === "uniform" ? { uniform: this.buffer.dataType } : { storage: this.buffer.dataType, access: this.usage }, this.buffer), o4 = Jn[this.usage];
    return t2.addDeclaration(`@group(${n}) @binding(${a}) var<${o4}> ${r3}: ${t2.resolve(this.buffer.dataType)};`), r3;
  }
  toString() {
    return `${this.usage}:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this.buffer.dataType }, H2);
  }
  get value() {
    if (!fe()) throw new Error("Cannot access buffer's value directly in JS.");
    return this[_t]();
  }
  get $() {
    return this.value;
  }
};
var et3 = class {
  constructor(t2, r3, n) {
    this.usage = t2;
    this.dataType = r3;
    this._membership = n;
    this[r] = { dataType: r3 }, oe(this, n.key);
  }
  resourceType = "buffer-usage";
  [r];
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout), a = Jn[this.usage];
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var<${a}> ${r3}: ${t2.resolve(this.dataType)};`), r3;
  }
  toString() {
    return `${this.usage}:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this.dataType }, H2);
  }
  get value() {
    if (!fe()) throw new Error("Cannot access buffer's value directly in JS.");
    return this[_t]();
  }
  get $() {
    return this.value;
  }
};
var Kn = /* @__PURE__ */ new WeakMap();
function Ir(e10) {
  if (!ve3(e10)) throw new Error(`Cannot pass ${e10} to asMutable, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`);
  let t2 = Kn.get(e10);
  return t2 || (t2 = new Ze2("mutable", e10), Kn.set(e10, t2)), t2;
}
var Hn = /* @__PURE__ */ new WeakMap();
function Ur(e10) {
  if (!ve3(e10)) throw new Error(`Cannot pass ${e10} to asReadonly, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`);
  let t2 = Hn.get(e10);
  return t2 || (t2 = new Ze2("readonly", e10), Hn.set(e10, t2)), t2;
}
var Yn = /* @__PURE__ */ new WeakMap();
function Fr(e10) {
  if (!Bt(e10)) throw new Error(`Cannot pass ${e10} to asUniform, as it is not allowed to be used as a uniform. To allow it, call .$usage('uniform') when creating the buffer.`);
  let t2 = Yn.get(e10);
  return t2 || (t2 = new Ze2("uniform", e10), Yn.set(e10, t2)), t2;
}
var oo = { uniform: Fr, mutable: Ir, readonly: Ur };
function tt2(e10, t2, r3) {
  return we(t2) ? new At2(e10, t2, r3) : new At2(e10, t2, r3, ["storage", "uniform"]);
}
function de3(e10) {
  return e10.resourceType === "buffer";
}
function io(e10) {
  return !!e10.usableAsVertex;
}
var Xn = getSystemEndianness();
var At2 = class {
  constructor(t2, r3, n, a) {
    this._group = t2;
    this.dataType = r3;
    this.initialOrBuffer = n;
    this._disallowedUsages = a;
    Ye2(n) ? (this._ownBuffer = false, this._buffer = n) : (this._ownBuffer = true, this.initial = n);
  }
  [r] = true;
  resourceType = "buffer";
  flags = GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC;
  _buffer = null;
  _ownBuffer;
  _destroyed = false;
  _hostBuffer;
  initial;
  usableAsUniform = false;
  usableAsStorage = false;
  usableAsVertex = false;
  usableAsIndex = false;
  get buffer() {
    let t2 = this._group.device;
    if (this._destroyed) throw new Error("This buffer has been destroyed");
    if (!this._buffer && (this._buffer = t2.createBuffer({ size: l(this.dataType), usage: this.flags, mappedAtCreation: !!this.initial, label: f(this) ?? "<unnamed>" }), this.initial)) {
      let r3 = new BufferWriter(this._buffer.getMappedRange());
      me2(r3, this.dataType, this.initial), this._buffer.unmap();
    }
    return this._buffer;
  }
  get destroyed() {
    return this._destroyed;
  }
  $name(t2) {
    return oe(this, t2), this._buffer && (this._buffer.label = t2), this;
  }
  $usage(...t2) {
    for (let r3 of t2) {
      if (this._disallowedUsages?.includes(r3)) throw new Error(`Buffer of type ${this.dataType.type} cannot be used as ${r3}`);
      this.flags |= r3 === "uniform" ? GPUBufferUsage.UNIFORM : 0, this.flags |= r3 === "storage" ? GPUBufferUsage.STORAGE : 0, this.flags |= r3 === "vertex" ? GPUBufferUsage.VERTEX : 0, this.flags |= r3 === "index" ? GPUBufferUsage.INDEX : 0, this.usableAsUniform = this.usableAsUniform || r3 === "uniform", this.usableAsStorage = this.usableAsStorage || r3 === "storage", this.usableAsVertex = this.usableAsVertex || r3 === "vertex", this.usableAsIndex = this.usableAsIndex || r3 === "index";
    }
    return this;
  }
  $addFlags(t2) {
    if (!this._ownBuffer) throw new Error("Cannot add flags to a buffer that is not managed by TypeGPU.");
    return t2 & GPUBufferUsage.MAP_READ ? (this.flags = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ, this) : t2 & GPUBufferUsage.MAP_WRITE ? (this.flags = GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE, this) : (this.flags |= t2, this);
  }
  compileWriter() {
    if (Ft2) Pt(this.dataType);
    else throw new Error("This environment does not allow eval");
  }
  write(t2) {
    let r3 = this.buffer, n = this._group.device;
    if (r3.mapState === "mapped") {
      let o4 = r3.getMappedRange();
      if (Ft2) {
        Pt(this.dataType)(new DataView(o4), 0, t2, Xn === "little");
        return;
      }
      me2(new BufferWriter(o4), this.dataType, t2);
      return;
    }
    let a = l(this.dataType);
    this._hostBuffer || (this._hostBuffer = new ArrayBuffer(a)), this._group.flush(), Ft2 ? Pt(this.dataType)(new DataView(this._hostBuffer), 0, t2, Xn === "little") : me2(new BufferWriter(this._hostBuffer), this.dataType, t2), n.queue.writeBuffer(r3, 0, this._hostBuffer, 0, a);
  }
  writePartial(t2) {
    let r3 = this.buffer, n = this._group.device, a = Qn(this.dataType, t2);
    if (r3.mapState === "mapped") {
      let o4 = r3.getMappedRange(), i = new Uint8Array(o4);
      for (let s of a) i.set(s.data, s.data.byteOffset);
    } else for (let o4 of a) n.queue.writeBuffer(r3, o4.data.byteOffset, o4.data, 0, o4.data.byteLength);
  }
  copyFrom(t2) {
    if (this.buffer.mapState === "mapped") throw new Error("Cannot copy to a mapped buffer.");
    let r3 = l(this.dataType);
    this._group.commandEncoder.copyBufferToBuffer(t2.buffer, 0, this.buffer, 0, r3);
  }
  async read() {
    this._group.flush();
    let t2 = this.buffer, r3 = this._group.device;
    if (t2.mapState === "mapped") {
      let i = t2.getMappedRange();
      return j3(new BufferReader(i), this.dataType);
    }
    if (t2.usage & GPUBufferUsage.MAP_READ) {
      await t2.mapAsync(GPUMapMode.READ);
      let i = t2.getMappedRange(), s = j3(new BufferReader(i), this.dataType);
      return t2.unmap(), s;
    }
    let n = r3.createBuffer({ size: l(this.dataType), usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ }), a = r3.createCommandEncoder();
    a.copyBufferToBuffer(t2, 0, n, 0, l(this.dataType)), r3.queue.submit([a.finish()]), await r3.queue.onSubmittedWorkDone(), await n.mapAsync(GPUMapMode.READ, 0, l(this.dataType));
    let o4 = j3(new BufferReader(n.getMappedRange()), this.dataType);
    return n.unmap(), n.destroy(), o4;
  }
  as(t2) {
    return oo[t2]?.(this);
  }
  destroy() {
    this._destroyed || (this._destroyed = true, this._ownBuffer && this._buffer?.destroy());
  }
  toString() {
    return `buffer:${f(this) ?? "<unnamed>"}`;
  }
};
function Zn(e10) {
  return new Ar(e10);
}
function ea(e10) {
  return new Cr(e10);
}
function rt2(e10) {
  let t2 = e10;
  return t2?.resourceType === "sampler" && !!t2[r];
}
function nt2(e10) {
  let t2 = e10;
  return t2?.resourceType === "sampler-comparison" && !!t2[r];
}
var Ct = class {
  constructor(t2) {
    this._membership = t2;
    this[se] = this, this[r] = {}, oe(this, t2.key);
  }
  [se];
  [r];
  resourceType = "sampler";
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout);
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r3}: sampler;`), r3;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Rt2 = class {
  constructor(t2) {
    this._membership = t2;
    this[se] = this, this[r] = {}, oe(this, t2.key);
  }
  [se];
  [r];
  resourceType = "sampler-comparison";
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout);
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r3}: sampler_comparison;`), r3;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Ar = class {
  constructor(t2) {
    this._props = t2;
    this[se] = this, this[r] = { unwrap: (r3) => (this._sampler || (this._sampler = r3.device.createSampler({ ...this._props, label: f(this) ?? "<unnamed>" })), this._sampler) }, this._filtering = t2.minFilter === "linear" || t2.magFilter === "linear" || t2.mipmapFilter === "linear";
  }
  [se];
  [r];
  resourceType = "sampler";
  _filtering;
  _sampler = null;
  $name(t2) {
    return oe(this, t2), this;
  }
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), { group: n, binding: a } = t2.allocateFixedEntry({ sampler: this._filtering ? "filtering" : "non-filtering" }, this);
    return t2.addDeclaration(`@group(${n}) @binding(${a}) var ${r3}: sampler;`), r3;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Cr = class {
  constructor(t2) {
    this._props = t2;
    this[se] = this, this[r] = { unwrap: (r3) => (this._sampler || (this._sampler = r3.device.createSampler({ ...this._props, label: f(this) ?? "<unnamed>" })), this._sampler) };
  }
  [se];
  [r];
  resourceType = "sampler-comparison";
  _sampler = null;
  $name(t2) {
    return oe(this, t2), this;
  }
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), { group: n, binding: a } = t2.allocateFixedEntry({ sampler: "comparison" }, this);
    return t2.addDeclaration(`@group(${n}) @binding(${a}) var ${r3}: sampler_comparison;`), r3;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var $t = class {
  constructor(t2) {
    this._membership = t2;
    oe(this, t2.key);
  }
  resourceType = "external-texture";
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout);
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r3}: texture_external;`), r3;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var ta = { r8unorm: p, r8snorm: p, r8uint: d, r8sint: w, r16uint: d, r16sint: w, r16float: p, rg8unorm: p, rg8snorm: p, rg8uint: d, rg8sint: w, r32uint: d, r32sint: w, r32float: p, rg16uint: d, rg16sint: w, rg16float: p, rgba8unorm: p, "rgba8unorm-srgb": p, rgba8snorm: p, rgba8uint: d, rgba8sint: w, bgra8unorm: p, "bgra8unorm-srgb": p, rgb9e5ufloat: p, rgb10a2uint: d, rgb10a2unorm: p, rg11b10ufloat: p, rg32uint: d, rg32sint: w, rg32float: p, rgba16uint: d, rgba16sint: w, rgba16float: p, rgba32uint: d, rgba32sint: w, rgba32float: p, stencil8: p, depth16unorm: p, depth24plus: p, "depth24plus-stencil8": p, depth32float: p, "depth32float-stencil8": p, "bc1-rgba-unorm": p, "bc1-rgba-unorm-srgb": p, "bc2-rgba-unorm": p, "bc2-rgba-unorm-srgb": p, "bc3-rgba-unorm": p, "bc3-rgba-unorm-srgb": p, "bc4-r-unorm": p, "bc4-r-snorm": p, "bc5-rg-unorm": p, "bc5-rg-snorm": p, "bc6h-rgb-ufloat": p, "bc6h-rgb-float": p, "bc7-rgba-unorm": p, "bc7-rgba-unorm-srgb": p, "etc2-rgb8unorm": p, "etc2-rgb8unorm-srgb": p, "etc2-rgb8a1unorm": p, "etc2-rgb8a1unorm-srgb": p, "etc2-rgba8unorm": p, "etc2-rgba8unorm-srgb": p, "eac-r11unorm": p, "eac-r11snorm": p, "eac-rg11unorm": p, "eac-rg11snorm": p, "astc-4x4-unorm": p, "astc-4x4-unorm-srgb": p, "astc-5x4-unorm": p, "astc-5x4-unorm-srgb": p, "astc-5x5-unorm": p, "astc-5x5-unorm-srgb": p, "astc-6x5-unorm": p, "astc-6x5-unorm-srgb": p, "astc-6x6-unorm": p, "astc-6x6-unorm-srgb": p, "astc-8x5-unorm": p, "astc-8x5-unorm-srgb": p, "astc-8x6-unorm": p, "astc-8x6-unorm-srgb": p, "astc-8x8-unorm": p, "astc-8x8-unorm-srgb": p, "astc-10x5-unorm": p, "astc-10x5-unorm-srgb": p, "astc-10x6-unorm": p, "astc-10x6-unorm-srgb": p, "astc-10x8-unorm": p, "astc-10x8-unorm-srgb": p, "astc-10x10-unorm": p, "astc-10x10-unorm-srgb": p, "astc-12x10-unorm": p, "astc-12x10-unorm-srgb": p, "astc-12x12-unorm": p, "astc-12x12-unorm-srgb": p, r16snorm: p, r16unorm: p, rg16unorm: p, rg16snorm: p, rgba16unorm: p, rgba16snorm: p };
var at2 = { rgba8unorm: Z, rgba8snorm: Z, rgba8uint: yt, rgba8sint: ut, rgba16uint: yt, rgba16sint: ut, rgba16float: Z, r32uint: yt, r32sint: ut, r32float: Z, rg32uint: yt, rg32sint: ut, rg32float: Z, rgba32uint: yt, rgba32sint: ut, rgba32float: Z, bgra8unorm: Z };
var ra = { f32: "float", u32: "uint", i32: "sint" };
var na = { float: p, "unfilterable-float": p, uint: d, sint: w, depth: p };
function aa(e10, t2) {
  return new Rr(e10, t2);
}
function Z4(e10) {
  return e10?.resourceType === "texture" && !!e10[r];
}
function ot2(e10) {
  return e10?.resourceType === "texture-storage-view" && !!e10[r];
}
function it2(e10) {
  return e10?.resourceType === "texture-sampled-view" && !!e10[r];
}
var oa = { mutable: "read_write", readonly: "read", writeonly: "write" };
var Rr = class {
  constructor(t2, r3) {
    this.props = t2;
    this._branch = r3;
    this[r] = { unwrap: () => {
      if (this._destroyed) throw new Error("This texture has been destroyed");
      return this._texture || (this._texture = this._branch.device.createTexture({ label: f(this) ?? "<unnamed>", format: this.props.format, size: this.props.size, usage: this._flags, dimension: this.props.dimension ?? "2d", viewFormats: this.props.viewFormats ?? [], mipLevelCount: this.props.mipLevelCount ?? 1, sampleCount: this.props.sampleCount ?? 1 })), this._texture;
    } };
  }
  [r];
  resourceType = "texture";
  usableAsSampled = false;
  usableAsStorage = false;
  usableAsRender = false;
  _destroyed = false;
  _flags = GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
  _texture = null;
  $name(t2) {
    return oe(this, t2), this;
  }
  $usage(...t2) {
    let r3 = t2.includes("storage"), n = t2.includes("sampled"), a = t2.includes("render");
    return this._flags |= n ? GPUTextureUsage.TEXTURE_BINDING : 0, this._flags |= r3 ? GPUTextureUsage.STORAGE_BINDING : 0, this._flags |= a ? GPUTextureUsage.RENDER_ATTACHMENT : 0, this.usableAsStorage ||= r3, this.usableAsSampled ||= n, this.usableAsRender ||= a, this;
  }
  createView(t2, r3) {
    if (t2 === "sampled") return this._asSampled(r3);
    let n = r3;
    switch (t2) {
      case "mutable":
        return this._asMutable(n);
      case "readonly":
        return this._asReadonly(n);
      case "writeonly":
        return this._asWriteonly(n);
    }
  }
  _asStorage(t2, r3) {
    if (!this.usableAsStorage) throw new Error("Unusable as storage");
    let n = t2?.format ?? this.props.format, a = at2[n];
    return K(!!a, `Unsupported storage texture format: ${n}`), new $r(t2 ?? {}, r3, this);
  }
  _asReadonly(t2) {
    return this._asStorage(t2, "readonly");
  }
  _asWriteonly(t2) {
    return this._asStorage(t2, "writeonly");
  }
  _asMutable(t2) {
    return this._asStorage(t2, "mutable");
  }
  _asSampled(t2) {
    if (!this.usableAsSampled) throw new Error("Unusable as sampled");
    let r3 = t2?.format ?? this.props.format;
    if (!at2[r3]) throw new Error(`Unsupported storage texture format: ${r3}`);
    return new Gr(t2, this);
  }
  destroy() {
    this._destroyed || (this._destroyed = true, this._texture?.destroy());
  }
};
var Et = { "1d": "1d", "2d": "2d", "2d-array": "2d_array", cube: "cube", "cube-array": "cube_array", "3d": "3d" };
var $r = class {
  constructor(t2, r3, n) {
    this.access = r3;
    this._texture = n;
    this[se] = this, this[r] = { unwrap: () => (this._view || (this._view = this._texture[r].unwrap().createView({ label: `${f(this) ?? "<unnamed>"} - View`, format: this._format, dimension: this.dimension })), this._view) }, this[G] = n, this.dimension = t2?.dimension ?? n.props.dimension ?? "2d", this._format = t2?.format ?? n.props.format, this.texelDataType = at2[this._format];
  }
  [se];
  [r];
  [G];
  resourceType = "texture-storage-view";
  texelDataType;
  dimension;
  _view;
  _format;
  $name(t2) {
    return this._texture.$name(t2), this;
  }
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), { group: n, binding: a } = t2.allocateFixedEntry({ storageTexture: this._format, access: this.access, viewDimension: this.dimension }, this), o4 = `texture_storage_${Et[this.dimension]}`;
    return t2.addDeclaration(`@group(${n}) @binding(${a}) var ${r3}: ${o4}<${this._format}, ${oa[this.access]}>;`), r3;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Gt2 = class {
  constructor(t2, r3, n, a) {
    this._format = t2;
    this.dimension = r3;
    this.access = n;
    this._membership = a;
    this[se] = this, this[r] = {}, this.texelDataType = at2[this._format], oe(this, a.key);
  }
  [se];
  [r];
  resourceType = "texture-storage-view";
  texelDataType;
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout), a = `texture_storage_${Et[this.dimension]}`;
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r3}: ${a}<${this._format}, ${oa[this.access]}>;`), r3;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Gr = class {
  constructor(t2, r3) {
    this._props = t2;
    this._texture = r3;
    this[se] = this, this[r] = { unwrap: () => (this._view || (this._view = this._texture[r].unwrap().createView({ label: `${f(this) ?? "<unnamed>"} - View`, ...this._props })), this._view) }, this[G] = r3, this.dimension = t2?.dimension ?? r3.props.dimension ?? "2d", this._format = t2?.format ?? r3.props.format, this.channelDataType = ta[this._format];
  }
  [se];
  [r];
  [G];
  resourceType = "texture-sampled-view";
  channelDataType;
  dimension;
  _format;
  _view;
  $name(t2) {
    return this._texture.$name(t2), this;
  }
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), n = (this._texture.props.sampleCount ?? 1) > 1, { group: a, binding: o4 } = t2.allocateFixedEntry({ texture: ra[this.channelDataType.type], viewDimension: this.dimension, multisampled: n }, this), i = n ? "texture_multisampled_2d" : `texture_${Et[this.dimension]}`;
    return t2.addDeclaration(`@group(${a}) @binding(${o4}) var ${r3}: ${i}<${t2.resolve(this.channelDataType)}>;`), r3;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
var Vt = class {
  constructor(t2, r3, n, a) {
    this.dimension = r3;
    this._multisampled = n;
    this._membership = a;
    this[se] = this, this[r] = {}, oe(this, a.key), this.channelDataType = na[t2];
  }
  [se];
  [r];
  resourceType = "texture-sampled-view";
  channelDataType;
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this)), n = t2.allocateLayoutEntry(this._membership.layout), a = this._multisampled ? "texture_multisampled_2d" : `texture_${Et[this.dimension]}`;
    return t2.addDeclaration(`@group(${n}) @binding(${this._membership.idx}) var ${r3}: ${a}<${t2.resolve(this.channelDataType)}>;`), r3;
  }
  toString() {
    return `${this.resourceType}:${f(this) ?? "<unnamed>"}`;
  }
};
function Vr(e10) {
  return !!e10?.usableAsSampled;
}
function so(e10) {
  return !!e10?.usableAsRender;
}
var _t2 = class e3 extends Error {
  constructor(t2) {
    super(`Resource '${f(t2) ?? "<unnamed>"}' cannot be bound as 'sampled'. Use .$usage('sampled') to allow it.`), Object.setPrototypeOf(this, e3.prototype);
  }
};
function kt(e10) {
  return new _r(e10);
}
function Lt2(e10) {
  return !!e10 && e10.resourceType === "bind-group-layout";
}
function kr(e10) {
  return !!e10 && e10.resourceType === "bind-group";
}
var Er = class e4 extends Error {
  constructor(t2, r3) {
    super(`Bind group '${t2 ?? "<unnamed>"}' is missing a required binding '${r3}'`), Object.setPrototypeOf(this, e4.prototype);
  }
};
var ia = ["compute"];
var ke2 = ["compute", "vertex", "fragment"];
var _r = class {
  constructor(t2) {
    this.entries = t2;
    let r3 = 0;
    for (let [n, a] of Object.entries(t2)) {
      if (a === null) {
        r3++;
        continue;
      }
      let o4 = { layout: this, key: n, idx: r3 };
      if ("uniform" in a && (this.bound[n] = new et3("uniform", a.uniform, o4)), "storage" in a) {
        let i = "type" in a.storage ? a.storage : a.storage(0);
        this.bound[n] = new et3(a.access ?? "readonly", i, o4);
      }
      "texture" in a && (this.bound[n] = new Vt(a.texture, a.viewDimension ?? "2d", a.multisampled ?? false, o4)), "storageTexture" in a && (this.bound[n] = new Gt2(a.storageTexture, a.viewDimension ?? "2d", a.access ?? "writeonly", o4)), "externalTexture" in a && (this.bound[n] = new $t(o4)), "sampler" in a && (a.sampler === "comparison" ? this.bound[n] = new Rt2(o4) : this.bound[n] = new Ct(o4)), "texture" in a || "storageTexture" in a || "externalTexture" in a || "sampler" in a ? this.value[n] = this.bound[n] : Object.defineProperty(this.value, n, { get: () => this.bound[n].value }), r3++;
    }
  }
  [r] = true;
  _index;
  resourceType = "bind-group-layout";
  bound = {};
  value = {};
  $ = this.value;
  toString() {
    return `bindGroupLayout:${f(this) ?? "<unnamed>"}`;
  }
  get index() {
    return this._index;
  }
  $name(t2) {
    return oe(this, t2), this;
  }
  $idx(t2) {
    return this._index = t2, this;
  }
  unwrap(t2) {
    return t2.device.createBindGroupLayout({ label: f(this) ?? "<unnamed>", entries: Object.values(this.entries).map((n, a) => {
      if (n === null) return null;
      let o4 = n.visibility, i = { binding: a, visibility: 0 };
      if ("uniform" in n) o4 = o4 ?? ke2, i.buffer = { type: "uniform" };
      else if ("storage" in n) o4 = o4 ?? (n.access === "mutable" ? ia : ke2), i.buffer = { type: n.access === "mutable" ? "storage" : "read-only-storage" };
      else if ("sampler" in n) o4 = o4 ?? ke2, i.sampler = { type: n.sampler };
      else if ("texture" in n) o4 = o4 ?? ke2, i.texture = { sampleType: n.texture, viewDimension: n.viewDimension ?? "2d", multisampled: n.multisampled ?? false };
      else if ("storageTexture" in n) {
        let s = n.access ?? "writeonly";
        o4 = o4 ?? (s === "readonly" ? ke2 : ia), i.storageTexture = { format: n.storageTexture, access: { mutable: "read-write", readonly: "read-only", writeonly: "write-only" }[s], viewDimension: n.viewDimension ?? "2d" };
      } else "externalTexture" in n && (o4 = o4 ?? ke2, i.externalTexture = {});
      return o4?.includes("compute") && (i.visibility |= GPUShaderStage.COMPUTE), o4?.includes("vertex") && (i.visibility |= GPUShaderStage.VERTEX), o4?.includes("fragment") && (i.visibility |= GPUShaderStage.FRAGMENT), i;
    }).filter((n) => n !== null) });
  }
};
var Le2 = class {
  constructor(t2, r3) {
    this.layout = t2;
    this.entries = r3;
    for (let n of Object.keys(t2.entries)) if (t2.entries[n] !== null && !(n in r3)) throw new Er(f(t2), n);
  }
  resourceType = "bind-group";
  unwrap(t2) {
    return t2.device.createBindGroup({ label: f(this.layout) ?? "<unnamed>", layout: t2.unwrap(this.layout), entries: Object.entries(this.layout.entries).map(([n, a], o4) => {
      if (a === null) return null;
      let i = this.entries[n];
      if (i === void 0) throw new Error(`'${n}' is a resource required to populate bind group layout '${f(this.layout) ?? "<unnamed>"}'.`);
      if ("uniform" in a) {
        let s;
        if (de3(i)) {
          if (!Bt(i)) throw new ye(i);
          s = { buffer: t2.unwrap(i) };
        } else s = { buffer: i };
        return { binding: o4, resource: s };
      }
      if ("storage" in a) {
        let s;
        if (de3(i)) {
          if (!ve3(i)) throw new Xe2(i);
          s = { buffer: t2.unwrap(i) };
        } else s = { buffer: i };
        return { binding: o4, resource: s };
      }
      if ("texture" in a) {
        let s;
        if (Z4(i)) {
          if (!Vr(i)) throw new _t2(i);
          s = t2.unwrap(i.createView("sampled"));
        } else it2(i) ? s = t2.unwrap(i) : s = i;
        return { binding: o4, resource: s };
      }
      if ("storageTexture" in a) {
        let s;
        if (Z4(i)) {
          if (!ve3(i)) throw new Xe2(i);
          a.access === "readonly" ? s = t2.unwrap(i.createView("readonly")) : a.access === "mutable" ? s = t2.unwrap(i.createView("mutable")) : s = t2.unwrap(i.createView("writeonly"));
        } else ot2(i) ? s = t2.unwrap(i) : s = i;
        return { binding: o4, resource: s };
      }
      if ("sampler" in a) return rt2(i) || nt2(i) ? { binding: o4, resource: t2.unwrap(i) } : { binding: o4, resource: i };
      if ("externalTexture" in a) return { binding: o4, resource: i };
      throw new Error(`Malformed bind group entry: ${i} (${JSON.stringify(i)})`);
    }).filter((n) => n !== null) });
  }
};
var { NodeTypeCatalog: D2 } = tinyest_exports;
var po = ["==", "!=", "<", "<=", ">", ">=", "<<", ">>", "+", "-", "*", "/", "%", "|", "^", "&", "&&", "||"];
var lo = ["&&", "||", "==", "!=", "<", "<=", ">", ">="];
function sa(e10, t2, r3) {
  return r3 ? lo.includes(t2) ? x : t2 === "=" ? r3 : e10 : t2 === "!" || t2 === "~" ? x : e10;
}
function mo(e10) {
  throw new Error(`'${JSON.stringify(e10)}' was not handled by the WGSL generator.`);
}
function ua(e10, [t2, r3]) {
  e10.pushBlockScope();
  try {
    return `${e10.indent()}{
${r3.map((n) => De3(e10, n)).join(`
`)}
${e10.dedent()}}`;
  } finally {
    e10.popBlockScope();
  }
}
function fo(e10, t2, r3) {
  return e10.defineVariable(t2, r3);
}
function Lr(e10, t2) {
  let r3 = e10.getById(t2);
  if (!r3) throw new Error(`Identifier ${t2} not found`);
  return r3;
}
function G3(e10, t2) {
  if (typeof t2 == "string") return Lr(e10, t2);
  if (typeof t2 == "boolean") return u(t2 ? "true" : "false", x);
  if (t2[0] === D2.logicalExpr || t2[0] === D2.binaryExpr || t2[0] === D2.assignmentExpr) {
    let [r3, n, a, o4] = t2, i = G3(e10, n), s = G3(e10, o4), p3 = t2[0] === D2.assignmentExpr ? [i.dataType] : [], u4 = z(e10, [i, s], p3), [f2, m2] = u4 || [i, s], g = e10.resolve(f2.value), y2 = e10.resolve(m2.value), x3 = sa(f2.dataType, a, m2.dataType);
    return u(po.includes(a) ? `(${g} ${a} ${y2})` : `${g} ${a} ${y2}`, x3);
  }
  if (t2[0] === D2.postUpdate) {
    let [r3, n, a] = t2, o4 = G3(e10, a), i = e10.resolve(o4.value);
    return u(`${i}${n}`, o4.dataType);
  }
  if (t2[0] === D2.unaryExpr) {
    let [r3, n, a] = t2, o4 = G3(e10, a), i = e10.resolve(o4.value), s = sa(o4.dataType, n);
    return u(`${n}${i}`, s);
  }
  if (t2[0] === D2.memberAccess) {
    let [r3, n, a] = t2, o4 = G3(e10, n);
    if (o4.dataType.type === "unknown") {
      let i = o4.value[a];
      return he3(i);
    }
    return Kt(o4.dataType) ? u(`(*${e10.resolve(o4.value)}).${a}`, Qe2(o4.dataType.inner, a)) : Gt(o4.dataType) && a === "length" ? o4.dataType.elementCount === 0 ? u(`arrayLength(&${e10.resolve(o4.value)})`, d) : u(String(o4.dataType.elementCount), In) : jt(o4.dataType) && a === "columns" ? u(o4.value, o4.dataType) : de(o4.dataType) && De(o4.value) ? he3(o4.value[a]) : u(`${e10.resolve(o4.value)}.${a}`, Qe2(o4.dataType, a));
  }
  if (t2[0] === D2.indexAccess) {
    let [r3, n, a] = t2, o4 = G3(e10, n), i = G3(e10, a), s = e10.resolve(o4.value), p3 = e10.resolve(i.value);
    if (o4.dataType.type === "unknown") {
      if (Array.isArray(a) && a[0] === D2.numericLiteral) return he3(o4.value[a[1]]);
      throw new Error(`Cannot index value ${s} of unknown type with index ${p3}`);
    }
    return Kt(o4.dataType) ? u(`(*${s})[${p3}]`, pr(o4.dataType.inner)) : u(`${s}[${p3}]`, un(o4.dataType) ? pr(o4.dataType) : yn);
  }
  if (t2[0] === D2.numericLiteral) {
    let r3 = lr(t2[1]);
    if (!r3) throw new Error(`Invalid numeric literal ${t2[1]}`);
    return r3;
  }
  if (t2[0] === D2.call) {
    let [r3, n, a] = t2, o4 = G3(e10, n);
    e10.callStack.push(o4.value);
    let s = a.map((m2) => G3(e10, m2)).map((m2) => u(e10.resolve(m2.value), m2.dataType)), p3 = s.map((m2) => m2.value);
    if (e10.callStack.pop(), s.forEach((m2, g) => {
      if (m2.dataType === yn) throw new Error(`Tried to pass '${m2.value}' of unknown type as argument #${g} to '${typeof o4.value == "string" ? o4.value : f(o4.value) ?? "<unnamed>"}()'`);
    }), typeof o4.value == "string") return u(`${o4.value}(${p3.join(", ")})`, o4.dataType);
    if (Yt(o4.value)) {
      let m2 = e10.resolve(o4.value);
      return u(`${m2}(${p3.join(", ")})`, o4.value);
    }
    if (!yr(o4.value)) throw new Error(`Function ${String(o4.value)} ${f(o4.value)} has not been created using TypeGPU APIs. Did you mean to wrap the function with tgpu.fn(args, return)(...) ?`);
    let u4 = o4.value[r]?.argTypes, f2;
    try {
      !u4 || u4 === "keep" ? f2 = s : u4 === "coerce" ? f2 = z(e10, s) ?? s : f2 = (Array.isArray(u4) ? u4 : u4(...s)).map((y2, x3) => [y2, s[x3]]).map(([y2, x3]) => {
        if (x3.dataType.type === "unknown") return console.warn(`Internal error: unknown type when generating expression: ${t2}`), x3;
        let b2 = z(e10, [x3], [y2])?.[0];
        if (!b2) throw new he(`Cannot convert argument of type '${x3.dataType.type}' to '${y2.type}' for function ${f(o4.value)}`, [{ function: o4.value, callStack: e10.callStack, error: `Cannot convert argument of type '${x3.dataType.type}' to '${y2.type}'`, toString: () => f(o4.value) }]);
        return b2;
      });
      let m2 = o4.value(...f2);
      return u(e10.resolve(m2.value), m2.dataType);
    } catch (m2) {
      throw new he(m2, [{ toString: () => f(o4.value) }]);
    }
  }
  if (t2[0] === D2.objectExpr) {
    let r3 = t2[1], n = e10.callStack[e10.callStack.length - 1];
    if (Yt(n)) {
      let a = Object.keys(n.propTypes), o4 = Object.fromEntries(a.map((s) => {
        let p3 = r3[s];
        if (p3 === void 0) throw new Error(`Missing property ${s} in object literal for struct ${n}`);
        return [s, G3(e10, p3)];
      })), i = fr(e10, n, o4);
      return u(i.map((s) => e10.resolve(s.value)).join(", "), n);
    }
    if (yr(n)) {
      let a = n[r]?.argTypes;
      if (typeof a == "object" && a !== null) {
        let o4 = Object.keys(a), i = {};
        for (let s of o4) {
          let p3 = r3[s];
          if (p3 === void 0) throw new Error(`Missing property ${s} in object literal for function ${n}`);
          let u4 = G3(e10, p3), f2 = a[s], m2 = z(e10, [u4], [f2]);
          i[s] = m2?.[0] ?? u4;
        }
        return u(i, yn);
      }
    }
    throw new Error("Object expressions are only allowed as return values of functions or as arguments to structs.");
  }
  if (t2[0] === D2.arrayExpr) {
    let [r3, n] = t2, a = n.map((m2) => G3(e10, m2));
    if (a.length === 0) throw new Error("Cannot create empty array literal.");
    let o4 = z(e10, a);
    if (!o4) throw new Error("The given values cannot be automatically converted to a common type. Consider explicitly casting them.");
    let i = o4[0]?.dataType, s = i.type === "abstractFloat" ? p : i.type === "abstractInt" ? w : i, u4 = `array<${e10.resolve(s)}, ${a.length}>`, f2 = o4.map((m2) => e10.resolve(m2.value));
    return u(`${u4}( ${f2.join(", ")} )`, j(s, a.length));
  }
  if (t2[0] === D2.stringLiteral) throw new Error("Cannot use string literals in TGSL.");
  if (t2[0] === D2.preUpdate) throw new Error("Cannot use pre-updates in TGSL.");
  mo(t2);
}
function Ot2(e10) {
  return typeof e10 != "object" || e10[0] !== D2.block ? [D2.block, [e10]] : e10;
}
function De3(e10, t2) {
  if (typeof t2 == "string") return `${e10.pre}${e10.resolve(Lr(e10, t2).value)};`;
  if (typeof t2 == "boolean") return `${e10.pre}${t2 ? "true" : "false"};`;
  if (t2[0] === D2.return) {
    let r3 = t2[1], n = r3 !== void 0 ? e10.resolve(G3(e10, r3).value) : void 0;
    if (Yt(e10.callStack[e10.callStack.length - 1]) && typeof r3 == "object" && r3[0] === D2.objectExpr) {
      let a = e10.resolve(e10.callStack[e10.callStack.length - 1]);
      return `${e10.pre}return ${a}(${n});`;
    }
    return n ? `${e10.pre}return ${n};` : `${e10.pre}return;`;
  }
  if (t2[0] === D2.if) {
    let [r3, n, a, o4] = t2, i = G3(e10, n), s = i, p3 = z(e10, [i], [x]);
    p3?.[0] && ([s] = p3);
    let u4 = e10.resolve(s.value);
    e10.indent();
    let f2 = De3(e10, Ot2(a));
    e10.dedent(), e10.indent();
    let m2 = o4 ? De3(e10, Ot2(o4)) : void 0;
    return e10.dedent(), m2 ? `${e10.pre}if (${u4})
${f2}
${e10.pre}else
${m2}` : `${e10.pre}if (${u4})
${f2}`;
  }
  if (t2[0] === D2.let || t2[0] === D2.const) {
    let [r3, n, a] = t2, o4 = a !== void 0 ? G3(e10, a) : void 0;
    if (!o4) throw new Error(`Cannot create variable '${n}' without an initial value.`);
    if (Re(o4.dataType)) throw new Error(`Cannot create variable '${n}' with loose data type.`);
    fo(e10, n, dr(o4.dataType));
    let i = e10.resolve(Lr(e10, n).value);
    if (typeof a == "object" && a[0] === D2.objectExpr && Yt(e10.callStack[e10.callStack.length - 1])) {
      let s = e10.callStack[e10.callStack.length - 1], p3 = a[1], u4 = {};
      for (let [g, y2] of Object.entries(p3)) {
        if (!y2) throw new Error(`Missing property ${g} in object literal`);
        u4[g] = G3(e10, y2);
      }
      let f2 = fr(e10, s, u4), m2 = e10.resolve(s);
      return `${e10.pre}var ${i} = ${m2}(${f2.map((g) => e10.resolve(g.value)).join(", ")});`;
    }
    return `${e10.pre}var ${i} = ${e10.resolve(o4.value)};`;
  }
  if (t2[0] === D2.block) return ua(e10, t2);
  if (t2[0] === D2.for) {
    let [r3, n, a, o4, i] = t2, s = n ? De3(e10, n) : void 0, p3 = s ? s.slice(0, -1) : "", u4 = a ? G3(e10, a) : void 0, f2 = u4;
    if (u4) {
      let b2 = z(e10, [u4], [x]);
      b2?.[0] && ([f2] = b2);
    }
    let m2 = f2 ? e10.resolve(f2.value) : "", g = o4 ? De3(e10, o4) : void 0, y2 = g ? g.slice(0, -1) : "";
    e10.indent();
    let x3 = De3(e10, Ot2(i));
    return e10.dedent(), `${e10.pre}for (${p3}; ${m2}; ${y2})
${x3}`;
  }
  if (t2[0] === D2.while) {
    let [r3, n, a] = t2, o4 = G3(e10, n), i = o4;
    if (o4) {
      let u4 = z(e10, [o4], [x]);
      u4?.[0] && ([i] = u4);
    }
    let s = e10.resolve(i.value);
    e10.indent();
    let p3 = De3(e10, Ot2(a));
    return e10.dedent(), `${e10.pre}while (${s})
${p3}`;
  }
  return t2[0] === D2.continue ? `${e10.pre}continue;` : t2[0] === D2.break ? `${e10.pre}break;` : `${e10.pre}${e10.resolve(G3(e10, t2).value)};`;
}
function pa(e10, t2) {
  return ua(e10, t2);
}
var la = "#CATCHALL#";
var Wr = class {
  _stack = [];
  _itemDepth = 0;
  get itemDepth() {
    return this._itemDepth;
  }
  get topItem() {
    let t2 = this._stack[this._stack.length - 1];
    if (!t2 || t2.type !== "item") throw new Error("Internal error, expected item layer to be on top.");
    return t2;
  }
  pushItem() {
    this._itemDepth++, this._stack.push({ type: "item", usedSlots: /* @__PURE__ */ new Set() });
  }
  popItem() {
    this.pop("item");
  }
  pushSlotBindings(t2) {
    this._stack.push({ type: "slotBinding", bindingMap: new WeakMap(t2) });
  }
  popSlotBindings() {
    this.pop("slotBinding");
  }
  pushFunctionScope(t2, r3, n, a) {
    this._stack.push({ type: "functionScope", args: t2, argAliases: r3, returnType: n, externalMap: a });
  }
  popFunctionScope() {
    this.pop("functionScope");
  }
  pushBlockScope() {
    this._stack.push({ type: "blockScope", declarations: /* @__PURE__ */ new Map() });
  }
  popBlockScope() {
    this.pop("blockScope");
  }
  pop(t2) {
    let r3 = this._stack[this._stack.length - 1];
    if (!r3 || t2 && r3.type !== t2) throw new Error(`Internal error, expected a ${t2} layer to be on top.`);
    this._stack.pop(), t2 === "item" && this._itemDepth--;
  }
  readSlot(t2) {
    for (let r3 = this._stack.length - 1; r3 >= 0; --r3) {
      let n = this._stack[r3];
      if (n?.type === "item") n.usedSlots.add(t2);
      else if (n?.type === "slotBinding") {
        let a = n.bindingMap.get(t2);
        if (a !== void 0) return a;
      } else if (!(n?.type === "functionScope" || n?.type === "blockScope")) throw new Error("Unknown layer type.");
    }
    return t2.defaultValue;
  }
  getSnippetById(t2) {
    for (let r3 = this._stack.length - 1; r3 >= 0; --r3) {
      let n = this._stack[r3];
      if (n?.type === "functionScope") {
        let a = n.args.find((i) => i.value === t2);
        if (a !== void 0) return a;
        if (n.argAliases[t2]) return n.argAliases[t2];
        let o4 = n.externalMap[t2];
        return o4 != null ? he3(o4) : void 0;
      }
      if (n?.type === "blockScope") {
        let a = n.declarations.get(t2);
        if (a !== void 0) return u(t2, a);
      }
    }
  }
  defineBlockVariable(t2, r3) {
    if (r3.type === "unknown") throw Error(`Tried to define variable '${t2}' of unknown type`);
    for (let n = this._stack.length - 1; n >= 0; --n) {
      let a = this._stack[n];
      if (a?.type === "blockScope") return a.declarations.set(t2, r3), u(t2, r3);
    }
    throw new Error("No block scope found to define a variable in.");
  }
};
var Wt2 = ["", "  ", "    ", "      ", "        ", "          ", "            ", "              ", "                "];
var Or = Wt2.length - 1;
var Mr = class {
  identLevel = 0;
  get pre() {
    return Wt2[this.identLevel] ?? Wt2[Or].repeat(this.identLevel / Or) + Wt2[this.identLevel % Or];
  }
  indent() {
    let t2 = this.pre;
    return this.identLevel++, t2;
  }
  dedent() {
    return this.identLevel--, this.pre;
  }
};
var Nr = class {
  _memoizedResolves = /* @__PURE__ */ new WeakMap();
  _memoizedDerived = /* @__PURE__ */ new WeakMap();
  _indentController = new Mr();
  _itemStateStack = new Wr();
  _declarations = [];
  _varyingLocations;
  get varyingLocations() {
    return this._varyingLocations;
  }
  [r] = { itemStateStack: this._itemStateStack };
  bindGroupLayoutsToPlaceholderMap = /* @__PURE__ */ new Map();
  _nextFreeLayoutPlaceholderIdx = 0;
  fixedBindings = [];
  callStack = [];
  names;
  constructor(t2) {
    this.names = t2.names;
  }
  get pre() {
    return this._indentController.pre;
  }
  indent() {
    return this._indentController.indent();
  }
  dedent() {
    return this._indentController.dedent();
  }
  getById(t2) {
    let r3 = this._itemStateStack.getSnippetById(t2);
    return r3 === void 0 ? null : r3;
  }
  defineVariable(t2, r3) {
    return this._itemStateStack.defineBlockVariable(t2, r3);
  }
  pushBlockScope() {
    this._itemStateStack.pushBlockScope();
  }
  popBlockScope() {
    this._itemStateStack.popBlockScope();
  }
  fnToWgsl(t2) {
    this._itemStateStack.pushFunctionScope(t2.args, t2.argAliases, t2.returnType, t2.externalMap);
    try {
      return { head: co(this, t2.args, t2.returnType), body: pa(this, t2.body) };
    } finally {
      this._itemStateStack.popFunctionScope();
    }
  }
  addDeclaration(t2) {
    this._declarations.push(t2);
  }
  allocateLayoutEntry(t2) {
    let r3 = this.bindGroupLayoutsToPlaceholderMap, n = r3.get(t2);
    return n || (n = `#BIND_GROUP_LAYOUT_${this._nextFreeLayoutPlaceholderIdx++}#`, r3.set(t2, n)), n;
  }
  allocateFixedEntry(t2, r3) {
    let n = this.fixedBindings.length;
    return this.fixedBindings.push({ layoutEntry: t2, resource: r3 }), { group: la, binding: n };
  }
  readSlot(t2) {
    let r3 = this._itemStateStack.readSlot(t2);
    if (r3 === void 0) throw new ue(t2);
    return r3;
  }
  withSlots(t2, r3) {
    this._itemStateStack.pushSlotBindings(t2);
    try {
      return r3();
    } finally {
      this._itemStateStack.popSlotBindings();
    }
  }
  withVaryingLocations(t2, r3) {
    this._varyingLocations = t2;
    try {
      return r3();
    } finally {
      this._varyingLocations = void 0;
    }
  }
  unwrap(t2) {
    if (He2(t2)) return this.withSlots(t2[At].pairs, () => this.unwrap(t2[At].inner));
    let r3 = t2;
    for (; ; ) if (Ge2(r3)) r3 = this.readSlot(r3);
    else if (Ve2(r3)) r3 = this._getOrCompute(r3);
    else break;
    return r3;
  }
  _getOrCompute(t2) {
    let r3 = this._memoizedDerived.get(t2) ?? [];
    this._itemStateStack.pushItem();
    try {
      for (let o4 of r3) if ([...o4.slotToValueMap.entries()].every(([s, p3]) => s.areEqual(this._itemStateStack.readSlot(s), p3))) return o4.result;
      pn(je.CPU);
      let n;
      try {
        n = t2["~compute"]();
      } finally {
        mn(je.CPU);
      }
      let a = /* @__PURE__ */ new Map();
      for (let o4 of this._itemStateStack.topItem.usedSlots) a.set(o4, this._itemStateStack.readSlot(o4));
      return r3.push({ slotToValueMap: a, result: n }), this._memoizedDerived.set(t2, r3), n;
    } catch (n) {
      throw n instanceof he ? n.appendToTrace(t2) : new he(n, [t2]);
    } finally {
      this._itemStateStack.popItem();
    }
  }
  _getOrInstantiate(t2) {
    let r3 = this._memoizedResolves.get(t2) ?? [];
    this._itemStateStack.pushItem();
    try {
      for (let o4 of r3) if ([...o4.slotToValueMap.entries()].every(([s, p3]) => s.areEqual(this._itemStateStack.readSlot(s), p3))) return o4.result;
      let n;
      un(t2) ? n = wr(this, t2) : Ve2(t2) || Ge2(t2) ? n = this.resolve(this.unwrap(t2)) : gr(t2) ? n = t2["~resolve"](this) : n = this.resolveValue(t2);
      let a = /* @__PURE__ */ new Map();
      for (let o4 of this._itemStateStack.topItem.usedSlots) a.set(o4, this._itemStateStack.readSlot(o4));
      return r3.push({ slotToValueMap: a, result: n }), this._memoizedResolves.set(t2, r3), n;
    } catch (n) {
      throw n instanceof he ? n.appendToTrace(t2) : new he(n, [t2]);
    } finally {
      this._itemStateStack.popItem();
    }
  }
  resolve(t2) {
    if (He2(t2)) return this.withSlots(t2[At].pairs, () => this.resolve(t2[At].inner));
    if (t2 && typeof t2 == "object" || typeof t2 == "function") {
      if (this._itemStateStack.itemDepth === 0) try {
        pn(je.GPU);
        let r3 = dn(this, () => this._getOrInstantiate(t2));
        return `${[...this._declarations].join(`

`)}${r3}`;
      } finally {
        mn(je.GPU);
      }
      return this._getOrInstantiate(t2);
    }
    return String(t2);
  }
  resolveValue(t2, r3) {
    if (wt(t2)) return this.resolve(t2);
    if (r3 && Gt(r3)) return `array(${t2.map((n) => this.resolveValue(n, r3.elementType))})`;
    if (Array.isArray(t2)) return `array(${t2.map((n) => this.resolveValue(n))})`;
    if (r3 && Yt(r3)) return `${this.resolve(r3)}(${Object.entries(r3.propTypes).map(([n, a]) => this.resolveValue(t2[n], a))})`;
    throw new Error(`Value ${t2} (as json: ${JSON.stringify(t2)}) of schema ${r3} is not resolvable to WGSL`);
  }
};
function fe3(e10, t2) {
  let r3 = new Nr(t2), n = r3.resolve(e10), a = r3.bindGroupLayoutsToPlaceholderMap, o4 = [], i = new Set([...a.keys()].map((m2) => m2.index).filter((m2) => m2 !== void 0)), s = zn(i), p3 = r3.fixedBindings.map((m2, g) => [String(g), m2.layoutEntry]), u4 = () => {
    let m2 = s.next().value, g = kt(Object.fromEntries(p3));
    return o4[m2] = g, n = n.replaceAll(la, String(m2)), [m2, new Le2(g, Object.fromEntries(r3.fixedBindings.map((y2, x3) => [String(x3), y2.resource])))];
  }, f2 = p3.length > 0 ? u4() : void 0;
  for (let [m2, g] of a.entries()) {
    let y2 = m2.index ?? s.next().value;
    o4[y2] = m2, n = n.replaceAll(g, String(y2));
  }
  return { code: n, usedBindGroupLayouts: o4, catchall: f2 };
}
function co(e10, t2, r3) {
  let n = t2.map((a) => `${a.value}: ${e10.resolve(a.dataType)}`).join(", ");
  return r3.type !== "void" ? `(${n}) -> ${Me2(r3)} ${e10.resolve(r3)}` : `(${n})`;
}
function zr(e10) {
  let { externals: t2, template: r3, names: n } = e10, a = {};
  return be3(a, t2 ?? {}), fe3({ "~resolve"(i) {
    return we3(i, a, r3 ?? "");
  }, toString: () => "<root>" }, { names: n === "strict" ? new le3() : new pe2() });
}
function ma(e10) {
  return zr(e10).code;
}
function da(e10, t2, r3, n) {
  return new jr(e10, t2, r3, n);
}
function st2(e10) {
  let t2 = e10;
  return t2?.resourceType === "query-set" && !!t2[r];
}
var jr = class {
  constructor(t2, r3, n, a) {
    this._group = t2;
    this.type = r3;
    this.count = n;
    this.rawQuerySet = a;
    this._ownQuerySet = !a, this._querySet = a || null;
  }
  resourceType = "query-set";
  _querySet = null;
  _ownQuerySet;
  _destroyed = false;
  _available = true;
  _readBuffer = null;
  _resolveBuffer = null;
  get querySet() {
    if (this._destroyed) throw new Error("This QuerySet has been destroyed.");
    return this.rawQuerySet ? this.rawQuerySet : this._querySet ? this._querySet : (this._querySet = this._group.device.createQuerySet({ type: this.type, count: this.count }), this._querySet);
  }
  get destroyed() {
    return this._destroyed;
  }
  get available() {
    return this._available;
  }
  get [r]() {
    let t2 = this;
    return { get readBuffer() {
      return t2._readBuffer || (t2._readBuffer = t2._group.device.createBuffer({ size: t2.count * BigUint64Array.BYTES_PER_ELEMENT, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ })), t2._readBuffer;
    }, get resolveBuffer() {
      return t2._resolveBuffer || (t2._resolveBuffer = t2._group.device.createBuffer({ size: t2.count * BigUint64Array.BYTES_PER_ELEMENT, usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC })), t2._resolveBuffer;
    } };
  }
  $name(t2) {
    return oe(this, t2), this._querySet && (this._querySet.label = t2), this;
  }
  resolve() {
    if (this._destroyed) throw new Error("This QuerySet has been destroyed.");
    if (!this._available) throw new Error("This QuerySet is busy resolving or reading.");
    let t2 = this._group.device.createCommandEncoder();
    t2.resolveQuerySet(this.querySet, 0, this.count, this[r].resolveBuffer, 0), this._group.device.queue.submit([t2.finish()]);
  }
  async read() {
    if (this._group.flush(), !this._resolveBuffer) throw new Error("QuerySet must be resolved before reading.");
    this._available = false;
    try {
      let t2 = this._group.device.createCommandEncoder();
      t2.copyBufferToBuffer(this[r].resolveBuffer, 0, this[r].readBuffer, 0, this.count * BigUint64Array.BYTES_PER_ELEMENT), this._group.device.queue.submit([t2.finish()]), await this._group.device.queue.onSubmittedWorkDone();
      let r3 = this[r].readBuffer;
      await r3.mapAsync(GPUMapMode.READ);
      let n = new BigUint64Array(r3.getMappedRange().slice());
      return r3.unmap(), Array.from(n);
    } finally {
      this._available = true;
    }
  }
  destroy() {
    this._destroyed || (this._destroyed = true, this._querySet && this._ownQuerySet && this._querySet.destroy(), this._readBuffer?.destroy(), this._resolveBuffer?.destroy(), this._readBuffer = this._resolveBuffer = null);
  }
};
var ut2 = class {
  constructor(t2) {
    this._make = t2;
  }
  _map = /* @__PURE__ */ new WeakMap();
  getOrMake(t2, ...r3) {
    if (this._map.has(t2)) return this._map.get(t2);
    let n = this._make(t2, ...r3);
    return this._map.set(t2, n), n;
  }
};
function Mt(e10, t2, r3) {
  if (!r3.enabledFeatures.has("timestamp-query")) throw new Error('Performance callback requires the "timestamp-query" feature to be enabled on GPU device.');
  return e10.timestampWrites ? { ...e10, performanceCallback: t2 } : { ...e10, performanceCallback: t2, hasAutoQuerySet: true, timestampWrites: { querySet: r3.createQuerySet("timestamp", 2), beginningOfPassWriteIndex: 0, endOfPassWriteIndex: 1 } };
}
function Nt(e10, t2, r3) {
  if (!r3.enabledFeatures.has("timestamp-query")) throw new Error('Timestamp writes require the "timestamp-query" feature to be enabled on GPU device.');
  e10.hasAutoQuerySet && e10.timestampWrites && e10.timestampWrites.querySet.destroy();
  let n = { querySet: t2.querySet };
  return t2.beginningOfPassWriteIndex !== void 0 && (n.beginningOfPassWriteIndex = t2.beginningOfPassWriteIndex), t2.endOfPassWriteIndex !== void 0 && (n.endOfPassWriteIndex = t2.endOfPassWriteIndex), { ...e10, hasAutoQuerySet: false, timestampWrites: n };
}
function zt(e10, t2) {
  if (!e10.timestampWrites) return {};
  let { querySet: r3, beginningOfPassWriteIndex: n, endOfPassWriteIndex: a } = e10.timestampWrites, o4 = { querySet: st2(r3) ? t2.unwrap(r3) : r3 };
  return n !== void 0 && (o4.beginningOfPassWriteIndex = n), a !== void 0 && (o4.endOfPassWriteIndex = a), { timestampWrites: o4 };
}
function pt({ root: e10, priors: t2 }) {
  let r3 = t2.timestampWrites?.querySet, n = t2.performanceCallback;
  if (!r3) throw new Error("Cannot dispatch workgroups with performance callback without a query set.");
  if (!st2(r3)) throw new Error("Performance callback with raw GPUQuerySet is not supported. Use TgpuQuerySet instead.");
  e10.commandEncoder.resolveQuerySet(e10.unwrap(r3), 0, r3.count, r3[r].resolveBuffer, 0), e10.flush(), e10.device.queue.onSubmittedWorkDone().then(async () => {
    if (!r3.available) return;
    let a = await r3.read(), o4 = a[t2.timestampWrites?.beginningOfPassWriteIndex ?? 0], i = a[t2.timestampWrites?.endOfPassWriteIndex ?? 1];
    if (o4 === void 0 || i === void 0) throw new Error("QuerySet did not return valid timestamps.");
    await n(o4, i);
  });
}
function fa(e10, t2, r3) {
  return new qr(new Qr(e10, t2, r3), {});
}
function ca(e10) {
  let t2 = e10;
  return t2?.resourceType === "compute-pipeline" && !!t2[r];
}
var qr = class e5 {
  constructor(t2, r3) {
    this._core = t2;
    this._priors = r3;
    this[r] = { get rawPipeline() {
      return t2.unwrap().pipeline;
    }, get priors() {
      return r3;
    } }, this[G] = t2;
  }
  [r];
  resourceType = "compute-pipeline";
  [G];
  "~resolve"(t2) {
    return t2.resolve(this._core);
  }
  toString() {
    return `computePipeline:${f(this) ?? "<unnamed>"}`;
  }
  get rawPipeline() {
    return this._core.unwrap().pipeline;
  }
  with(t2, r3) {
    return new e5(this._core, { ...this._priors, bindGroupLayoutMap: new Map([...this._priors.bindGroupLayoutMap ?? [], [t2, r3]]) });
  }
  withPerformanceCallback(t2) {
    let r3 = Mt(this._priors, t2, this._core.branch);
    return new e5(this._core, r3);
  }
  withTimestampWrites(t2) {
    let r3 = Nt(this._priors, t2, this._core.branch);
    return new e5(this._core, r3);
  }
  dispatchWorkgroups(t2, r3, n) {
    let a = this._core.unwrap(), { branch: o4 } = this._core, i = { label: f(this._core) ?? "<unnamed>", ...zt(this._priors, o4) }, s = o4.commandEncoder.beginComputePass(i);
    s.setPipeline(a.pipeline);
    let p3 = new Set(a.usedBindGroupLayouts);
    if (a.usedBindGroupLayouts.forEach((u4, f2) => {
      if (a.catchall && f2 === a.catchall[0]) s.setBindGroup(f2, o4.unwrap(a.catchall[1])), p3.delete(u4);
      else {
        let m2 = this._priors.bindGroupLayoutMap?.get(u4);
        m2 !== void 0 && (p3.delete(u4), s.setBindGroup(f2, o4.unwrap(m2)));
      }
    }), p3.size > 0) throw new le(p3);
    s.dispatchWorkgroups(t2, r3, n), s.end(), this._priors.performanceCallback && pt({ root: o4, priors: this._priors });
  }
  $name(t2) {
    return oe(this._core, t2), this;
  }
};
var Qr = class {
  constructor(t2, r3, n) {
    this.branch = t2;
    this._slotBindings = r3;
    this._entryFn = n;
  }
  _memo;
  "~resolve"(t2) {
    return t2.withSlots(this._slotBindings, () => (t2.resolve(this._entryFn), ""));
  }
  toString() {
    return "computePipelineCore";
  }
  unwrap() {
    if (this._memo === void 0) {
      let t2 = this.branch.device, r3, n;
      if (Ft?.enabled) {
        let p3 = performance.mark("typegpu:resolution:start");
        r3 = fe3(this, { names: this.branch.nameRegistry }), n = performance.measure("typegpu:resolution", { start: p3.name });
      } else r3 = fe3(this, { names: this.branch.nameRegistry });
      let { code: a, usedBindGroupLayouts: o4, catchall: i } = r3;
      i !== void 0 && o4[i[0]]?.$name(`${f(this) ?? "<unnamed>"} - Automatic Bind Group & Layout`);
      let s = t2.createShaderModule({ label: `${f(this) ?? "<unnamed>"} - Shader`, code: a });
      this._memo = { pipeline: t2.createComputePipeline({ label: f(this) ?? "<unnamed>", layout: t2.createPipelineLayout({ label: `${f(this) ?? "<unnamed>"} - Pipeline Layout`, bindGroupLayouts: o4.map((p3) => this.branch.unwrap(p3)) }), compute: { module: s } }), usedBindGroupLayouts: o4, catchall: i }, Ft?.enabled && (async () => {
        let p3 = performance.mark("typegpu:compile-start");
        await t2.queue.onSubmittedWorkDone();
        let u4 = performance.measure("typegpu:compiled", { start: p3.name });
        Ft?.record("resolution", { resolveDuration: n?.duration, compileDuration: u4.duration, wgslSize: a.length });
      })();
    }
    return this._memo;
  }
};
function Yr(e10, t2 = "vertex") {
  return new Hr(e10, t2);
}
function qt2(e10) {
  return e10?.resourceType === "vertex-layout";
}
var Kr = Symbol("defaultAttribEntry");
function jt2(e10, t2, r3, n, a) {
  if (Te(t2) || sn(t2)) {
    let o4 = hn(t2);
    return o4 !== void 0 && (n[a ?? Kr] = o4), jt2(e10, t2.inner, b(r3, I(t2)), n);
  }
  if (Yt(t2)) {
    let o4 = r3;
    return Object.fromEntries(Object.entries(t2.propTypes).map(([i, s]) => {
      o4 = b(o4, u2(s));
      let p3 = [i, jt2(e10, s, o4, n, i)];
      return o4 += l(s), p3;
    }));
  }
  if (rn(t2)) {
    let o4 = r3;
    return Object.fromEntries(Object.entries(t2.propTypes).map(([i, s]) => {
      o4 = b(o4, I(s));
      let p3 = [i, jt2(e10, s, o4, n, i)];
      return o4 += l(s), p3;
    }));
  }
  if ("type" in t2 && typeof t2.type == "string") {
    if (be.includes(t2.type)) return { _layout: e10, format: t2.type, offset: r3 };
    let o4 = qt[t2.type];
    if (o4) return { _layout: e10, format: o4, offset: r3 };
  }
  throw new Error(`Unsupported data used in vertex layout: ${String(t2)}`);
}
var Hr = class {
  constructor(t2, r3) {
    this.schemaForCount = t2;
    this.stepMode = r3;
    let n = t2(0);
    this.stride = b(l(n.elementType), u2(n)), this.attrib = jt2(this, n.elementType, 0, this._customLocationMap);
  }
  [r] = true;
  resourceType = "vertex-layout";
  stride;
  attrib;
  _customLocationMap = {};
  get vertexLayout() {
    if (this._customLocationMap[Kr] !== void 0) {
      if (typeof this.attrib.format != "string" || typeof this.attrib.offset != "number") throw new Error("Single attribute vertex layouts must have a format and offset.");
      return { arrayStride: this.stride, stepMode: this.stepMode, attributes: [{ format: this.attrib.format, offset: this.attrib.offset, shaderLocation: this._customLocationMap[Kr] }] };
    }
    if (!Object.keys(this.attrib).every((r3) => this._customLocationMap[r3] !== void 0)) throw new Error("All attributes must have custom locations in order to unwrap a vertex layout.");
    return { arrayStride: this.stride, stepMode: this.stepMode, attributes: [...Object.entries(this.attrib).map(([r3, n]) => ({ format: n.format, offset: n.offset, shaderLocation: this._customLocationMap[r3] }))] };
  }
  $name(t2) {
    return oe(this, t2), this;
  }
};
function go(e10) {
  return typeof e10?.loadOp == "string";
}
function ga(e10, t2) {
  if (un(e10)) {
    if (!go(t2)) throw new Error("Expected a single color attachment, not a record.");
    return [t2];
  }
  let r3 = [];
  for (let n of Object.keys(e10)) {
    let a = t2[n];
    if (!a) throw new Error(`A color attachment by the name of '${n}' was not provided to the shader.`);
    r3.push(a);
  }
  return r3;
}
function yo(e10) {
  return typeof e10?.format == "string";
}
function ya(e10, t2) {
  if (un(e10)) {
    if (Jt(e10)) return [];
    if (!yo(t2)) throw new Error("Expected a single color target configuration, not a record.");
    return [t2];
  }
  let r3 = [];
  for (let n of Object.keys(e10)) {
    let a = t2[n];
    if (!a) throw new Error(`A color target by the name of '${n}' was not provided to the shader.`);
    r3.push(a);
  }
  return r3;
}
function Ta(e10) {
  return new Jr(new Xr(e10), {});
}
function xa(e10) {
  let t2 = e10;
  return t2?.resourceType === "render-pipeline" && !!t2[r];
}
var Jr = class e6 {
  [r];
  resourceType = "render-pipeline";
  [G];
  hasIndexBuffer = false;
  constructor(t2, r3) {
    this[r] = { core: t2, priors: r3 }, this[G] = t2;
  }
  "~resolve"(t2) {
    return t2.resolve(this[r].core);
  }
  toString() {
    return `renderPipeline:${f(this) ?? "<unnamed>"}`;
  }
  $name(t2) {
    return oe(this[r].core, t2), this;
  }
  with(t2, r3) {
    let n = this[r];
    if (Lt2(t2)) return new e6(n.core, { ...n.priors, bindGroupLayoutMap: new Map([...n.priors.bindGroupLayoutMap ?? [], [t2, r3]]) });
    if (qt2(t2)) return new e6(n.core, { ...n.priors, vertexLayoutMap: new Map([...n.priors.vertexLayoutMap ?? [], [t2, r3]]) });
    throw new Error("Unsupported value passed into .with()");
  }
  withPerformanceCallback(t2) {
    let r3 = this[r], n = Mt(r3.priors, t2, r3.core.options.branch);
    return new e6(r3.core, n);
  }
  withTimestampWrites(t2) {
    let r3 = this[r], n = Nt(r3.priors, t2, r3.core.options.branch);
    return new e6(r3.core, n);
  }
  withColorAttachment(t2) {
    let r3 = this[r];
    return new e6(r3.core, { ...r3.priors, colorAttachment: t2 });
  }
  withDepthStencilAttachment(t2) {
    let r3 = this[r];
    return new e6(r3.core, { ...r3.priors, depthStencilAttachment: t2 });
  }
  withIndexBuffer(t2, r3, n, a) {
    let o4 = this[r];
    if (Ye2(t2)) {
      if (typeof r3 != "string") throw new Error("If a GPUBuffer is passed, indexFormat must be provided.");
      return new e6(o4.core, { ...o4.priors, indexBuffer: { buffer: t2, indexFormat: r3, offsetBytes: n, sizeBytes: a } });
    }
    let i = { u32: "uint32", u16: "uint16" }, s = t2.dataType.elementType;
    return new e6(o4.core, { ...o4.priors, indexBuffer: { buffer: t2, indexFormat: i[s.type], offsetBytes: r3 !== void 0 ? r3 * lt(s) : void 0, sizeBytes: a !== void 0 ? a * lt(s) : void 0 } });
  }
  setupRenderPass() {
    let t2 = this[r], r3 = t2.core.unwrap(), { branch: n, fragmentFn: a } = t2.core.options, o4 = ga(a.shell.out, t2.priors.colorAttachment ?? {}).map((m2) => Z4(m2.view) ? { ...m2, view: n.unwrap(m2.view).createView() } : m2), i = { label: f(t2.core) ?? "<unnamed>", colorAttachments: o4, ...zt(t2.priors, n) };
    if (t2.priors.depthStencilAttachment !== void 0) {
      let m2 = t2.priors.depthStencilAttachment;
      Z4(m2.view) ? i.depthStencilAttachment = { ...m2, view: n.unwrap(m2.view).createView() } : i.depthStencilAttachment = m2;
    }
    let s = n.commandEncoder.beginRenderPass(i);
    s.setPipeline(r3.pipeline);
    let p3 = new Set(r3.usedBindGroupLayouts);
    r3.usedBindGroupLayouts.forEach((m2, g) => {
      if (r3.catchall && g === r3.catchall[0]) s.setBindGroup(g, n.unwrap(r3.catchall[1])), p3.delete(m2);
      else {
        let y2 = t2.priors.bindGroupLayoutMap?.get(m2);
        y2 !== void 0 && (p3.delete(m2), s.setBindGroup(g, n.unwrap(y2)));
      }
    });
    let u4 = new Set(t2.core.usedVertexLayouts);
    if (t2.core.usedVertexLayouts.forEach((m2, g) => {
      let y2 = t2.priors.vertexLayoutMap?.get(m2);
      y2 && (u4.delete(m2), s.setVertexBuffer(g, n.unwrap(y2)));
    }), p3.size > 0) throw new le(p3);
    if (u4.size > 0) throw new xe(u4);
    return s;
  }
  draw(t2, r3, n, a) {
    let o4 = this[r], i = this.setupRenderPass(), { branch: s } = o4.core.options;
    i.draw(t2, r3, n, a), i.end(), o4.priors.performanceCallback ? pt({ root: s, priors: o4.priors }) : s.flush();
  }
  drawIndexed(t2, r3, n, a, o4) {
    let i = this[r];
    if (!i.priors.indexBuffer) throw new Error("No index buffer set for this render pipeline.");
    let { buffer: s, indexFormat: p3, offsetBytes: u4, sizeBytes: f2 } = i.priors.indexBuffer, m2 = this.setupRenderPass(), { branch: g } = i.core.options;
    Ye2(s) ? m2.setIndexBuffer(s, p3, u4, f2) : m2.setIndexBuffer(g.unwrap(s), p3, u4, f2), m2.drawIndexed(t2, r3, n, a, o4), m2.end(), i.priors.performanceCallback ? pt({ root: g, priors: i.priors }) : g.flush();
  }
};
var Xr = class {
  constructor(t2) {
    this.options = t2;
    let r3 = jn(t2.vertexFn.shell.in ?? {}, t2.vertexAttribs);
    this._vertexBufferLayouts = r3.bufferDefinitions, this.usedVertexLayouts = r3.usedVertexLayouts, this._targets = ya(t2.fragmentFn.shell.out, t2.targets);
  }
  usedVertexLayouts;
  _memo;
  _vertexBufferLayouts;
  _targets;
  "~resolve"(t2) {
    let { vertexFn: r3, fragmentFn: n, slotBindings: a } = this.options, o4 = To(r3.shell.out, n.shell.in, f(r3) ?? "<unnamed>", f(n) ?? "<unnamed>");
    return t2.withVaryingLocations(o4, () => t2.withSlots(a, () => (t2.resolve(r3), t2.resolve(n), "")));
  }
  toString() {
    return "renderPipelineCore";
  }
  unwrap() {
    if (this._memo === void 0) {
      let { branch: t2, primitiveState: r3, depthStencilState: n, multisampleState: a } = this.options, o4 = t2.device, i, s;
      if (Ft?.enabled) {
        let x3 = performance.mark("typegpu:resolution:start");
        i = fe3(this, { names: t2.nameRegistry }), s = performance.measure("typegpu:resolution", { start: x3.name });
      } else i = fe3(this, { names: t2.nameRegistry });
      let { code: p3, usedBindGroupLayouts: u4, catchall: f2 } = i;
      f2 !== void 0 && u4[f2[0]]?.$name(`${f(this) ?? "<unnamed>"} - Automatic Bind Group & Layout`);
      let m2 = o4.createShaderModule({ label: `${f(this) ?? "<unnamed>"} - Shader`, code: p3 }), g = { layout: o4.createPipelineLayout({ label: `${f(this) ?? "<unnamed>"} - Pipeline Layout`, bindGroupLayouts: u4.map((x3) => t2.unwrap(x3)) }), vertex: { module: m2, buffers: this._vertexBufferLayouts }, fragment: { module: m2, targets: this._targets } }, y2 = f(this);
      y2 !== void 0 && (g.label = y2), r3 && (we(r3.stripIndexFormat) ? g.primitive = { ...r3, stripIndexFormat: { u32: "uint32", u16: "uint16" }[r3.stripIndexFormat.type] } : g.primitive = r3), n && (g.depthStencil = n), a && (g.multisample = a), this._memo = { pipeline: o4.createRenderPipeline(g), usedBindGroupLayouts: u4, catchall: f2 }, Ft?.enabled && (async () => {
        let x3 = performance.mark("typegpu:compile-start");
        await o4.queue.onSubmittedWorkDone();
        let b2 = performance.measure("typegpu:compiled", { start: x3.name });
        Ft?.record("resolution", { resolveDuration: s?.duration, compileDuration: b2.duration, wgslSize: p3.length });
      })();
    }
    return this._memo;
  }
};
function To(e10, t2, r3, n) {
  let a = {}, o4 = /* @__PURE__ */ new Set();
  function i(p3, u4) {
    a[p3] = u4, o4.add(u4);
  }
  for (let [p3, u4] of Object.entries(e10)) {
    let f2 = hn(u4);
    f2 !== void 0 && i(p3, f2);
  }
  for (let [p3, u4] of Object.entries(t2 ?? {})) {
    let f2 = hn(u4);
    f2 !== void 0 && (a[p3] === void 0 ? i(p3, f2) : a[p3] !== f2 && console.warn(`Mismatched location between vertexFn (${r3}) output (${a[p3]}) and fragmentFn (${n}) input (${f2}) for the key "${p3}", using the location set on vertex output.`));
  }
  let s = 0;
  for (let p3 of Object.keys(e10 ?? {})) if (!(Dt(e10[p3]) || a[p3] !== void 0)) {
    for (; o4.has(s); ) s++;
    i(p3, s);
  }
  return a;
}
function Zr(e10) {
  return e10 instanceof Ie2;
}
var Ie2 = class {
  constructor(t2, r3) {
    this.resourceType = t2;
    this.buffer = r3;
    this[G] = r3, this.#t = this.buffer.as(this.resourceType);
  }
  [r] = true;
  [G];
  #t;
  $name(t2) {
    return oe(this[G], t2), this;
  }
  write(t2) {
    this.buffer.write(t2);
  }
  writePartial(t2) {
    this.buffer.writePartial(t2);
  }
  read() {
    return this.buffer.read();
  }
  get value() {
    return this.#t.value;
  }
  "~resolve"(t2) {
    return t2.resolve(this.#t);
  }
  get $() {
    return this.value;
  }
};
var en2 = class e7 {
  constructor(t2) {
    this.bindings = t2;
  }
  with(t2, r3) {
    return new e7([...this.bindings, [Ee3(t2) ? t2.slot : t2, r3]]);
  }
  pipe(t2) {
    let r3 = t2(this);
    return new e7([...this.bindings, ...r3.bindings]);
  }
};
var tn2 = class e8 {
  constructor(t2, r3) {
    this._getRoot = t2;
    this._slotBindings = r3;
  }
  with(t2, r3) {
    return new e8(this._getRoot, [...this._slotBindings, [Ee3(t2) ? t2.slot : t2, r3]]);
  }
  withCompute(t2) {
    return new rn3(this._getRoot(), this._slotBindings, t2);
  }
  withVertex(t2, r3) {
    return new nn3({ branch: this._getRoot(), primitiveState: void 0, depthStencilState: void 0, slotBindings: this._slotBindings, vertexFn: t2, vertexAttribs: r3, multisampleState: void 0 });
  }
  pipe(t2) {
    let r3 = t2(new en2([]));
    return new e8(this._getRoot, [...this._slotBindings, ...r3.bindings]);
  }
};
var rn3 = class {
  constructor(t2, r3, n) {
    this._root = t2;
    this._slotBindings = r3;
    this._entryFn = n;
  }
  createPipeline() {
    return fa(this._root, this._slotBindings, this._entryFn);
  }
};
var nn3 = class {
  constructor(t2) {
    this._options = t2;
  }
  withFragment(t2, r3, n) {
    return K(typeof t2 != "string", "Just type mismatch validation"), K(typeof r3 != "string", "Just type mismatch validation"), new an2({ ...this._options, fragmentFn: t2, targets: r3 });
  }
};
var an2 = class e9 {
  constructor(t2) {
    this._options = t2;
  }
  withPrimitive(t2) {
    return new e9({ ...this._options, primitiveState: t2 });
  }
  withDepthStencil(t2) {
    return new e9({ ...this._options, depthStencilState: t2 });
  }
  withMultisample(t2) {
    return new e9({ ...this._options, multisampleState: t2 });
  }
  createPipeline() {
    return Ta(this._options);
  }
};
var Qt = class extends tn2 {
  constructor(r3, n, a) {
    super(() => this, []);
    this.device = r3;
    this.nameRegistry = n;
    this._ownDevice = a;
    this["~unstable"] = this;
  }
  "~unstable";
  _disposables = [];
  _unwrappedBindGroupLayouts = new ut2((r3) => r3.unwrap(this));
  _unwrappedBindGroups = new ut2((r3) => r3.unwrap(this));
  _commandEncoder = null;
  get commandEncoder() {
    return this._commandEncoder || (this._commandEncoder = this.device.createCommandEncoder()), this._commandEncoder;
  }
  get enabledFeatures() {
    return new Set(this.device.features);
  }
  createBuffer(r3, n) {
    let a = tt2(this, r3, n);
    return this._disposables.push(a), a;
  }
  createUniform(r3, n) {
    let a = tt2(this, r3, n).$usage("uniform");
    return this._disposables.push(a), new Ie2("uniform", a);
  }
  createMutable(r3, n) {
    let a = tt2(this, r3, n).$usage("storage");
    return this._disposables.push(a), new Ie2("mutable", a);
  }
  createReadonly(r3, n) {
    let a = tt2(this, r3, n).$usage("storage");
    return this._disposables.push(a), new Ie2("readonly", a);
  }
  createQuerySet(r3, n, a) {
    return da(this, r3, n, a);
  }
  createBindGroup(r3, n) {
    return new Le2(r3, n);
  }
  destroy() {
    for (let r3 of this._disposables) r3.destroy();
    this._ownDevice && this.device.destroy();
  }
  createTexture(r3) {
    let n = aa(r3, this);
    return this._disposables.push(n), n;
  }
  unwrap(r3) {
    if (ca(r3)) return r3[r].rawPipeline;
    if (xa(r3)) return r3[r].core.unwrap().pipeline;
    if (Lt2(r3)) return this._unwrappedBindGroupLayouts.getOrMake(r3);
    if (kr(r3)) return this._unwrappedBindGroups.getOrMake(r3);
    if (de3(r3)) return r3.buffer;
    if (Z4(r3)) return r3[r].unwrap();
    if (ot2(r3)) {
      if (r3[r].unwrap) return r3[r].unwrap();
      throw new Error("Cannot unwrap laid-out texture view.");
    }
    if (it2(r3)) {
      if (r3[r].unwrap) return r3[r].unwrap();
      throw new Error("Cannot unwrap laid-out texture view.");
    }
    if (qt2(r3)) return r3.vertexLayout;
    if (rt2(r3)) {
      if (r3[r].unwrap) return r3[r].unwrap(this);
      throw new Error("Cannot unwrap laid-out sampler.");
    }
    if (nt2(r3)) {
      if (r3[r].unwrap) return r3[r].unwrap(this);
      throw new Error("Cannot unwrap laid-out comparison sampler.");
    }
    if (st2(r3)) return r3.querySet;
    throw new Error(`Unknown resource type: ${r3}`);
  }
  beginRenderPass(r3, n) {
    let a = this.commandEncoder.beginRenderPass(r3), o4 = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s, p3 = () => {
      if (!s) throw new Error("Cannot draw without a call to pass.setPipeline");
      let { core: u4, priors: f2 } = s[r], m2 = u4.unwrap();
      a.setPipeline(m2.pipeline);
      let g = new Set(m2.usedBindGroupLayouts);
      m2.usedBindGroupLayouts.forEach((x3, b2) => {
        if (m2.catchall && b2 === m2.catchall[0]) a.setBindGroup(b2, this.unwrap(m2.catchall[1])), g.delete(x3);
        else {
          let I2 = f2.bindGroupLayoutMap?.get(x3) ?? o4.get(x3);
          I2 !== void 0 && (g.delete(x3), kr(I2) ? a.setBindGroup(b2, this.unwrap(I2)) : a.setBindGroup(b2, I2));
        }
      });
      let y2 = /* @__PURE__ */ new Set();
      if (u4.usedVertexLayouts.forEach((x3, b2) => {
        let I2 = f2.vertexLayoutMap?.get(x3), P2 = I2 ? { buffer: I2, offset: void 0, size: void 0 } : i.get(x3);
        !P2 || !P2.buffer ? y2.add(x3) : de3(P2.buffer) ? a.setVertexBuffer(b2, this.unwrap(P2.buffer), P2.offset, P2.size) : a.setVertexBuffer(b2, P2.buffer, P2.offset, P2.size);
      }), g.size > 0) throw new le(g);
      if (y2.size > 0) throw new xe(y2);
    };
    n({ setViewport(...u4) {
      a.setViewport(...u4);
    }, setScissorRect(...u4) {
      a.setScissorRect(...u4);
    }, setBlendConstant(...u4) {
      a.setBlendConstant(...u4);
    }, setStencilReference(...u4) {
      a.setStencilReference(...u4);
    }, beginOcclusionQuery(...u4) {
      a.beginOcclusionQuery(...u4);
    }, endOcclusionQuery(...u4) {
      a.endOcclusionQuery(...u4);
    }, executeBundles(...u4) {
      a.executeBundles(...u4);
    }, setPipeline(u4) {
      s = u4;
    }, setIndexBuffer: (u4, f2, m2, g) => {
      de3(u4) ? a.setIndexBuffer(this.unwrap(u4), f2, m2, g) : a.setIndexBuffer(u4, f2, m2, g);
    }, setVertexBuffer(u4, f2, m2, g) {
      i.set(u4, { buffer: f2, offset: m2, size: g });
    }, setBindGroup(u4, f2) {
      o4.set(u4, f2);
    }, draw(u4, f2, m2, g) {
      p3(), a.draw(u4, f2, m2, g);
    }, drawIndexed(...u4) {
      p3(), a.drawIndexed(...u4);
    }, drawIndirect(...u4) {
      p3(), a.drawIndirect(...u4);
    }, drawIndexedIndirect(...u4) {
      p3(), a.drawIndexedIndirect(...u4);
    } }), a.end();
  }
  flush() {
    this._commandEncoder && (this.device.queue.submit([this._commandEncoder.finish()]), this._commandEncoder = null);
  }
};
async function ha(e10) {
  let { adapter: t2, device: r3, unstable_names: n = "random" } = e10 ?? {};
  if (!navigator.gpu) throw new Error("WebGPU is not supported by this browser.");
  let a = await navigator.gpu.requestAdapter(t2);
  if (!a) throw new Error("Could not find a compatible GPU");
  let o4 = [];
  for (let i of r3?.requiredFeatures ?? []) {
    if (!a.features.has(i)) throw new Error(`Requested feature "${i}" is not supported by the adapter.`);
    o4.push(i);
  }
  for (let i of r3?.optionalFeatures ?? []) a.features.has(i) ? o4.push(i) : console.warn(`Optional feature "${i}" is not supported by the adapter.`);
  return new Qt(await a.requestDevice({ ...r3, requiredFeatures: o4 }), n === "random" ? new pe2() : new le3(), true);
}
function ba(e10) {
  let { device: t2, unstable_names: r3 = "random" } = e10 ?? {};
  return new Qt(t2, r3 === "random" ? new pe2() : new le3(), false);
}
function lt2(e10) {
  return new on(e10);
}
var on = class {
  constructor(t2 = void 0) {
    this.defaultValue = t2;
  }
  [r] = true;
  resourceType = "slot";
  $name(t2) {
    return oe(this, t2), this;
  }
  areEqual(t2, r3) {
    return Object.is(t2, r3);
  }
  toString() {
    return `slot:${f(this) ?? "<unnamed>"}`;
  }
  [_t](t2) {
    return Ke(t2, t2.unwrap(this));
  }
  get value() {
    let t2 = wn();
    if (!t2) throw new Error("Cannot access tgpu.slot's value outside of resolution.");
    return this[_t](t2);
  }
  get $() {
    return this.value;
  }
};
function wa(e10, t2) {
  return new sn3(e10, t2);
}
var sn3 = class {
  constructor(t2, r3 = void 0) {
    this.schema = t2;
    this.defaultValue = r3;
    this.slot = lt2(r3), this[G] = this.slot;
  }
  [r] = true;
  resourceType = "accessor";
  slot;
  $name(t2) {
    return this.slot.$name(t2), this;
  }
  toString() {
    return `accessor:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this.schema }, H2);
  }
  get value() {
    if (!fe()) throw new Error("`tgpu.accessor` values are only accessible on the GPU");
    return this[_t]();
  }
  get $() {
    return this.value;
  }
  "~resolve"(t2) {
    let r3 = t2.unwrap(this.slot);
    return Rn(r3) || Zr(r3) ? t2.resolve(r3) : hr(r3) ? `${t2.resolve(r3)}()` : t2.resolveValue(r3, this.schema);
  }
};
function Sa(e10) {
  return ho(e10);
}
function xo([e10, t2]) {
  return `${f(e10) ?? "<unnamed>"}=${t2}`;
}
function ho(e10) {
  if (wn()) throw new Error("Cannot create tgpu.derived objects at the resolution stage.");
  return { resourceType: "derived", "~compute": e10, [ie]: void 0, [It]: void 0, [_t](r3) {
    return Ke(r3, r3.unwrap(this));
  }, get value() {
    let r3 = wn();
    if (!r3) throw new Error("Cannot access tgpu.derived's value outside of resolution.");
    return this[_t](r3);
  }, get $() {
    return this.value;
  }, with(r3, n) {
    return va(this, [[r3, n]]);
  }, toString() {
    return "derived";
  } };
}
function va(e10, t2) {
  return { resourceType: "derived", [ie]: void 0, [It]: void 0, "~compute"() {
    throw new Error("'~compute' should never be read on bound derived items.");
  }, [At]: { inner: e10, pairs: t2 }, [_t](n) {
    return Ke(n, n.unwrap(this));
  }, get value() {
    let n = wn();
    if (!n) throw new Error("Cannot access tgpu.derived's value outside of resolution.");
    return this[_t](n);
  }, get $() {
    return this.value;
  }, with(n, a) {
    return va(e10, [...t2, [n, a]]);
  }, toString() {
    return `derived[${t2.map(xo).join(", ")}]`;
  } };
}
function Da(e10, t2) {
  return new Kt2("private", e10, t2);
}
function Ia(e10) {
  return new Kt2("workgroup", e10);
}
var Kt2 = class {
  constructor(t2, r3, n) {
    this.scope = t2;
    this._dataType = r3;
    this._initialValue = n;
    this[r] = { scope: t2 };
  }
  "~resolve"(t2) {
    let r3 = t2.names.makeUnique(f(this));
    return this._initialValue ? t2.addDeclaration(`var<${this.scope}> ${r3}: ${t2.resolve(this._dataType)} = ${t2.resolveValue(this._initialValue, this._dataType)};`) : t2.addDeclaration(`var<${this.scope}> ${r3}: ${t2.resolve(this._dataType)};`), r3;
  }
  $name(t2) {
    return oe(this, t2), this;
  }
  toString() {
    return `var:${f(this) ?? "<unnamed>"}`;
  }
  [_t]() {
    return new Proxy({ "~resolve": (t2) => t2.resolve(this), toString: () => `.value:${f(this) ?? "<unnamed>"}`, [se]: this._dataType }, H2);
  }
  get value() {
    if (!fe()) throw new Error("`tgpu.var` values are only accessible on the GPU");
    return this[_t]();
  }
};
var bo = { fn: xr, bindGroupLayout: kt, vertexLayout: Yr, slot: lt2, init: ha, initFromDevice: ba, resolve: ma, resolveWithContext: zr, "~unstable": { fn: xr, fragmentFn: Nn, vertexFn: zn2, computeFn: Wn, vertexLayout: Yr, derived: Sa, slot: lt2, accessor: wa, privateVar: Da, workgroupVar: Ia, const: Cn, declare: Gn, sampler: Zn, comparisonSampler: ea } };
var um = bo;
export {
  le as MissingBindGroupsError,
  ce as MissingLinksError,
  ue as MissingSlotValueError,
  xe as MissingVertexBuffersError,
  ye as NotUniformError,
  pe2 as RandomNameRegistry,
  he as ResolutionError,
  le3 as StrictNameRegistry,
  um as default,
  de3 as isBuffer,
  Zr as isBufferShorthand,
  nt2 as isComparisonSampler,
  Ve2 as isDerived,
  it2 as isSampledTextureView,
  rt2 as isSampler,
  Ge2 as isSlot,
  ot2 as isStorageTextureView,
  Z4 as isTexture,
  hr as isTgpuFn,
  so as isUsableAsRender,
  Vr as isUsableAsSampled,
  ve3 as isUsableAsStorage,
  Bt as isUsableAsUniform,
  io as isUsableAsVertex,
  bo as tgpu,
  Ir as unstable_asMutable,
  Ur as unstable_asReadonly,
  Fr as unstable_asUniform
};
//# sourceMappingURL=typegpu.js.map
