import {
  BufferReader,
  BufferWriter,
  Ce,
  De as De2,
  Ee,
  G,
  Ge,
  He,
  Je,
  Le,
  Oe,
  Pe,
  Qe,
  Se,
  Ue,
  We,
  Xe,
  Ye,
  Ze,
  _e,
  an,
  c as c2,
  cn,
  en,
  ie,
  je,
  ke,
  me,
  nn,
  pe,
  qe,
  rn,
  sn,
  tn,
  vn,
  xn,
  yn,
  ze
} from "./chunk-ORN3T3RZ.js";
import {
  De,
  Gt,
  H,
  Hn,
  In,
  Kt,
  Tt,
  Wt,
  Z,
  at,
  bt,
  c,
  ct,
  d,
  dt,
  ft,
  gt,
  nt,
  o,
  ot,
  p,
  pt,
  rt,
  u,
  ut,
  w,
  we,
  wt,
  x,
  yt,
  zt
} from "./chunk-VTSB6TYK.js";
import "./chunk-PZ5AY32C.js";

// node_modules/typegpu/std/index.js
var Ve = o(() => {
  throw new Error("discard() can only be used on the GPU.");
}, () => u("discard;", Wt), "discard");
var Ue2 = o((e, t) => me(c.translation(t), e), (e, t) => ({ value: `(${c.translation(t).value} * ${e.value})`, dataType: e.dataType }), "translate4");
var Ee2 = o((e, t) => me(c.scaling(t), e), (e, t) => ({ value: `(${c.scaling(t).value} * ${e.value})`, dataType: e.dataType }), "scale4");
var Oe2 = o((e, t) => me(c.rotationX(t), e), (e, t) => ({ value: `(${c.rotationX(t).value} * ${e.value})`, dataType: e.dataType }), "rotateX4");
var Le2 = o((e, t) => me(c.rotationY(t), e), (e, t) => ({ value: `(${c.rotationY(t).value} * ${e.value})`, dataType: e.dataType }), "rotateY4");
var _e2 = o((e, t) => me(c.rotationZ(t), e), (e, t) => ({ value: `(${c.rotationZ(t).value} * ${e.value})`, dataType: e.dataType }), "rotateZ4");
function g(e) {
  return e.dataType.type.includes("2") ? rt : e.dataType.type.includes("3") ? ot : ct;
}
var Pe2 = o((e, t) => k(b(e, t)), (e, t) => u(`all(${e.value} == ${t.value})`, x), "allEq");
var b = o((e, t) => c2.eq[e.kind](e, t), (e, t) => u(`(${e.value} == ${t.value})`, g(e)), "eq");
var he = o((e, t) => m(b(e, t)), (e, t) => u(`(${e.value} != ${t.value})`, g(e)), "ne");
var w2 = o((e, t) => c2.lt[e.kind](e, t), (e, t) => u(`(${e.value} < ${t.value})`, g(e)), "lt");
var Ge2 = o((e, t) => B(w2(e, t), b(e, t)), (e, t) => u(`(${e.value} <= ${t.value})`, g(e)), "le");
var Ne = o((e, t) => J(m(w2(e, t)), m(b(e, t))), (e, t) => u(`(${e.value} > ${t.value})`, g(e)), "gt");
var Fe = o((e, t) => m(w2(e, t)), (e, t) => u(`(${e.value} >= ${t.value})`, g(e)), "ge");
var m = o((e) => c2.neg[e.kind](e), (e) => u(`!(${e.value})`, e.dataType), "not");
var B = o((e, t) => c2.or[e.kind](e, t), (e, t) => u(`(${e.value} | ${t.value})`, e.dataType), "or");
var J = o((e, t) => m(B(m(e), m(t))), (e, t) => u(`(${e.value} & ${t.value})`, e.dataType), "and");
var k = o((e) => c2.all[e.kind](e), (e) => u(`all(${e.value})`, x), "all");
var We2 = o((e) => !k(m(e)), (e) => u(`any(${e.value})`, x), "any");
var Xe2 = o((e, t, o2 = 0.01) => typeof e == "number" && typeof t == "number" ? Math.abs(e - t) < o2 : De(e) && De(t) ? c2.isCloseToZero[e.kind](ie(e, t), o2) : false, (e, t, o2 = u(0.01, p)) => G(e) && G(t) ? u(`(abs(f32(${e.value}) - f32(${t.value})) <= ${o2.value})`, x) : !G(e) && !G(t) ? u(`all(abs(${e.value} - ${t.value}) <= (${e.value} - ${e.value}) + ${o2.value})`, x) : u("false", x), "isCloseTo");
var Je2 = o((e, t, o2) => typeof o2 == "boolean" ? o2 ? t : e : c2.select[e.kind](e, t, o2), (e, t, o2) => u(`select(${e.value}, ${t.value}, ${o2.value})`, e.dataType), "select");
var Me = o(() => console.warn("workgroupBarrier is a no-op outside of GPU mode."), () => u("workgroupBarrier()", Wt), "workgroupBarrier");
var qe2 = o(() => console.warn("storageBarrier is a no-op outside of GPU mode."), () => u("storageBarrier()", Wt), "storageBarrier");
var Ce2 = o(() => console.warn("textureBarrier is a no-op outside of GPU mode."), () => u("textureBarrier()", Wt), "textureBarrier");
var Ze2 = o((e) => {
  throw new Error("Atomic operations are not supported outside of GPU mode.");
}, (e) => {
  if (we(e.dataType) && e.dataType.type === "atomic") return u(`atomicLoad(&${e.value})`, e.dataType.inner);
  throw new Error(`Invalid atomic type: ${JSON.stringify(e.dataType, null, 2)}`);
}, "atomicLoad");
var Ye2 = o((e, t) => {
  throw new Error("Atomic operations are not supported outside of GPU mode.");
}, (e, t) => {
  if (!we(e.dataType) || e.dataType.type !== "atomic") throw new Error(`Invalid atomic type: ${JSON.stringify(e.dataType, null, 2)}`);
  return u(`atomicStore(&${e.value}, ${t.value})`, Wt);
}, "atomicStore");
var f = (e, t) => e.dataType.type === "atomic" && e.dataType.inner.type === "i32" ? [e.dataType, w] : [e.dataType, d];
var je2 = o((e, t) => {
  throw new Error("Atomic operations are not supported outside of GPU mode.");
}, (e, t) => {
  if (we(e.dataType) && e.dataType.type === "atomic") return u(`atomicAdd(&${e.value}, ${t.value})`, e.dataType.inner);
  throw new Error(`Invalid atomic type: ${JSON.stringify(e.dataType, null, 2)}`);
}, "atomicAdd", f);
var Re = o((e, t) => {
  throw new Error("Atomic operations are not supported outside of GPU mode.");
}, (e, t) => {
  if (we(e.dataType) && e.dataType.type === "atomic") return u(`atomicSub(&${e.value}, ${t.value})`, e.dataType.inner);
  throw new Error(`Invalid atomic type: ${JSON.stringify(e.dataType, null, 2)}`);
}, "atomicSub", f);
var ze2 = o((e, t) => {
  throw new Error("Atomic operations are not supported outside of GPU mode.");
}, (e, t) => {
  if (we(e.dataType) && e.dataType.type === "atomic") return u(`atomicMax(&${e.value}, ${t.value})`, e.dataType.inner);
  throw new Error(`Invalid atomic type: ${JSON.stringify(e.dataType, null, 2)}`);
}, "atomicMax", f);
var He2 = o((e, t) => {
  throw new Error("Atomic operations are not supported outside of GPU mode.");
}, (e, t) => {
  if (we(e.dataType) && e.dataType.type === "atomic") return u(`atomicMin(&${e.value}, ${t.value})`, e.dataType.inner);
  throw new Error(`Invalid atomic type: ${JSON.stringify(e.dataType, null, 2)}`);
}, "atomicMin", f);
var Ke = o((e, t) => {
  throw new Error("Atomic operations are not supported outside of GPU mode.");
}, (e, t) => {
  if (we(e.dataType) && e.dataType.type === "atomic") return u(`atomicAnd(&${e.value}, ${t.value})`, e.dataType.inner);
  throw new Error(`Invalid atomic type: ${JSON.stringify(e.dataType, null, 2)}`);
}, "atomicAnd", f);
var Qe2 = o((e, t) => {
  throw new Error("Atomic operations are not supported outside of GPU mode.");
}, (e, t) => {
  if (we(e.dataType) && e.dataType.type === "atomic") return u(`atomicOr(&${e.value}, ${t.value})`, e.dataType.inner);
  throw new Error(`Invalid atomic type: ${JSON.stringify(e.dataType, null, 2)}`);
}, "atomicOr", f);
var et = o((e, t) => {
  throw new Error("Atomic operations are not supported outside of GPU mode.");
}, (e, t) => {
  if (we(e.dataType) && e.dataType.type === "atomic") return u(`atomicXor(&${e.value}, ${t.value})`, e.dataType.inner);
  throw new Error(`Invalid atomic type: ${JSON.stringify(e.dataType, null, 2)}`);
}, "atomicXor", f);
var tt = o((e) => e.length, (e) => Kt(e.dataType) && Gt(e.dataType.inner) && e.dataType.inner.elementCount > 0 ? u(String(e.dataType.inner.elementCount), In) : u(`arrayLength(${e.value})`, d), "arrayLength", (e) => [Hn(e.dataType)]);
var rt2 = o((e) => {
  let t = new ArrayBuffer(4);
  new BufferWriter(t).writeUint32(e);
  let n = new BufferReader(t);
  return H(n.readFloat16(), n.readFloat16());
}, (e) => u(`unpack2x16float(${e.value})`, H), "unpack2x16float");
var at2 = o((e) => {
  let t = new ArrayBuffer(4), o2 = new BufferWriter(t);
  o2.writeFloat16(e.x), o2.writeFloat16(e.y);
  let n = new BufferReader(t);
  return d(n.readUint32());
}, (e) => u(`pack2x16float(${e.value})`, d), "pack2x16float");
var ot2 = o((e) => {
  let t = new ArrayBuffer(4);
  new BufferWriter(t).writeUint32(e);
  let n = new BufferReader(t);
  return Z(n.readUint8() / 255, n.readUint8() / 255, n.readUint8() / 255, n.readUint8() / 255);
}, (e) => u(`unpack4x8unorm(${e.value})`, Z), "unpack4x8unorm");
var nt2 = o((e) => {
  let t = new ArrayBuffer(4), o2 = new BufferWriter(t);
  o2.writeUint8(e.x * 255), o2.writeUint8(e.y * 255), o2.writeUint8(e.z * 255), o2.writeUint8(e.w * 255);
  let n = new BufferReader(t);
  return d(n.readUint32());
}, (e) => u(`pack4x8unorm(${e.value})`, d), "pack4x8unorm");
var ut2 = o((e, t, o2, n, u2) => {
  throw new Error("Texture sampling is not supported outside of GPU mode.");
}, (e, t, o2, n, u2) => {
  let l = [e, t, o2];
  return n !== void 0 && l.push(n), u2 !== void 0 && l.push(u2), u(`textureSample(${l.map(($) => $.value).join(", ")})`, Z);
}, "textureSample");
var pt2 = o((e, t, o2, n, u2) => {
  throw new Error("Texture sampling is not supported outside of GPU mode.");
}, (e, t, o2, n, u2) => {
  let l = [e, t, o2, n];
  return u2 !== void 0 && l.push(u2), u(`textureSampleLevel(${l.map(($) => $.value).join(", ")})`, Z);
}, "textureSampleLevel");
var it = { u32: yt, i32: ut, f32: Z };
var Tt2 = o((e, t, o2) => {
  throw new Error("Texture loading is not supported outside of GPU mode.");
}, (e, t, o2) => {
  let n = [e, t];
  o2 !== void 0 && n.push(o2);
  let u2 = e.dataType;
  return u(`textureLoad(${n.map((l) => l.value).join(", ")})`, "texelDataType" in u2 ? u2.texelDataType : it[u2.channelDataType.type]);
}, "textureLoad");
var dt2 = o((e, t, o2, n) => {
  throw new Error("Texture storing is not supported outside of GPU mode.");
}, (e, t, o2, n) => u(`textureStore(${[e, t, o2, n].filter((u2) => u2 !== void 0).map((u2) => u2.value).join(", ")})`, Wt), "textureStore");
var st = o((e, t) => {
  throw new Error("Texture dimensions are not supported outside of GPU mode.");
}, (e, t) => {
  let o2 = e.dataType.dimension;
  return u(`textureDimensions(${e.value}${t !== void 0 ? `, ${t.value}` : ""})`, o2 === "1d" ? d : o2 === "3d" ? at : nt);
}, "textureDimensions");
export {
  Le as abs,
  Ue as acos,
  We as acosh,
  ke as add,
  k as all,
  Pe2 as allEq,
  J as and,
  We2 as any,
  tt as arrayLength,
  qe as asin,
  _e as atan2,
  je2 as atomicAdd,
  Ke as atomicAnd,
  Ze2 as atomicLoad,
  ze2 as atomicMax,
  He2 as atomicMin,
  Qe2 as atomicOr,
  Ye2 as atomicStore,
  Re as atomicSub,
  et as atomicXor,
  Ce as ceil,
  Se as clamp,
  De2 as cos,
  Ee as cosh,
  je as cross,
  Ve as discard,
  rn as distance,
  Oe as div,
  ze as dot,
  b as eq,
  nn as exp,
  sn as exp2,
  Ze as floor,
  Ge as fract,
  Fe as ge,
  Ne as gt,
  dt as identity2,
  wt as identity3,
  pt as identity4,
  Xe2 as isCloseTo,
  Ge2 as le,
  pe as length,
  He as log,
  Je as log2,
  w2 as lt,
  Qe as max,
  Xe as min,
  cn as mix,
  me as mul,
  he as ne,
  vn as neg,
  Pe as normalize,
  m as not,
  B as or,
  at2 as pack2x16float,
  nt2 as pack4x8unorm,
  tn as pow,
  an as reflect,
  Oe2 as rotateX4,
  Le2 as rotateY4,
  _e2 as rotateZ4,
  bt as rotationX4,
  ft as rotationY4,
  zt as rotationZ4,
  Ee2 as scale4,
  Tt as scaling4,
  Je2 as select,
  Ye as sign,
  en as sin,
  xn as sqrt,
  qe2 as storageBarrier,
  ie as sub,
  yn as tanh,
  Ce2 as textureBarrier,
  st as textureDimensions,
  Tt2 as textureLoad,
  ut2 as textureSample,
  pt2 as textureSampleLevel,
  dt2 as textureStore,
  Ue2 as translate4,
  gt as translation4,
  rt2 as unpack2x16float,
  ot2 as unpack4x8unorm,
  Me as workgroupBarrier
};
//# sourceMappingURL=typegpu_std.js.map
