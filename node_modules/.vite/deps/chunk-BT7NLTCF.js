import {
  Gt,
  H,
  Re,
  Te,
  X,
  Yt,
  Z,
  Zt,
  an,
  at,
  d,
  f,
  it,
  me,
  nn,
  nt,
  oe,
  on,
  p,
  pe,
  r,
  rn,
  sn,
  tt,
  ut,
  w,
  we,
  x,
  yt
} from "./chunk-VTSB6TYK.js";

// node_modules/typegpu/chunk-S62QJDM6.js
function J(t, e) {
  let r2 = e;
  try {
    r2 = t(e);
  } catch {
    let o = t?.type;
    console.warn(`Schema of type ${o ?? "<unknown>"} is not callable.`);
  }
  return r2;
}
function Z2(t) {
  let e = (r2) => Object.fromEntries(Object.entries(t).map(([o, x2]) => [o, J(x2, r2[o])]));
  return Object.setPrototypeOf(e, tt2), e.propTypes = t, e;
}
var tt2 = { [r]: true, type: "struct", $name(t) {
  return oe(this, t), this;
}, toString() {
  return `struct:${f(this) ?? "<unnamed>"}`;
} };
var b = (t, e) => {
  let r2 = e - 1, o = ~r2;
  return (t & r2) === 0 ? t : (t & o) + e;
};
var n = class {
  constructor(e) {
    this.type = e;
  }
  [r] = true;
};
var et = { uint8: d, uint8x2: nt, uint8x4: yt, sint8: w, sint8x2: tt, sint8x4: ut, unorm8: p, unorm8x2: H, unorm8x4: Z, snorm8: p, snorm8x2: H, snorm8x4: Z, uint16: d, uint16x2: nt, uint16x4: yt, sint16: w, sint16x2: tt, sint16x4: ut, unorm16: p, unorm16x2: H, unorm16x4: Z, snorm16: p, snorm16x2: H, snorm16x4: Z, float16: p, float16x2: H, float16x4: Z, float32: p, float32x2: H, float32x3: X, float32x4: Z, uint32: d, uint32x2: nt, uint32x3: at, uint32x4: yt, sint32: w, sint32x2: tt, sint32x3: it, sint32x4: ut, "unorm10-10-10-2": Z, "unorm8x4-bgra": Z };
var q = Object.keys(et);
var _t = new n("uint8");
var Lt = new n("uint8x2");
var $t = new n("uint8x4");
var Wt = new n("sint8");
var kt = new n("sint8x2");
var Pt = new n("sint8x4");
var Ut = new n("unorm8");
var Ot = new n("unorm8x2");
var zt = new n("unorm8x4");
var Et = new n("snorm8");
var Nt = new n("snorm8x2");
var Ct = new n("snorm8x4");
var Mt = new n("uint16");
var Gt2 = new n("uint16x2");
var jt = new n("uint16x4");
var Rt = new n("sint16");
var Kt = new n("sint16x2");
var Ht = new n("sint16x4");
var Jt = new n("unorm16");
var qt = new n("unorm16x2");
var Qt = new n("unorm16x4");
var Xt = new n("snorm16");
var Yt2 = new n("snorm16x2");
var Zt2 = new n("snorm16x4");
var te = new n("float16");
var ee = new n("float16x2");
var ne = new n("float16x4");
var re = new n("float32");
var oe2 = new n("float32x2");
var ie = new n("float32x3");
var ae = new n("float32x4");
var se = new n("uint32");
var pe2 = new n("uint32x2");
var ue = new n("uint32x3");
var le = new n("uint32x4");
var xe = new n("sint32");
var me2 = new n("sint32x2");
var ce = new n("sint32x3");
var ye = new n("sint32x4");
var fe = new n("unorm10-10-10-2");
var de = new n("unorm8x4-bgra");
var nt2 = { f32: 4, f16: 2, i32: 4, u32: 4, u16: 2, vec2f: 8, vec2h: 4, vec2i: 8, vec2u: 8, vec3f: 16, vec3h: 8, vec3i: 16, vec3u: 16, vec4f: 16, vec4h: 8, vec4i: 16, vec4u: 16, mat2x2f: 8, mat3x3f: 16, mat4x4f: 16, atomic: 4 };
function rt(t) {
  let e = t?.type, r2 = nt2[e];
  if (r2 !== void 0) return r2;
  if (Yt(t)) return Object.values(t.propTypes).map(u).reduce((o, x2) => o > x2 ? o : x2);
  if (Gt(t)) return u(t.elementType);
  if (rn(t)) {
    let o = Object.values(t.propTypes)[0];
    return o ? an(o) ?? 1 : 1;
  }
  if (nn(t)) return an(t.elementType) ?? 1;
  if (Te(t) || sn(t)) return an(t) ?? u(t.inner);
  if (q.includes(e)) return 1;
  throw new Error(`Cannot determine alignment of data: ${JSON.stringify(t)}`);
}
function ot(t) {
  if (rn(t)) {
    let e = Object.values(t.propTypes)[0];
    return e ? I(e) : 1;
  }
  return nn(t) ? I(t.elementType) : sn(t) ? an(t) ?? I(t.inner) : an(t) ?? 1;
}
var Q = /* @__PURE__ */ new WeakMap();
var X2 = /* @__PURE__ */ new WeakMap();
function u(t) {
  let e = Q.get(t);
  return e === void 0 && (e = rt(t), Q.set(t, e)), e;
}
function I(t) {
  let e = X2.get(t);
  return e === void 0 && (e = ot(t), X2.set(t, e)), e;
}
function it2(t) {
  return u(t);
}
var at2 = { f32: 4, f16: 2, i32: 4, u32: 4, u16: 2, vec2f: 8, vec2h: 4, vec2i: 8, vec2u: 8, vec3f: 12, vec3h: 6, vec3i: 12, vec3u: 12, vec4f: 16, vec4h: 8, vec4i: 16, vec4u: 16, mat2x2f: 16, mat3x3f: 48, mat4x4f: 64, uint8: 1, uint8x2: 2, uint8x4: 4, sint8: 1, sint8x2: 2, sint8x4: 4, unorm8: 1, unorm8x2: 2, unorm8x4: 4, snorm8: 1, snorm8x2: 2, snorm8x4: 4, uint16: 2, uint16x2: 4, uint16x4: 8, sint16: 2, sint16x2: 4, sint16x4: 8, unorm16: 2, unorm16x2: 4, unorm16x4: 8, snorm16: 2, snorm16x2: 4, snorm16x4: 8, float16: 2, float16x2: 4, float16x4: 8, float32: 4, float32x2: 8, float32x3: 12, float32x4: 16, uint32: 4, uint32x2: 8, uint32x3: 12, uint32x4: 16, sint32: 4, sint32x2: 8, sint32x3: 12, sint32x4: 16, "unorm10-10-10-2": 4, "unorm8x4-bgra": 4, atomic: 4 };
function st(t) {
  let e = 0;
  for (let r2 of Object.values(t.propTypes)) {
    if (Number.isNaN(e)) throw new Error("Only the last property of a struct can be unbounded");
    if (e = b(e, u(r2)), e += l(r2), Number.isNaN(e) && r2.type !== "array") throw new Error("Cannot nest unbounded struct within another struct");
  }
  return b(e, u(t));
}
function pt(t) {
  let e = 0;
  for (let r2 of Object.values(t.propTypes)) {
    let o = I(r2);
    e = b(e, o), e += l(r2);
  }
  return e;
}
function ut2(t) {
  let e = at2[t?.type];
  if (e !== void 0) return e;
  if (Yt(t)) return st(t);
  if (rn(t)) return pt(t);
  if (Gt(t)) {
    if (t.elementCount === 0) return Number.NaN;
    let r2 = u(t.elementType);
    return b(l(t.elementType), r2) * t.elementCount;
  }
  if (nn(t)) {
    let r2 = I(t.elementType);
    return b(l(t.elementType), r2) * t.elementCount;
  }
  if (Te(t) || sn(t)) return on(t) ?? l(t.inner);
  throw new Error(`Cannot determine size of data: ${t}`);
}
var Y = /* @__PURE__ */ new WeakMap();
function l(t) {
  let e = Y.get(t);
  return e === void 0 && (e = ut2(t), Y.set(t, e)), e;
}
function lt(t) {
  return l(t);
}
function j(t, e) {
  return new G(t, e);
}
var G = class {
  constructor(e, r2) {
    this.elementType = e;
    this.elementCount = r2;
    if (Number.isNaN(l(e))) throw new Error("Cannot nest runtime sized arrays.");
    if (!Number.isInteger(r2) || r2 < 0) throw new Error(`Cannot create array schema with invalid element count: ${r2}.`);
  }
  [r] = true;
  type = "array";
  toString() {
    return `arrayOf(${this.elementType})`;
  }
};
function xt(t, e) {
  return new R(t, e);
}
var R = class {
  constructor(e, r2) {
    this.elementType = e;
    this.elementCount = r2;
    if (!Number.isInteger(r2) || r2 < 0) throw new Error(`Cannot create disarray schema with invalid element count: ${r2}.`);
  }
  [r] = true;
  type = "disarray";
};
function mt(t) {
  let e = (r2) => r2;
  return Object.setPrototypeOf(e, ct), e.propTypes = t, e;
}
var ct = { [r]: true, type: "unstruct", $name(t) {
  return oe(this, t), this;
}, toString() {
  return `unstruct:${f(this) ?? "<unnamed>"}`;
} };
function yt2(t) {
  return new K(t);
}
var K = class {
  constructor(e) {
    this.inner = e;
  }
  [r] = true;
  type = "atomic";
};
function B(t, e) {
  return Te(t) ? new W(t.inner, [e, ...t.attribs]) : sn(t) ? new k(t.inner, [e, ...t.attribs]) : Re(t) ? new k(t, [e]) : new W(t, [e]);
}
function ft(t, e) {
  return B(e, { [r]: true, type: "@align", value: t });
}
function dt(t, e) {
  return B(e, { [r]: true, type: "@size", value: t });
}
function Tt(t, e) {
  return B(e, { [r]: true, type: "@location", value: t });
}
function gt(t, e) {
  return B(e, { [r]: true, type: "@interpolate", value: t });
}
function Dt(t) {
  return (Te(t) || sn(t)) && t.attribs.find(Zt) !== void 0;
}
function Me(t) {
  return !Te(t) && !sn(t) ? "" : t.attribs.map((e) => `${e.type}(${e.value}) `).join("");
}
var $ = class {
  constructor(e, r2) {
    this.inner = e;
    this.attribs = r2;
    let o = r2.find(pe)?.value, x2 = r2.find(me)?.value;
    if (o !== void 0) {
      if (o <= 0) throw new Error(`Custom data alignment must be a positive number, got: ${o}.`);
      if (Math.log2(o) % 1 !== 0) throw new Error(`Alignment has to be a power of 2, got: ${o}.`);
      if (we(this.inner) && o % u(this.inner) !== 0) throw new Error(`Custom alignment has to be a multiple of the standard data alignment. Got: ${o}, expected multiple of: ${u(this.inner)}.`);
    }
    if (x2 !== void 0) {
      if (x2 < l(this.inner)) throw new Error(`Custom data size cannot be smaller then the standard data size. Got: ${x2}, expected at least: ${l(this.inner)}.`);
      if (x2 <= 0) throw new Error(`Custom data size must be a positive number. Got: ${x2}.`);
    }
  }
  [r] = true;
};
var W = class extends $ {
  [r] = true;
  type = "decorated";
};
var k = class extends $ {
  [r] = true;
  type = "loose-decorated";
};
function a(t, e) {
  return B(t, { [r]: true, type: "@builtin", value: e });
}
var bt = { vertexIndex: a(d, "vertex_index"), instanceIndex: a(d, "instance_index"), position: a(Z, "position"), clipDistances: a(j(d, 8), "clip_distances"), frontFacing: a(x, "front_facing"), fragDepth: a(p, "frag_depth"), sampleIndex: a(d, "sample_index"), sampleMask: a(d, "sample_mask"), localInvocationId: a(at, "local_invocation_id"), localInvocationIndex: a(d, "local_invocation_index"), globalInvocationId: a(at, "global_invocation_id"), workgroupId: a(at, "workgroup_id"), numWorkgroups: a(at, "num_workgroups"), subgroupInvocationId: a(d, "subgroup_invocation_id"), subgroupSize: a(d, "subgroup_size") };

export {
  J,
  Z2 as Z,
  b,
  et,
  q,
  _t,
  Lt,
  $t,
  Wt,
  kt,
  Pt,
  Ut,
  Ot,
  zt,
  Et,
  Nt,
  Ct,
  Mt,
  Gt2 as Gt,
  jt,
  Rt,
  Kt,
  Ht,
  Jt,
  qt,
  Qt,
  Xt,
  Yt2 as Yt,
  Zt2 as Zt,
  te,
  ee,
  ne,
  re,
  oe2 as oe,
  ie,
  ae,
  se,
  pe2 as pe,
  ue,
  le,
  xe,
  me2 as me,
  ce,
  ye,
  fe,
  de,
  u,
  I,
  it2 as it,
  l,
  lt,
  j,
  xt,
  mt,
  yt2 as yt,
  ft,
  dt,
  Tt,
  gt,
  Dt,
  Me,
  bt
};
//# sourceMappingURL=chunk-BT7NLTCF.js.map
