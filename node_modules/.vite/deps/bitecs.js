import "./chunk-PZ5AY32C.js";

// node_modules/bitecs/dist/core/index.min.mjs
var S = (e, t, n) => Object.defineProperty(e, t, { value: n, enumerable: false, writable: true, configurable: true });
var X = (e, t) => t & e.entityMask;
var Y = (e, t) => t >>> e.versionShift & (1 << e.versionBits) - 1;
var Te = (e, t) => {
  let o = Y(e, t) + 1 & (1 << e.versionBits) - 1;
  return t & e.entityMask | o << e.versionShift;
};
var Ce = (e) => ({ versioning: true, versionBits: e });
var U = (e) => {
  let t = e ? typeof e == "function" ? e() : e : { versioning: false, versionBits: 8 }, n = t.versionBits ?? 8, o = t.versioning ?? false, s = 32 - n, r = (1 << s) - 1, i = s, a = (1 << n) - 1 << i;
  return { aliveCount: 0, dense: [], sparse: [], maxId: 0, versioning: o, versionBits: n, entityMask: r, versionShift: i, versionMask: a };
};
var Z = (e) => {
  if (e.aliveCount < e.dense.length) {
    let n = e.dense[e.aliveCount], o = n;
    return e.sparse[o] = e.aliveCount, e.aliveCount++, n;
  }
  let t = ++e.maxId;
  return e.dense.push(t), e.sparse[t] = e.aliveCount, e.aliveCount++, t;
};
var ee = (e, t) => {
  let n = e.sparse[t];
  if (n === void 0 || n >= e.aliveCount) return;
  let o = e.aliveCount - 1, s = e.dense[o];
  if (e.sparse[s] = n, e.dense[n] = s, e.sparse[t] = o, e.dense[o] = t, e.versioning) {
    let r = Te(e, t);
    e.dense[o] = r;
  }
  e.aliveCount--;
};
var V = (e, t) => {
  let n = X(e, t), o = e.sparse[n];
  return o !== void 0 && o < e.aliveCount && e.dense[o] === t;
};
var m = Symbol.for("bitecs_internal");
var he = (e, t) => S(e || {}, m, { entityIndex: t || U(), entityMasks: [[]], entityComponents: /* @__PURE__ */ new Map(), bitflag: 1, componentMap: /* @__PURE__ */ new Map(), componentCount: 0, queries: /* @__PURE__ */ new Set(), queriesHashMap: /* @__PURE__ */ new Map(), notQueries: /* @__PURE__ */ new Set(), dirtyQueries: /* @__PURE__ */ new Set(), entitiesWithRelations: /* @__PURE__ */ new Set() });
function Ie(...e) {
  let t, n;
  return e.forEach((o) => {
    typeof o == "object" && "add" in o && "remove" in o ? t = o : typeof o == "object" && (n = o);
  }), he(n, t);
}
var Oe = (e) => {
  let t = e[m];
  return t.entityIndex = U(), t.entityMasks = [[]], t.entityComponents = /* @__PURE__ */ new Map(), t.bitflag = 1, t.componentMap = /* @__PURE__ */ new Map(), t.componentCount = 0, t.queries = /* @__PURE__ */ new Set(), t.queriesHashMap = /* @__PURE__ */ new Map(), t.notQueries = /* @__PURE__ */ new Set(), t.dirtyQueries = /* @__PURE__ */ new Set(), t.entitiesWithRelations = /* @__PURE__ */ new Set(), e;
};
var Ee = (e) => {
  delete e[m];
};
var We = (e) => Object.keys(e[m].componentMap);
var Se = (e) => Array.from(e[m].entityComponents.keys());
var z = () => {
  let e = [], t = [], n = (i) => e[t[i]] === i;
  return { add: (i) => {
    n(i) || (t[i] = e.push(i) - 1);
  }, remove: (i) => {
    if (!n(i)) return;
    let a = t[i], p = e.pop();
    p !== i && (e[a] = p, t[p] = a);
  }, has: n, sparse: t, dense: e, reset: () => {
    e.length = 0, t.length = 0;
  } };
};
var te = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : ArrayBuffer;
var ne = (e = 1e3) => {
  let t = [], n = 0, o = new Uint32Array(new te(e * 4)), s = (p) => p < t.length && t[p] < n && o[t[p]] === p;
  return { add: (p) => {
    if (!s(p)) {
      if (n >= o.length) {
        let l = new Uint32Array(new te(o.length * 2 * 4));
        l.set(o), o = l;
      }
      o[n] = p, t[p] = n, n++;
    }
  }, remove: (p) => {
    if (!s(p)) return;
    n--;
    let l = t[p], u = o[n];
    o[l] = u, t[u] = l;
  }, has: s, sparse: t, get dense() {
    return new Uint32Array(o.buffer, 0, n);
  }, reset: () => {
    n = 0, t.length = 0;
  } };
};
var A = () => {
  let e = /* @__PURE__ */ new Set();
  return { subscribe: (o) => (e.add(o), () => {
    e.delete(o);
  }), notify: (o, ...s) => Array.from(e).reduce((r, i) => {
    let a = i(o, ...s);
    return a && typeof a == "object" ? { ...r, ...a } : r;
  }, {}) };
};
var R = Symbol.for("bitecs-opType");
var g = Symbol.for("bitecs-opTerms");
var oe = (...e) => ({ [R]: "Or", [g]: e });
var re = (...e) => ({ [R]: "And", [g]: e });
var se = (...e) => ({ [R]: "Not", [g]: e });
var Me = oe;
var Qe = re;
var ke = se;
var Ae = (...e) => ({ [R]: "add", [g]: e });
var De = (...e) => ({ [R]: "remove", [g]: e });
var $e = (e) => ({ [R]: "set", [g]: [e] });
var je = (e) => ({ [R]: "get", [g]: [e] });
function qe(e, t, n) {
  let o = e[m], { [R]: s, [g]: r } = t;
  if (s === "add" || s === "remove") {
    let i = L(e, r), a = o.queriesHashMap.get(i);
    return a || (a = K(e, r)), a[s === "add" ? "addObservable" : "removeObservable"].subscribe(n);
  } else if (s === "set" || s === "get") {
    if (r.length !== 1) throw new Error("Set and Get hooks can only observe a single component");
    let i = r[0], a = o.componentMap.get(i);
    return a || (a = I(e, i)), a[s === "set" ? "setObservable" : "getObservable"].subscribe(n);
  }
  throw new Error(`Invalid hook type: ${s}`);
}
var L = (e, t) => {
  let n = e[m], o = (r) => (n.componentMap.has(r) || I(e, r), n.componentMap.get(r).id), s = (r) => {
    if (R in r) {
      let a = r[g].map(o).sort((l, u) => l - u);
      return `${r[R].toLowerCase()}(${a.join(",")})`;
    } else return o(r).toString();
  };
  return t.map(s).sort().join("-");
};
var K = (e, t, n = {}) => {
  let o = e[m], s = L(e, t), r = [], i = [], a = [], p = (c, b) => {
    c.forEach((N) => {
      o.componentMap.has(N) || I(e, N), b.push(N);
    });
  };
  t.forEach((c) => {
    R in c ? c[R] === "Not" ? p(c[g], i) : c[R] === "Or" && p(c[g], a) : (o.componentMap.has(c) || I(e, c), r.push(c));
  });
  let l = (c) => o.componentMap.get(c), u = r.concat(i.flat()).concat(a.flat()).map(l), f = n.buffered ? ne() : z(), d = z(), k = u.map((c) => c.generationId).reduce((c, b) => (c.includes(b) || c.push(b), c), []), x = (c, b) => (c[b.generationId] || (c[b.generationId] = 0), c[b.generationId] |= b.bitflag, c), _ = r.map(l).reduce(x, {}), be = i.map(l).reduce(x, {}), Re = a.map(l).reduce(x, {}), xe = u.reduce(x, {}), ge = A(), ve = A(), W = Object.assign(f, { components: r, notComponents: i, orComponents: a, allComponents: u, masks: _, notMasks: be, orMasks: Re, hasMasks: xe, generations: k, toRemove: d, addObservable: ge, removeObservable: ve, queues: {} });
  o.queries.add(W), o.queriesHashMap.set(s, W), u.forEach((c) => {
    c.queries.add(W);
  }), i.length && o.notQueries.add(W);
  let J = o.entityIndex;
  for (let c = 0; c < J.aliveCount; c++) {
    let b = J.dense[c];
    if (O(e, b, M)) continue;
    D(e, W, b) && $(W, b);
  }
  return W;
};
function G(e, t, n = {}) {
  let o = e[m], s = L(e, t), r = o.queriesHashMap.get(s);
  return r ? n.buffered && !("buffer" in r.dense) && (r = K(e, t, { buffered: true })) : r = K(e, t, n), r.dense;
}
function Pe(e, t) {
  return ae(e), G(e, t);
}
function D(e, t, n) {
  let o = e[m], { masks: s, notMasks: r, orMasks: i, generations: a } = t;
  for (let p = 0; p < a.length; p++) {
    let l = a[p], u = s[l], f = r[l], d = i[l], k = o.entityMasks[l][n];
    if (f && k & f || u && (k & u) !== u || d && !(k & d)) return false;
  }
  return true;
}
var $ = (e, t) => {
  e.toRemove.remove(t), e.addObservable.notify(t), e.add(t);
};
var He = (e) => {
  for (let t = 0; t < e.toRemove.dense.length; t++) {
    let n = e.toRemove.dense[t];
    e.remove(n);
  }
  e.toRemove.reset();
};
var ae = (e) => {
  let t = e[m];
  t.dirtyQueries.size && (t.dirtyQueries.forEach(He), t.dirtyQueries.clear());
};
var H = (e, t, n) => {
  let o = e[m];
  !t.has(n) || t.toRemove.has(n) || (t.toRemove.add(n), o.dirtyQueries.add(t), t.removeObservable.notify(n));
};
var we = (e, t) => {
  let n = e[m], o = L(e, t), s = n.queriesHashMap.get(o);
  s && (n.queries.delete(s), n.queriesHashMap.delete(o));
};
var Q = Symbol.for("bitecs-relation");
var h = Symbol.for("bitecs-pairTarget");
var j = Symbol.for("bitecs-isPairComponent");
var v = Symbol.for("bitecs-relationData");
var F = () => {
  let e = { pairsMap: /* @__PURE__ */ new Map(), initStore: void 0, exclusiveRelation: false, autoRemoveSubject: false, onTargetRemoved: void 0 }, t = (n) => {
    if (n === void 0) throw Error("Relation target is undefined");
    let o = n === "*" ? y : n;
    if (!e.pairsMap.has(o)) {
      let s = e.initStore ? e.initStore(n) : {};
      S(s, Q, t), S(s, h, o), S(s, j, true), e.pairsMap.set(o, s);
    }
    return e.pairsMap.get(o);
  };
  return S(t, v, e), t;
};
var ie = (e) => (t) => {
  let n = t[v];
  return n.initStore = e, t;
};
var Be = (e) => {
  let t = e[v];
  return t.exclusiveRelation = true, e;
};
var pe = (e) => {
  let t = e[v];
  return t.autoRemoveSubject = true, e;
};
var ce = (e) => (t) => {
  let n = t[v];
  return n.onTargetRemoved = e, t;
};
var T = (e, t) => {
  if (e === void 0) throw Error("Relation is undefined");
  return e(t);
};
var q = (e, t, n) => {
  let o = w(e, t), s = [];
  for (let r of o) r[Q] === n && r[h] !== y && !me(r[h]) && s.push(r[h]);
  return s;
};
function Ne(...e) {
  if (e.length === 1 && typeof e[0] == "object") {
    let { store: t, exclusive: n, autoRemoveSubject: o, onTargetRemoved: s } = e[0];
    return [t && ie(t), n && Be, o && pe, s && ce(s)].filter(Boolean).reduce((i, a) => a(i), F());
  } else return e.reduce((n, o) => o(n), F());
}
var le = Symbol.for("bitecs-wildcard");
function Ue() {
  let e = F();
  return Object.defineProperty(e, le, { value: true, enumerable: false, writable: false, configurable: false }), e;
}
function Ve() {
  let e = Symbol.for("bitecs-global-wildcard");
  return globalThis[e] || (globalThis[e] = Ue()), globalThis[e];
}
var y = Ve();
function Ke() {
  return F();
}
function Le() {
  let e = Symbol.for("bitecs-global-isa");
  return globalThis[e] || (globalThis[e] = Ke()), globalThis[e];
}
var P = Le();
function Ge(e) {
  return e ? Object.getOwnPropertySymbols(e).includes(le) : false;
}
function me(e) {
  return e ? Object.getOwnPropertySymbols(e).includes(v) : false;
}
var I = (e, t) => {
  if (!t) throw new Error("bitECS - Cannot register null or undefined component");
  let n = e[m], o = /* @__PURE__ */ new Set(), s = { id: n.componentCount++, generationId: n.entityMasks.length - 1, bitflag: n.bitflag, ref: t, queries: o, setObservable: A(), getObservable: A() };
  return n.componentMap.set(t, s), n.bitflag *= 2, n.bitflag >= 2 ** 31 && (n.bitflag = 1, n.entityMasks.push([])), s;
};
var Fe = (e, t) => {
  t.forEach((n) => I(e, n));
};
var O = (e, t, n) => {
  let o = e[m], s = o.componentMap.get(n);
  if (!s) return false;
  let { generationId: r, bitflag: i } = s;
  return (o.entityMasks[r][t] & i) === i;
};
var ue = (e, t, n) => {
  let s = e[m].componentMap.get(n);
  if (s && O(e, t, n)) return s.getObservable.notify(t);
};
var _e = (e, t) => ({ component: e, data: t });
var fe = (e, t, n, o, s = /* @__PURE__ */ new Set()) => {
  if (!s.has(o)) {
    s.add(o), C(t, n, P(o));
    for (let r of w(t, o)) if (r !== M && !O(t, n, r)) {
      C(t, n, r);
      let i = e.componentMap.get(r);
      if (i?.setObservable) {
        let a = ue(t, o, r);
        i.setObservable.notify(n, a);
      }
    }
    for (let r of q(t, o, P)) fe(e, t, n, r, s);
  }
};
var C = (e, t, ...n) => {
  if (!B(e, t)) throw new Error(`Cannot add component - entity ${t} does not exist in the world.`);
  let o = e[m];
  n.forEach((s) => {
    let r = "component" in s ? s.component : s, i = "data" in s ? s.data : void 0;
    o.componentMap.has(r) || I(e, r);
    let a = o.componentMap.get(r);
    if (i !== void 0 && a.setObservable.notify(t, i), O(e, t, r)) return;
    let { generationId: p, bitflag: l, queries: u } = a;
    if (o.entityMasks[p][t] |= l, O(e, t, M) || u.forEach((f) => {
      f.toRemove.remove(t), D(e, f, t) ? $(f, t) : H(e, f, t);
    }), o.entityComponents.get(t).add(r), r[j]) {
      let f = r[Q], d = r[h];
      if (C(e, t, T(f, y)), C(e, t, T(y, d)), typeof d == "number" && (C(e, d, T(y, t)), C(e, d, T(y, f)), o.entitiesWithRelations.add(d), o.entitiesWithRelations.add(t)), o.entitiesWithRelations.add(d), f[v].exclusiveRelation === true && d !== y) {
        let x = q(e, t, f)[0];
        x != null && x !== d && E(e, t, f(x));
      }
      if (f === P) {
        let x = q(e, t, P);
        for (let _ of x) fe(o, e, t, _);
      }
    }
  });
};
var ze = C;
var E = (e, t, ...n) => {
  let o = e[m];
  if (!B(e, t)) throw new Error(`Cannot remove component - entity ${t} does not exist in the world.`);
  n.forEach((s) => {
    if (!O(e, t, s)) return;
    let r = o.componentMap.get(s), { generationId: i, bitflag: a, queries: p } = r;
    if (o.entityMasks[i][t] &= ~a, p.forEach((l) => {
      l.toRemove.remove(t), D(e, l, t) ? $(l, t) : H(e, l, t);
    }), o.entityComponents.get(t).delete(s), s[j]) {
      let l = s[h];
      E(e, t, T(y, l));
      let u = s[Q];
      q(e, t, u).length === 0 && E(e, t, T(u, y));
    }
  });
};
var Je = E;
var M = {};
var Xe = (e) => {
  let t = de(e);
  return C(e, t, M), t;
};
var de = (e) => {
  let t = e[m], n = Z(t.entityIndex);
  return t.notQueries.forEach((o) => {
    D(e, o, n) && $(o, n);
  }), t.entityComponents.set(n, /* @__PURE__ */ new Set()), n;
};
var ye = (e, t) => {
  let n = e[m];
  if (!V(n.entityIndex, t)) return;
  let o = [t], s = /* @__PURE__ */ new Set();
  for (; o.length > 0; ) {
    let r = o.shift();
    if (s.has(r)) continue;
    s.add(r);
    let i = [];
    if (n.entitiesWithRelations.has(r)) {
      for (let a of G(e, [y(r)])) if (B(e, a)) for (let p of n.entityComponents.get(a)) {
        if (!p[j]) continue;
        let u = p[Q][v];
        i.push(() => E(e, a, T(y, r))), p[h] === r && (i.push(() => E(e, a, p)), u.autoRemoveSubject && o.push(a), u.onTargetRemoved && i.push(() => u.onTargetRemoved(e, a, r)));
      }
      n.entitiesWithRelations.delete(r);
    }
    for (let a of i) a();
    for (let a of o) ye(e, a);
    for (let a of n.queries) H(e, a, r);
    ee(n.entityIndex, r), n.entityComponents.delete(r);
    for (let a = 0; a < n.entityMasks.length; a++) n.entityMasks[a][r] = 0;
  }
};
var w = (e, t) => {
  let n = e[m];
  if (t === void 0) throw new Error("getEntityComponents: entity id is undefined.");
  if (!V(n.entityIndex, t)) throw new Error(`getEntityComponents: entity ${t} does not exist in the world.`);
  return Array.from(n.entityComponents.get(t));
};
var B = (e, t) => V(e[m].entityIndex, t);
var Ye = (...e) => (...t) => e.reduce((n, o) => [o(...n)], t)[0];
export {
  m as $internal,
  Qe as All,
  re as And,
  Me as Any,
  P as IsA,
  ke as None,
  se as Not,
  oe as Or,
  T as Pair,
  M as Prefab,
  y as Wildcard,
  C as addComponent,
  ze as addComponents,
  de as addEntity,
  Xe as addPrefab,
  ae as commitRemovals,
  U as createEntityIndex,
  Ne as createRelation,
  Ie as createWorld,
  Ee as deleteWorld,
  B as entityExists,
  Se as getAllEntities,
  ue as getComponentData,
  w as getEntityComponents,
  X as getId,
  q as getRelationTargets,
  Y as getVersion,
  We as getWorldComponents,
  O as hasComponent,
  G as innerQuery,
  me as isRelation,
  Ge as isWildcard,
  qe as observe,
  Ae as onAdd,
  je as onGet,
  De as onRemove,
  $e as onSet,
  Ye as pipe,
  Pe as query,
  I as registerComponent,
  Fe as registerComponents,
  K as registerQuery,
  E as removeComponent,
  Je as removeComponents,
  ye as removeEntity,
  we as removeQuery,
  Oe as resetWorld,
  _e as set,
  pe as withAutoRemoveSubject,
  ce as withOnTargetRemoved,
  ie as withStore,
  Ce as withVersioning
};
//# sourceMappingURL=bitecs.js.map
