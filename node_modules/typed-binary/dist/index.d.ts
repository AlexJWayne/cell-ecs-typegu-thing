type Endianness = 'big' | 'little';
type BufferView = ArrayLike<number> & ArrayBufferView;
interface ISerialInput {
    readBool(): boolean;
    /**
     * @deprecated Use `readUint8` instead.
     */
    readByte(): number;
    readInt8(): number;
    readUint8(): number;
    readInt16(): number;
    readUint16(): number;
    readInt32(): number;
    readUint32(): number;
    readFloat16(): number;
    readFloat32(): number;
    readString(): string;
    readSlice(bufferView: BufferView, offset: number, byteLength: number): void;
    seekTo(offset: number): void;
    skipBytes(bytes: number): void;
    readonly endianness: Endianness;
    readonly currentByteOffset: number;
}
interface ISerialOutput {
    writeBool(value: boolean): void;
    /**
     * @deprecated Use `writeUint8` instead.
     */
    writeByte(value: number): void;
    writeInt8(value: number): void;
    writeUint8(value: number): void;
    writeInt16(value: number): void;
    writeUint16(value: number): void;
    writeInt32(value: number): void;
    writeUint32(value: number): void;
    writeFloat16(value: number): void;
    writeFloat32(value: number): void;
    writeString(value: string): void;
    writeSlice(bufferView: BufferView): void;
    seekTo(offset: number): void;
    skipBytes(bytes: number): void;
    readonly endianness: Endianness;
    readonly currentByteOffset: number;
}
interface IMeasurer {
    add(bytes: number): IMeasurer;
    fork(): IMeasurer;
    readonly unbounded: IMeasurer;
    readonly size: number;
    readonly isUnbounded: boolean;
}

type MaxValue = typeof MaxValue;
declare const MaxValue: unique symbol;
interface IKeyedSchema<TKeyDef extends string, TUnwrapped> extends ISchema<TUnwrapped> {
    readonly __keyDefinition: TKeyDef;
}
type AnyKeyedSchema = IKeyedSchema<string, unknown>;
/**
 * Removes one layer of schema wrapping.
 *
 * @example ```
 * Unwrap<ISchema<ISchema<number>>> -> ISchema<number>
 * Unwrap<ISchema<number>> -> number
 * ```
 *
 * Keyed schemas are bypassed.
 *
 * @example ```
 * Unwrap<IKeyedSchema<'abc', ISchema<number>>> -> IKeyedSchema<'abc', number>
 * ```
 */
type Unwrap<T> = T extends IKeyedSchema<infer TKeyDef, infer TInner> ? IKeyedSchema<TKeyDef, Unwrap<TInner>> : T extends ISchema<infer TInner> ? TInner : T;
/**
 * Removes one layer of schema wrapping of record properties.
 *
 * @example ```
 * Unwrap<{
 *   a: ISchema<number>,
 *   b: ISchema<ISchema<string>>
 * }>
 * // <=>
 * {
 *   a: number,
 *   b: ISchema<string>
 * }
 * ```
 */
type UnwrapRecord<T> = T extends IKeyedSchema<infer TKeyDef, Record<infer K, unknown>> ? IKeyedSchema<TKeyDef, {
    [key in K]: Unwrap<T['__unwrapped'][key]>;
}> : T extends Record<infer K, unknown> ? {
    [key in K]: Unwrap<T[key]>;
} : T;
type __UnwrapArray<T> = T extends unknown[] ? {
    [key in keyof T]: Unwrap<T[key]>;
} : never;
/**
 * Removes one layer of schema wrapping of array elements.
 *
 * @example ```
 * Unwrap<[a: ISchema<number>, b: ISchema<ISchema<string>>]>
 * // <=>
 * [a: number, b: ISchema<string>]
 * ```
 */
type UnwrapArray<T> = T extends IKeyedSchema<infer TKeyDef, unknown[]> ? IKeyedSchema<TKeyDef, __UnwrapArray<T['__unwrapped']>> : T extends unknown[] ? __UnwrapArray<T> : T;
interface ISchemaWithProperties<TProps extends Record<string, AnySchema>> extends ISchema<UnwrapRecord<TProps>> {
    readonly properties: TProps;
}
type AnySchemaWithProperties = ISchemaWithProperties<Record<string, AnySchema>>;
type PropertiesOf<T extends AnySchemaWithProperties> = T['properties'];
type PropertyDescription = {
    bufferOffset: number;
    schema: ISchema<unknown>;
};
/**
 * @param TUnwrap one level of unwrapping to the inferred type.
 */
interface ISchema<TUnwrapped> {
    readonly __unwrapped: TUnwrapped;
    resolveReferences(ctx: IRefResolver): void;
    write(output: ISerialOutput, value: Parsed<TUnwrapped>): void;
    read(input: ISerialInput): Parsed<TUnwrapped>;
    measure(value: Parsed<TUnwrapped> | MaxValue, measurer?: IMeasurer): IMeasurer;
    seekProperty(reference: Parsed<TUnwrapped> | MaxValue, prop: keyof TUnwrapped): PropertyDescription | null;
}
type AnySchema = ISchema<unknown>;
declare abstract class Schema<TUnwrapped> implements ISchema<TUnwrapped> {
    readonly __unwrapped: TUnwrapped;
    resolveReferences(ctx: IRefResolver): void;
    abstract write(output: ISerialOutput, value: Parsed<TUnwrapped>): void;
    abstract read(input: ISerialInput): Parsed<TUnwrapped>;
    abstract measure(value: Parsed<TUnwrapped> | MaxValue, measurer?: IMeasurer): IMeasurer;
    seekProperty(_reference: Parsed<TUnwrapped> | MaxValue, _prop: keyof TUnwrapped): PropertyDescription | null;
}
declare class Ref<K extends string> {
    readonly key: K;
    constructor(key: K);
}
type SubTypeKey = 'string' | 'enum';
declare const SubTypeKey: {
    readonly STRING: "string";
    readonly ENUM: "enum";
};
interface IRefResolver {
    hasKey(key: string): boolean;
    resolve<TSchema extends AnySchema>(schemaOrRef: TSchema): TSchema;
    register<K extends string>(key: K, schema: ISchema<unknown>): void;
}

/**
 * @example ```
 * type ObjectUnion = ({ a: number, b: number } | { a: number, c: number });
 *
 * keyof ObjectUnion -> 'a'
 * DistributedKeyOf<ObjectUnion> -> 'a' | 'b' | 'c'
 * ```
 */
type DistributedKeyOf<T> = T extends unknown ? keyof T : never;
/**
 * @example ```
 * type ObjectUnion = { a: number, b: number } | { a: number, c: number };
 *
 * MergeRecordUnion<ObjectUnion> -> { a: number, b: number, c: number }
 * ```
 */
type MergeRecordUnion<T> = {
    [K in DistributedKeyOf<T>]: Extract<T, {
        [key in K]: unknown;
    }>[K];
};
type Parsed<T, 
/** type key dictionary, gets populated during recursive parsing */
TKeyDict extends {
    [key in keyof TKeyDict]: TKeyDict[key];
} = Record<string, never>> = T extends IKeyedSchema<infer TKeyDefinition, infer TUnwrapped> ? Parsed<TUnwrapped, TKeyDict & {
    [key in TKeyDefinition]: Unwrap<T>;
}> : T extends ISchema<infer TUnwrapped> ? Parsed<TUnwrapped, TKeyDict> : T extends Ref<infer K> ? K extends keyof TKeyDict ? Parsed<TKeyDict[K], TKeyDict> : never : T extends Record<string, unknown> ? {
    [K in keyof T]: Parsed<T[K], TKeyDict>;
} : T extends unknown[] ? {
    [K in keyof T]: Parsed<T[K], TKeyDict>;
} : T;
type ParseUnwrapped<T> = Parsed<Unwrap<T>>;
type ParseUnwrappedRecord<T> = Parsed<UnwrapRecord<T>>;

declare class ArraySchema<TElement extends AnySchema> extends Schema<Unwrap<TElement>[]> {
    private readonly _unstableElementSchema;
    readonly length: number;
    private elementSchema;
    constructor(_unstableElementSchema: TElement, length: number);
    resolveReferences(ctx: IRefResolver): void;
    write(output: ISerialOutput, values: ParseUnwrapped<TElement>[]): void;
    read(input: ISerialInput): ParseUnwrapped<TElement>[];
    /**
     * Returns the maximum number of bytes this schema can take up.
     *
     * Returns `NaN` if the schema is unbounded. If you would like to know
     * how many bytes a particular value encoding will take up, use `.measure(value)`.
     *
     * Alias for `.measure(MaxValue).size`
     */
    get maxSize(): number;
    measure(values: ParseUnwrapped<TElement>[] | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare function arrayOf<TSchema extends AnySchema>(elementSchema: TSchema, length: number): ArraySchema<TSchema>;

declare class BoolSchema extends Schema<boolean> {
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Alias for `.measure(MaxValue).size`
     */
    readonly maxSize = 1;
    read(input: ISerialInput): boolean;
    write(output: ISerialOutput, value: boolean): void;
    measure(_: boolean | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const bool: BoolSchema;
declare class StringSchema extends Schema<string> {
    private static _cachedEncoder;
    private static get _encoder();
    read(input: ISerialInput): string;
    write<T extends string>(output: ISerialOutput, value: T): void;
    measure(value: string | typeof MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const string: StringSchema;
declare class Int8Schema extends Schema<number> {
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Alias for `.measure(MaxValue).size`
     */
    readonly maxSize = 1;
    read(input: ISerialInput): number;
    write(output: ISerialOutput, value: number): void;
    measure(_: number | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const i8: Int8Schema;
declare class Uint8Schema extends Schema<number> {
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Alias for `.measure(MaxValue).size`
     */
    readonly maxSize = 1;
    read(input: ISerialInput): number;
    write(output: ISerialOutput, value: number): void;
    measure(_: number | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const u8: Uint8Schema;
/**
 * Alias for `bin.u8`
 */
declare const byte: Uint8Schema;
declare class Int16Schema extends Schema<number> {
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Alias for `.measure(MaxValue).size`
     */
    readonly maxSize = 2;
    read(input: ISerialInput): number;
    write(output: ISerialOutput, value: number): void;
    measure(_: number | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const i16: Int16Schema;
declare class Uint16Schema extends Schema<number> {
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Alias for `.measure(MaxValue).size`
     */
    readonly maxSize = 2;
    read(input: ISerialInput): number;
    write(output: ISerialOutput, value: number): void;
    measure(_: number | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const u16: Uint16Schema;
declare class Int32Schema extends Schema<number> {
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Alias for `.measure(MaxValue).size`
     */
    readonly maxSize = 4;
    read(input: ISerialInput): number;
    write(output: ISerialOutput, value: number): void;
    measure(_: number | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const i32: Int32Schema;
declare class Uint32Schema extends Schema<number> {
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Alias for `.measure(MaxValue).size`
     */
    readonly maxSize = 4;
    read(input: ISerialInput): number;
    write(output: ISerialOutput, value: number): void;
    measure(_: number | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const u32: Uint32Schema;
declare class Float16Schema extends Schema<number> {
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Alias for `.measure(MaxValue).size`
     */
    readonly maxSize = 2;
    read(input: ISerialInput): number;
    write(output: ISerialOutput, value: number): void;
    measure(_: number | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const f16: Float16Schema;
declare class Float32Schema extends Schema<number> {
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Alias for `.measure(MaxValue).size`
     */
    readonly maxSize = 4;
    read(input: ISerialInput): number;
    write(output: ISerialOutput, value: number): void;
    measure(_: number | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const f32: Float32Schema;

declare class CharsSchema<TLength extends number = number> extends Schema<string> {
    readonly length: TLength;
    constructor(length: TLength);
    write(output: ISerialOutput, value: string): void;
    read(input: ISerialInput): string;
    measure(_: string, measurer?: IMeasurer): IMeasurer;
}
declare function chars<T extends number>(length: T): CharsSchema<T>;

type AnyObjectSchema = ObjectSchema<Record<string, AnySchema>>;
declare class ObjectSchema<TProps extends Record<string, AnySchema>> extends Schema<UnwrapRecord<TProps>> implements ISchemaWithProperties<TProps> {
    private readonly _properties;
    properties: TProps;
    constructor(_properties: TProps);
    resolveReferences(ctx: IRefResolver): void;
    write(output: ISerialOutput, value: ParseUnwrappedRecord<TProps>): void;
    read(input: ISerialInput): ParseUnwrappedRecord<TProps>;
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Is `NaN` if the schema is unbounded. If you would like to know
     * how many bytes a particular value encoding will take up, use `.measure(value)`.
     *
     * Alias for `.measure(MaxValue).size`
     */
    get maxSize(): number;
    measure(value: ParseUnwrappedRecord<TProps> | typeof MaxValue, measurer?: IMeasurer): IMeasurer;
    seekProperty(reference: ParseUnwrappedRecord<TProps> | MaxValue, prop: keyof UnwrapRecord<TProps>): PropertyDescription | null;
}
declare function object<P extends Record<string, AnySchema>>(properties: P): ObjectSchema<P>;
type UnwrapGeneric<Base extends Record<string, AnySchema>, Ext> = {
    [TKey in keyof Ext]: ISchema<UnwrapRecord<Base> & {
        type: TKey;
    } & UnwrapRecord<Unwrap<Ext[TKey]>>>;
}[keyof Ext];
declare class GenericObjectSchema<TUnwrapBase extends Record<string, AnySchema>, // Base properties
TUnwrapExt extends Record<string, AnySchemaWithProperties>> extends Schema<UnwrapGeneric<TUnwrapBase, TUnwrapExt>> {
    readonly keyedBy: SubTypeKey;
    private readonly _subTypeMap;
    private _baseObject;
    subTypeMap: TUnwrapExt;
    constructor(keyedBy: SubTypeKey, properties: TUnwrapBase, _subTypeMap: TUnwrapExt);
    resolveReferences(ctx: IRefResolver): void;
    write(output: ISerialOutput, value: Parsed<UnwrapGeneric<TUnwrapBase, TUnwrapExt>>): void;
    read(input: ISerialInput): Parsed<UnwrapGeneric<TUnwrapBase, TUnwrapExt>>;
    measure(value: Parsed<UnwrapGeneric<TUnwrapBase, TUnwrapExt>> | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare function generic<P extends Record<string, AnySchema>, S extends {
    [Key in keyof S]: AnySchemaWithProperties;
}>(properties: P, subTypeMap: S): GenericObjectSchema<P, S>;
declare function genericEnum<P extends Record<string, AnySchema>, S extends {
    [Key in keyof S]: AnySchemaWithProperties;
}>(properties: P, subTypeMap: S): GenericObjectSchema<P, S>;

type Concat<Objs extends AnyObjectSchema[]> = ObjectSchema<MergeRecordUnion<PropertiesOf<Objs[number]>>>;
declare function concat<Objs extends AnyObjectSchema[]>(objs: Objs): Concat<Objs>;

declare class DynamicArraySchema<TElement extends AnySchema> extends Schema<Unwrap<TElement>[]> {
    private readonly _unstableElementType;
    elementType: TElement;
    constructor(_unstableElementType: TElement);
    resolveReferences(ctx: IRefResolver): void;
    write(output: ISerialOutput, values: ParseUnwrapped<TElement>[]): void;
    read(input: ISerialInput): ParseUnwrapped<TElement>[];
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Is `NaN` if the schema is unbounded. If you would like to know
     * how many bytes a particular value encoding will take up, use `.measure(value)`.
     *
     * Alias for `.measure(MaxValue).size`
     */
    get maxSize(): number;
    measure(values: ParseUnwrapped<TElement>[] | typeof MaxValue, measurer?: IMeasurer): IMeasurer;
    seekProperty(reference: ParseUnwrapped<TElement>[] | MaxValue, prop: number): PropertyDescription | null;
}
declare function dynamicArrayOf<TSchema extends AnySchema>(elementSchema: TSchema): DynamicArraySchema<TSchema>;

declare class KeyedSchema<TInner extends ISchema<unknown>, TKeyDef extends string> implements IKeyedSchema<TKeyDef, Unwrap<TInner>> {
    readonly key: TKeyDef;
    readonly __unwrapped: Unwrap<TInner>;
    readonly __keyDefinition: TKeyDef;
    innerType: TInner;
    constructor(key: TKeyDef, innerResolver: (ref: ISchema<Ref<TKeyDef>>) => TInner);
    resolveReferences(ctx: IRefResolver): void;
    read(input: ISerialInput): ParseUnwrapped<TInner>;
    write(output: ISerialOutput, value: ParseUnwrapped<TInner>): void;
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Is `NaN` if the schema is unbounded. If you would like to know
     * how many bytes a particular value encoding will take up, use `.measure(value)`.
     *
     * Alias for `.measure(MaxValue).size`
     */
    get maxSize(): number;
    measure(value: ParseUnwrapped<TInner> | typeof MaxValue, measurer?: IMeasurer): IMeasurer;
    seekProperty(reference: ParseUnwrapped<TInner> | typeof MaxValue, prop: keyof Unwrap<TInner>): PropertyDescription | null;
}
declare function keyed<K extends string, P extends ISchema<unknown>>(key: K, inner: (ref: ISchema<Ref<K>>) => P): KeyedSchema<P, K>;

declare class OptionalSchema<TInner extends AnySchema> extends Schema<Unwrap<TInner> | undefined> {
    private readonly _innerUnstableSchema;
    private innerSchema;
    constructor(_innerUnstableSchema: TInner);
    resolveReferences(ctx: IRefResolver): void;
    write(output: ISerialOutput, value: ParseUnwrapped<TInner> | undefined): void;
    read(input: ISerialInput): ParseUnwrapped<TInner> | undefined;
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Is `NaN` if the schema is unbounded. If you would like to know
     * how many bytes a particular value encoding will take up, use `.measure(value)`.
     *
     * Alias for `.measure(MaxValue).size`
     */
    get maxSize(): number;
    measure(value: ParseUnwrapped<TInner> | MaxValue | undefined, measurer?: IMeasurer): IMeasurer;
}
declare function optional<TSchema extends AnySchema>(innerType: TSchema): OptionalSchema<TSchema>;

declare class TupleSchema<TSequence extends [AnySchema, ...AnySchema[]]> extends Schema<UnwrapArray<TSequence>> {
    private readonly _unstableSchemas;
    private schemas;
    constructor(_unstableSchemas: TSequence);
    resolveReferences(ctx: IRefResolver): void;
    write(output: ISerialOutput, values: Parsed<UnwrapArray<TSequence>>): void;
    read(input: ISerialInput): Parsed<UnwrapArray<TSequence>>;
    /**
     * The maximum number of bytes this schema can take up.
     *
     * Is `NaN` if the schema is unbounded. If you would like to know
     * how many bytes a particular value encoding will take up, use `.measure(value)`.
     *
     * Alias for `.measure(MaxValue).size`
     */
    get maxSize(): number;
    measure(values: Parsed<UnwrapArray<TSequence>> | MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare function tupleOf<TSchema extends [AnySchema, ...AnySchema[]]>(schemas: TSchema): TupleSchema<TSchema>;

type TypedArrayConstructor<T> = {
    readonly BYTES_PER_ELEMENT: number;
    new (buffer: ArrayBufferLike, offset?: number, length?: number): T;
};
declare class TypedArraySchema<TTypedArray extends ArrayLike<number> & ArrayBufferView> extends Schema<TTypedArray> {
    readonly length: number;
    private readonly _arrayConstructor;
    readonly byteLength: number;
    constructor(length: number, _arrayConstructor: TypedArrayConstructor<TTypedArray>);
    write(output: ISerialOutput, value: Parsed<TTypedArray>): void;
    read(input: ISerialInput): Parsed<TTypedArray>;
    measure(_value: Parsed<TTypedArray> | typeof MaxValue, measurer?: IMeasurer): IMeasurer;
}
declare const u8Array: (length: number) => TypedArraySchema<Uint8Array>;
declare const u8ClampedArray: (length: number) => TypedArraySchema<Uint8ClampedArray>;
declare const u16Array: (length: number) => TypedArraySchema<Uint16Array>;
declare const u32Array: (length: number) => TypedArraySchema<Uint32Array>;
declare const i8Array: (length: number) => TypedArraySchema<Int8Array>;
declare const i16Array: (length: number) => TypedArraySchema<Int16Array>;
declare const i32Array: (length: number) => TypedArraySchema<Int32Array>;
declare const f32Array: (length: number) => TypedArraySchema<Float32Array>;
declare const f64Array: (length: number) => TypedArraySchema<Float64Array>;

type BufferIOOptions = {
    /**
     * @default 0
     */
    byteOffset?: number;
    /**
     * @default 'system'
     */
    endianness?: Endianness | 'system';
};
declare class BufferIOBase {
    protected readonly dataView: DataView;
    protected readonly littleEndian: boolean;
    protected byteOffset: number;
    readonly endianness: Endianness;
    constructor(buffer: ArrayBufferLike, options?: BufferIOOptions);
    get currentByteOffset(): number;
    seekTo(offset: number): void;
    skipBytes(bytes: number): void;
}

declare class BufferReader extends BufferIOBase implements ISerialInput {
    private _cachedTextDecoder;
    private get _textDecoder();
    readBool(): boolean;
    readByte(): number;
    readInt8(): number;
    readUint8(): number;
    readInt16(): number;
    readUint16(): number;
    readInt32(): number;
    readUint32(): number;
    readFloat16(): number;
    readFloat32(): number;
    readString(): string;
    readSlice(bufferView: ArrayLike<number> & ArrayBufferView, offset: number, byteLength: number): void;
}

declare class BufferWriter extends BufferIOBase implements ISerialOutput {
    private _cachedTextEncoder;
    private get _textEncoder();
    writeBool(value: boolean): void;
    writeByte(value: number): void;
    writeInt8(value: number): void;
    writeUint8(value: number): void;
    writeInt16(value: number): void;
    writeUint16(value: number): void;
    writeInt32(value: number): void;
    writeUint32(value: number): void;
    writeFloat16(value: number): void;
    writeFloat32(value: number): void;
    writeString(value: string): void;
    writeSlice(bufferView: ArrayLike<number> & ArrayBufferView): void;
}

declare class Measurer implements IMeasurer {
    size: number;
    unbounded: IMeasurer;
    isUnbounded: boolean;
    add(bytes: number): IMeasurer;
    fork(): IMeasurer;
}

declare class UnresolvedReferenceError extends Error {
    constructor(msg: string);
}
declare class ValidationError extends Error {
    constructor(msg: string);
}

type bin_BufferReader = BufferReader;
declare const bin_BufferReader: typeof BufferReader;
type bin_BufferWriter = BufferWriter;
declare const bin_BufferWriter: typeof BufferWriter;
type bin_Endianness = Endianness;
type bin_IMeasurer = IMeasurer;
type bin_ISerialInput = ISerialInput;
type bin_ISerialOutput = ISerialOutput;
declare const bin_MaxValue: typeof MaxValue;
type bin_Measurer = Measurer;
declare const bin_Measurer: typeof Measurer;
type bin_Parsed<T, TKeyDict extends {
    [key in keyof TKeyDict]: TKeyDict[key];
} = Record<string, never>> = Parsed<T, TKeyDict>;
type bin_UnresolvedReferenceError = UnresolvedReferenceError;
declare const bin_UnresolvedReferenceError: typeof UnresolvedReferenceError;
type bin_ValidationError = ValidationError;
declare const bin_ValidationError: typeof ValidationError;
declare const bin_arrayOf: typeof arrayOf;
declare const bin_bool: typeof bool;
declare const bin_byte: typeof byte;
declare const bin_chars: typeof chars;
declare const bin_concat: typeof concat;
declare const bin_dynamicArrayOf: typeof dynamicArrayOf;
declare const bin_f16: typeof f16;
declare const bin_f32: typeof f32;
declare const bin_f32Array: typeof f32Array;
declare const bin_f64Array: typeof f64Array;
declare const bin_generic: typeof generic;
declare const bin_genericEnum: typeof genericEnum;
declare const bin_i16: typeof i16;
declare const bin_i16Array: typeof i16Array;
declare const bin_i32: typeof i32;
declare const bin_i32Array: typeof i32Array;
declare const bin_i8: typeof i8;
declare const bin_i8Array: typeof i8Array;
declare const bin_keyed: typeof keyed;
declare const bin_object: typeof object;
declare const bin_optional: typeof optional;
declare const bin_string: typeof string;
declare const bin_tupleOf: typeof tupleOf;
declare const bin_u16: typeof u16;
declare const bin_u16Array: typeof u16Array;
declare const bin_u32: typeof u32;
declare const bin_u32Array: typeof u32Array;
declare const bin_u8: typeof u8;
declare const bin_u8Array: typeof u8Array;
declare const bin_u8ClampedArray: typeof u8ClampedArray;
declare namespace bin {
  export { bin_BufferReader as BufferReader, bin_BufferWriter as BufferWriter, type bin_Endianness as Endianness, type bin_IMeasurer as IMeasurer, type bin_ISerialInput as ISerialInput, type bin_ISerialOutput as ISerialOutput, bin_MaxValue as MaxValue, bin_Measurer as Measurer, type bin_Parsed as Parsed, bin_UnresolvedReferenceError as UnresolvedReferenceError, bin_ValidationError as ValidationError, bin_arrayOf as arrayOf, bin_bool as bool, bin_byte as byte, bin_chars as chars, bin_concat as concat, bin_dynamicArrayOf as dynamicArrayOf, bin_f16 as f16, bin_f32 as f32, bin_f32Array as f32Array, bin_f64Array as f64Array, bin_generic as generic, bin_genericEnum as genericEnum, bin_i16 as i16, bin_i16Array as i16Array, bin_i32 as i32, bin_i32Array as i32Array, bin_i8 as i8, bin_i8Array as i8Array, bin_keyed as keyed, bin_object as object, bin_optional as optional, bin_string as string, bin_tupleOf as tupleOf, bin_u16 as u16, bin_u16Array as u16Array, bin_u32 as u32, bin_u32Array as u32Array, bin_u8 as u8, bin_u8Array as u8Array, bin_u8ClampedArray as u8ClampedArray };
}

declare function getSystemEndianness(): 'big' | 'little';

export { type AnyKeyedSchema, type AnyObjectSchema, type AnySchema, type AnySchemaWithProperties, ArraySchema, BoolSchema, BufferReader, BufferWriter, Uint8Schema as ByteSchema, CharsSchema, DynamicArraySchema, type Endianness, Float16Schema, Float32Schema, GenericObjectSchema, type IKeyedSchema, type IMeasurer, type IRefResolver, type ISchema, type ISchemaWithProperties, type ISerialInput, type ISerialOutput, Int16Schema, Int32Schema, Int8Schema, KeyedSchema, MaxValue, Measurer, ObjectSchema, OptionalSchema, type ParseUnwrapped, type Parsed, Ref, Schema, StringSchema, SubTypeKey, TupleSchema, TypedArraySchema, Uint16Schema, Uint32Schema, Uint8Schema, UnresolvedReferenceError, type Unwrap, type UnwrapArray, type UnwrapRecord, ValidationError, arrayOf, bin, bool, byte, chars, concat, bin as default, dynamicArrayOf, f16, f32, f32Array, f64Array, generic, genericEnum, getSystemEndianness, i16, i16Array, i32, i32Array, i8, i8Array, keyed, object, optional, string, tupleOf, u16, u16Array, u32, u32Array, u8, u8Array, u8ClampedArray };
