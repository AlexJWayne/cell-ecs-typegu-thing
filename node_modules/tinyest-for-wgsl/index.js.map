{"version":3,"sources":["../src/parsers.ts"],"sourcesContent":["import type * as babel from '@babel/types';\nimport type * as acorn from 'acorn';\nimport * as tinyest from 'tinyest';\nimport { FuncParameterType } from 'tinyest';\n\nconst { NodeTypeCatalog: NODE } = tinyest;\n\ntype Scope = {\n  /** identifiers declared in this scope */\n  declaredNames: string[];\n};\n\ntype Context = {\n  /** Holds a set of all identifiers that were used in code, but were not declared in code. */\n  externalNames: Set<string>;\n  /** Used to signal to identifiers that they should not treat their resolution as possible external uses. */\n  ignoreExternalDepth: number;\n  stack: Scope[];\n};\n\ntype JsNode = babel.Node | acorn.AnyNode;\n\nfunction isDeclared(ctx: Context, name: string) {\n  return ctx.stack.some((scope) => scope.declaredNames.includes(name));\n}\n\nconst BINARY_OP_MAP = {\n  '==': '==',\n  '!=': '!=',\n  '===': '==',\n  '!==': '!=',\n  '<': '<',\n  '<=': '<=',\n  '>': '>',\n  '>=': '>=',\n  '<<': '<<',\n  '>>': '>>',\n  get '>>>'(): never {\n    throw new Error('The `>>>` operator is unsupported in TGSL.');\n  },\n  '+': '+',\n  '-': '-',\n  '*': '*',\n  '/': '/',\n  '%': '%',\n  '|': '|',\n  '^': '^',\n  '&': '&',\n  get in(): never {\n    throw new Error('The `in` operator is unsupported in TGSL.');\n  },\n  get instanceof(): never {\n    throw new Error('The `instanceof` operator is unsupported in TGSL.');\n  },\n  get '**'(): never {\n    // TODO: Translate 'a ** b' into 'pow(a, b)'.\n    throw new Error(\n      'The `**` operator is unsupported in TGSL. Use std.pow() instead.',\n    );\n  },\n  get '|>'(): never {\n    throw new Error('The `|>` operator is unsupported in TGSL.');\n  },\n} as const;\n\nconst LOGICAL_OP_MAP = {\n  '||': '||',\n  '&&': '&&',\n  get '??'(): never {\n    throw new Error('The `??` operator is unsupported in TGSL.');\n  },\n} as const;\n\nconst ASSIGNMENT_OP_MAP = {\n  '=': '=',\n  '+=': '+=',\n  '-=': '-=',\n  '*=': '*=',\n  '/=': '/=',\n  '%=': '%=',\n  '<<=': '<<=',\n  '>>=': '>>=',\n  get '>>>='(): never {\n    throw new Error('The `>>>=` operator is unsupported in TGSL.');\n  },\n  '|=': '|=',\n  '^=': '^=',\n  '&=': '&=',\n  '**=': '**=',\n  '||=': '||=',\n  '&&=': '&&=',\n  get '??='(): never {\n    throw new Error('The `??=` operator is unsupported in TGSL.');\n  },\n} as const;\n\nconst Transpilers: Partial<\n  {\n    [Type in JsNode['type']]: (\n      ctx: Context,\n      node: Extract<JsNode, { type: Type }>,\n    ) => tinyest.AnyNode;\n  }\n> = {\n  Program(ctx, node) {\n    const body = node.body[0];\n\n    if (!body) {\n      throw new Error('tgpu.fn was not implemented correctly.');\n    }\n\n    return transpile(ctx, body);\n  },\n\n  ExpressionStatement: (ctx, node) => transpile(ctx, node.expression),\n\n  ArrowFunctionExpression: (ctx, node) => {\n    throw new Error('Arrow functions are not supported inside TGSL.');\n  },\n\n  BlockStatement(ctx, node) {\n    ctx.stack.push({ declaredNames: [] });\n\n    const result = [\n      NODE.block,\n      node.body.map(\n        (statement) => transpile(ctx, statement) as tinyest.Statement,\n      ),\n    ] as const;\n\n    ctx.stack.pop();\n\n    return result;\n  },\n\n  ReturnStatement: (ctx, node) =>\n    node.argument\n      ? [NODE.return, transpile(ctx, node.argument) as tinyest.Expression]\n      : [NODE.return],\n\n  Identifier(ctx, node) {\n    if (ctx.ignoreExternalDepth === 0 && !isDeclared(ctx, node.name)) {\n      ctx.externalNames.add(node.name);\n    }\n\n    return node.name;\n  },\n\n  BinaryExpression(ctx, node) {\n    const wgslOp = BINARY_OP_MAP[node.operator];\n    const left = transpile(ctx, node.left) as tinyest.Expression;\n    const right = transpile(ctx, node.right) as tinyest.Expression;\n    return [NODE.binaryExpr, left, wgslOp, right];\n  },\n\n  LogicalExpression(ctx, node) {\n    const wgslOp = LOGICAL_OP_MAP[node.operator];\n    const left = transpile(ctx, node.left) as tinyest.Expression;\n    const right = transpile(ctx, node.right) as tinyest.Expression;\n    return [NODE.logicalExpr, left, wgslOp, right];\n  },\n\n  AssignmentExpression(ctx, node) {\n    const wgslOp = ASSIGNMENT_OP_MAP[node.operator as acorn.AssignmentOperator];\n    const left = transpile(ctx, node.left) as tinyest.Expression;\n    const right = transpile(ctx, node.right) as tinyest.Expression;\n    return [NODE.assignmentExpr, left, wgslOp, right];\n  },\n\n  UnaryExpression(ctx, node) {\n    const wgslOp = node.operator;\n    const argument = transpile(ctx, node.argument) as tinyest.Expression;\n    return [NODE.unaryExpr, wgslOp, argument] as tinyest.UnaryExpression;\n  },\n\n  MemberExpression(ctx, node) {\n    const object = transpile(ctx, node.object) as tinyest.Expression;\n\n    // If the property is computed, it could potentially be an external identifier.\n    if (node.computed) {\n      const property = transpile(ctx, node.property) as tinyest.Expression;\n      return [NODE.indexAccess, object, property];\n    }\n\n    // If the property is not computed, we don't want to register identifiers as external.\n    ctx.ignoreExternalDepth++;\n    const property = transpile(ctx, node.property) as tinyest.Expression;\n    ctx.ignoreExternalDepth--;\n\n    if (typeof property !== 'string') {\n      throw new Error('Expected identifier as property access key.');\n    }\n\n    return [NODE.memberAccess, object, property];\n  },\n\n  UpdateExpression(ctx, node) {\n    const operator = node.operator;\n    const argument = transpile(ctx, node.argument) as tinyest.Expression;\n    if (node.prefix) {\n      throw new Error('Prefix update expressions are not supported in WGSL.');\n    }\n    return [NODE.postUpdate, operator, argument];\n  },\n\n  Literal(ctx, node) {\n    if (typeof node.value === 'boolean') {\n      return node.value;\n    }\n    if (typeof node.value === 'string') {\n      return [NODE.stringLiteral, node.value];\n    }\n    return [NODE.numericLiteral, node.raw ?? ''];\n  },\n\n  NumericLiteral(ctx, node) {\n    return [NODE.numericLiteral, String(node.value) ?? ''];\n  },\n\n  BooleanLiteral(ctx, node) {\n    return node.value;\n  },\n\n  StringLiteral(ctx, node) {\n    return [NODE.stringLiteral, node.value];\n  },\n\n  CallExpression(ctx, node) {\n    const callee = transpile(ctx, node.callee) as tinyest.Expression;\n\n    const args = node.arguments.map((arg) =>\n      transpile(ctx, arg)\n    ) as tinyest.Expression[];\n\n    return [NODE.call, callee, args];\n  },\n\n  ArrayExpression: (ctx, node) => [\n    NODE.arrayExpr,\n    node.elements.map((elem) => {\n      if (!elem || elem.type === 'SpreadElement') {\n        throw new Error('Spread elements are not supported in TGSL.');\n      }\n      return transpile(ctx, elem) as tinyest.Expression;\n    }),\n  ],\n\n  VariableDeclaration(ctx, node) {\n    if (node.declarations.length !== 1 || !node.declarations[0]) {\n      throw new Error(\n        'Currently only one declaration in a statement is supported.',\n      );\n    }\n\n    const decl = node.declarations[0];\n    ctx.ignoreExternalDepth++;\n    const id = transpile(ctx, decl.id);\n    ctx.ignoreExternalDepth--;\n\n    if (typeof id !== 'string') {\n      throw new Error('Invalid variable declaration, expected identifier.');\n    }\n\n    ctx.stack[ctx.stack.length - 1]?.declaredNames.push(id);\n\n    const init = decl.init\n      ? (transpile(ctx, decl.init) as tinyest.Expression)\n      : undefined;\n\n    if (node.kind === 'var') {\n      throw new Error('`var` declarations are not supported.');\n    }\n\n    if (node.kind === 'const') {\n      if (init === undefined) {\n        throw new Error(\n          'Did not provide initial value in `const` declaration.',\n        );\n      }\n      return [NODE.const, id, init];\n    }\n\n    return init !== undefined ? [NODE.let, id, init] : [NODE.let, id];\n  },\n\n  IfStatement(ctx, node) {\n    const test = transpile(ctx, node.test) as tinyest.Expression;\n    const consequent = transpile(ctx, node.consequent) as tinyest.Statement;\n    const alternate = node.alternate\n      ? (transpile(ctx, node.alternate) as tinyest.Statement)\n      : undefined;\n\n    return alternate\n      ? [NODE.if, test, consequent, alternate]\n      : [NODE.if, test, consequent];\n  },\n\n  ObjectExpression(ctx, node) {\n    const properties: Record<string, tinyest.Expression> = {};\n\n    for (const prop of node.properties) {\n      // TODO: Handle SpreadElement\n      if (prop.type === 'SpreadElement') {\n        throw new Error('Spread elements are not supported in TGSL.');\n      }\n\n      // TODO: Handle computed properties\n      if (prop.key.type !== 'Identifier' && prop.key.type !== 'Literal') {\n        throw new Error(\n          'Only Identifier and Literal keys are supported as object keys.',\n        );\n      }\n\n      // TODO: Handle Object method\n      if (prop.type === 'ObjectMethod') {\n        throw new Error('Object method elements are not supported in TGSL.');\n      }\n\n      ctx.ignoreExternalDepth++;\n      const key = prop.key.type === 'Identifier'\n        ? (transpile(ctx, prop.key) as string)\n        : String(prop.key.value);\n      ctx.ignoreExternalDepth--;\n      const value = transpile(ctx, prop.value) as tinyest.Expression;\n\n      properties[key] = value;\n    }\n\n    return [NODE.objectExpr, properties];\n  },\n\n  ForStatement(ctx, node) {\n    const init = node.init\n      ? (transpile(ctx, node.init) as tinyest.Statement)\n      : null;\n    const condition = node.test\n      ? (transpile(ctx, node.test) as tinyest.Expression)\n      : null;\n    const update = node.update\n      ? (transpile(ctx, node.update) as tinyest.Statement)\n      : null;\n    const body = transpile(ctx, node.body) as tinyest.Statement;\n\n    return [NODE.for, init, condition, update, body];\n  },\n\n  WhileStatement(ctx, node) {\n    const condition = transpile(ctx, node.test) as tinyest.Expression;\n    const body = transpile(ctx, node.body) as tinyest.Statement;\n    return [NODE.while, condition, body];\n  },\n\n  ContinueStatement() {\n    return [NODE.continue];\n  },\n\n  BreakStatement() {\n    return [NODE.break];\n  },\n\n  TSAsExpression(ctx, node) {\n    return transpile(ctx, node.expression);\n  },\n\n  TSSatisfiesExpression(ctx, node) {\n    return transpile(ctx, node.expression);\n  },\n};\n\nfunction transpile(ctx: Context, node: JsNode): tinyest.AnyNode {\n  const transpiler = Transpilers[node.type];\n\n  if (!transpiler) {\n    throw new Error(`Unsupported JS functionality: ${node.type}`);\n  }\n\n  // @ts-ignore <too much for typescript, it seems :/ >\n  return transpiler(ctx, node);\n}\n\nexport type TranspilationResult = {\n  params: tinyest.FuncParameter[];\n  body: tinyest.Block;\n  /**\n   * All identifiers found in the function code that are not declared in the\n   * function itself, or in the block that is accessing that identifier.\n   */\n  externalNames: string[];\n};\n\nexport function extractFunctionParts(rootNode: JsNode): {\n  params: tinyest.FuncParameter[];\n  body:\n    | acorn.BlockStatement\n    | acorn.Expression\n    | babel.BlockStatement\n    | babel.Expression;\n} {\n  let functionNode:\n    | acorn.ArrowFunctionExpression\n    | acorn.FunctionExpression\n    | acorn.FunctionDeclaration\n    | acorn.AnonymousFunctionDeclaration\n    | babel.ArrowFunctionExpression\n    | babel.FunctionExpression\n    | babel.FunctionDeclaration\n    | null = null;\n\n  // Unwrapping until we get to a function\n  let unwrappedNode = rootNode;\n  while (true) {\n    if (unwrappedNode.type === 'Program') {\n      const statement = unwrappedNode.body.filter(\n        (n) =>\n          n.type === 'ExpressionStatement' || n.type === 'FunctionDeclaration',\n      )[0]; // <- assuming only one function declaration\n\n      if (!statement) {\n        break;\n      }\n\n      unwrappedNode = statement;\n    } else if (unwrappedNode.type === 'ExpressionStatement') {\n      unwrappedNode = unwrappedNode.expression;\n    } else if (unwrappedNode.type === 'ArrowFunctionExpression') {\n      functionNode = unwrappedNode;\n      break; // We got a function\n    } else if (unwrappedNode.type === 'FunctionExpression') {\n      functionNode = unwrappedNode;\n      break; // We got a function\n    } else if (unwrappedNode.type === 'FunctionDeclaration') {\n      functionNode = unwrappedNode;\n      break; // We got a function\n    } else {\n      // Unsupported node\n      break;\n    }\n  }\n\n  if (!functionNode) {\n    throw new Error(\n      `tgpu.fn expected a single function to be passed as implementation ${\n        JSON.stringify(unwrappedNode)\n      }`,\n    );\n  }\n\n  if (functionNode.async) {\n    throw new Error('tgpu.fn cannot be async');\n  }\n\n  if (functionNode.generator) {\n    throw new Error('tgpu.fn cannot be a generator');\n  }\n\n  const unsupportedTypes = new Set(\n    functionNode.params.flatMap((param) =>\n      param.type === 'ObjectPattern' || param.type === 'Identifier'\n        ? []\n        : [param.type]\n    ),\n  );\n  if (unsupportedTypes.size > 0) {\n    throw new Error(\n      `Unsupported function parameter type(s): ${[...unsupportedTypes]}`,\n    );\n  }\n\n  return {\n    params: (functionNode\n      .params as (\n        | babel.Identifier\n        | acorn.Identifier\n        | babel.ObjectPattern\n        | acorn.ObjectPattern\n      )[]).map((param) =>\n        param.type === 'ObjectPattern'\n          ? {\n            type: FuncParameterType.destructuredObject,\n            props: param.properties.flatMap((prop) =>\n              (prop.type === 'Property' || prop.type === 'ObjectProperty') &&\n                prop.key.type === 'Identifier' &&\n                prop.value.type === 'Identifier'\n                ? [{ name: prop.key.name, alias: prop.value.name }]\n                : []\n            ),\n          }\n          : {\n            type: FuncParameterType.identifier,\n            name: param.name,\n          }\n      ),\n    body: functionNode.body,\n  };\n}\n\nexport function transpileFn(rootNode: JsNode): TranspilationResult {\n  const { params, body } = extractFunctionParts(rootNode);\n\n  const ctx: Context = {\n    externalNames: new Set(),\n    ignoreExternalDepth: 0,\n    stack: [\n      {\n        declaredNames: params.flatMap((param) =>\n          param.type === FuncParameterType.identifier\n            ? param.name\n            : param.props.map((prop) => prop.alias)\n        ),\n      },\n    ],\n  };\n\n  const tinyestBody = transpile(ctx, body);\n  const externalNames = [...ctx.externalNames];\n\n  if (body.type === 'BlockStatement') {\n    return {\n      params,\n      body: tinyestBody as tinyest.Block,\n      externalNames,\n    };\n  }\n\n  return {\n    params,\n    body: [NODE.block, [[NODE.return, tinyestBody as tinyest.Expression]]],\n    externalNames,\n  };\n}\n\nexport function transpileNode(node: JsNode): tinyest.AnyNode {\n  const ctx: Context = {\n    externalNames: new Set(),\n    ignoreExternalDepth: 0,\n    stack: [\n      {\n        declaredNames: [],\n      },\n    ],\n  };\n\n  return transpile(ctx, node);\n}\n"],"mappings":"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","names":["tinyest","FuncParameterType","NODE","isDeclared","ctx","name","scope","BINARY_OP_MAP","LOGICAL_OP_MAP","ASSIGNMENT_OP_MAP","Transpilers","node","body","transpile","result","statement","wgslOp","left","right","argument","object","property","operator","_a","callee","args","arg","elem","decl","id","init","test","consequent","alternate","properties","prop","key","value","condition","update","transpiler","extractFunctionParts","rootNode","functionNode","unwrappedNode","n","unsupportedTypes","param","transpileFn","params","tinyestBody","externalNames","transpileNode"]}