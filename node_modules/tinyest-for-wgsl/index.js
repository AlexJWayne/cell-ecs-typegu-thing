import*as u from"tinyest";import{FuncParameterType as l}from"tinyest";var{NodeTypeCatalog:i}=u;function y(t,e){return t.stack.some(r=>r.declaredNames.includes(e))}var d={"==":"==","!=":"!=","===":"==","!==":"!=","<":"<","<=":"<=",">":">",">=":">=","<<":"<<",">>":">>",get">>>"(){throw new Error("The `>>>` operator is unsupported in TGSL.")},"+":"+","-":"-","*":"*","/":"/","%":"%","|":"|","^":"^","&":"&",get in(){throw new Error("The `in` operator is unsupported in TGSL.")},get instanceof(){throw new Error("The `instanceof` operator is unsupported in TGSL.")},get"**"(){throw new Error("The `**` operator is unsupported in TGSL. Use std.pow() instead.")},get"|>"(){throw new Error("The `|>` operator is unsupported in TGSL.")}},m={"||":"||","&&":"&&",get"??"(){throw new Error("The `??` operator is unsupported in TGSL.")}},E={"=":"=","+=":"+=","-=":"-=","*=":"*=","/=":"/=","%=":"%=","<<=":"<<=",">>=":">>=",get">>>="(){throw new Error("The `>>>=` operator is unsupported in TGSL.")},"|=":"|=","^=":"^=","&=":"&=","**=":"**=","||=":"||=","&&=":"&&=",get"??="(){throw new Error("The `??=` operator is unsupported in TGSL.")}},f={Program(t,e){let r=e.body[0];if(!r)throw new Error("tgpu.fn was not implemented correctly.");return o(t,r)},ExpressionStatement:(t,e)=>o(t,e.expression),ArrowFunctionExpression:(t,e)=>{throw new Error("Arrow functions are not supported inside TGSL.")},BlockStatement(t,e){t.stack.push({declaredNames:[]});let r=[i.block,e.body.map(n=>o(t,n))];return t.stack.pop(),r},ReturnStatement:(t,e)=>e.argument?[i.return,o(t,e.argument)]:[i.return],Identifier(t,e){return t.ignoreExternalDepth===0&&!y(t,e.name)&&t.externalNames.add(e.name),e.name},BinaryExpression(t,e){let r=d[e.operator],n=o(t,e.left),s=o(t,e.right);return[i.binaryExpr,n,r,s]},LogicalExpression(t,e){let r=m[e.operator],n=o(t,e.left),s=o(t,e.right);return[i.logicalExpr,n,r,s]},AssignmentExpression(t,e){let r=E[e.operator],n=o(t,e.left),s=o(t,e.right);return[i.assignmentExpr,n,r,s]},UnaryExpression(t,e){let r=e.operator,n=o(t,e.argument);return[i.unaryExpr,r,n]},MemberExpression(t,e){let r=o(t,e.object);if(e.computed){let s=o(t,e.property);return[i.indexAccess,r,s]}t.ignoreExternalDepth++;let n=o(t,e.property);if(t.ignoreExternalDepth--,typeof n!="string")throw new Error("Expected identifier as property access key.");return[i.memberAccess,r,n]},UpdateExpression(t,e){let r=e.operator,n=o(t,e.argument);if(e.prefix)throw new Error("Prefix update expressions are not supported in WGSL.");return[i.postUpdate,r,n]},Literal(t,e){var r;return typeof e.value=="boolean"?e.value:typeof e.value=="string"?[i.stringLiteral,e.value]:[i.numericLiteral,(r=e.raw)!=null?r:""]},NumericLiteral(t,e){var r;return[i.numericLiteral,(r=String(e.value))!=null?r:""]},BooleanLiteral(t,e){return e.value},StringLiteral(t,e){return[i.stringLiteral,e.value]},CallExpression(t,e){let r=o(t,e.callee),n=e.arguments.map(s=>o(t,s));return[i.call,r,n]},ArrayExpression:(t,e)=>[i.arrayExpr,e.elements.map(r=>{if(!r||r.type==="SpreadElement")throw new Error("Spread elements are not supported in TGSL.");return o(t,r)})],VariableDeclaration(t,e){var a;if(e.declarations.length!==1||!e.declarations[0])throw new Error("Currently only one declaration in a statement is supported.");let r=e.declarations[0];t.ignoreExternalDepth++;let n=o(t,r.id);if(t.ignoreExternalDepth--,typeof n!="string")throw new Error("Invalid variable declaration, expected identifier.");(a=t.stack[t.stack.length-1])==null||a.declaredNames.push(n);let s=r.init?o(t,r.init):void 0;if(e.kind==="var")throw new Error("`var` declarations are not supported.");if(e.kind==="const"){if(s===void 0)throw new Error("Did not provide initial value in `const` declaration.");return[i.const,n,s]}return s!==void 0?[i.let,n,s]:[i.let,n]},IfStatement(t,e){let r=o(t,e.test),n=o(t,e.consequent),s=e.alternate?o(t,e.alternate):void 0;return s?[i.if,r,n,s]:[i.if,r,n]},ObjectExpression(t,e){let r={};for(let n of e.properties){if(n.type==="SpreadElement")throw new Error("Spread elements are not supported in TGSL.");if(n.key.type!=="Identifier"&&n.key.type!=="Literal")throw new Error("Only Identifier and Literal keys are supported as object keys.");if(n.type==="ObjectMethod")throw new Error("Object method elements are not supported in TGSL.");t.ignoreExternalDepth++;let s=n.key.type==="Identifier"?o(t,n.key):String(n.key.value);t.ignoreExternalDepth--;let a=o(t,n.value);r[s]=a}return[i.objectExpr,r]},ForStatement(t,e){let r=e.init?o(t,e.init):null,n=e.test?o(t,e.test):null,s=e.update?o(t,e.update):null,a=o(t,e.body);return[i.for,r,n,s,a]},WhileStatement(t,e){let r=o(t,e.test),n=o(t,e.body);return[i.while,r,n]},ContinueStatement(){return[i.continue]},BreakStatement(){return[i.break]},TSAsExpression(t,e){return o(t,e.expression)},TSSatisfiesExpression(t,e){return o(t,e.expression)}};function o(t,e){let r=f[e.type];if(!r)throw new Error(`Unsupported JS functionality: ${e.type}`);return r(t,e)}function x(t){let e=null,r=t;for(;;)if(r.type==="Program"){let s=r.body.filter(a=>a.type==="ExpressionStatement"||a.type==="FunctionDeclaration")[0];if(!s)break;r=s}else if(r.type==="ExpressionStatement")r=r.expression;else if(r.type==="ArrowFunctionExpression"){e=r;break}else if(r.type==="FunctionExpression"){e=r;break}else if(r.type==="FunctionDeclaration"){e=r;break}else break;if(!e)throw new Error(`tgpu.fn expected a single function to be passed as implementation ${JSON.stringify(r)}`);if(e.async)throw new Error("tgpu.fn cannot be async");if(e.generator)throw new Error("tgpu.fn cannot be a generator");let n=new Set(e.params.flatMap(s=>s.type==="ObjectPattern"||s.type==="Identifier"?[]:[s.type]));if(n.size>0)throw new Error(`Unsupported function parameter type(s): ${[...n]}`);return{params:e.params.map(s=>s.type==="ObjectPattern"?{type:l.destructuredObject,props:s.properties.flatMap(a=>(a.type==="Property"||a.type==="ObjectProperty")&&a.key.type==="Identifier"&&a.value.type==="Identifier"?[{name:a.key.name,alias:a.value.name}]:[])}:{type:l.identifier,name:s.name}),body:e.body}}function g(t){let{params:e,body:r}=x(t),n={externalNames:new Set,ignoreExternalDepth:0,stack:[{declaredNames:e.flatMap(p=>p.type===l.identifier?p.name:p.props.map(c=>c.alias))}]},s=o(n,r),a=[...n.externalNames];return r.type==="BlockStatement"?{params:e,body:s,externalNames:a}:{params:e,body:[i.block,[[i.return,s]]],externalNames:a}}function w(t){return o({externalNames:new Set,ignoreExternalDepth:0,stack:[{declaredNames:[]}]},t)}export{g as transpileFn,w as transpileNode};
//# sourceMappingURL=index.js.map