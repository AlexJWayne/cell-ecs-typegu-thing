import { FuncParameter, Block } from 'tinyest';

interface MetaData {
    name?: string | undefined;
    ast?: {
        v: number;
        params: FuncParameter[];
        body: Block;
        externalNames: string[];
    } | undefined;
    externals?: Record<string, unknown> | undefined;
}
/**
 * Don't use or you WILL get fired from your job.
 *
 * The information that this type describes is additional
 * properties that we add onto `globalThis`, used by tools
 * like `unplugin-typegpu` or our test suite.
 *
 * @internal
 */
type INTERNAL_GlobalExt = typeof globalThis & {
    __TYPEGPU_META__: WeakMap<object, MetaData>;
    __TYPEGPU_AUTONAME__: <T>(exp: T, label: string) => T;
    __TYPEGPU_MEASURE_PERF__?: boolean | undefined;
    __TYPEGPU_PERF_RECORDS__?: Map<string, unknown[]> | undefined;
};
/**
 * Can be assigned a name. Not to be confused with
 * being able to HAVE a name.
 * The `$name` function should use `setName` to rename the object itself,
 * or rename the object `$getNameForward` symbol points to instead if applicable.
 */
interface TgpuNamable {
    $name(label: string): this;
}

declare const $internal: unique symbol;
/**
 * Marks an object with slot-value bindings
 */
declare const $providing: unique symbol;
/**
 * Type token for the inferred (CPU & GPU) representation of a resource
 */
declare const $repr: unique symbol;
/**
 * Type token for the inferred (GPU-side) representation of a resource
 * If present, it shadows the value of `$repr` for GPU-side inference.
 */
declare const $gpuRepr: unique symbol;
/**
 * Type token for the inferred partial representation of a resource.
 * If present, it shadows the value of `$repr` for use in partial IO.
 */
declare const $reprPartial: unique symbol;
/**
 * Type token holding schemas that are identical in memory layout.
 */
declare const $memIdent: unique symbol;

/**
 * Extracts the inferred representation of a resource.
 * For inferring types as seen by the GPU, see {@link InferGPU}
 *
 * @example
 * type A = Infer<F32> // => number
 * type B = Infer<WgslArray<F32>> // => number[]
 * type C = Infer<Atomic<U32>> // => number
 */
type Infer<T> = T extends {
    readonly [$repr]: infer TRepr;
} ? TRepr : T;
/**
 * Extracts a sparse/partial inferred representation of a resource.
 * Used by the `buffer.writePartial` API.
 *
 * @example
 * type A = InferPartial<F32> // => number | undefined
 * type B = InferPartial<WgslStruct<{ a: F32 }>> // => { a?: number | undefined }
 * type C = InferPartial<WgslArray<F32>> // => { idx: number; value: number | undefined }[] | undefined
 */
type InferPartial<T> = T extends {
    readonly [$reprPartial]: infer TRepr;
} ? TRepr : T extends {
    readonly [$repr]: infer TRepr;
} ? TRepr | undefined : T;
/**
 * Extracts the inferred representation of a resource (as seen by the GPU).
 *
 * @example
 * type A = InferGPU<F32> // => number
 * type B = InferGPU<WgslArray<F32>> // => number[]
 * type C = InferGPU<Atomic<U32>> // => atomicU32
 */
type InferGPU<T> = T extends {
    readonly [$gpuRepr]: infer TRepr;
} ? TRepr : Infer<T>;
type InferRecord<T extends Record<string | number | symbol, unknown>> = {
    [Key in keyof T]: Infer<T[Key]>;
};
type InferPartialRecord<T extends Record<string | number | symbol, unknown>> = {
    [Key in keyof T]?: InferPartial<T[Key]>;
};
type InferGPURecord<T extends Record<string | number | symbol, unknown>> = {
    [Key in keyof T]: InferGPU<T[Key]>;
};
type MemIdentity<T> = T extends {
    readonly [$memIdent]: infer TMemIdent;
} ? TMemIdent : T;
type MemIdentityRecord<T extends Record<string | number | symbol, unknown>> = {
    [Key in keyof T]: MemIdentity<T[Key]>;
};

type Default<T, TDefault> = unknown extends T ? TDefault : T extends undefined ? TDefault : T;
type UnionToIntersection<U> = (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I : never;
type Prettify<T> = {
    [K in keyof T]: T[K];
} & {};
/**
 * Removes properties from record type that extend `Prop`
 */
type OmitProps<T extends Record<string, unknown>, Prop> = Pick<T, {
    [Key in keyof T]: T[Key] extends Prop ? never : Key;
}[keyof T]>;
type NullableToOptional<T> = {
    [K in keyof T as T[K] extends null ? K : never]?: T[K];
} & {
    [K in keyof T as T[K] extends null ? never : K]: T[K];
};
/**
 * The opposite of Readonly<T>
 */
type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};

type DecoratedLocation<T extends BaseData> = Decorated<T, Location[]>;
interface NumberArrayView {
    readonly length: number;
    [n: number]: number;
    [Symbol.iterator]: () => Iterator<number>;
}
interface BaseData {
    readonly [$internal]: true;
    readonly type: string;
    readonly [$repr]: unknown;
}
/**
 * Represents a 64-bit integer.
 */
interface AbstractInt {
    readonly [$internal]: true;
    readonly type: 'abstractInt';
    readonly [$repr]: number;
}
/**
 * Represents a 64-bit IEEE 754 floating point number.
 */
interface AbstractFloat {
    readonly [$internal]: true;
    readonly type: 'abstractFloat';
    readonly [$repr]: number;
}
interface Void {
    readonly [$internal]: true;
    readonly type: 'void';
    readonly [$repr]: void;
}
declare const Void: Void;
interface Swizzle2<T2, T3, T4> {
    readonly xx: T2;
    readonly xy: T2;
    readonly yx: T2;
    readonly yy: T2;
    readonly xxx: T3;
    readonly xxy: T3;
    readonly xyx: T3;
    readonly xyy: T3;
    readonly yxx: T3;
    readonly yxy: T3;
    readonly yyx: T3;
    readonly yyy: T3;
    readonly xxxx: T4;
    readonly xxxy: T4;
    readonly xxyx: T4;
    readonly xxyy: T4;
    readonly xyxx: T4;
    readonly xyxy: T4;
    readonly xyyx: T4;
    readonly xyyy: T4;
    readonly yxxx: T4;
    readonly yxxy: T4;
    readonly yxyx: T4;
    readonly yxyy: T4;
    readonly yyxx: T4;
    readonly yyxy: T4;
    readonly yyyx: T4;
    readonly yyyy: T4;
}
interface Swizzle3<T2, T3, T4> extends Swizzle2<T2, T3, T4> {
    readonly xz: T2;
    readonly yz: T2;
    readonly zx: T2;
    readonly zy: T2;
    readonly zz: T2;
    readonly xxz: T3;
    readonly xyz: T3;
    readonly xzx: T3;
    readonly xzy: T3;
    readonly xzz: T3;
    readonly yxz: T3;
    readonly yyz: T3;
    readonly yzx: T3;
    readonly yzy: T3;
    readonly yzz: T3;
    readonly zxx: T3;
    readonly zxy: T3;
    readonly zxz: T3;
    readonly zyx: T3;
    readonly zyy: T3;
    readonly zyz: T3;
    readonly zzx: T3;
    readonly zzy: T3;
    readonly zzz: T3;
    readonly xxxz: T4;
    readonly xxyz: T4;
    readonly xxzx: T4;
    readonly xxzy: T4;
    readonly xxzz: T4;
    readonly xyxz: T4;
    readonly xyyz: T4;
    readonly xyzx: T4;
    readonly xyzy: T4;
    readonly xyzz: T4;
    readonly xzxx: T4;
    readonly xzxy: T4;
    readonly xzxz: T4;
    readonly xzyx: T4;
    readonly xzyy: T4;
    readonly xzyz: T4;
    readonly xzzx: T4;
    readonly xzzy: T4;
    readonly xzzz: T4;
    readonly yxxz: T4;
    readonly yxyz: T4;
    readonly yxzx: T4;
    readonly yxzy: T4;
    readonly yxzz: T4;
    readonly yyxz: T4;
    readonly yyyz: T4;
    readonly yyzx: T4;
    readonly yyzy: T4;
    readonly yyzz: T4;
    readonly yzxx: T4;
    readonly yzxy: T4;
    readonly yzxz: T4;
    readonly yzyx: T4;
    readonly yzyy: T4;
    readonly yzyz: T4;
    readonly yzzx: T4;
    readonly yzzy: T4;
    readonly yzzz: T4;
    readonly zxxx: T4;
    readonly zxxy: T4;
    readonly zxxz: T4;
    readonly zxyx: T4;
    readonly zxyy: T4;
    readonly zxyz: T4;
    readonly zxzx: T4;
    readonly zxzy: T4;
    readonly zxzz: T4;
    readonly zyxx: T4;
    readonly zyxy: T4;
    readonly zyxz: T4;
    readonly zyyx: T4;
    readonly zyyy: T4;
    readonly zyyz: T4;
    readonly zyzx: T4;
    readonly zyzy: T4;
    readonly zyzz: T4;
    readonly zzxx: T4;
    readonly zzxy: T4;
    readonly zzxz: T4;
    readonly zzyx: T4;
    readonly zzyy: T4;
    readonly zzyz: T4;
    readonly zzzx: T4;
    readonly zzzy: T4;
    readonly zzzz: T4;
}
interface Swizzle4<T2, T3, T4> extends Swizzle3<T2, T3, T4> {
    readonly yw: T2;
    readonly zw: T2;
    readonly wx: T2;
    readonly wy: T2;
    readonly wz: T2;
    readonly ww: T2;
    readonly xxw: T3;
    readonly xyw: T3;
    readonly xzw: T3;
    readonly xwx: T3;
    readonly xwy: T3;
    readonly xwz: T3;
    readonly xww: T3;
    readonly yxw: T3;
    readonly yyw: T3;
    readonly yzw: T3;
    readonly ywx: T3;
    readonly ywy: T3;
    readonly ywz: T3;
    readonly yww: T3;
    readonly zxw: T3;
    readonly zyw: T3;
    readonly zzw: T3;
    readonly zwx: T3;
    readonly zwy: T3;
    readonly zwz: T3;
    readonly zww: T3;
    readonly wxx: T3;
    readonly wxz: T3;
    readonly wxy: T3;
    readonly wyy: T3;
    readonly wyz: T3;
    readonly wzz: T3;
    readonly wwx: T3;
    readonly wwy: T3;
    readonly wwz: T3;
    readonly www: T3;
    readonly xxxw: T4;
    readonly xxyw: T4;
    readonly xxzw: T4;
    readonly xxwx: T4;
    readonly xxwy: T4;
    readonly xxwz: T4;
    readonly xxww: T4;
    readonly xyxw: T4;
    readonly xyyw: T4;
    readonly xyzw: T4;
    readonly xywx: T4;
    readonly xywy: T4;
    readonly xywz: T4;
    readonly xyww: T4;
    readonly xzxw: T4;
    readonly xzyw: T4;
    readonly xzzw: T4;
    readonly xzwx: T4;
    readonly xzwy: T4;
    readonly xzwz: T4;
    readonly xzww: T4;
    readonly xwxx: T4;
    readonly xwxy: T4;
    readonly xwxz: T4;
    readonly xwyy: T4;
    readonly xwyz: T4;
    readonly xwzz: T4;
    readonly xwwx: T4;
    readonly xwwy: T4;
    readonly xwwz: T4;
    readonly xwww: T4;
    readonly yxxw: T4;
    readonly yxyw: T4;
    readonly yxzw: T4;
    readonly yxwx: T4;
    readonly yxwy: T4;
    readonly yxwz: T4;
    readonly yxww: T4;
    readonly yyxw: T4;
    readonly yyyw: T4;
    readonly yyzw: T4;
    readonly yywx: T4;
    readonly yywy: T4;
    readonly yywz: T4;
    readonly yyww: T4;
    readonly yzxw: T4;
    readonly yzyw: T4;
    readonly yzzw: T4;
    readonly yzwx: T4;
    readonly yzwy: T4;
    readonly yzwz: T4;
    readonly yzww: T4;
    readonly ywxx: T4;
    readonly ywxy: T4;
    readonly ywxz: T4;
    readonly ywxw: T4;
    readonly ywyy: T4;
    readonly ywyz: T4;
    readonly ywzz: T4;
    readonly ywwx: T4;
    readonly ywwy: T4;
    readonly ywwz: T4;
    readonly ywww: T4;
    readonly zxxw: T4;
    readonly zxyw: T4;
    readonly zxzw: T4;
    readonly zxwx: T4;
    readonly zxwy: T4;
    readonly zxwz: T4;
    readonly zxww: T4;
    readonly zyxw: T4;
    readonly zyyw: T4;
    readonly zyzw: T4;
    readonly zywx: T4;
    readonly zywy: T4;
    readonly zywz: T4;
    readonly zyww: T4;
    readonly zzxw: T4;
    readonly zzyw: T4;
    readonly zzzw: T4;
    readonly zzwx: T4;
    readonly zzwy: T4;
    readonly zzwz: T4;
    readonly zzww: T4;
    readonly zwxx: T4;
    readonly zwxy: T4;
    readonly zwxz: T4;
    readonly zwxw: T4;
    readonly zwyy: T4;
    readonly zwyz: T4;
    readonly zwzz: T4;
    readonly zwwx: T4;
    readonly zwwy: T4;
    readonly zwwz: T4;
    readonly zwww: T4;
    readonly wxxx: T4;
    readonly wxxy: T4;
    readonly wxxz: T4;
    readonly wxxw: T4;
    readonly wxyx: T4;
    readonly wxyy: T4;
    readonly wxyz: T4;
    readonly wxyw: T4;
    readonly wxzx: T4;
    readonly wxzy: T4;
    readonly wxzz: T4;
    readonly wxzw: T4;
    readonly wxwx: T4;
    readonly wxwy: T4;
    readonly wxwz: T4;
    readonly wxww: T4;
    readonly wyxx: T4;
    readonly wyxy: T4;
    readonly wyxz: T4;
    readonly wyxw: T4;
    readonly wyyy: T4;
    readonly wyyz: T4;
    readonly wyzw: T4;
    readonly wywx: T4;
    readonly wywy: T4;
    readonly wywz: T4;
    readonly wyww: T4;
    readonly wzxx: T4;
    readonly wzxy: T4;
    readonly wzxz: T4;
    readonly wzxw: T4;
    readonly wzyy: T4;
    readonly wzyz: T4;
    readonly wzzy: T4;
    readonly wzzw: T4;
    readonly wzwx: T4;
    readonly wzwy: T4;
    readonly wzwz: T4;
    readonly wzww: T4;
    readonly wwxx: T4;
    readonly wwxy: T4;
    readonly wwxz: T4;
    readonly wwxw: T4;
    readonly wwyy: T4;
    readonly wwyz: T4;
    readonly wwzz: T4;
    readonly wwwx: T4;
    readonly wwwy: T4;
    readonly wwwz: T4;
    readonly wwww: T4;
}
type Tuple2<S> = [S, S];
type Tuple3<S> = [S, S, S];
type Tuple4<S> = [S, S, S, S];
/**
 * Interface representing its WGSL vector type counterpart: vec2f or vec2<f32>.
 * A vector with 2 elements of type f32
 */
interface v2f extends Tuple2<number>, Swizzle2<v2f, v3f, v4f> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2f';
    x: number;
    y: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec2h or vec2<f16>.
 * A vector with 2 elements of type f16
 */
interface v2h extends Tuple2<number>, Swizzle2<v2h, v3h, v4h> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2h';
    x: number;
    y: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec2i or vec2<i32>.
 * A vector with 2 elements of type i32
 */
interface v2i extends Tuple2<number>, Swizzle2<v2i, v3i, v4i> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2i';
    x: number;
    y: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec2u or vec2<u32>.
 * A vector with 2 elements of type u32
 */
interface v2u extends Tuple2<number>, Swizzle2<v2u, v3u, v4u> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2u';
    x: number;
    y: number;
}
/**
 * Interface representing its WGSL vector type counterpart: `vec2<bool>`.
 * A vector with 2 elements of type `bool`
 */
interface v2b extends Tuple2<boolean>, Swizzle2<v2b, v3b, v4b> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec2<bool>';
    x: boolean;
    y: boolean;
}
/**
 * Interface representing its WGSL vector type counterpart: vec3f or vec3<f32>.
 * A vector with 3 elements of type f32
 */
interface v3f extends Tuple3<number>, Swizzle3<v2f, v3f, v4f> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3f';
    x: number;
    y: number;
    z: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec3h or vec3<f16>.
 * A vector with 3 elements of type f16
 */
interface v3h extends Tuple3<number>, Swizzle3<v2h, v3h, v4h> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3h';
    x: number;
    y: number;
    z: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec3i or vec3<i32>.
 * A vector with 3 elements of type i32
 */
interface v3i extends Tuple3<number>, Swizzle3<v2i, v3i, v4i> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3i';
    x: number;
    y: number;
    z: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec3u or vec3<u32>.
 * A vector with 3 elements of type u32
 */
interface v3u extends Tuple3<number>, Swizzle3<v2u, v3u, v4u> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3u';
    x: number;
    y: number;
    z: number;
}
/**
 * Interface representing its WGSL vector type counterpart: `vec3<bool>`.
 * A vector with 3 elements of type `bool`
 */
interface v3b extends Tuple3<boolean>, Swizzle3<v2b, v3b, v4b> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec3<bool>';
    x: boolean;
    y: boolean;
    z: boolean;
}
/**
 * Interface representing its WGSL vector type counterpart: vec4f or vec4<f32>.
 * A vector with 4 elements of type f32
 */
interface v4f extends Tuple4<number>, Swizzle4<v2f, v3f, v4f> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4f';
    x: number;
    y: number;
    z: number;
    w: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec4h or vec4<f16>.
 * A vector with 4 elements of type f16
 */
interface v4h extends Tuple4<number>, Swizzle4<v2h, v3h, v4h> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4h';
    x: number;
    y: number;
    z: number;
    w: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec4i or vec4<i32>.
 * A vector with 4 elements of type i32
 */
interface v4i extends Tuple4<number>, Swizzle4<v2i, v3i, v4i> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4i';
    x: number;
    y: number;
    z: number;
    w: number;
}
/**
 * Interface representing its WGSL vector type counterpart: vec4u or vec4<u32>.
 * A vector with 4 elements of type u32
 */
interface v4u extends Tuple4<number>, Swizzle4<v2u, v3u, v4u> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4u';
    x: number;
    y: number;
    z: number;
    w: number;
}
/**
 * Interface representing its WGSL vector type counterpart: `vec4<bool>`.
 * A vector with 4 elements of type `bool`
 */
interface v4b extends Tuple4<boolean>, Swizzle4<v2b, v3b, v4b> {
    readonly [$internal]: true;
    /** use to distinguish between vectors of the same size on the type level */
    readonly kind: 'vec4<bool>';
    x: boolean;
    y: boolean;
    z: boolean;
    w: boolean;
}
type AnyFloatVecInstance = v2f | v2h | v3f | v3h | v4f | v4h;
type AnyBooleanVecInstance = v2b | v3b | v4b;
type AnyNumericVec2Instance = v2f | v2h | v2i | v2u;
type AnyNumericVec3Instance = v3f | v3h | v3i | v3u;
type AnyNumericVec4Instance = v4f | v4h | v4i | v4u;
type AnyNumericVecInstance = AnyNumericVec2Instance | AnyNumericVec3Instance | AnyNumericVec4Instance;
type AnyVec2Instance = v2f | v2h | v2i | v2u | v2b;
type AnyVec3Instance = v3f | v3h | v3i | v3u | v3b;
type AnyVec4Instance = v4f | v4h | v4i | v4u | v4b;
type AnyVecInstance = AnyVec2Instance | AnyVec3Instance | AnyVec4Instance;
interface matBase<TColumn> extends NumberArrayView {
    readonly [$internal]: true;
    readonly columns: readonly TColumn[];
}
/**
 * Interface representing its WGSL matrix type counterpart: mat2x2
 * A matrix with 2 rows and 2 columns, with elements of type `TColumn`
 */
interface mat2x2<TColumn> extends matBase<TColumn> {
    readonly length: 4;
    readonly kind: string;
    readonly columns: readonly [TColumn, TColumn];
    [n: number]: number;
}
/**
 * Interface representing its WGSL matrix type counterpart: mat2x2f or mat2x2<f32>
 * A matrix with 2 rows and 2 columns, with elements of type d.f32
 */
interface m2x2f extends mat2x2<v2f> {
    readonly kind: 'mat2x2f';
}
/**
 * Interface representing its WGSL matrix type counterpart: mat3x3
 * A matrix with 3 rows and 3 columns, with elements of type `TColumn`
 */
interface mat3x3<TColumn> extends matBase<TColumn> {
    readonly length: 12;
    readonly kind: string;
    readonly columns: readonly [TColumn, TColumn, TColumn];
    [n: number]: number;
}
/**
 * Interface representing its WGSL matrix type counterpart: mat3x3f or mat3x3<f32>
 * A matrix with 3 rows and 3 columns, with elements of type d.f32
 */
interface m3x3f extends mat3x3<v3f> {
    readonly kind: 'mat3x3f';
}
/**
 * Interface representing its WGSL matrix type counterpart: mat4x4
 * A matrix with 4 rows and 4 columns, with elements of type `TColumn`
 */
interface mat4x4<TColumn> extends matBase<TColumn> {
    readonly length: 16;
    readonly kind: string;
    readonly columns: readonly [
        TColumn,
        TColumn,
        TColumn,
        TColumn
    ];
    [n: number]: number;
}
/**
 * Interface representing its WGSL matrix type counterpart: mat4x4f or mat4x4<f32>
 * A matrix with 4 rows and 4 columns, with elements of type d.f32
 */
interface m4x4f extends mat4x4<v4f> {
    readonly kind: 'mat4x4f';
}
type AnyMatInstance = m2x2f | m3x3f | m4x4f;
type vBaseForMat<T extends AnyMatInstance> = T extends m2x2f ? v2f : T extends m3x3f ? v3f : v4f;
type mBaseForVec<T extends AnyVecInstance> = T extends v2f ? m2x2f : T extends v3f ? m3x3f : T extends v4f ? m4x4f : never;
/**
 * Boolean schema representing a single WGSL bool value.
 * Cannot be used inside buffers as it is not host-shareable.
 */
interface Bool {
    readonly [$internal]: true;
    readonly type: 'bool';
    readonly [$repr]: boolean;
    (v?: number | boolean): boolean;
}
/**
 * 32-bit float schema representing a single WGSL f32 value.
 */
interface F32 {
    readonly [$internal]: true;
    readonly type: 'f32';
    readonly [$repr]: number;
    (v?: number | boolean): number;
}
/**
 * 16-bit float schema representing a single WGSL f16 value.
 */
interface F16 {
    readonly [$internal]: true;
    readonly type: 'f16';
    readonly [$repr]: number;
    (v?: number | boolean): number;
}
/**
 * Signed 32-bit integer schema representing a single WGSL i32 value.
 */
interface I32 {
    readonly [$internal]: true;
    readonly type: 'i32';
    readonly [$repr]: number;
    readonly [$memIdent]: I32 | Atomic<I32> | DecoratedLocation<I32>;
    (v?: number | boolean): number;
}
/**
 * Unsigned 32-bit integer schema representing a single WGSL u32 value.
 */
interface U32 {
    readonly [$internal]: true;
    readonly type: 'u32';
    readonly [$repr]: number;
    readonly [$memIdent]: U32 | Atomic<U32> | DecoratedLocation<U32>;
    (v?: number | boolean): number;
}
/**
 * Unsigned 16-bit integer schema used exclusively for index buffer schemas.
 */
interface U16 {
    readonly [$internal]: true;
    readonly type: 'u16';
    readonly [$repr]: number;
}
/**
 * Type of the `d.vec2f` object/function: vector data type schema/constructor
 */
interface Vec2f {
    readonly [$internal]: true;
    readonly type: 'vec2f';
    readonly [$repr]: v2f;
    (x: number, y: number): v2f;
    (xy: number): v2f;
    (): v2f;
    (v: AnyNumericVec2Instance): v2f;
}
/**
 * Type of the `d.vec2h` object/function: vector data type schema/constructor
 */
interface Vec2h {
    readonly [$internal]: true;
    readonly type: 'vec2h';
    readonly [$repr]: v2h;
    (x: number, y: number): v2h;
    (xy: number): v2h;
    (): v2h;
    (v: AnyNumericVec2Instance): v2h;
}
/**
 * Type of the `d.vec2i` object/function: vector data type schema/constructor
 */
interface Vec2i {
    readonly [$internal]: true;
    readonly type: 'vec2i';
    readonly [$repr]: v2i;
    (x: number, y: number): v2i;
    (xy: number): v2i;
    (): v2i;
    (v: AnyNumericVec2Instance): v2i;
}
/**
 * Type of the `d.vec2u` object/function: vector data type schema/constructor
 */
interface Vec2u {
    readonly [$internal]: true;
    readonly type: 'vec2u';
    readonly [$repr]: v2u;
    (x: number, y: number): v2u;
    (xy: number): v2u;
    (): v2u;
    (v: AnyNumericVec2Instance): v2u;
}
/**
 * Type of the `d.vec2b` object/function: vector data type schema/constructor
 * Cannot be used inside buffers as it is not host-shareable.
 */
interface Vec2b {
    readonly [$internal]: true;
    readonly type: 'vec2<bool>';
    readonly [$repr]: v2b;
    (x: boolean, y: boolean): v2b;
    (xy: boolean): v2b;
    (): v2b;
    (v: v2b): v2b;
}
/**
 * Type of the `d.vec3f` object/function: vector data type schema/constructor
 */
interface Vec3f {
    readonly [$internal]: true;
    readonly type: 'vec3f';
    readonly [$repr]: v3f;
    (x: number, y: number, z: number): v3f;
    (xyz: number): v3f;
    (): v3f;
    (v: AnyNumericVec3Instance): v3f;
    (v0: AnyNumericVec2Instance, z: number): v3f;
    (x: number, v0: AnyNumericVec2Instance): v3f;
}
/**
 * Type of the `d.vec3h` object/function: vector data type schema/constructor
 */
interface Vec3h {
    readonly [$internal]: true;
    readonly type: 'vec3h';
    readonly [$repr]: v3h;
    (x: number, y: number, z: number): v3h;
    (xyz: number): v3h;
    (): v3h;
    (v: AnyNumericVec3Instance): v3h;
    (v0: AnyNumericVec2Instance, z: number): v3h;
    (x: number, v0: AnyNumericVec2Instance): v3h;
}
/**
 * Type of the `d.vec3i` object/function: vector data type schema/constructor
 */
interface Vec3i {
    readonly [$internal]: true;
    readonly type: 'vec3i';
    readonly [$repr]: v3i;
    (x: number, y: number, z: number): v3i;
    (xyz: number): v3i;
    (): v3i;
    (v: AnyNumericVec3Instance): v3i;
    (v0: AnyNumericVec2Instance, z: number): v3i;
    (x: number, v0: AnyNumericVec2Instance): v3i;
}
/**
 * Type of the `d.vec3u` object/function: vector data type schema/constructor
 */
interface Vec3u {
    readonly [$internal]: true;
    readonly type: 'vec3u';
    readonly [$repr]: v3u;
    (x: number, y: number, z: number): v3u;
    (xyz: number): v3u;
    (): v3u;
    (v: AnyNumericVec3Instance): v3u;
    (v0: AnyNumericVec2Instance, z: number): v3u;
    (x: number, v0: AnyNumericVec2Instance): v3u;
}
/**
 * Type of the `d.vec3b` object/function: vector data type schema/constructor
 * Cannot be used inside buffers as it is not host-shareable.
 */
interface Vec3b {
    readonly [$internal]: true;
    readonly type: 'vec3<bool>';
    readonly [$repr]: v3b;
    (x: boolean, y: boolean, z: boolean): v3b;
    (xyz: boolean): v3b;
    (): v3b;
    (v: v3b): v3b;
    (v0: v2b, z: boolean): v3b;
    (x: boolean, v0: v2b): v3b;
}
/**
 * Type of the `d.vec4f` object/function: vector data type schema/constructor
 */
interface Vec4f {
    readonly [$internal]: true;
    readonly type: 'vec4f';
    readonly [$repr]: v4f;
    (x: number, y: number, z: number, w: number): v4f;
    (xyzw: number): v4f;
    (): v4f;
    (v: AnyNumericVec4Instance): v4f;
    (v0: AnyNumericVec3Instance, w: number): v4f;
    (x: number, v0: AnyNumericVec3Instance): v4f;
    (v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance): v4f;
    (v0: AnyNumericVec2Instance, z: number, w: number): v4f;
    (x: number, v0: AnyNumericVec2Instance, z: number): v4f;
    (x: number, y: number, v0: AnyNumericVec2Instance): v4f;
}
/**
 * Type of the `d.vec4h` object/function: vector data type schema/constructor
 */
interface Vec4h {
    readonly [$internal]: true;
    readonly type: 'vec4h';
    readonly [$repr]: v4h;
    (x: number, y: number, z: number, w: number): v4h;
    (xyzw: number): v4h;
    (): v4h;
    (v: AnyNumericVec4Instance): v4h;
    (v0: AnyNumericVec3Instance, w: number): v4h;
    (x: number, v0: AnyNumericVec3Instance): v4h;
    (v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance): v4h;
    (v0: AnyNumericVec2Instance, z: number, w: number): v4h;
    (x: number, v0: AnyNumericVec2Instance, z: number): v4h;
    (x: number, y: number, v0: AnyNumericVec2Instance): v4h;
}
/**
 * Type of the `d.vec4i` object/function: vector data type schema/constructor
 */
interface Vec4i {
    readonly [$internal]: true;
    readonly type: 'vec4i';
    readonly [$repr]: v4i;
    (x: number, y: number, z: number, w: number): v4i;
    (xyzw: number): v4i;
    (): v4i;
    (v: AnyNumericVec4Instance): v4i;
    (v0: AnyNumericVec3Instance, w: number): v4i;
    (x: number, v0: AnyNumericVec3Instance): v4i;
    (v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance): v4i;
    (v0: AnyNumericVec2Instance, z: number, w: number): v4i;
    (x: number, v0: AnyNumericVec2Instance, z: number): v4i;
    (x: number, y: number, v0: AnyNumericVec2Instance): v4i;
}
/**
 * Type of the `d.vec4u` object/function: vector data type schema/constructor
 */
interface Vec4u {
    readonly [$internal]: true;
    readonly type: 'vec4u';
    readonly [$repr]: v4u;
    (x: number, y: number, z: number, w: number): v4u;
    (xyzw: number): v4u;
    (): v4u;
    (v: AnyNumericVec4Instance): v4u;
    (v0: AnyNumericVec3Instance, w: number): v4u;
    (x: number, v0: AnyNumericVec3Instance): v4u;
    (v0: AnyNumericVec2Instance, v1: AnyNumericVec2Instance): v4u;
    (v0: AnyNumericVec2Instance, z: number, w: number): v4u;
    (x: number, v0: AnyNumericVec2Instance, z: number): v4u;
    (x: number, y: number, v0: AnyNumericVec2Instance): v4u;
}
/**
 * Type of the `d.vec4b` object/function: vector data type schema/constructor
 * Cannot be used inside buffers as it is not host-shareable.
 */
interface Vec4b {
    readonly [$internal]: true;
    readonly type: 'vec4<bool>';
    readonly [$repr]: v4b;
    (x: boolean, y: boolean, z: boolean, w: boolean): v4b;
    (xyzw: boolean): v4b;
    (): v4b;
    (v: v4b): v4b;
    (v0: v3b, w: boolean): v4b;
    (x: boolean, v0: v3b): v4b;
    (v0: v2b, v1: v2b): v4b;
    (v0: v2b, z: boolean, w: boolean): v4b;
    (x: boolean, v0: v2b, z: boolean): v4b;
    (x: boolean, y: boolean, v0: v2b): v4b;
}
/**
 * Type of the `d.mat2x2f` object/function: matrix data type schema/constructor
 */
interface Mat2x2f {
    readonly [$internal]: true;
    readonly type: 'mat2x2f';
    readonly [$repr]: m2x2f;
    (...elements: [number, number, number, number]): m2x2f;
    (...columns: [v2f, v2f]): m2x2f;
    (): m2x2f;
    identity(): m2x2f;
}
/**
 * Type of the `d.mat3x3f` object/function: matrix data type schema/constructor
 */
interface Mat3x3f {
    readonly [$internal]: true;
    readonly type: 'mat3x3f';
    readonly [$repr]: m3x3f;
    (...elements: [number, number, number, number, number, number, number, number, number]): m3x3f;
    (...columns: [v3f, v3f, v3f]): m3x3f;
    (): m3x3f;
    identity(): m3x3f;
}
/**
 * Type of the `d.mat4x4f` object/function: matrix data type schema/constructor
 */
interface Mat4x4f {
    readonly [$internal]: true;
    readonly type: 'mat4x4f';
    readonly [$repr]: m4x4f;
    (...elements: [number, number, number, number, number, number, number, number, number, number, number, number, number, number, number, number]): m4x4f;
    (...columns: [v4f, v4f, v4f, v4f]): m4x4f;
    (): m4x4f;
    identity(): m4x4f;
    translation(vec: v3f): m4x4f;
    scaling(vec: v3f): m4x4f;
    rotationX(angle: number): m4x4f;
    rotationY(angle: number): m4x4f;
    rotationZ(angle: number): m4x4f;
}
/**
 * Array schema constructed via `d.arrayOf` function.
 *
 * Responsible for handling reading and writing array values
 * between binary and JS representation. Takes into account
 * the `byteAlignment` requirement of its elementType.
 */
interface WgslArray<TElement extends BaseData = BaseData> {
    readonly [$internal]: true;
    readonly type: 'array';
    readonly elementCount: number;
    readonly elementType: TElement;
    readonly [$repr]: Infer<TElement>[];
    readonly [$gpuRepr]: InferGPU<TElement>[];
    readonly [$reprPartial]: {
        idx: number;
        value: InferPartial<TElement>;
    }[] | undefined;
    readonly [$memIdent]: WgslArray<MemIdentity<TElement>>;
}
/**
 * Struct schema constructed via `d.struct` function.
 *
 * Responsible for handling reading and writing struct values
 * between binary and JS representation. Takes into account
 * the `byteAlignment` requirement of its members.
 */
interface WgslStruct<TProps extends Record<string, BaseData> = Record<string, BaseData>> extends TgpuNamable {
    (props: Prettify<InferRecord<TProps>>): Prettify<InferRecord<TProps>>;
    readonly [$internal]: true;
    readonly type: 'struct';
    readonly propTypes: TProps;
    readonly [$repr]: Prettify<InferRecord<TProps>>;
    readonly [$gpuRepr]: Prettify<InferGPURecord<TProps>>;
    readonly [$memIdent]: WgslStruct<Prettify<MemIdentityRecord<TProps>>>;
    readonly [$reprPartial]: Prettify<Partial<InferPartialRecord<TProps>>> | undefined;
}
type AnyWgslStruct = WgslStruct<any>;
type AddressSpace = 'uniform' | 'storage' | 'workgroup' | 'private' | 'function' | 'handle';
type Access = 'read' | 'write' | 'read-write';
interface Ptr<TAddr extends AddressSpace = AddressSpace, TInner extends BaseData = BaseData, // can also be sampler or texture (╯'□')╯︵ ┻━┻
TAccess extends Access = Access> {
    readonly [$internal]: true;
    readonly type: 'ptr';
    readonly inner: TInner;
    readonly addressSpace: TAddr;
    readonly access: TAccess;
    readonly [$repr]: Infer<TInner>;
}
/**
 * Schema representing the `atomic<...>` WGSL data type.
 */
interface Atomic<TInner extends U32 | I32 = U32 | I32> {
    readonly [$internal]: true;
    readonly type: 'atomic';
    readonly inner: TInner;
    readonly [$repr]: Infer<TInner>;
    readonly [$gpuRepr]: TInner extends U32 ? atomicU32 : atomicI32;
    readonly [$memIdent]: MemIdentity<TInner>;
}
interface atomicU32 {
    readonly [$internal]: true;
    readonly type: 'atomicU32';
}
interface atomicI32 {
    readonly [$internal]: true;
    readonly type: 'atomicI32';
}
interface Align<T extends number> {
    readonly [$internal]: true;
    readonly type: '@align';
    readonly value: T;
}
interface Size<T extends number> {
    readonly [$internal]: true;
    readonly type: '@size';
    readonly value: T;
}
interface Location<T extends number = number> {
    readonly [$internal]: true;
    readonly type: '@location';
    readonly value: T;
}
type PerspectiveOrLinearInterpolationType = `${'perspective' | 'linear'}${'' | ', center' | ', centroid' | ', sample'}`;
type FlatInterpolationType = `flat${'' | ', first' | ', either'}`;
type InterpolationType = PerspectiveOrLinearInterpolationType | FlatInterpolationType;
interface Interpolate<T extends InterpolationType = InterpolationType> {
    readonly [$internal]: true;
    readonly type: '@interpolate';
    readonly value: T;
}
interface Builtin<T extends string> {
    readonly [$internal]: true;
    readonly type: '@builtin';
    readonly value: T;
}
interface Decorated<TInner extends BaseData = BaseData, TAttribs extends unknown[] = unknown[]> {
    readonly [$internal]: true;
    readonly type: 'decorated';
    readonly inner: TInner;
    readonly attribs: TAttribs;
    readonly [$repr]: Infer<TInner>;
    readonly [$gpuRepr]: InferGPU<TInner>;
    readonly [$reprPartial]: InferPartial<TInner>;
    readonly [$memIdent]: TAttribs extends Location[] ? MemIdentity<TInner> | Decorated<MemIdentity<TInner>, TAttribs> : Decorated<MemIdentity<TInner>, TAttribs>;
}
declare const wgslTypeLiterals: readonly ["bool", "f32", "f16", "i32", "u32", "u16", "vec2f", "vec2h", "vec2i", "vec2u", "vec2<bool>", "vec3f", "vec3h", "vec3i", "vec3u", "vec3<bool>", "vec4f", "vec4h", "vec4i", "vec4u", "vec4<bool>", "mat2x2f", "mat3x3f", "mat4x4f", "struct", "array", "ptr", "atomic", "decorated", "abstractInt", "abstractFloat", "void"];
type WgslTypeLiteral = (typeof wgslTypeLiterals)[number];
type PerspectiveOrLinearInterpolatableBaseType = F32 | F16 | Vec2f | Vec2h | Vec3f | Vec3h | Vec4f | Vec4h;
type PerspectiveOrLinearInterpolatableData = PerspectiveOrLinearInterpolatableBaseType | Decorated<PerspectiveOrLinearInterpolatableBaseType>;
type FlatInterpolatableAdditionalBaseType = I32 | U32 | Vec2i | Vec2u | Vec3i | Vec3u | Vec4i | Vec4u;
type FlatInterpolatableData = PerspectiveOrLinearInterpolatableData | FlatInterpolatableAdditionalBaseType | Decorated<FlatInterpolatableAdditionalBaseType>;
type AnyWgslData = Bool | F32 | F16 | I32 | U32 | U16 | Vec2f | Vec2h | Vec2i | Vec2u | Vec2b | Vec3f | Vec3h | Vec3i | Vec3u | Vec3b | Vec4f | Vec4h | Vec4i | Vec4u | Vec4b | Mat2x2f | Mat3x3f | Mat4x4f | AnyWgslStruct | WgslArray | Ptr | Atomic<U32> | Atomic<I32> | Decorated | AbstractInt | AbstractFloat | Void;
declare function isWgslData(value: unknown): value is AnyWgslData;
/**
 * Checks whether passed in value is an array schema,
 * as opposed to, e.g., a disarray schema.
 *
 * Array schemas can be used to describe uniform and storage buffers,
 * whereas disarray schemas cannot.
 *
 * @example
 * isWgslArray(d.arrayOf(d.u32, 4)) // true
 * isWgslArray(d.disarray(d.u32, 4)) // false
 * isWgslArray(d.vec3f) // false
 */
declare function isWgslArray<T extends WgslArray>(schema: T | unknown): schema is T;
/**
 * Checks whether passed in value is a struct schema,
 * as opposed to, e.g., an unstruct schema.
 *
 * Struct schemas can be used to describe uniform and storage buffers,
 * whereas unstruct schemas cannot.
 *
 * @example
 * isWgslStruct(d.struct({ a: d.u32 })) // true
 * isWgslStruct(d.unstruct({ a: d.u32 })) // false
 * isWgslStruct(d.vec3f) // false
 */
declare function isWgslStruct<T extends WgslStruct>(schema: T | unknown): schema is T;
/**
 * Checks whether passed in value is a pointer ('function' scope) schema.
 *
 * @example
 * isPtrFn(d.ptrFn(d.f32)) // true
 * isPtrFn(d.f32) // false
 */
declare function isPtr<T extends Ptr>(schema: T | unknown): schema is T;
/**
 * Checks whether the passed in value is an atomic schema.
 *
 * @example
 * isAtomic(d.atomic(d.u32)) // true
 * isAtomic(d.u32) // false
 */
declare function isAtomic<T extends Atomic<U32 | I32>>(schema: T | unknown): schema is T;
declare function isAlignAttrib<T extends Align<number>>(value: unknown | T): value is T;
declare function isSizeAttrib<T extends Size<number>>(value: unknown | T): value is T;
declare function isLocationAttrib<T extends Location<number>>(value: unknown | T): value is T;
declare function isInterpolateAttrib<T extends Interpolate<InterpolationType>>(value: unknown | T): value is T;
declare function isBuiltinAttrib<T extends Builtin<string>>(value: unknown | T): value is T;
declare function isDecorated<T extends Decorated>(value: unknown | T): value is T;

interface TgpuConst<TDataType extends AnyWgslData = AnyWgslData> extends TgpuNamable {
    readonly value: InferGPU<TDataType>;
    readonly $: InferGPU<TDataType>;
    readonly [$internal]: {
        readonly dataType: TDataType;
    };
}
/**
 * Creates a module constant with specified value.
 */
declare function constant<TDataType extends AnyWgslData>(dataType: TDataType, value: InferGPU<TDataType>): TgpuConst<TDataType>;

/**
 * Extra declaration that shall be included in final WGSL code,
 * when resolving objects that use it.
 */
interface TgpuDeclare {
    $uses(dependencyMap: Record<string, unknown>): this;
}
/**
 * Allows defining extra declarations that shall be included in the final WGSL code,
 * when resolving objects that use them.
 *
 * Using this API is generally discouraged, as it shouldn't be necessary in any common scenario.
 * It was developed to ensure full compatibility of TypeGPU programs with current and future versions of WGSL.
 */
declare function declare(declaration: string): TgpuDeclare;

type BuiltinVertexIndex = Decorated<U32, [Builtin<'vertex_index'>]>;
type BuiltinInstanceIndex = Decorated<U32, [Builtin<'instance_index'>]>;
type BuiltinPosition = Decorated<Vec4f, [Builtin<'position'>]>;
type BuiltinClipDistances = Decorated<WgslArray<U32>, [
    Builtin<'clip_distances'>
]>;
type BuiltinFrontFacing = Decorated<Bool, [Builtin<'front_facing'>]>;
type BuiltinFragDepth = Decorated<F32, [Builtin<'frag_depth'>]>;
type BuiltinSampleIndex = Decorated<U32, [Builtin<'sample_index'>]>;
type BuiltinSampleMask = Decorated<U32, [Builtin<'sample_mask'>]>;
type BuiltinLocalInvocationId = Decorated<Vec3u, [
    Builtin<'local_invocation_id'>
]>;
type BuiltinLocalInvocationIndex = Decorated<U32, [
    Builtin<'local_invocation_index'>
]>;
type BuiltinGlobalInvocationId = Decorated<Vec3u, [
    Builtin<'global_invocation_id'>
]>;
type BuiltinWorkgroupId = Decorated<Vec3u, [Builtin<'workgroup_id'>]>;
type BuiltinNumWorkgroups = Decorated<Vec3u, [
    Builtin<'num_workgroups'>
]>;
type BuiltinSubgroupInvocationId = Decorated<U32, [
    Builtin<'subgroup_invocation_id'>
]>;
type BuiltinSubgroupSize = Decorated<U32, [Builtin<'subgroup_size'>]>;
declare const builtin: {
    readonly vertexIndex: BuiltinVertexIndex;
    readonly instanceIndex: BuiltinInstanceIndex;
    readonly position: BuiltinPosition;
    readonly clipDistances: BuiltinClipDistances;
    readonly frontFacing: BuiltinFrontFacing;
    readonly fragDepth: BuiltinFragDepth;
    readonly sampleIndex: BuiltinSampleIndex;
    readonly sampleMask: BuiltinSampleMask;
    readonly localInvocationId: BuiltinLocalInvocationId;
    readonly localInvocationIndex: BuiltinLocalInvocationIndex;
    readonly globalInvocationId: BuiltinGlobalInvocationId;
    readonly workgroupId: BuiltinWorkgroupId;
    readonly numWorkgroups: BuiltinNumWorkgroups;
    readonly subgroupInvocationId: BuiltinSubgroupInvocationId;
    readonly subgroupSize: BuiltinSubgroupSize;
};
type AnyBuiltin = (typeof builtin)[keyof typeof builtin];
type AnyComputeBuiltin = BuiltinLocalInvocationId | BuiltinLocalInvocationIndex | BuiltinGlobalInvocationId | BuiltinWorkgroupId | BuiltinNumWorkgroups | BuiltinSubgroupInvocationId | BuiltinSubgroupSize;
type AnyVertexInputBuiltin = BuiltinVertexIndex | BuiltinInstanceIndex;
type AnyVertexOutputBuiltin = BuiltinClipDistances | BuiltinPosition;
type AnyFragmentInputBuiltin = BuiltinPosition | BuiltinFrontFacing | BuiltinSampleIndex | BuiltinSampleMask | BuiltinSubgroupInvocationId | BuiltinSubgroupSize;
type AnyFragmentOutputBuiltin = BuiltinFragDepth | BuiltinSampleMask;
type OmitBuiltins<S> = S extends AnyBuiltin ? never : S extends BaseData ? S : {
    [Key in keyof S as S[Key] extends AnyBuiltin ? never : Key]: S[Key];
};

interface StorageFlag {
    usableAsStorage: true;
}
/**
 * @deprecated Use StorageFlag instead.
 */
type Storage = StorageFlag;
declare function isUsableAsStorage<T>(value: T): value is T & StorageFlag;

interface TgpuQuerySet<T extends GPUQueryType> extends TgpuNamable {
    readonly resourceType: 'query-set';
    readonly type: T;
    readonly count: number;
    readonly querySet: GPUQuerySet;
    readonly destroyed: boolean;
    readonly available: boolean;
    readonly [$internal]: {
        readonly readBuffer: GPUBuffer;
        readonly resolveBuffer: GPUBuffer;
    };
    resolve(): void;
    read(): Promise<bigint[]>;
    destroy(): void;
}

interface NameRegistry {
    /**
     * Creates a valid WGSL identifier, each guaranteed to be unique
     * in the lifetime of a single resolution process.
     * @param primer Used in the generation process, makes the identifier more recognizable.
     */
    makeUnique(primer?: string): string;
}
declare class RandomNameRegistry implements NameRegistry {
    private lastUniqueId;
    makeUnique(primer?: string | undefined): string;
}
declare class StrictNameRegistry implements NameRegistry {
    /**
     * Allows to provide a good fallback for instances of the
     * same function that are bound to different slot values.
     */
    private readonly _usedNames;
    makeUnique(primer?: string | undefined): string;
}

/**
 * Describes a function signature (its arguments and return type)
 */
type TgpuFnShellHeader<Args extends AnyData[], Return extends AnyData> = {
    readonly [$internal]: true;
    readonly argTypes: Args;
    readonly returnType: Return;
    readonly isEntry: false;
};
/**
 * Describes a function signature (its arguments and return type).
 * Allows creating tgpu functions by calling this shell
 * and passing the implementation (as WGSL string or JS function) as the argument.
 */
type TgpuFnShell<Args extends AnyData[], Return extends AnyData> = TgpuFnShellHeader<Args, Return> & (<T extends (...args: InferArgs<Args>) => Infer<Return>>(implementation: T) => TgpuFn<Prettify<InheritArgNames<(...args: Args) => Return, T>>['result']>) & ((implementation: string) => TgpuFn<(...args: Args) => Return>) & ((strings: TemplateStringsArray, ...values: unknown[]) => TgpuFn<(...args: Args) => Return>);
interface TgpuFnBase<ImplSchema extends AnyFn> extends TgpuNamable {
    readonly [$internal]: {
        implementation: Implementation<ImplSchema>;
        argTypes: FnArgsConversionHint;
    };
    readonly resourceType: 'function';
    readonly shell: TgpuFnShellHeader<Parameters<ImplSchema>, Extract<ReturnType<ImplSchema>, AnyData>>;
    readonly [$providing]?: Providing | undefined;
    $uses(dependencyMap: Record<string, unknown>): this;
    with<T>(slot: TgpuSlot<T>, value: Eventual<T>): TgpuFn<ImplSchema>;
    with<T extends AnyData>(accessor: TgpuAccessor<T>, value: TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>): TgpuFn<ImplSchema>;
}
type TgpuFn<ImplSchema extends AnyFn = (...args: any[]) => any> = TgpuFnBase<ImplSchema> & InferImplSchema<ImplSchema>;
declare function fn<Args extends AnyData[] | []>(argTypes: Args, returnType?: undefined): TgpuFnShell<Args, Void>;
declare function fn<Args extends AnyData[] | [], Return extends AnyData>(argTypes: Args, returnType: Return): TgpuFnShell<Args, Return>;
declare function isTgpuFn<Args extends AnyData[] | [], Return extends AnyData>(value: unknown | TgpuFn<(...args: Args) => Return>): value is TgpuFn<(...args: Args) => Return>;

interface TgpuSlot<T> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'slot';
    readonly [$repr]: Infer<T>;
    readonly [$gpuRepr]: InferGPU<T>;
    readonly defaultValue: T | undefined;
    /**
     * Used to determine if code generated using either value `a` or `b` in place
     * of the slot will be equivalent. Defaults to `Object.is`.
     */
    areEqual(a: T, b: T): boolean;
    readonly value: InferGPU<T>;
    readonly $: InferGPU<T>;
}
interface TgpuDerived<T> {
    readonly resourceType: 'derived';
    readonly value: InferGPU<T>;
    readonly $: InferGPU<T>;
    readonly [$repr]: Infer<T>;
    readonly [$gpuRepr]: InferGPU<T>;
    readonly [$providing]?: Providing | undefined;
    with<TValue>(slot: TgpuSlot<TValue>, value: Eventual<TValue>): TgpuDerived<T>;
    /**
     * @internal
     */
    '~compute'(): T;
}
interface TgpuAccessor<T extends AnyData = AnyData> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'accessor';
    readonly [$repr]: Infer<T>;
    readonly [$gpuRepr]: InferGPU<T>;
    readonly schema: T;
    readonly defaultValue: TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T> | undefined;
    readonly slot: TgpuSlot<TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>>;
    readonly value: InferGPU<T>;
    readonly $: InferGPU<T>;
}
/**
 * Represents a value that is available at resolution time.
 */
type Eventual<T> = T | TgpuSlot<T> | TgpuDerived<T>;
type SlotValuePair<T = unknown> = [TgpuSlot<T>, T];
type Providing = {
    inner: unknown;
    pairs: SlotValuePair[];
};
declare function isSlot<T>(value: unknown | TgpuSlot<T>): value is TgpuSlot<T>;
declare function isDerived<T extends TgpuDerived<unknown>>(value: T | unknown): value is T;

interface Timeable {
    withPerformanceCallback(callback: (start: bigint, end: bigint) => void | Promise<void>): this;
    withTimestampWrites(options: {
        querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;
        beginningOfPassWriteIndex?: number;
        endOfPassWriteIndex?: number;
    }): this;
}
type TimestampWritesPriors = {
    readonly timestampWrites?: {
        querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;
        beginningOfPassWriteIndex?: number;
        endOfPassWriteIndex?: number;
    };
    readonly performanceCallback?: (start: bigint, end: bigint) => void | Promise<void>;
    readonly hasAutoQuerySet?: boolean;
};

interface ComputePipelineInternals {
    readonly rawPipeline: GPUComputePipeline;
    readonly priors: TgpuComputePipelinePriors & TimestampWritesPriors;
}
interface TgpuComputePipeline extends TgpuNamable, SelfResolvable, Timeable {
    readonly [$internal]: ComputePipelineInternals;
    readonly resourceType: 'compute-pipeline';
    with(bindGroupLayout: TgpuBindGroupLayout, bindGroup: TgpuBindGroup): TgpuComputePipeline;
    dispatchWorkgroups(x: number, y?: number | undefined, z?: number | undefined): void;
}
type TgpuComputePipelinePriors = {
    readonly bindGroupLayoutMap?: Map<TgpuBindGroupLayout, TgpuBindGroup>;
} & TimestampWritesPriors;

declare const vertexFormats: readonly ["uint8", "uint8x2", "uint8x4", "sint8", "sint8x2", "sint8x4", "unorm8", "unorm8x2", "unorm8x4", "snorm8", "snorm8x2", "snorm8x4", "uint16", "uint16x2", "uint16x4", "sint16", "sint16x2", "sint16x4", "unorm16", "unorm16x2", "unorm16x4", "snorm16", "snorm16x2", "snorm16x4", "float16", "float16x2", "float16x4", "float32", "float32x2", "float32x3", "float32x4", "uint32", "uint32x2", "uint32x3", "uint32x4", "sint32", "sint32x2", "sint32x3", "sint32x4", "unorm10-10-10-2", "unorm8x4-bgra"];
type VertexFormat = (typeof vertexFormats)[number];
declare const kindToDefaultFormatMap: {
    readonly f32: "float32";
    readonly vec2f: "float32x2";
    readonly vec3f: "float32x3";
    readonly vec4f: "float32x4";
    readonly f16: "float16";
    readonly vec2h: "float16x2";
    readonly vec4h: "float16x4";
    readonly u32: "uint32";
    readonly vec2u: "uint32x2";
    readonly vec3u: "uint32x3";
    readonly vec4u: "uint32x4";
    readonly i32: "sint32";
    readonly vec2i: "sint32x2";
    readonly vec3i: "sint32x3";
    readonly vec4i: "sint32x4";
};
type KindToDefaultFormatMap = typeof kindToDefaultFormatMap;
interface TgpuVertexAttrib<TFormat extends VertexFormat = VertexFormat> {
    readonly format: TFormat;
    readonly offset: number;
}
type AnyVertexAttribs = Record<string, TgpuVertexAttrib> | TgpuVertexAttrib;
/**
 * All vertex attribute formats that can be interpreted as
 * an single or multi component u32 in a shader.
 * https://www.w3.org/TR/webgpu/#vertex-formats
 */
type U32CompatibleFormats = TgpuVertexAttrib<'uint8'> | TgpuVertexAttrib<'uint8x2'> | TgpuVertexAttrib<'uint8x4'> | TgpuVertexAttrib<'uint16'> | TgpuVertexAttrib<'uint16x2'> | TgpuVertexAttrib<'uint16x4'> | TgpuVertexAttrib<'uint32'> | TgpuVertexAttrib<'uint32x2'> | TgpuVertexAttrib<'uint32x3'> | TgpuVertexAttrib<'uint32x4'>;
/**
 * All vertex attribute formats that can be interpreted as
 * an single or multi component i32 in a shader.
 * https://www.w3.org/TR/webgpu/#vertex-formats
 */
type I32CompatibleFormats = TgpuVertexAttrib<'sint8'> | TgpuVertexAttrib<'sint8x2'> | TgpuVertexAttrib<'sint8x4'> | TgpuVertexAttrib<'sint16'> | TgpuVertexAttrib<'sint16x2'> | TgpuVertexAttrib<'sint16x4'> | TgpuVertexAttrib<'sint32'> | TgpuVertexAttrib<'sint32x2'> | TgpuVertexAttrib<'sint32x3'> | TgpuVertexAttrib<'sint32x4'>;
/**
 * All vertex attribute formats that can be interpreted as
 * an single or multi component f32 in a shader.
 * https://www.w3.org/TR/webgpu/#vertex-formats
 */
type F32CompatibleFormats = TgpuVertexAttrib<'unorm8'> | TgpuVertexAttrib<'unorm8x2'> | TgpuVertexAttrib<'unorm8x4'> | TgpuVertexAttrib<'snorm8'> | TgpuVertexAttrib<'snorm8x2'> | TgpuVertexAttrib<'snorm8x4'> | TgpuVertexAttrib<'unorm16'> | TgpuVertexAttrib<'unorm16x2'> | TgpuVertexAttrib<'unorm16x4'> | TgpuVertexAttrib<'snorm16'> | TgpuVertexAttrib<'snorm16x2'> | TgpuVertexAttrib<'snorm16x4'> | TgpuVertexAttrib<'float16'> | TgpuVertexAttrib<'float16x2'> | TgpuVertexAttrib<'float16x4'> | TgpuVertexAttrib<'float32'> | TgpuVertexAttrib<'float32x2'> | TgpuVertexAttrib<'float32x3'> | TgpuVertexAttrib<'float32x4'> | TgpuVertexAttrib<'unorm10-10-10-2'> | TgpuVertexAttrib<'unorm8x4-bgra'>;
/**
 * All vertex attribute formats that can be interpreted as
 * a single or multi component f16 in a shader. (same as f32 on the shader side)
 * https://www.w3.org/TR/webgpu/#vertex-formats
 */
type F16CompatibleFormats = F32CompatibleFormats;
type KindToAcceptedAttribMap = {
    u32: U32CompatibleFormats;
    vec2u: U32CompatibleFormats;
    vec3u: U32CompatibleFormats;
    vec4u: U32CompatibleFormats;
    i32: I32CompatibleFormats;
    vec2i: I32CompatibleFormats;
    vec3i: I32CompatibleFormats;
    vec4i: I32CompatibleFormats;
    f16: F16CompatibleFormats;
    vec2h: F16CompatibleFormats;
    vec3h: F16CompatibleFormats;
    vec4h: F16CompatibleFormats;
    f32: F32CompatibleFormats;
    vec2f: F32CompatibleFormats;
    vec3f: F32CompatibleFormats;
    vec4f: F32CompatibleFormats;
};

type WithLocations<T extends IORecord> = {
    [Key in keyof T]: IsBuiltin<T[Key]> extends true ? T[Key] : HasCustomLocation<T[Key]> extends true ? T[Key] : Decorate<T[Key], Location>;
};
type IOLayoutToSchema<T extends IOLayout> = T extends BaseData ? Decorate<T, Location<0>> : T extends IORecord ? WgslStruct<WithLocations<T>> : T extends {
    type: 'void';
} ? void : never;

type FragmentInConstrained = IORecord<BaseIOData | Decorated<BaseIOData, (Location | Interpolate)[]> | AnyFragmentInputBuiltin>;
type FragmentOutConstrained = IOLayout<Vec4f | Decorated<Vec4f, (Location | Interpolate)[]> | AnyFragmentOutputBuiltin>;
/**
 * Describes a fragment entry function signature (its arguments, return type and targets)
 */
type TgpuFragmentFnShellHeader<FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained> = {
    readonly in: FragmentIn | undefined;
    readonly out: FragmentOut;
    readonly returnType: IOLayoutToSchema<FragmentOut>;
    readonly isEntry: true;
};
/**
 * Describes a fragment entry function signature (its arguments, return type and targets).
 * Allows creating tgpu fragment functions by calling this shell
 * and passing the implementation (as WGSL string or JS function) as the argument.
 */
type TgpuFragmentFnShell<FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained> = TgpuFragmentFnShellHeader<FragmentIn, FragmentOut> /**
 * Creates a type-safe implementation of this signature
 */ & ((implementation: (input: InferIO<FragmentIn>) => InferIO<FragmentOut>) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>) & /**
 * @param implementation
 *   Raw WGSL function implementation with header and body
 *   without `fn` keyword and function name
 *   e.g. `"(x: f32) -> f32 { return x; }"`;
 */ ((implementation: string) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>) & ((strings: TemplateStringsArray, ...values: unknown[]) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>) & {
    /**
     * @deprecated Invoke the shell as a function instead.
     */
    does: ((implementation: (input: InferIO<FragmentIn>) => InferIO<FragmentOut>) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>) & /**
     * @param implementation
     *   Raw WGSL function implementation with header and body
     *   without `fn` keyword and function name
     *   e.g. `"(x: f32) -> f32 { return x; }"`;
     */ ((implementation: string) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>);
};
interface TgpuFragmentFn<Varying extends FragmentInConstrained = FragmentInConstrained, Output extends FragmentOutConstrained = FragmentOutConstrained> extends TgpuNamable {
    readonly [$internal]: true;
    readonly shell: TgpuFragmentFnShellHeader<Varying, Output>;
    readonly outputType: IOLayoutToSchema<Output>;
    $uses(dependencyMap: Record<string, unknown>): this;
}
declare function fragmentFn<FragmentOut extends FragmentOutConstrained>(options: {
    out: FragmentOut;
}): TgpuFragmentFnShell<{}, FragmentOut>;
declare function fragmentFn<FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained>(options: {
    in: FragmentIn;
    out: FragmentOut;
}): TgpuFragmentFnShell<FragmentIn, FragmentOut>;

type VertexInConstrained = IORecord<BaseIOData | Decorated<BaseIOData, Location[]> | AnyVertexInputBuiltin>;
type VertexOutConstrained = IORecord<BaseIOData | Decorated<BaseIOData, (Location | Interpolate)[]> | AnyVertexOutputBuiltin>;
/**
 * Describes a vertex entry function signature (its arguments, return type and attributes)
 */
type TgpuVertexFnShellHeader<VertexIn extends VertexInConstrained, VertexOut extends VertexOutConstrained> = {
    readonly in: VertexIn | undefined;
    readonly out: VertexOut;
    readonly argTypes: [IOLayoutToSchema<VertexIn>] | [];
    readonly isEntry: true;
};
/**
 * Describes a vertex entry function signature (its arguments, return type and attributes).
 * Allows creating tgpu vertex functions by calling this shell
 * and passing the implementation (as WGSL string or JS function) as the argument.
 */
type TgpuVertexFnShell<VertexIn extends VertexInConstrained, VertexOut extends VertexOutConstrained> = TgpuVertexFnShellHeader<VertexIn, VertexOut> & ((implementation: (input: InferIO<VertexIn>) => InferIO<VertexOut>) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>) & ((implementation: string) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>) & ((strings: TemplateStringsArray, ...values: unknown[]) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>) & {
    /**
     * @deprecated Invoke the shell as a function instead.
     */
    does: ((implementation: (input: InferIO<VertexIn>) => InferIO<VertexOut>) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>) & ((implementation: string) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>);
};
interface TgpuVertexFn<VertexIn extends VertexInConstrained = VertexInConstrained, VertexOut extends VertexOutConstrained = VertexOutConstrained> extends TgpuNamable {
    readonly [$internal]: true;
    readonly shell: TgpuVertexFnShellHeader<VertexIn, VertexOut>;
    $uses(dependencyMap: Record<string, unknown>): this;
}
declare function vertexFn<VertexOut extends VertexOutConstrained>(options: {
    out: VertexOut;
}): TgpuVertexFnShell<{}, VertexOut>;
declare function vertexFn<VertexIn extends VertexInConstrained, VertexOut extends VertexOutConstrained>(options: {
    in: VertexIn;
    out: VertexOut;
}): TgpuVertexFnShell<VertexIn, VertexOut>;

type TextureProps = {
    size: readonly number[];
    format: GPUTextureFormat;
    viewFormats?: GPUTextureFormat[] | undefined;
    dimension?: GPUTextureDimension | undefined;
    mipLevelCount?: number | undefined;
    sampleCount?: number | undefined;
};

declare const texelFormatToChannelType: {
    r8unorm: F32;
    r8snorm: F32;
    r8uint: U32;
    r8sint: I32;
    r16uint: U32;
    r16sint: I32;
    r16float: F32;
    rg8unorm: F32;
    rg8snorm: F32;
    rg8uint: U32;
    rg8sint: I32;
    r32uint: U32;
    r32sint: I32;
    r32float: F32;
    rg16uint: U32;
    rg16sint: I32;
    rg16float: F32;
    rgba8unorm: F32;
    'rgba8unorm-srgb': F32;
    rgba8snorm: F32;
    rgba8uint: U32;
    rgba8sint: I32;
    bgra8unorm: F32;
    'bgra8unorm-srgb': F32;
    rgb9e5ufloat: F32;
    rgb10a2uint: U32;
    rgb10a2unorm: F32;
    rg11b10ufloat: F32;
    rg32uint: U32;
    rg32sint: I32;
    rg32float: F32;
    rgba16uint: U32;
    rgba16sint: I32;
    rgba16float: F32;
    rgba32uint: U32;
    rgba32sint: I32;
    rgba32float: F32;
    stencil8: F32;
    depth16unorm: F32;
    depth24plus: F32;
    'depth24plus-stencil8': F32;
    depth32float: F32;
    'depth32float-stencil8': F32;
    'bc1-rgba-unorm': F32;
    'bc1-rgba-unorm-srgb': F32;
    'bc2-rgba-unorm': F32;
    'bc2-rgba-unorm-srgb': F32;
    'bc3-rgba-unorm': F32;
    'bc3-rgba-unorm-srgb': F32;
    'bc4-r-unorm': F32;
    'bc4-r-snorm': F32;
    'bc5-rg-unorm': F32;
    'bc5-rg-snorm': F32;
    'bc6h-rgb-ufloat': F32;
    'bc6h-rgb-float': F32;
    'bc7-rgba-unorm': F32;
    'bc7-rgba-unorm-srgb': F32;
    'etc2-rgb8unorm': F32;
    'etc2-rgb8unorm-srgb': F32;
    'etc2-rgb8a1unorm': F32;
    'etc2-rgb8a1unorm-srgb': F32;
    'etc2-rgba8unorm': F32;
    'etc2-rgba8unorm-srgb': F32;
    'eac-r11unorm': F32;
    'eac-r11snorm': F32;
    'eac-rg11unorm': F32;
    'eac-rg11snorm': F32;
    'astc-4x4-unorm': F32;
    'astc-4x4-unorm-srgb': F32;
    'astc-5x4-unorm': F32;
    'astc-5x4-unorm-srgb': F32;
    'astc-5x5-unorm': F32;
    'astc-5x5-unorm-srgb': F32;
    'astc-6x5-unorm': F32;
    'astc-6x5-unorm-srgb': F32;
    'astc-6x6-unorm': F32;
    'astc-6x6-unorm-srgb': F32;
    'astc-8x5-unorm': F32;
    'astc-8x5-unorm-srgb': F32;
    'astc-8x6-unorm': F32;
    'astc-8x6-unorm-srgb': F32;
    'astc-8x8-unorm': F32;
    'astc-8x8-unorm-srgb': F32;
    'astc-10x5-unorm': F32;
    'astc-10x5-unorm-srgb': F32;
    'astc-10x6-unorm': F32;
    'astc-10x6-unorm-srgb': F32;
    'astc-10x8-unorm': F32;
    'astc-10x8-unorm-srgb': F32;
    'astc-10x10-unorm': F32;
    'astc-10x10-unorm-srgb': F32;
    'astc-12x10-unorm': F32;
    'astc-12x10-unorm-srgb': F32;
    'astc-12x12-unorm': F32;
    'astc-12x12-unorm-srgb': F32;
    r16snorm: F32;
    r16unorm: F32;
    rg16unorm: F32;
    rg16snorm: F32;
    rgba16unorm: F32;
    rgba16snorm: F32;
};
type TexelFormatToChannelType = typeof texelFormatToChannelType;
type TexelFormatToStringChannels = {
    [Key in keyof TexelFormatToChannelType]: TexelFormatToChannelType[Key]['type'];
};
type KeysWithValue<T extends Record<string, unknown>, TValue> = keyof {
    [Key in keyof T as T[Key] extends TValue ? Key : never]: Key;
};
type ChannelTypeToLegalFormats = {
    [Key in TexelFormatToChannelType[keyof TexelFormatToChannelType]['type']]: KeysWithValue<TexelFormatToStringChannels, Key>;
};
type SampleTypeToStringChannelType = {
    float: 'f32';
    'unfilterable-float': 'f32';
    depth: 'f32';
    sint: 'i32';
    uint: 'u32';
};
type ViewDimensionToDimension = {
    '1d': '1d';
    '2d': '2d';
    '2d-array': '2d';
    '3d': '3d';
    cube: '2d';
    'cube-array': '2d';
};
/**
 * https://www.w3.org/TR/WGSL/#storage-texel-formats
 */
type StorageTextureTexelFormat = 'rgba8unorm' | 'rgba8snorm' | 'rgba8uint' | 'rgba8sint' | 'rgba16uint' | 'rgba16sint' | 'rgba16float' | 'r32uint' | 'r32sint' | 'r32float' | 'rg32uint' | 'rg32sint' | 'rg32float' | 'rgba32uint' | 'rgba32sint' | 'rgba32float' | 'bgra8unorm';
declare const texelFormatToDataType: {
    readonly rgba8unorm: Vec4f;
    readonly rgba8snorm: Vec4f;
    readonly rgba8uint: Vec4u;
    readonly rgba8sint: Vec4i;
    readonly rgba16uint: Vec4u;
    readonly rgba16sint: Vec4i;
    readonly rgba16float: Vec4f;
    readonly r32uint: Vec4u;
    readonly r32sint: Vec4i;
    readonly r32float: Vec4f;
    readonly rg32uint: Vec4u;
    readonly rg32sint: Vec4i;
    readonly rg32float: Vec4f;
    readonly rgba32uint: Vec4u;
    readonly rgba32sint: Vec4i;
    readonly rgba32float: Vec4f;
    readonly bgra8unorm: Vec4f;
};
declare const channelFormatToSchema: {
    float: F32;
    'unfilterable-float': F32;
    uint: U32;
    sint: I32;
    depth: F32;
};
type ChannelFormatToSchema = typeof channelFormatToSchema;
type TexelFormatToDataType = typeof texelFormatToDataType;
type TexelFormatToDataTypeOrNever<T> = T extends keyof TexelFormatToDataType ? TexelFormatToDataType[T] : never;
/**
 * Represents what formats a storage view can choose from based on its owner texture's props.
 */
type StorageFormatOptions<TProps extends TextureProps> = Extract<TProps['format'] | Default<TProps['viewFormats'], []>[number], StorageTextureTexelFormat>;
/**
 * Represents what formats a sampled view can choose from based on its owner texture's props.
 */
type SampledFormatOptions<TProps extends TextureProps> = TProps['format'] | Default<TProps['viewFormats'], []>[number];

interface Sampled {
    usableAsSampled: true;
}
interface Render {
    usableAsRender: true;
}
type LiteralToExtensionMap = {
    storage: StorageFlag;
    sampled: Sampled;
    render: Render;
};
type AllowedUsages<TProps extends TextureProps> = 'sampled' | 'render' | (TProps['format'] extends StorageTextureTexelFormat ? 'storage' : never);
declare function isUsableAsSampled<T>(value: T): value is T & Sampled;
declare function isUsableAsRender<T>(value: T): value is T & Render;

type ResolveStorageDimension<TDimension extends GPUTextureViewDimension, TProps extends TextureProps> = StorageTextureDimension extends TDimension ? Default<TProps['dimension'], '2d'> : TDimension extends StorageTextureDimension ? TDimension : '2d';
type ViewUsages$1<TProps extends TextureProps, TTexture extends TgpuTexture<TProps>> = boolean extends TTexture['usableAsSampled'] ? boolean extends TTexture['usableAsStorage'] ? never : 'readonly' | 'writeonly' | 'mutable' : boolean extends TTexture['usableAsStorage'] ? 'sampled' : 'readonly' | 'writeonly' | 'mutable' | 'sampled';
interface TextureInternals {
    unwrap(): GPUTexture;
}
interface TextureViewInternals {
    readonly unwrap?: (() => GPUTextureView) | undefined;
}
type ChannelData = U32 | I32 | F32;
type TexelData = Vec4u | Vec4i | Vec4f;
/**
 * @param TProps all properties that distinguish this texture apart from other textures on the type level.
 */
interface TgpuTexture<TProps extends TextureProps = TextureProps> extends TgpuNamable {
    readonly [$internal]: TextureInternals;
    readonly resourceType: 'texture';
    readonly props: TProps;
    readonly usableAsStorage: boolean;
    readonly usableAsSampled: boolean;
    readonly usableAsRender: boolean;
    $usage<T extends AllowedUsages<TProps>[]>(...usages: T): this & UnionToIntersection<LiteralToExtensionMap[T[number]]>;
    createView<TUsage extends ViewUsages$1<TProps, this>, TDimension extends 'sampled' extends TUsage ? GPUTextureViewDimension : StorageTextureDimension, TFormat extends 'sampled' extends TUsage ? SampledFormatOptions<TProps> : StorageFormatOptions<TProps>>(access: TUsage, params?: TextureViewParams<TDimension, TFormat>): {
        mutable: TgpuMutableTexture<ResolveStorageDimension<TDimension, TProps>, TexelFormatToDataTypeOrNever<StorageFormatOptions<TProps> extends TFormat ? TProps['format'] : TFormat>>;
        readonly: TgpuReadonlyTexture<ResolveStorageDimension<TDimension, TProps>, TexelFormatToDataTypeOrNever<StorageFormatOptions<TProps> extends TFormat ? TProps['format'] : TFormat>>;
        writeonly: TgpuWriteonlyTexture<ResolveStorageDimension<TDimension, TProps>, TexelFormatToDataTypeOrNever<StorageFormatOptions<TProps> extends TFormat ? TProps['format'] : TFormat>>;
        sampled: TgpuSampledTexture<GPUTextureViewDimension extends TDimension ? Default<TProps['dimension'], '2d'> : TDimension, TexelFormatToChannelType[SampledFormatOptions<TProps> extends TFormat ? TProps['format'] : TFormat]>;
    }[TUsage];
    destroy(): void;
}
type StorageTextureAccess = 'readonly' | 'writeonly' | 'mutable';
/**
 * Based on @see GPUTextureViewDimension
 * https://www.w3.org/TR/WGSL/#texture-depth
 */
type StorageTextureDimension = '1d' | '2d' | '2d-array' | '3d';
type TextureViewParams<TDimension extends GPUTextureViewDimension | undefined, TFormat extends GPUTextureFormat | undefined> = {
    format?: TFormat;
    dimension?: TDimension;
    aspect?: GPUTextureAspect;
    baseMipLevel?: number;
    mipLevelCount?: number;
    baseArrayLayout?: number;
    arrayLayerCount?: number;
};
interface TgpuStorageTexture<TDimension extends StorageTextureDimension = StorageTextureDimension, TData extends TexelData = TexelData> {
    readonly [$internal]: TextureViewInternals;
    readonly resourceType: 'texture-storage-view';
    readonly dimension: TDimension;
    readonly texelDataType: TData;
    readonly access: StorageTextureAccess;
}
/**
 * A texture accessed as "readonly" storage on the GPU.
 */
interface TgpuReadonlyTexture<TDimension extends StorageTextureDimension = StorageTextureDimension, TData extends TexelData = TexelData> extends TgpuStorageTexture<TDimension, TData> {
    readonly access: 'readonly';
}
/**
 * A texture accessed as "writeonly" storage on the GPU.
 */
interface TgpuWriteonlyTexture<TDimension extends StorageTextureDimension = StorageTextureDimension, TData extends TexelData = TexelData> extends TgpuStorageTexture<TDimension, TData> {
    readonly access: 'writeonly';
}
/**
 * A texture accessed as "mutable" (or read_write) storage on the GPU.
 */
interface TgpuMutableTexture<TDimension extends StorageTextureDimension = StorageTextureDimension, TData extends TexelData = TexelData> extends TgpuStorageTexture<TDimension, TData> {
    readonly access: 'mutable';
}
/**
 * A texture accessed as sampled on the GPU.
 */
interface TgpuSampledTexture<TDimension extends GPUTextureViewDimension = GPUTextureViewDimension, TData extends ChannelData = ChannelData> {
    readonly [$internal]: TextureViewInternals;
    readonly resourceType: 'texture-sampled-view';
    readonly dimension: TDimension;
    readonly channelDataType: TData;
}
declare function isTexture<T extends TgpuTexture>(value: unknown | T): value is T;
declare function isStorageTextureView<T extends TgpuReadonlyTexture | TgpuWriteonlyTexture | TgpuMutableTexture>(value: unknown | T): value is T;
declare function isSampledTextureView<T extends TgpuSampledTexture>(value: unknown | T): value is T;
type TgpuAnyTextureView = TgpuReadonlyTexture | TgpuWriteonlyTexture | TgpuMutableTexture | TgpuSampledTexture;

/**
 * The array can hold T, where T is a single/multi-component numeric, or a struct with members of type T.
 * Examples of valid array members:
 * - Vec3f,
 * - unorm8x2
 * - WgslStruct<{ a: Vec3f, b: unorm8x2 }>
 * - WgslStruct<{ nested: WgslStruct<{ a: Vec3f }> }>
 */
type DataToContainedAttribs<T> = T extends AnyWgslStruct | AnyUnstruct ? {
    [Key in keyof T['propTypes']]: DataToContainedAttribs<T['propTypes'][Key]>;
} : T extends {
    type: VertexFormat;
} ? TgpuVertexAttrib<T['type']> : T extends {
    type: keyof KindToDefaultFormatMap;
} ? TgpuVertexAttrib<KindToDefaultFormatMap[T['type']]> : T extends Decorated<infer TInner> ? DataToContainedAttribs<TInner> : never;
/**
 * Interprets an array as a set of vertex attributes.
 */
type ArrayToContainedAttribs<T extends WgslArray | Disarray> = DataToContainedAttribs<T['elementType']>;
type LayoutToAllowedAttribs<T> = T extends {
    type: keyof KindToAcceptedAttribMap;
} ? KindToAcceptedAttribMap[T['type']] : T extends Record<string, unknown> ? {
    [Key in keyof T]: LayoutToAllowedAttribs<T[Key]>;
} : never;

interface TgpuVertexLayout<TData extends WgslArray | Disarray = WgslArray | Disarray> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'vertex-layout';
    readonly stride: number;
    readonly stepMode: 'vertex' | 'instance';
    readonly attrib: ArrayToContainedAttribs<TData>;
    readonly vertexLayout: GPUVertexBufferLayout;
    schemaForCount(n: number): TData;
}
declare function vertexLayout<TData extends WgslArray | Disarray>(schemaForCount: (count: number) => TData, stepMode?: 'vertex' | 'instance'): TgpuVertexLayout<TData>;

interface RenderPipelineInternals {
    readonly core: RenderPipelineCore;
    readonly priors: TgpuRenderPipelinePriors & TimestampWritesPriors;
}
interface HasIndexBuffer {
    readonly hasIndexBuffer: true;
    drawIndexed(indexCount: number, instanceCount?: number, firstIndex?: number, baseVertex?: number, firstInstance?: number): void;
}
interface TgpuRenderPipeline<Output extends IOLayout = IOLayout> extends TgpuNamable, SelfResolvable, Timeable {
    readonly [$internal]: RenderPipelineInternals;
    readonly resourceType: 'render-pipeline';
    readonly hasIndexBuffer: boolean;
    with<TData extends WgslArray | Disarray>(vertexLayout: TgpuVertexLayout<TData>, buffer: TgpuBuffer<TData> & VertexFlag): this;
    with<Entries extends Record<string, TgpuLayoutEntry | null>>(bindGroupLayout: TgpuBindGroupLayout<Entries>, bindGroup: TgpuBindGroup<Entries>): this;
    withColorAttachment(attachment: FragmentOutToColorAttachment<Output>): this;
    withDepthStencilAttachment(attachment: DepthStencilAttachment): this;
    withIndexBuffer(buffer: TgpuBuffer<AnyWgslData> & IndexFlag, offsetElements?: number, sizeElements?: number): this & HasIndexBuffer;
    withIndexBuffer(buffer: GPUBuffer, indexFormat: GPUIndexFormat, offsetBytes?: number, sizeBytes?: number): this & HasIndexBuffer;
    draw(vertexCount: number, instanceCount?: number, firstVertex?: number, firstInstance?: number): void;
}
type FragmentOutToTargets<T extends IOLayout> = T extends IOData ? GPUColorTargetState : T extends Record<string, unknown> ? {
    [Key in keyof T]: GPUColorTargetState;
} : T extends {
    type: 'void';
} ? Record<string, never> : never;
type FragmentOutToColorAttachment<T extends IOLayout> = T extends IOData ? ColorAttachment : T extends Record<string, unknown> ? {
    [Key in keyof T]: ColorAttachment;
} : never;
type AnyFragmentTargets = GPUColorTargetState | Record<string, GPUColorTargetState>;
interface ColorAttachment {
    /**
     * A {@link GPUTextureView} describing the texture subresource that will be output to for this
     * color attachment.
     */
    view: (TgpuTexture & Render) | GPUTextureView;
    /**
     * Indicates the depth slice index of {@link GPUTextureViewDimension#"3d"} {@link GPURenderPassColorAttachment#view}
     * that will be output to for this color attachment.
     */
    depthSlice?: GPUIntegerCoordinate;
    /**
     * A {@link GPUTextureView} describing the texture subresource that will receive the resolved
     * output for this color attachment if {@link GPURenderPassColorAttachment#view} is
     * multisampled.
     */
    resolveTarget?: GPUTextureView;
    /**
     * Indicates the value to clear {@link GPURenderPassColorAttachment#view} to prior to executing the
     * render pass. If not map/exist|provided, defaults to `{r: 0, g: 0, b: 0, a: 0}`. Ignored
     * if {@link GPURenderPassColorAttachment#loadOp} is not {@link GPULoadOp#"clear"}.
     * The components of {@link GPURenderPassColorAttachment#clearValue} are all double values.
     * They are converted to a texel value of texture format matching the render attachment.
     * If conversion fails, a validation error is generated.
     */
    clearValue?: GPUColor;
    /**
     * Indicates the load operation to perform on {@link GPURenderPassColorAttachment#view} prior to
     * executing the render pass.
     * Note: It is recommended to prefer clearing; see {@link GPULoadOp#"clear"} for details.
     */
    loadOp: GPULoadOp;
    /**
     * The store operation to perform on {@link GPURenderPassColorAttachment#view}
     * after executing the render pass.
     */
    storeOp: GPUStoreOp;
}
interface DepthStencilAttachment {
    /**
     * A {@link GPUTextureView} | ({@link TgpuTexture} & {@link Render}) describing the texture subresource that will be output to
     * and read from for this depth/stencil attachment.
     */
    view: (TgpuTexture & Render) | GPUTextureView;
    /**
     * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s depth component
     * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#depthLoadOp}
     * is not {@link GPULoadOp#"clear"}. Must be between 0.0 and 1.0, inclusive (unless unrestricted depth is enabled).
     */
    depthClearValue?: number;
    /**
     * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s
     * depth component prior to executing the render pass.
     * Note: It is recommended to prefer clearing; see {@link GPULoadOp#"clear"} for details.
     */
    depthLoadOp?: GPULoadOp;
    /**
     * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s
     * depth component after executing the render pass.
     */
    depthStoreOp?: GPUStoreOp;
    /**
     * Indicates that the depth component of {@link GPURenderPassDepthStencilAttachment#view}
     * is read only.
     */
    depthReadOnly?: boolean;
    /**
     * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s stencil component
     * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#stencilLoadOp}
     * is not {@link GPULoadOp#"clear"}.
     * The value will be converted to the type of the stencil aspect of `view` by taking the same
     * number of LSBs as the number of bits in the stencil aspect of one texel block|texel of `view`.
     */
    stencilClearValue?: GPUStencilValue;
    /**
     * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s
     * stencil component prior to executing the render pass.
     * Note: It is recommended to prefer clearing; see {@link GPULoadOp#"clear"} for details.
     */
    stencilLoadOp?: GPULoadOp;
    /**
     * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s
     * stencil component after executing the render pass.
     */
    stencilStoreOp?: GPUStoreOp;
    /**
     * Indicates that the stencil component of {@link GPURenderPassDepthStencilAttachment#view}
     * is read only.
     */
    stencilReadOnly?: boolean;
}
type AnyFragmentColorAttachment = ColorAttachment | Record<string, ColorAttachment>;
type RenderPipelineCoreOptions = {
    branch: ExperimentalTgpuRoot;
    slotBindings: [TgpuSlot<unknown>, unknown][];
    vertexAttribs: AnyVertexAttribs;
    vertexFn: TgpuVertexFn;
    fragmentFn: TgpuFragmentFn;
    primitiveState: GPUPrimitiveState | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {
        stripIndexFormat?: U32 | U16;
    } | undefined;
    depthStencilState: GPUDepthStencilState | undefined;
    targets: AnyFragmentTargets;
    multisampleState: GPUMultisampleState | undefined;
};
type TgpuRenderPipelinePriors = {
    readonly vertexLayoutMap?: Map<TgpuVertexLayout, TgpuBuffer<AnyWgslData> & VertexFlag> | undefined;
    readonly bindGroupLayoutMap?: Map<TgpuBindGroupLayout, TgpuBindGroup> | undefined;
    readonly colorAttachment?: AnyFragmentColorAttachment | undefined;
    readonly depthStencilAttachment?: DepthStencilAttachment | undefined;
    readonly indexBuffer?: {
        buffer: TgpuBuffer<AnyWgslData> & IndexFlag | GPUBuffer;
        indexFormat: GPUIndexFormat;
        offsetBytes?: number | undefined;
        sizeBytes?: number | undefined;
    } | undefined;
} & TimestampWritesPriors;
type Memo = {
    pipeline: GPURenderPipeline;
    usedBindGroupLayouts: TgpuBindGroupLayout[];
    catchall: [number, TgpuBindGroup] | undefined;
};
declare class RenderPipelineCore implements SelfResolvable {
    readonly options: RenderPipelineCoreOptions;
    readonly usedVertexLayouts: TgpuVertexLayout[];
    private _memo;
    private readonly _vertexBufferLayouts;
    private readonly _targets;
    constructor(options: RenderPipelineCoreOptions);
    '~resolve'(ctx: ResolutionCtx): string;
    toString(): string;
    unwrap(): Memo;
}

interface SamplerInternals {
    readonly unwrap?: ((branch: Unwrapper) => GPUSampler) | undefined;
}
interface SamplerProps {
    addressModeU?: GPUAddressMode;
    addressModeV?: GPUAddressMode;
    /**
     * Specifies the address modes for the texture width, height, and depth
     * coordinates, respectively.
     */
    addressModeW?: GPUAddressMode;
    /**
     * Specifies the sampling behavior when the sample footprint is smaller than or equal to one
     * texel.
     */
    magFilter?: GPUFilterMode;
    /**
     * Specifies the sampling behavior when the sample footprint is larger than one texel.
     */
    minFilter?: GPUFilterMode;
    /**
     * Specifies behavior for sampling between mipmap levels.
     */
    mipmapFilter?: GPUMipmapFilterMode;
    lodMinClamp?: number;
    /**
     * Specifies the minimum and maximum levels of detail, respectively, used internally when
     * sampling a texture.
     */
    lodMaxClamp?: number;
    /**
     * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is
     * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.
     * Anisotropic filtering improves the image quality of textures sampled at oblique viewing
     * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of
     * anisotropy supported when filtering.
     *
     * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range
     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}
     * will be clamped to the maximum value that the platform supports.
     * The precise filtering behavior is implementation-dependent.
     */
    maxAnisotropy?: number;
}
interface ComparisonSamplerProps {
    compare: GPUCompareFunction;
    addressModeU?: GPUAddressMode;
    addressModeV?: GPUAddressMode;
    /**
     * Specifies the address modes for the texture width, height, and depth
     * coordinates, respectively.
     */
    addressModeW?: GPUAddressMode;
    /**
     * Specifies the sampling behavior when the sample footprint is smaller than or equal to one
     * texel.
     */
    magFilter?: GPUFilterMode;
    /**
     * Specifies the sampling behavior when the sample footprint is larger than one texel.
     */
    minFilter?: GPUFilterMode;
    /**
     * Specifies behavior for sampling between mipmap levels.
     */
    mipmapFilter?: GPUMipmapFilterMode;
    lodMinClamp?: number;
    /**
     * Specifies the minimum and maximum levels of detail, respectively, used internally when
     * sampling a texture.
     */
    lodMaxClamp?: number;
    /**
     * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is
     * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.
     * Anisotropic filtering improves the image quality of textures sampled at oblique viewing
     * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of
     * anisotropy supported when filtering.
     *
     * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range
     * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}
     * will be clamped to the maximum value that the platform supports.
     * The precise filtering behavior is implementation-dependent.
     */
    maxAnisotropy?: number;
}
interface TgpuSampler {
    readonly [$internal]: SamplerInternals;
    readonly resourceType: 'sampler';
}
interface TgpuComparisonSampler {
    readonly [$internal]: SamplerInternals;
    readonly resourceType: 'sampler-comparison';
}
interface TgpuFixedSampler extends TgpuSampler, TgpuNamable {
}
interface TgpuFixedComparisonSampler extends TgpuComparisonSampler, TgpuNamable {
}
declare function sampler(props: SamplerProps): TgpuFixedSampler;
declare function comparisonSampler(props: ComparisonSamplerProps): TgpuFixedComparisonSampler;
declare function isSampler(resource: unknown): resource is TgpuSampler;
declare function isComparisonSampler(resource: unknown): resource is TgpuComparisonSampler;

interface Unwrapper {
    readonly device: GPUDevice;
    unwrap(resource: TgpuComputePipeline): GPUComputePipeline;
    unwrap(resource: TgpuRenderPipeline): GPURenderPipeline;
    unwrap(resource: TgpuBindGroupLayout): GPUBindGroupLayout;
    unwrap(resource: TgpuBindGroup): GPUBindGroup;
    unwrap(resource: TgpuBuffer<AnyData>): GPUBuffer;
    unwrap(resource: TgpuTexture): GPUTexture;
    unwrap(resource: TgpuReadonlyTexture | TgpuWriteonlyTexture | TgpuMutableTexture | TgpuSampledTexture): GPUTextureView;
    unwrap(resource: TgpuVertexLayout): GPUVertexBufferLayout;
    unwrap(resource: TgpuSampler): GPUSampler;
    unwrap(resource: TgpuComparisonSampler): GPUSampler;
    unwrap(resource: TgpuQuerySet<GPUQueryType>): GPUQuerySet;
}

interface TgpuBufferShorthandBase<TData extends BaseData> extends TgpuNamable {
    readonly [$internal]: true;
    write(data: Infer<TData>): void;
    writePartial(data: InferPartial<TData>): void;
    read(): Promise<Infer<TData>>;
}
interface TgpuMutable<TData extends BaseData> extends TgpuBufferShorthandBase<TData> {
    readonly resourceType: 'mutable';
    readonly buffer: TgpuBuffer<TData> & StorageFlag;
    value: InferGPU<TData>;
    $: InferGPU<TData>;
}
interface TgpuReadonly<TData extends BaseData> extends TgpuBufferShorthandBase<TData> {
    readonly resourceType: 'readonly';
    readonly buffer: TgpuBuffer<TData> & StorageFlag;
    readonly value: InferGPU<TData>;
    readonly $: InferGPU<TData>;
}
interface TgpuUniform<TData extends BaseData> extends TgpuBufferShorthandBase<TData> {
    readonly resourceType: 'uniform';
    readonly buffer: TgpuBuffer<TData> & UniformFlag;
    readonly value: InferGPU<TData>;
    readonly $: InferGPU<TData>;
}
type TgpuBufferShorthand<TData extends BaseData> = TgpuMutable<TData> | TgpuReadonly<TData> | TgpuUniform<TData>;
declare function isBufferShorthand<TData extends BaseData>(value: unknown | TgpuBufferShorthand<TData>): value is TgpuBufferShorthand<TData>;

interface WithCompute {
    createPipeline(): TgpuComputePipeline;
}
type ValidateFragmentIn<VertexOut extends VertexOutConstrained, FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained> = UndecorateRecord<FragmentIn> extends Partial<UndecorateRecord<VertexOut>> ? UndecorateRecord<VertexOut> extends UndecorateRecord<FragmentIn> ? [
    entryFn: TgpuFragmentFn<FragmentIn, FragmentOut>,
    targets: FragmentOutToTargets<FragmentOut>
] : [
    entryFn: 'n/a',
    targets: 'n/a',
    MissingFromVertexOutput: {
        [Key in Exclude<keyof FragmentIn, keyof VertexOut>]: FragmentIn[Key];
    }
] : [
    entryFn: 'n/a',
    targets: 'n/a',
    MismatchedVertexOutput: {
        [Key in keyof FragmentIn & keyof VertexOut as FragmentIn[Key] extends VertexOut[Key] ? never : Key]: [got: VertexOut[Key], expecting: FragmentIn[Key]];
    }
];
interface WithVertex<VertexOut extends VertexOutConstrained = VertexOutConstrained> {
    withFragment<FragmentIn extends FragmentInConstrained, FragmentOut extends FragmentOutConstrained>(...args: ValidateFragmentIn<VertexOut, FragmentIn, FragmentOut>): WithFragment<FragmentOut>;
}
interface WithFragment<Output extends FragmentOutConstrained = FragmentOutConstrained> {
    withPrimitive(primitiveState: GPUPrimitiveState | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {
        stripIndexFormat?: U32 | U16;
    } | undefined): WithFragment<Output>;
    withDepthStencil(depthStencilState: GPUDepthStencilState | undefined): WithFragment<Output>;
    withMultisample(multisampleState: GPUMultisampleState | undefined): WithFragment<Output>;
    createPipeline(): TgpuRenderPipeline<Output>;
}
interface Configurable {
    readonly bindings: [slot: TgpuSlot<unknown>, value: unknown][];
    with<T>(slot: TgpuSlot<T>, value: Eventual<T>): Configurable;
    with<T extends AnyWgslData>(accessor: TgpuAccessor<T>, value: TgpuFn<() => T> | TgpuBufferUsage<T> | TgpuBufferShorthand<T> | Infer<T>): Configurable;
    pipe(transform: (cfg: Configurable) => Configurable): Configurable;
}
interface WithBinding {
    withCompute<ComputeIn extends IORecord<AnyComputeBuiltin>>(entryFn: TgpuComputeFn<ComputeIn>): WithCompute;
    withVertex<VertexIn extends VertexInConstrained, VertexOut extends VertexOutConstrained>(entryFn: TgpuVertexFn<VertexIn, VertexOut>, attribs: LayoutToAllowedAttribs<OmitBuiltins<VertexIn>>): WithVertex<VertexOut>;
    with<T>(slot: TgpuSlot<T>, value: Eventual<T>): WithBinding;
    with<T extends AnyWgslData>(accessor: TgpuAccessor<T>, value: TgpuFn<() => T> | TgpuBufferUsage<T> | TgpuBufferShorthand<T> | Infer<T>): WithBinding;
    pipe(transform: (cfg: Configurable) => Configurable): WithBinding;
}
type CreateTextureOptions<TSize, TFormat extends GPUTextureFormat, TMipLevelCount extends number, TSampleCount extends number, TViewFormat extends GPUTextureFormat, TDimension extends GPUTextureDimension> = {
    /**
     * The width, height, and depth or layer count of the texture.
     */
    size: TSize;
    /**
     * The format of the texture.
     */
    format: TFormat;
    /**
     * The number of mip levels the texture will contain.
     * @default 1
     */
    mipLevelCount?: TMipLevelCount | undefined;
    /**
     * The sample count of the texture. A sampleCount > 1 indicates a multisampled texture.
     * @default 1
     */
    sampleCount?: TSampleCount | undefined;
    /**
     * Specifies extra formats (in addition to the texture's actual format) that can be used
     * when creating views of this texture.
     * @default []
     */
    viewFormats?: TViewFormat[] | undefined;
    /**
     * Whether the texture is one-dimensional, an array of two-dimensional layers, or three-dimensional.
     * @default '2d'
     */
    dimension?: TDimension | undefined;
};
type CreateTextureResult<TSize extends readonly number[], TFormat extends GPUTextureFormat, TMipLevelCount extends number, TSampleCount extends number, TViewFormat extends GPUTextureFormat, TDimension extends GPUTextureDimension> = Prettify<{
    size: Mutable<TSize>;
    format: TFormat;
} & OmitProps<{
    dimension: GPUTextureDimension extends TDimension ? undefined : TDimension extends '2d' ? undefined : TDimension;
    mipLevelCount: number extends TMipLevelCount ? undefined : TMipLevelCount extends 1 ? undefined : TMipLevelCount;
    sampleCount: number extends TSampleCount ? undefined : TSampleCount extends 1 ? undefined : TSampleCount;
    viewFormats: GPUTextureFormat extends TViewFormat ? undefined : TViewFormat[] extends never[] ? undefined : TViewFormat[];
}, undefined>>;
interface RenderPass {
    /**
     * Sets the viewport used during the rasterization stage to linearly map from
     * NDC (i.e., normalized device coordinates) to viewport coordinates.
     * @param x - Minimum X value of the viewport in pixels.
     * @param y - Minimum Y value of the viewport in pixels.
     * @param width - Width of the viewport in pixels.
     * @param height - Height of the viewport in pixels.
     * @param minDepth - Minimum depth value of the viewport.
     * @param maxDepth - Maximum depth value of the viewport.
     */
    setViewport(x: number, y: number, width: number, height: number, minDepth: number, maxDepth: number): void;
    /**
     * Sets the scissor rectangle used during the rasterization stage.
     * After transformation into viewport coordinates any fragments which fall outside the scissor
     * rectangle will be discarded.
     * @param x - Minimum X value of the scissor rectangle in pixels.
     * @param y - Minimum Y value of the scissor rectangle in pixels.
     * @param width - Width of the scissor rectangle in pixels.
     * @param height - Height of the scissor rectangle in pixels.
     */
    setScissorRect(x: number, y: number, width: number, height: number): void;
    /**
     * Sets the constant blend color and alpha values used with {@link GPUBlendFactor#constant}
     * and {@link GPUBlendFactor#"one-minus-constant"} {@link GPUBlendFactor}s.
     * @param color - The color to use when blending.
     */
    setBlendConstant(color: GPUColor): void;
    /**
     * Sets the {@link RenderState#[[stencilReference]]} value used during stencil tests with
     * the {@link GPUStencilOperation#"replace"} {@link GPUStencilOperation}.
     * @param reference - The new stencil reference value.
     */
    setStencilReference(reference: GPUStencilValue): undefined;
    /**
     * @param queryIndex - The index of the query in the query set.
     */
    beginOcclusionQuery(queryIndex: GPUSize32): undefined;
    endOcclusionQuery(): undefined;
    /**
     * Executes the commands previously recorded into the given {@link GPURenderBundle}s as part of
     * this render pass.
     * When a {@link GPURenderBundle} is executed, it does not inherit the render pass's pipeline, bind
     * groups, or vertex and index buffers. After a {@link GPURenderBundle} has executed, the render
     * pass's pipeline, bind group, and vertex/index buffer state is cleared
     * (to the initial, empty values).
     * Note: The state is cleared, not restored to the previous state.
     * This occurs even if zero {@link GPURenderBundle|GPURenderBundles} are executed.
     * @param bundles - List of render bundles to execute.
     */
    executeBundles(bundles: Iterable<GPURenderBundle>): undefined;
    setPipeline(pipeline: TgpuRenderPipeline): void;
    /**
     * Sets the current index buffer.
     * @param buffer - Buffer containing index data to use for subsequent drawing commands.
     * @param indexFormat - Format of the index data contained in `buffer`.
     * @param offset - Offset in bytes into `buffer` where the index data begins. Defaults to `0`.
     * @param size - Size in bytes of the index data in `buffer`.
     * 	             Defaults to the size of the buffer minus the offset.
     */
    setIndexBuffer<TData extends WgslArray | Disarray>(buffer: TgpuBuffer<TData> | GPUBuffer, indexFormat: GPUIndexFormat, offset?: GPUSize64, size?: GPUSize64): void;
    setVertexBuffer<TData extends WgslArray | Disarray>(vertexLayout: TgpuVertexLayout<TData>, buffer: (TgpuBuffer<TData> & VertexFlag) | GPUBuffer, offset?: GPUSize64, size?: GPUSize64): void;
    setBindGroup<Entries extends Record<string, TgpuLayoutEntry | null>>(bindGroupLayout: TgpuBindGroupLayout<Entries>, bindGroup: TgpuBindGroup<Entries> | GPUBindGroup): void;
    /**
     * Draws primitives.
     * @param vertexCount - The number of vertices to draw.
     * @param instanceCount - The number of instances to draw.
     * @param firstVertex - Offset into the vertex buffers, in vertices, to begin drawing from.
     * @param firstInstance - First instance to draw.
     */
    draw(vertexCount: number, instanceCount?: number | undefined, firstVertex?: number | undefined, firstInstance?: number | undefined): void;
    /**
     * Draws indexed primitives.
     * @param indexCount - The number of indices to draw.
     * @param instanceCount - The number of instances to draw.
     * @param firstIndex - Offset into the index buffer, in indices, begin drawing from.
     * @param baseVertex - Added to each index value before indexing into the vertex buffers.
     * @param firstInstance - First instance to draw.
     */
    drawIndexed(indexCount: number, instanceCount?: number | undefined, firstIndex?: number | undefined, baseVertex?: number | undefined, firstInstance?: number | undefined): void;
    /**
     * Draws primitives using parameters read from a {@link GPUBuffer}.
     * Packed block of **four 32-bit unsigned integer values (16 bytes total)**, given in the same
     * order as the arguments for {@link GPURenderEncoderBase#draw}. For example:
     * @param indirectBuffer - Buffer containing the indirect draw parameters.
     * @param indirectOffset - Offset in bytes into `indirectBuffer` where the drawing data begins.
     */
    drawIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64): undefined;
    /**
     * Draws indexed primitives using parameters read from a {@link GPUBuffer}.
     * Tightly packed block of **five 32-bit unsigned integer values (20 bytes total)**, given in
     * the same order as the arguments for {@link GPURenderEncoderBase#drawIndexed}. For example:
     * @param indirectBuffer - Buffer containing the indirect drawIndexed parameters.
     * @param indirectOffset - Offset in bytes into `indirectBuffer` where the drawing data begins.
     */
    drawIndexedIndirect(indirectBuffer: GPUBuffer, indirectOffset: GPUSize64): undefined;
}
type ValidateSchema<TData extends AnyData> = HasNestedType<[
    TData
], 'bool'> extends true ? 'Error: Bool is not host-shareable, use U32 or I32 instead' : HasNestedType<[TData], 'u16'> extends true ? TData extends {
    type: 'array';
    elementType: {
        type: 'u16';
    };
} ? TData : 'Error: U16 is only usable inside arrays for index buffers' : TData;
interface TgpuRoot extends Unwrapper {
    /**
     * The GPU device associated with this root.
     */
    readonly device: GPUDevice;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     *
     * @remarks
     * Typed wrapper around a GPUBuffer.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param initial The initial value of the buffer. (optional)
     */
    createBuffer<TData extends AnyData>(typeSchema: ValidateSchema<TData>, initial?: Infer<TData> | undefined): TgpuBuffer<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     *
     * @remarks
     * Typed wrapper around a GPUBuffer.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param gpuBuffer A vanilla WebGPU buffer.
     */
    createBuffer<TData extends AnyData>(typeSchema: ValidateSchema<TData>, gpuBuffer: GPUBuffer): TgpuBuffer<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Read-only on the GPU, optimized for small data. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param initial The initial value of the buffer. (optional)
     */
    createUniform<TData extends AnyWgslData>(typeSchema: TData, initial?: Infer<TData>): TgpuUniform<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Read-only on the GPU, optimized for small data. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param gpuBuffer A vanilla WebGPU buffer.
     */
    createUniform<TData extends AnyWgslData>(typeSchema: TData, gpuBuffer: GPUBuffer): TgpuUniform<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Can be mutated in-place on the GPU. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param initial The initial value of the buffer. (optional)
     */
    createMutable<TData extends AnyWgslData>(typeSchema: TData, initial?: Infer<TData>): TgpuMutable<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Can be mutated in-place on the GPU. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param gpuBuffer A vanilla WebGPU buffer.
     */
    createMutable<TData extends AnyWgslData>(typeSchema: TData, gpuBuffer: GPUBuffer): TgpuMutable<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Read-only on the GPU, optimized for large data. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param initial The initial value of the buffer. (optional)
     */
    createReadonly<TData extends AnyWgslData>(typeSchema: TData, initial?: Infer<TData>): TgpuReadonly<TData>;
    /**
     * Allocates memory on the GPU, allows passing data between host and shader.
     * Read-only on the GPU, optimized for large data. For a general-purpose buffer,
     * use {@link TgpuRoot.createBuffer}.
     *
     * @param typeSchema The type of data that this buffer will hold.
     * @param gpuBuffer A vanilla WebGPU buffer.
     */
    createReadonly<TData extends AnyWgslData>(typeSchema: TData, gpuBuffer: GPUBuffer): TgpuReadonly<TData>;
    /**
     * Creates a query set for collecting timestamps or occlusion queries.
     *
     * @remarks
     * Typed wrapper around a GPUQuerySet.
     *
     * @param type The type of queries to collect ('occlusion' or 'timestamp').
     * @param count The number of queries in the set.
     * @param rawQuerySet An optional pre-existing GPUQuerySet to use instead of creating a new one.
     */
    createQuerySet<T extends GPUQueryType>(type: T, count: number, rawQuerySet?: GPUQuerySet | undefined): TgpuQuerySet<T>;
    /**
     * Creates a group of resources that can be bound to a shader based on a specified layout.
     *
     * @remarks
     * Typed wrapper around a GPUBindGroup.
     *
     * @example
     * const fooLayout = tgpu.bindGroupLayout({
     *  foo: { uniform: d.vec3f },
     *  bar: { texture: 'float' },
     * });
     *
     * const fooBuffer = ...;
     * const barTexture = ...;
     *
     * const fooBindGroup = root.createBindGroup(fooLayout, {
     *  foo: fooBuffer,
     *  bar: barTexture,
     * });
     *
     * @param layout Layout describing the bind group to be created.
     * @param entries A record with values being the resources populating the bind group
     * and keys being their associated names, matching the layout keys.
     */
    createBindGroup<Entries extends Record<string, TgpuLayoutEntry | null> = Record<string, TgpuLayoutEntry | null>>(layout: TgpuBindGroupLayout<Entries>, entries: ExtractBindGroupInputFromLayout<Entries>): TgpuBindGroup<Entries>;
    /**
     * Retrieves a read-only list of all enabled features of the GPU device.
     * @returns A set of strings representing the enabled features.
     */
    get enabledFeatures(): ReadonlySet<GPUFeatureName>;
    /**
     * Destroys all underlying resources (i.e. buffers...) created through this root object.
     * If the object is created via `tgpu.init` instead of `tgpu.initFromDevice`,
     * then the inner GPU device is destroyed as well.
     */
    destroy(): void;
    '~unstable': Omit<ExperimentalTgpuRoot, keyof TgpuRoot>;
}
interface ExperimentalTgpuRoot extends TgpuRoot, WithBinding {
    readonly nameRegistry: NameRegistry;
    /**
     * The current command encoder. This property will
     * hold the same value until `flush()` is called.
     */
    readonly commandEncoder: GPUCommandEncoder;
    createTexture<TWidth extends number, THeight extends number, TDepth extends number, TSize extends readonly [TWidth] | readonly [TWidth, THeight] | readonly [TWidth, THeight, TDepth], TFormat extends GPUTextureFormat, TMipLevelCount extends number, TSampleCount extends number, TViewFormat extends GPUTextureFormat, TDimension extends GPUTextureDimension>(props: CreateTextureOptions<TSize, TFormat, TMipLevelCount, TSampleCount, TViewFormat, TDimension>): TgpuTexture<CreateTextureResult<TSize, TFormat, TMipLevelCount, TSampleCount, TViewFormat, TDimension>>;
    beginRenderPass(descriptor: GPURenderPassDescriptor, callback: (pass: RenderPass) => void): void;
    /**
     * Causes all commands enqueued by pipelines to be
     * submitted to the GPU.
     */
    flush(): void;
}

interface UniformFlag {
    usableAsUniform: true;
}
/**
 * @deprecated Use UniformFlag instead.
 */
type Uniform = UniformFlag;
interface VertexFlag {
    usableAsVertex: true;
}
interface IndexFlag {
    usableAsIndex: true;
}
/**
 * @deprecated Use VertexFlag instead.
 */
type Vertex = VertexFlag;
type LiteralToUsageType<T extends 'uniform' | 'storage' | 'vertex' | 'index'> = T extends 'uniform' ? UniformFlag : T extends 'storage' ? StorageFlag : T extends 'vertex' ? VertexFlag : T extends 'index' ? IndexFlag : never;
type ViewUsages<TBuffer extends TgpuBuffer<BaseData>> = (boolean extends TBuffer['usableAsUniform'] ? never : 'uniform') | (boolean extends TBuffer['usableAsStorage'] ? never : 'readonly' | 'mutable');
type UsageTypeToBufferUsage<TData extends BaseData> = {
    uniform: TgpuBufferUniform<TData> & TgpuFixedBufferUsage<TData>;
    mutable: TgpuBufferMutable<TData> & TgpuFixedBufferUsage<TData>;
    readonly: TgpuBufferReadonly<TData> & TgpuFixedBufferUsage<TData>;
};
type IsIndexCompatible<TData extends BaseData> = UnwrapDecorated<TData> extends {
    readonly type: 'array';
    readonly elementType: infer TElement;
} ? TElement extends BaseData ? UnwrapDecorated<TElement> extends {
    readonly type: 'u32' | 'u16';
} ? true : false : false : false;
interface TgpuBuffer<TData extends BaseData> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'buffer';
    readonly dataType: TData;
    readonly initial?: Infer<TData> | undefined;
    readonly buffer: GPUBuffer;
    readonly destroyed: boolean;
    usableAsUniform: boolean;
    usableAsStorage: boolean;
    usableAsVertex: boolean;
    usableAsIndex: boolean;
    $usage<T extends RestrictUsages<TData>>(...usages: T): this & UnionToIntersection<LiteralToUsageType<T[number]>>;
    $addFlags(flags: GPUBufferUsageFlags): this;
    as<T extends ViewUsages<this>>(usage: T): UsageTypeToBufferUsage<TData>[T];
    compileWriter(): void;
    write(data: Infer<TData>): void;
    writePartial(data: InferPartial<TData>): void;
    copyFrom(srcBuffer: TgpuBuffer<MemIdentity<TData>>): void;
    read(): Promise<Infer<TData>>;
    destroy(): void;
}
declare function isBuffer<T extends TgpuBuffer<AnyData>>(value: T | unknown): value is T;
declare function isUsableAsVertex<T extends TgpuBuffer<AnyData>>(buffer: T): buffer is T & VertexFlag;
type IsArrayOfU32<TData extends BaseData> = UnwrapDecorated<TData> extends {
    readonly type: 'array';
    readonly elementType: infer TElement;
} ? TElement extends BaseData ? UnwrapDecorated<TElement> extends {
    readonly type: 'u32';
} ? true : false : false : false;
type IsWgslLiteral<TData extends BaseData> = TData extends {
    readonly type: WgslTypeLiteral;
} ? true : false;
type RestrictUsages<TData extends BaseData> = string extends TData['type'] ? ('uniform' | 'storage' | 'vertex' | 'index')[] : IsIndexCompatible<TData> extends true ? IsArrayOfU32<TData> extends true ? ('uniform' | 'storage' | 'vertex' | 'index')[] : ['index'] : IsWgslLiteral<TData> extends true ? ('uniform' | 'storage' | 'vertex')[] : ['vertex'];

type TgpuLayoutEntryBase = {
    /**
     * Limits this resource's visibility to specific shader stages.
     *
     * By default, each resource is visible to all shader stage types, but
     * depending on the underlying implementation, this may have performance implications.
     *
     * @default ['compute'] for mutable resources
     * @default ['compute','vertex','fragment'] for everything else
     */
    visibility?: TgpuShaderStage[];
};
type TgpuLayoutUniform = TgpuLayoutEntryBase & {
    uniform: AnyWgslData;
};
type TgpuLayoutStorage = TgpuLayoutEntryBase & {
    storage: AnyWgslData | ((arrayLength: number) => AnyWgslData);
    /** @default 'readonly' */
    access?: 'mutable' | 'readonly';
};
type TgpuLayoutSampler = TgpuLayoutEntryBase & {
    sampler: 'filtering' | 'non-filtering';
};
type TgpuLayoutComparisonSampler = TgpuLayoutEntryBase & {
    sampler: 'comparison';
};
type TgpuLayoutTexture<TSampleType extends GPUTextureSampleType = GPUTextureSampleType> = TgpuLayoutEntryBase & {
    /**
     * - 'float' - f32
     * - 'unfilterable-float' - f32, cannot be used with filtering samplers
     * - 'depth' - f32
     * - 'sint' - i32
     * - 'uint' - u32
     */
    texture: TSampleType;
    /**
     * @default '2d'
     */
    viewDimension?: GPUTextureViewDimension;
    /**
     * @default false
     */
    multisampled?: boolean;
};
type TgpuLayoutStorageTexture<TFormat extends StorageTextureTexelFormat = StorageTextureTexelFormat> = TgpuLayoutEntryBase & {
    storageTexture: TFormat;
    /** @default 'writeonly' */
    access?: 'readonly' | 'writeonly' | 'mutable';
    /** @default '2d' */
    viewDimension?: StorageTextureDimension;
};
type TgpuLayoutExternalTexture = TgpuLayoutEntryBase & {
    externalTexture: Record<string, never>;
};
type TgpuLayoutEntry = TgpuLayoutUniform | TgpuLayoutStorage | TgpuLayoutSampler | TgpuLayoutComparisonSampler | TgpuLayoutTexture | TgpuLayoutStorageTexture | TgpuLayoutExternalTexture;
type UnwrapRuntimeConstructorInner<T extends BaseData | ((_: number) => BaseData)> = T extends (_: number) => BaseData ? ReturnType<T> : T;
type UnwrapRuntimeConstructor<T extends AnyData | ((_: number) => AnyData)> = T extends unknown ? UnwrapRuntimeConstructorInner<T> : never;
interface TgpuBindGroupLayout<Entries extends Record<string, TgpuLayoutEntry | null> = Record<string, TgpuLayoutEntry | null>> extends TgpuNamable {
    readonly [$internal]: true;
    readonly resourceType: 'bind-group-layout';
    readonly entries: Entries;
    readonly bound: {
        [K in keyof Entries]: BindLayoutEntry<Entries[K]>;
    };
    readonly value: {
        [K in keyof Entries]: InferLayoutEntry<Entries[K]>;
    };
    readonly $: {
        [K in keyof Entries]: InferLayoutEntry<Entries[K]>;
    };
    /**
     * An explicit numeric index assigned to this bind group layout. If undefined, a unique
     * index is assigned automatically during resolution. This can be changed with the
     * `.$idx()` method.
     */
    readonly index: number | undefined;
    /**
     * Associates this bind group layout with an explicit numeric index. When a call to this
     * method is omitted, a unique numeric index is assigned to it automatically.
     *
     * Used when generating WGSL code: `@group(${index}) @binding(...) ...;`
     */
    $idx(index?: number): this;
    /**
     * Creates a raw WebGPU resource based on the typed descriptor.
     * NOTE: This creates a new resource every time, better to use `root.unwrap(...)` instead.
     * @param unwrapper Used to unwrap any resources that this resource depends on.
     */
    unwrap(unwrapper: Unwrapper): GPUBindGroupLayout;
}
type StorageUsageForEntry<T extends TgpuLayoutStorage> = T extends {
    access?: infer Access;
} ? 'mutable' | 'readonly' extends Access ? TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>> | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>> : 'readonly' extends Access ? TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>> : 'mutable' extends Access ? TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>> : TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>> | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>> : TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>;
type GetUsageForStorageTexture<T extends TgpuLayoutStorageTexture, TAccess extends 'readonly' | 'writeonly' | 'mutable'> = {
    mutable: TgpuMutableTexture<Default<GetDimension<T['viewDimension']>, '2d'>, TexelFormatToDataType[T['storageTexture']]>;
    readonly: TgpuReadonlyTexture<Default<GetDimension<T['viewDimension']>, '2d'>, TexelFormatToDataType[T['storageTexture']]>;
    writeonly: TgpuWriteonlyTexture<Default<GetDimension<T['viewDimension']>, '2d'>, TexelFormatToDataType[T['storageTexture']]>;
}[TAccess];
type StorageTextureUsageForEntry<T extends TgpuLayoutStorageTexture> = T extends unknown ? GetUsageForStorageTexture<T, Default<T['access'], 'writeonly'>> : never;
type GetDimension<T extends GPUTextureViewDimension | undefined> = T extends keyof ViewDimensionToDimension ? ViewDimensionToDimension[T] : undefined;
type GetTextureRestriction<T extends TgpuLayoutTexture> = Default<GetDimension<T['viewDimension']>, '2d'> extends infer Dimension ? Dimension extends '2d' ? {
    format: ChannelTypeToLegalFormats[SampleTypeToStringChannelType[T['texture']]];
    dimension?: Dimension;
} : {
    format: ChannelTypeToLegalFormats[SampleTypeToStringChannelType[T['texture']]];
    dimension: Dimension;
} : never;
type GetStorageTextureRestriction<T extends TgpuLayoutStorageTexture> = Default<GetDimension<T['viewDimension']>, '2d'> extends infer Dimension ? Dimension extends '2d' ? {
    format: T['storageTexture'];
    dimension?: Dimension;
} : {
    format: T['storageTexture'];
    dimension: Dimension;
} : never;
type LayoutEntryToInput<T extends TgpuLayoutEntry | null> = TgpuLayoutEntry | null extends T ? TgpuBuffer<AnyWgslData> | GPUBuffer | TgpuSampler | GPUSampler | TgpuComparisonSampler | GPUSampler | TgpuTexture | TgpuSampledTexture | TgpuMutableTexture | TgpuReadonlyTexture | TgpuWriteonlyTexture | GPUTextureView | GPUExternalTexture : T extends TgpuLayoutUniform ? (TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['uniform']>>> & UniformFlag) | GPUBuffer : T extends TgpuLayoutStorage ? (TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['storage']>>> & StorageFlag) | GPUBuffer : T extends TgpuLayoutSampler ? TgpuSampler | GPUSampler : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler | GPUSampler : T extends TgpuLayoutTexture ? GPUTextureView | (Sampled & TgpuTexture<Prettify<TextureProps & GetTextureRestriction<T>>>) | TgpuSampledTexture<Default<T['viewDimension'], '2d'>, ChannelFormatToSchema[T['texture']]> : T extends TgpuLayoutStorageTexture ? GPUTextureView | (StorageFlag & TgpuTexture<Prettify<TextureProps & GetStorageTextureRestriction<T>>>) | StorageTextureUsageForEntry<T> : T extends TgpuLayoutExternalTexture ? GPUExternalTexture : never;
type BindLayoutEntry<T extends TgpuLayoutEntry | null> = T extends TgpuLayoutUniform ? TgpuBufferUniform<T['uniform']> : T extends TgpuLayoutStorage ? StorageUsageForEntry<T> : T extends TgpuLayoutSampler ? TgpuSampler : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler : T extends TgpuLayoutTexture ? TgpuSampledTexture<Default<T['viewDimension'], '2d'>, ChannelFormatToSchema[T['texture']]> : T extends TgpuLayoutStorageTexture ? StorageTextureUsageForEntry<T> : never;
type InferLayoutEntry<T extends TgpuLayoutEntry | null> = T extends TgpuLayoutUniform ? Infer<T['uniform']> : T extends TgpuLayoutStorage ? Infer<UnwrapRuntimeConstructor<T['storage']>> : T extends TgpuLayoutSampler ? TgpuSampler : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler : T extends TgpuLayoutTexture ? TgpuSampledTexture<Default<T['viewDimension'], '2d'>, ChannelFormatToSchema[T['texture']]> : T extends TgpuLayoutStorageTexture ? StorageTextureUsageForEntry<T> : never;
type ExtractBindGroupInputFromLayout<T extends Record<string, TgpuLayoutEntry | null>> = NullableToOptional<{
    [K in keyof T]: LayoutEntryToInput<T[K]>;
}>;
type TgpuBindGroup<Entries extends Record<string, TgpuLayoutEntry | null> = Record<string, TgpuLayoutEntry | null>> = {
    readonly resourceType: 'bind-group';
    readonly layout: TgpuBindGroupLayout<Entries>;
    unwrap(unwrapper: Unwrapper): GPUBindGroup;
};
declare function bindGroupLayout<Entries extends Record<string, TgpuLayoutEntry | null>>(entries: Entries): TgpuBindGroupLayout<Prettify<Entries>>;

interface TgpuBufferUsage<TData extends BaseData = BaseData, TUsage extends BindableBufferUsage = BindableBufferUsage> {
    readonly resourceType: 'buffer-usage';
    readonly usage: TUsage;
    readonly [$repr]: Infer<TData>;
    value: InferGPU<TData>;
    $: InferGPU<TData>;
    readonly [$internal]: {
        readonly dataType: TData;
    };
}
interface TgpuBufferUniform<TData extends BaseData> extends TgpuBufferUsage<TData, 'uniform'> {
    readonly value: InferGPU<TData>;
    readonly $: InferGPU<TData>;
}
interface TgpuBufferReadonly<TData extends BaseData> extends TgpuBufferUsage<TData, 'readonly'> {
    readonly value: InferGPU<TData>;
    readonly $: InferGPU<TData>;
}
interface TgpuFixedBufferUsage<TData extends BaseData> extends TgpuNamable {
    readonly buffer: TgpuBuffer<TData>;
}
interface TgpuBufferMutable<TData extends BaseData> extends TgpuBufferUsage<TData, 'mutable'> {
}
declare function isUsableAsUniform<T extends TgpuBuffer<AnyData>>(buffer: T): buffer is T & UniformFlag;
/**
 * @deprecated Use buffer.as('mutable') instead.
 */
declare function asMutable<TData extends AnyWgslData>(buffer: TgpuBuffer<TData> & StorageFlag): TgpuBufferMutable<TData> & TgpuFixedBufferUsage<TData>;
/**
 * @deprecated Use buffer.as('readonly') instead.
 */
declare function asReadonly<TData extends AnyWgslData>(buffer: TgpuBuffer<TData> & StorageFlag): TgpuBufferReadonly<TData> & TgpuFixedBufferUsage<TData>;
/**
 * @deprecated Use buffer.as('uniform') instead.
 */
declare function asUniform<TData extends AnyWgslData>(buffer: TgpuBuffer<TData> & UniformFlag): TgpuBufferUniform<TData> & TgpuFixedBufferUsage<TData>;

interface TgpuExternalTexture {
    readonly resourceType: 'external-texture';
}

type VariableScope = 'private' | 'workgroup';
interface TgpuVar<TScope extends VariableScope = VariableScope, TDataType extends AnyData = AnyData> extends TgpuNamable {
    value: Infer<TDataType>;
    readonly [$internal]: {
        readonly scope: TScope;
    };
}
/**
 * Defines a variable scoped to each entry function (private).
 *
 * @param dataType The schema of the held data's type
 * @param initialValue If not provided, the variable will be initialized to the dataType's "zero-value".
 */
declare function privateVar<TDataType extends AnyData>(dataType: TDataType, initialValue?: Infer<TDataType>): TgpuVar<'private', TDataType>;
/**
 * Defines a variable scoped to the whole workgroup, shared between entry functions
 * of the same invocation.
 *
 * @param dataType The schema of the held data's type
 */
declare function workgroupVar<TDataType extends AnyData>(dataType: TDataType): TgpuVar<'workgroup', TDataType>;

type ResolvableObject = SelfResolvable | TgpuBufferUsage | TgpuConst | TgpuDeclare | TgpuFn | TgpuComputeFn | TgpuFragmentFn | TgpuComputePipeline | TgpuRenderPipeline | TgpuVertexFn | TgpuSampler | TgpuAccessor | TgpuExternalTexture | TgpuTexture | TgpuAnyTextureView | TgpuVar | AnyVecInstance | AnyMatInstance | AnyData | TgpuFn;
type Wgsl = Eventual<string | number | boolean | ResolvableObject>;
type TgpuShaderStage = 'compute' | 'vertex' | 'fragment';
interface FnToWgslOptions {
    args: Snippet[];
    argAliases: Record<string, Snippet>;
    returnType: AnyData;
    body: Block;
    externalMap: Record<string, unknown>;
}
type ItemLayer = {
    type: 'item';
    usedSlots: Set<TgpuSlot<unknown>>;
};
interface ItemStateStack {
    readonly itemDepth: number;
    readonly topItem: ItemLayer;
    pushItem(): void;
    popItem(): void;
    pushSlotBindings(pairs: SlotValuePair<unknown>[]): void;
    popSlotBindings(): void;
    pushFunctionScope(args: Snippet[], argAliases: Record<string, Snippet>, returnType: AnyData, externalMap: Record<string, unknown>): void;
    popFunctionScope(): void;
    pushBlockScope(): void;
    popBlockScope(): void;
    pop(type?: 'functionScope' | 'blockScope' | 'slotBinding' | 'item'): void;
    readSlot<T>(slot: TgpuSlot<T>): T | undefined;
    getSnippetById(id: string): Snippet | undefined;
    defineBlockVariable(id: string, type: AnyWgslData | UnknownData): Snippet;
}
/**
 * Passed into each resolvable item. All items in a tree share a resolution ctx,
 * but there can be layers added and removed from the item stack when going down
 * and up the tree.
 */
interface ResolutionCtx {
    readonly names: NameRegistry;
    addDeclaration(declaration: string): void;
    /**
     * Reserves a bind group number, and returns a placeholder that will be replaced
     * with a concrete number at the end of the resolution process.
     */
    allocateLayoutEntry(layout: TgpuBindGroupLayout): string;
    /**
     * Reserves a spot in the catch-all bind group, without the indirection of a bind-group.
     * This means the resource is 'fixed', and cannot be swapped between code execution.
     */
    allocateFixedEntry(layoutEntry: TgpuLayoutEntry, resource: object): {
        group: string;
        binding: number;
    };
    withSlots<T>(pairs: SlotValuePair<unknown>[], callback: () => T): T;
    /**
     * Unwraps all layers of slot/derived indirection and returns the concrete value if available.
     * @throws {MissingSlotValueError}
     */
    unwrap<T>(eventual: Eventual<T>): T;
    resolve(item: unknown): string;
    resolveValue<T extends BaseData>(value: Infer<T> | InferGPU<T>, schema: T): string;
    fnToWgsl(options: FnToWgslOptions): {
        head: Wgsl;
        body: Wgsl;
    };
    withVaryingLocations<T>(locations: Record<string, number>, callback: () => T): T;
    get varyingLocations(): Record<string, number> | undefined;
    [$internal]: {
        itemStateStack: ItemStateStack;
    };
}
/**
 * Houses a method '~resolve` that returns a code string
 * representing it, as opposed to offloading the resolution
 * to another mechanism.
 */
interface SelfResolvable {
    '~resolve'(ctx: ResolutionCtx): string;
    toString(): string;
}
type BindableBufferUsage = 'uniform' | 'readonly' | 'mutable';
type DefaultConversionStrategy = 'keep' | 'coerce';
type FnArgsConversionHint = AnyData[] | ((...args: Snippet[]) => AnyWgslData[]) | DefaultConversionStrategy | undefined;

type FormatToWGSLType<T extends VertexFormat> = (typeof formatToWGSLType)[T];
interface TgpuVertexFormatData<T extends VertexFormat> {
    readonly [$internal]: true;
    readonly type: T;
    readonly [$repr]: Infer<FormatToWGSLType<T>>;
}
declare const formatToWGSLType: {
    readonly uint8: U32;
    readonly uint8x2: Vec2u;
    readonly uint8x4: Vec4u;
    readonly sint8: I32;
    readonly sint8x2: Vec2i;
    readonly sint8x4: Vec4i;
    readonly unorm8: F32;
    readonly unorm8x2: Vec2f;
    readonly unorm8x4: Vec4f;
    readonly snorm8: F32;
    readonly snorm8x2: Vec2f;
    readonly snorm8x4: Vec4f;
    readonly uint16: U32;
    readonly uint16x2: Vec2u;
    readonly uint16x4: Vec4u;
    readonly sint16: I32;
    readonly sint16x2: Vec2i;
    readonly sint16x4: Vec4i;
    readonly unorm16: F32;
    readonly unorm16x2: Vec2f;
    readonly unorm16x4: Vec4f;
    readonly snorm16: F32;
    readonly snorm16x2: Vec2f;
    readonly snorm16x4: Vec4f;
    readonly float16: F32;
    readonly float16x2: Vec2f;
    readonly float16x4: Vec4f;
    readonly float32: F32;
    readonly float32x2: Vec2f;
    readonly float32x3: Vec3f;
    readonly float32x4: Vec4f;
    readonly uint32: U32;
    readonly uint32x2: Vec2u;
    readonly uint32x3: Vec3u;
    readonly uint32x4: Vec4u;
    readonly sint32: I32;
    readonly sint32x2: Vec2i;
    readonly sint32x3: Vec3i;
    readonly sint32x4: Vec4i;
    readonly 'unorm10-10-10-2': Vec4f;
    readonly 'unorm8x4-bgra': Vec4f;
};
declare const packedFormats: string[];
type uint8 = TgpuVertexFormatData<'uint8'>;
declare const uint8: uint8;
type uint8x2 = TgpuVertexFormatData<'uint8x2'>;
declare const uint8x2: uint8x2;
type uint8x4 = TgpuVertexFormatData<'uint8x4'>;
declare const uint8x4: uint8x4;
type sint8 = TgpuVertexFormatData<'sint8'>;
declare const sint8: sint8;
type sint8x2 = TgpuVertexFormatData<'sint8x2'>;
declare const sint8x2: sint8x2;
type sint8x4 = TgpuVertexFormatData<'sint8x4'>;
declare const sint8x4: sint8x4;
type unorm8 = TgpuVertexFormatData<'unorm8'>;
declare const unorm8: unorm8;
type unorm8x2 = TgpuVertexFormatData<'unorm8x2'>;
declare const unorm8x2: unorm8x2;
type unorm8x4 = TgpuVertexFormatData<'unorm8x4'>;
declare const unorm8x4: unorm8x4;
type snorm8 = TgpuVertexFormatData<'snorm8'>;
declare const snorm8: snorm8;
type snorm8x2 = TgpuVertexFormatData<'snorm8x2'>;
declare const snorm8x2: snorm8x2;
type snorm8x4 = TgpuVertexFormatData<'snorm8x4'>;
declare const snorm8x4: snorm8x4;
type uint16 = TgpuVertexFormatData<'uint16'>;
declare const uint16: uint16;
type uint16x2 = TgpuVertexFormatData<'uint16x2'>;
declare const uint16x2: uint16x2;
type uint16x4 = TgpuVertexFormatData<'uint16x4'>;
declare const uint16x4: uint16x4;
type sint16 = TgpuVertexFormatData<'sint16'>;
declare const sint16: sint16;
type sint16x2 = TgpuVertexFormatData<'sint16x2'>;
declare const sint16x2: sint16x2;
type sint16x4 = TgpuVertexFormatData<'sint16x4'>;
declare const sint16x4: sint16x4;
type unorm16 = TgpuVertexFormatData<'unorm16'>;
declare const unorm16: unorm16;
type unorm16x2 = TgpuVertexFormatData<'unorm16x2'>;
declare const unorm16x2: unorm16x2;
type unorm16x4 = TgpuVertexFormatData<'unorm16x4'>;
declare const unorm16x4: unorm16x4;
type snorm16 = TgpuVertexFormatData<'snorm16'>;
declare const snorm16: snorm16;
type snorm16x2 = TgpuVertexFormatData<'snorm16x2'>;
declare const snorm16x2: snorm16x2;
type snorm16x4 = TgpuVertexFormatData<'snorm16x4'>;
declare const snorm16x4: snorm16x4;
type float16 = TgpuVertexFormatData<'float16'>;
declare const float16: float16;
type float16x2 = TgpuVertexFormatData<'float16x2'>;
declare const float16x2: float16x2;
type float16x4 = TgpuVertexFormatData<'float16x4'>;
declare const float16x4: float16x4;
type float32 = TgpuVertexFormatData<'float32'>;
declare const float32: float32;
type float32x2 = TgpuVertexFormatData<'float32x2'>;
declare const float32x2: float32x2;
type float32x3 = TgpuVertexFormatData<'float32x3'>;
declare const float32x3: float32x3;
type float32x4 = TgpuVertexFormatData<'float32x4'>;
declare const float32x4: float32x4;
type uint32 = TgpuVertexFormatData<'uint32'>;
declare const uint32: uint32;
type uint32x2 = TgpuVertexFormatData<'uint32x2'>;
declare const uint32x2: uint32x2;
type uint32x3 = TgpuVertexFormatData<'uint32x3'>;
declare const uint32x3: uint32x3;
type uint32x4 = TgpuVertexFormatData<'uint32x4'>;
declare const uint32x4: uint32x4;
type sint32 = TgpuVertexFormatData<'sint32'>;
declare const sint32: sint32;
type sint32x2 = TgpuVertexFormatData<'sint32x2'>;
declare const sint32x2: sint32x2;
type sint32x3 = TgpuVertexFormatData<'sint32x3'>;
declare const sint32x3: sint32x3;
type sint32x4 = TgpuVertexFormatData<'sint32x4'>;
declare const sint32x4: sint32x4;
type unorm10_10_10_2 = TgpuVertexFormatData<'unorm10-10-10-2'>;
declare const unorm10_10_10_2: unorm10_10_10_2;
type unorm8x4_bgra = TgpuVertexFormatData<'unorm8x4-bgra'>;
declare const unorm8x4_bgra: unorm8x4_bgra;
type PackedData = uint8 | uint8x2 | uint8x4 | sint8 | sint8x2 | sint8x4 | unorm8 | unorm8x2 | unorm8x4 | snorm8 | snorm8x2 | snorm8x4 | uint16 | uint16x2 | uint16x4 | sint16 | sint16x2 | sint16x4 | unorm16 | unorm16x2 | unorm16x4 | snorm16 | snorm16x2 | snorm16x4 | float16 | float16x2 | float16x4 | float32 | float32x2 | float32x3 | float32x4 | uint32 | uint32x2 | uint32x3 | uint32x4 | sint32 | sint32x2 | sint32x3 | sint32x4 | unorm10_10_10_2 | unorm8x4_bgra;

type TgpuDualFn<TImpl extends (...args: never[]) => unknown> = TImpl & {
    [$internal]: {
        implementation: TImpl | string;
        argTypes: FnArgsConversionHint;
    };
};
/**
 * Array schema constructed via `d.disarrayOf` function.
 *
 * Useful for defining vertex buffers.
 * Elements in the schema are not aligned in respect to their `byteAlignment`,
 * unless they are explicitly decorated with the custom align attribute
 * via `d.align` function.
 */
interface Disarray<TElement extends BaseData = BaseData> {
    readonly [$internal]: true;
    readonly type: 'disarray';
    readonly elementCount: number;
    readonly elementType: TElement;
    readonly [$repr]: Infer<TElement>[];
    readonly [$reprPartial]: {
        idx: number;
        value: InferPartial<TElement>;
    }[] | undefined;
}
/**
 * Struct schema constructed via `d.unstruct` function.
 *
 * Useful for defining vertex buffers, as the standard layout restrictions do not apply.
 * Members are not aligned in respect to their `byteAlignment`,
 * unless they are explicitly decorated with the custom align attribute
 * via `d.align` function.
 */
interface Unstruct<TProps extends Record<string, BaseData> = Record<string, BaseData>> extends TgpuNamable {
    readonly [$internal]: true;
    (props: Prettify<InferRecord<TProps>>): Prettify<InferRecord<TProps>>;
    readonly type: 'unstruct';
    readonly propTypes: TProps;
    readonly [$repr]: Prettify<InferRecord<TProps>>;
    readonly [$gpuRepr]: Prettify<InferGPURecord<TProps>>;
    readonly [$memIdent]: Unstruct<Prettify<MemIdentityRecord<TProps>>>;
    readonly [$reprPartial]: Prettify<Partial<InferPartialRecord<TProps>>> | undefined;
}
type AnyUnstruct = Unstruct<any>;
interface LooseDecorated<TInner extends BaseData = BaseData, TAttribs extends unknown[] = unknown[]> {
    readonly [$internal]: true;
    readonly type: 'loose-decorated';
    readonly inner: TInner;
    readonly attribs: TAttribs;
    readonly [$repr]: Infer<TInner>;
}
declare const looseTypeLiterals: readonly ["unstruct", "disarray", "loose-decorated", "uint8", "uint8x2", "uint8x4", "sint8", "sint8x2", "sint8x4", "unorm8", "unorm8x2", "unorm8x4", "snorm8", "snorm8x2", "snorm8x4", "uint16", "uint16x2", "uint16x4", "sint16", "sint16x2", "sint16x4", "unorm16", "unorm16x2", "unorm16x4", "snorm16", "snorm16x2", "snorm16x4", "float16", "float16x2", "float16x4", "float32", "float32x2", "float32x3", "float32x4", "uint32", "uint32x2", "uint32x3", "uint32x4", "sint32", "sint32x2", "sint32x3", "sint32x4", "unorm10-10-10-2", "unorm8x4-bgra"];
type LooseTypeLiteral = (typeof looseTypeLiterals)[number];
type AnyLooseData = Disarray | AnyUnstruct | LooseDecorated | PackedData;
declare function isLooseData(data: unknown): data is AnyLooseData;
/**
 * Checks whether the passed in value is a disarray schema,
 * as opposed to, e.g., a regular array schema.
 *
 * Array schemas can be used to describe uniform and storage buffers,
 * whereas disarray schemas cannot. Disarrays are useful for
 * defining vertex buffers instead.
 *
 * @example
 * isDisarray(d.arrayOf(d.u32, 4)) // false
 * isDisarray(d.disarrayOf(d.u32, 4)) // true
 * isDisarray(d.vec3f) // false
 */
declare function isDisarray<T extends Disarray>(schema: T | unknown): schema is T;
/**
 * Checks whether passed in value is a unstruct schema,
 * as opposed to, e.g., a struct schema.
 *
 * Struct schemas can be used to describe uniform and storage buffers,
 * whereas unstruct schemas cannot. Unstructs are useful for
 * defining vertex buffers instead.
 *
 * @example
 * isUnstruct(d.struct({ a: d.u32 })) // false
 * isUnstruct(d.unstruct({ a: d.u32 })) // true
 * isUnstruct(d.vec3f) // false
 */
declare function isUnstruct<T extends Unstruct>(schema: T | unknown): schema is T;
declare function isLooseDecorated<T extends LooseDecorated>(value: T | unknown): value is T;
declare function isData(value: unknown): value is AnyData;
type AnyData = AnyWgslData | AnyLooseData;
interface UnknownData {
    readonly type: 'unknown';
}
declare const UnknownData: UnknownData;
interface Snippet {
    readonly value: unknown;
    readonly dataType: AnyData | UnknownData;
}
type UnwrapDecorated<TData extends BaseData> = TData extends {
    readonly type: 'decorated';
    readonly inner: infer TInner;
} ? TInner extends BaseData ? UnwrapDecorated<TInner> : TData : TData;
type HasNestedType<TData extends [BaseData], TType extends string> = UnwrapDecorated<TData[0]> extends {
    readonly type: TType;
} ? true : UnwrapDecorated<TData[0]> extends {
    readonly type: 'array';
    readonly elementType: infer TElement;
} ? TElement extends BaseData ? UnwrapDecorated<TElement> extends {
    readonly type: TType;
} ? true : HasNestedType<[TElement], TType> : false : UnwrapDecorated<TData[0]> extends {
    readonly type: 'struct';
    readonly propTypes: infer TProps;
} ? TProps extends Record<string, BaseData> ? true extends {
    [K in keyof TProps]: UnwrapDecorated<TProps[K]> extends {
        readonly type: TType;
    } ? true : HasNestedType<[TProps[K]], TType>;
}[keyof TProps] ? true : false : false : false;

declare const builtinNames: readonly ["vertex_index", "instance_index", "position", "clip_distances", "front_facing", "frag_depth", "sample_index", "sample_mask", "fragment", "local_invocation_id", "local_invocation_index", "global_invocation_id", "workgroup_id", "num_workgroups", "subgroup_invocation_id", "subgroup_size"];
type BuiltinName = (typeof builtinNames)[number];
type AnyAttribute<AllowedBuiltins extends Builtin<BuiltinName> = Builtin<BuiltinName>> = Align<number> | Size<number> | Location<number> | Interpolate<InterpolationType> | AllowedBuiltins;
type ExtractAttributes<T> = T extends {
    readonly attribs: unknown[];
} ? T['attribs'] : [];
type Undecorate<T> = T extends {
    readonly inner: infer TInner;
} ? TInner : T;
type UndecorateRecord<T extends Record<string, unknown>> = {
    [Key in keyof T]: Undecorate<T[Key]>;
};
/**
 * Decorates a data-type `TData` with an attribute `TAttrib`.
 *
 * - if `TData` is loose
 *   - if `TData` is already `LooseDecorated`
 *     - Prepend `TAttrib` to the existing attribute tuple.
 *   - else
 *     - Wrap `TData` with `LooseDecorated` and a single attribute `[TAttrib]`
 * - else
 *   - if `TData` is already `Decorated`
 *     - Prepend `TAttrib` to the existing attribute tuple.
 *   - else
 *     - Wrap `TData` with `Decorated` and a single attribute `[TAttrib]`
 */
type Decorate<TData extends BaseData, TAttrib extends AnyAttribute> = TData['type'] extends WgslTypeLiteral ? Decorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]> : TData['type'] extends LooseTypeLiteral ? LooseDecorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]> : never;
type IsBuiltin<T> = ExtractAttributes<T>[number] extends [] ? false : ExtractAttributes<T>[number] extends Builtin<BuiltinName> ? true : false;
type HasCustomLocation<T> = ExtractAttributes<T>[number] extends [] ? false : ExtractAttributes<T>[number] extends Location ? true : false;
/**
 * Gives the wrapped data-type a custom byte alignment. Useful in order to
 * fulfill uniform alignment requirements.
 *
 * @example
 * const Data = d.struct({
 *   a: u32, // takes up 4 bytes
 *   // 12 bytes of padding, because `b` is custom aligned to multiples of 16 bytes
 *   b: d.align(16, u32),
 * });
 *
 * @param alignment The multiple of bytes this data should align itself to.
 * @param data The data-type to align.
 */
declare function align<TAlign extends number, TData extends AnyData>(alignment: TAlign, data: TData): Decorate<TData, Align<TAlign>>;
/**
 * Adds padding bytes after the wrapped data-type, until the whole value takes up `size` bytes.
 *
 * @example
 * const Data = d.struct({
 *   a: d.size(16, u32), // takes up 16 bytes, instead of 4
 *   b: u32, // starts at byte 16, because `a` has a custom size
 * });
 *
 * @param size The amount of bytes that should be reserved for this data-type.
 * @param data The data-type to wrap.
 */
declare function size<TSize extends number, TData extends AnyData>(size: TSize, data: TData): Decorate<TData, Size<TSize>>;
/**
 * Assigns an explicit numeric location to a struct member or a parameter that has this type.
 *
 * @example
 * const VertexOutput = {
 *   a: d.u32, // has implicit location 0
 *   b: d.location(5, d.u32),
 *   c: d.u32, // has implicit location 6
 * };
 *
 * @param location The explicit numeric location.
 * @param data The data-type to wrap.
 */
declare function location<TLocation extends number, TData extends AnyData>(location: TLocation, data: TData): Decorate<TData, Location<TLocation>>;
/**
 * Specifies how user-defined vertex shader output (fragment shader input)
 * must be interpolated.
 *
 * Tip: Integer outputs cannot be interpolated.
 *
 * @example
 * const VertexOutput = {
 *   a: d.f32, // has implicit 'perspective, center' interpolation
 *   b: d.interpolate('linear, sample', d.f32),
 * };
 *
 * @param interpolationType How data should be interpolated.
 * @param data The data-type to wrap.
 */
declare function interpolate<TInterpolation extends PerspectiveOrLinearInterpolationType, TData extends PerspectiveOrLinearInterpolatableData>(interpolationType: TInterpolation, data: TData): Decorate<TData, Interpolate<TInterpolation>>;
/**
 * Specifies how user-defined vertex shader output (fragment shader input)
 * must be interpolated.
 *
 * Tip: Default sampling method of `flat` is `first`. Unless you specifically
 * need deterministic behavior provided by `'flat, first'`, prefer explicit
 * `'flat, either'` as it could be slightly faster in hardware.
 *
 * @example
 * const VertexOutput = {
 *   a: d.f32, // has implicit 'perspective, center' interpolation
 *   b: d.interpolate('flat, either', d.u32), // integer outputs cannot interpolate
 * };
 *
 * @param interpolationType How data should be interpolated.
 * @param data The data-type to wrap.
 */
declare function interpolate<TInterpolation extends FlatInterpolationType, TData extends FlatInterpolatableData>(interpolationType: TInterpolation, data: TData): Decorate<TData, Interpolate<TInterpolation>>;
declare function isBuiltin<T extends Decorated<AnyWgslData, AnyAttribute[]> | LooseDecorated<AnyLooseData, AnyAttribute[]>>(value: T | unknown): value is T;

type AnyFn = (...args: never[]) => unknown;
type InferArgs<T extends unknown[]> = {
    [Idx in keyof T]: Infer<T[Idx]>;
};
type InheritTupleValues<T, From> = {
    [K in keyof T]: K extends keyof From ? From[K] : never;
};
/**
 * Returns a type that has arg and return types of `T`, but argument
 * names of `From`
 *
 * Wrapped in an object type with `result` prop just so that it's easier
 * to remove InheritArgNames<...> from Intellisense with Prettify<T>['result']
 */
type InheritArgNames<T extends AnyFn, From extends AnyFn> = {
    result: (...args: Parameters<((...args: InheritTupleValues<Parameters<From>, Parameters<T>>) => ReturnType<T>) & T>) => ReturnType<T>;
};
type InferImplSchema<ImplSchema extends AnyFn> = (...args: InferArgs<Parameters<ImplSchema>>) => Infer<ReturnType<ImplSchema>>;
type Implementation<ImplSchema extends AnyFn = AnyFn> = string | InferImplSchema<ImplSchema>;
type BaseIOData = Bool | F32 | F16 | I32 | U32 | Vec2f | Vec3f | Vec4f | Vec2h | Vec3h | Vec4h | Vec2i | Vec3i | Vec4i | Vec2u | Vec3u | Vec4u;
type IOData = BaseIOData | Decorated<BaseIOData, AnyAttribute[]> | BuiltinClipDistances;
type IORecord<TElementType extends IOData = IOData> = Record<string, TElementType>;
/**
 * Used for I/O definitions of entry functions.
 */
type IOLayout<TElementType extends IOData = IOData> = TElementType | IORecord<TElementType> | Void;
type InferIO<T> = T extends {
    type: string;
} ? Infer<T> : T extends Record<string, unknown> ? {
    [K in keyof T]: Infer<T[K]>;
} : T;

/**
 * Describes a compute entry function signature (its arguments, return type and workgroup size)
 */
type TgpuComputeFnShellHeader<ComputeIn extends IORecord<AnyComputeBuiltin>> = {
    readonly argTypes: [IOLayoutToSchema<ComputeIn>] | [];
    readonly returnType: Void;
    readonly workgroupSize: [number, number, number];
    readonly isEntry: true;
};
/**
 * Describes a compute entry function signature (its arguments, return type and workgroup size).
 * Allows creating tgpu compute functions by calling this shell
 * and passing the implementation (as WGSL string or JS function) as the argument.
 */
type TgpuComputeFnShell<ComputeIn extends IORecord<AnyComputeBuiltin>> = TgpuComputeFnShellHeader<ComputeIn>
/**
 * Creates a type-safe implementation of this signature
 */
 & ((implementation: (input: InferIO<ComputeIn>) => undefined) => TgpuComputeFn<ComputeIn>) & /**
 * @param implementation
 *   Raw WGSL function implementation with header and body
 *   without `fn` keyword and function name
 *   e.g. `"(x: f32) -> f32 { return x; }"`;
 */ ((implementation: string) => TgpuComputeFn<ComputeIn>) & ((strings: TemplateStringsArray, ...values: unknown[]) => TgpuComputeFn<ComputeIn>) & {
    /**
     * @deprecated Invoke the shell as a function instead.
     */
    does: ((implementation: (input: InferIO<ComputeIn>) => undefined) => TgpuComputeFn<ComputeIn>) & /**
     * @param implementation
     *   Raw WGSL function implementation with header and body
     *   without `fn` keyword and function name
     *   e.g. `"(x: f32) -> f32 { return x; }"`;
     */ ((implementation: string) => TgpuComputeFn<ComputeIn>);
};
interface TgpuComputeFn<ComputeIn extends IORecord<AnyComputeBuiltin> = any> extends TgpuNamable {
    readonly [$internal]: true;
    readonly shell: TgpuComputeFnShellHeader<ComputeIn>;
    $uses(dependencyMap: Record<string, unknown>): this;
}
declare function computeFn(options: {
    workgroupSize: number[];
}): TgpuComputeFnShell<{}>;
declare function computeFn<ComputeIn extends IORecord<AnyComputeBuiltin>>(options: {
    in: ComputeIn;
    workgroupSize: number[];
}): TgpuComputeFnShell<ComputeIn>;

export { type Storage as $, type AnyWgslData as A, isSlot as B, isComparisonSampler as C, type Disarray as D, isSampler as E, isSampledTextureView as F, isStorageTextureView as G, isTexture as H, type Infer as I, isUsableAsRender as J, isUsableAsSampled as K, isUsableAsStorage as L, asMutable as M, asReadonly as N, asUniform as O, isUsableAsUniform as P, isBufferShorthand as Q, RandomNameRegistry as R, StrictNameRegistry as S, type TgpuBindGroupLayout as T, isTgpuFn as U, type Configurable as V, type Wgsl as W, type WithBinding as X, type WithCompute as Y, type WithFragment as Z, type WithVertex as _, type TgpuBindGroup as a, type Vec3h as a$, type StorageFlag as a0, type TgpuRenderPipeline as a1, type TgpuComputePipeline as a2, type IndexFlag as a3, type Uniform as a4, type UniformFlag as a5, type Vertex as a6, type VertexFlag as a7, type TgpuBufferMutable as a8, type TgpuBufferReadonly as a9, type TgpuLayoutStorageTexture as aA, type TgpuLayoutTexture as aB, type TgpuLayoutUniform as aC, type TgpuFnShell as aD, type TgpuVertexFn as aE, type TgpuVertexFnShell as aF, type TgpuFragmentFn as aG, type TgpuFragmentFnShell as aH, type TgpuComputeFn as aI, type TgpuComputeFnShell as aJ, type TgpuDeclare as aK, type INTERNAL_GlobalExt as aL, type Bool as aM, type F16 as aN, type F32 as aO, type I32 as aP, type U16 as aQ, type U32 as aR, type WgslStruct as aS, type Ptr as aT, type Vec2b as aU, type Vec2f as aV, type Vec2h as aW, type Vec2i as aX, type Vec2u as aY, type Vec3b as aZ, type Vec3f as a_, type TgpuBufferUniform as aa, type TgpuMutable as ab, type TgpuReadonly as ac, type TgpuUniform as ad, type Eventual as ae, type TgpuAnyTextureView as af, type TgpuMutableTexture as ag, type TgpuReadonlyTexture as ah, type TgpuSampledTexture as ai, type TgpuTexture as aj, type TgpuWriteonlyTexture as ak, type TextureProps as al, type Render as am, type Sampled as an, type TgpuConst as ao, type TgpuVar as ap, type VariableScope as aq, type TgpuSampler as ar, type BindLayoutEntry as as, type ExtractBindGroupInputFromLayout as at, type LayoutEntryToInput as au, type TgpuLayoutComparisonSampler as av, type TgpuLayoutEntry as aw, type TgpuLayoutExternalTexture as ax, type TgpuLayoutSampler as ay, type TgpuLayoutStorage as az, type TgpuRoot as b, builtin as b$, type Vec3i as b0, type Vec3u as b1, type Vec4b as b2, type Vec4f as b3, type Vec4h as b4, type Vec4i as b5, type Vec4u as b6, type BaseData as b7, type Unstruct as b8, type Atomic as b9, type v2b as bA, type v2f as bB, type v2i as bC, type v2u as bD, type v3b as bE, type v3f as bF, type v3i as bG, type v3u as bH, type v4b as bI, type v4f as bJ, type v4i as bK, type v4u as bL, type AnyLooseData as bM, type LooseDecorated as bN, align as bO, type AnyAttribute as bP, type HasCustomLocation as bQ, interpolate as bR, type IsBuiltin as bS, isBuiltin as bT, location as bU, size as bV, isData as bW, isDisarray as bX, isLooseData as bY, isLooseDecorated as bZ, isUnstruct as b_, isAlignAttrib as ba, isAtomic as bb, isBuiltinAttrib as bc, isDecorated as bd, isInterpolateAttrib as be, isLocationAttrib as bf, isPtr as bg, isSizeAttrib as bh, isWgslArray as bi, isWgslData as bj, isWgslStruct as bk, Void as bl, type Align as bm, type AnyVecInstance as bn, type AnyWgslStruct as bo, type Builtin as bp, type Decorated as bq, type Interpolate as br, type Location as bs, type m2x2f as bt, type m3x3f as bu, type m4x4f as bv, type Mat2x2f as bw, type Mat3x3f as bx, type Mat4x4f as by, type Size as bz, type TgpuFn as c, type AnyNumericVecInstance as c$, type AnyBuiltin as c0, type BuiltinClipDistances as c1, type BuiltinFragDepth as c2, type BuiltinFrontFacing as c3, type BuiltinGlobalInvocationId as c4, type BuiltinInstanceIndex as c5, type BuiltinLocalInvocationId as c6, type BuiltinLocalInvocationIndex as c7, type BuiltinNumWorkgroups as c8, type BuiltinPosition as c9, sint16x2 as cA, sint16x4 as cB, unorm16 as cC, unorm16x2 as cD, unorm16x4 as cE, snorm16 as cF, snorm16x2 as cG, snorm16x4 as cH, float16 as cI, float16x2 as cJ, float16x4 as cK, float32 as cL, float32x2 as cM, float32x3 as cN, float32x4 as cO, uint32 as cP, uint32x2 as cQ, uint32x3 as cR, uint32x4 as cS, sint32 as cT, sint32x2 as cU, sint32x3 as cV, sint32x4 as cW, unorm10_10_10_2 as cX, unorm8x4_bgra as cY, type PackedData as cZ, type TgpuDualFn as c_, type BuiltinSampleIndex as ca, type BuiltinSampleMask as cb, type BuiltinVertexIndex as cc, type BuiltinWorkgroupId as cd, type InferGPU as ce, type InferPartial as cf, type FormatToWGSLType as cg, type TgpuVertexFormatData as ch, formatToWGSLType as ci, packedFormats as cj, uint8 as ck, uint8x2 as cl, uint8x4 as cm, sint8 as cn, sint8x2 as co, sint8x4 as cp, unorm8 as cq, unorm8x2 as cr, unorm8x4 as cs, snorm8 as ct, snorm8x2 as cu, snorm8x4 as cv, uint16 as cw, uint16x2 as cx, uint16x4 as cy, sint16 as cz, type TgpuBufferUsage as d, type AnyMatInstance as d0, type vBaseForMat as d1, type mBaseForVec as d2, type AnyFloatVecInstance as d3, type v3h as d4, type v2h as d5, type v4h as d6, type AnyVec2Instance as d7, type AnyVec3Instance as d8, type AnyBooleanVecInstance as d9, type atomicI32 as da, type atomicU32 as db, type TgpuStorageTexture as dc, type TexelData as dd, type ChannelData as de, type TgpuAccessor as e, type TgpuDerived as f, type TgpuSlot as g, type TgpuVertexLayout as h, type WgslArray as i, type TgpuBuffer as j, type AnyData as k, fn as l, bindGroupLayout as m, fragmentFn as n, vertexFn as o, computeFn as p, privateVar as q, constant as r, declare as s, sampler as t, comparisonSampler as u, vertexLayout as v, workgroupVar as w, isBuffer as x, isUsableAsVertex as y, isDerived as z };
