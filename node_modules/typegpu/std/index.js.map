{"version":3,"sources":["../../src/std/discard.ts","../../src/std/matrix.ts","../../src/std/boolean.ts","../../src/std/atomic.ts","../../src/std/array.ts","../../src/std/packing.ts","../../src/std/texture.ts"],"sourcesContent":["import { snip } from '../data/dataTypes.ts';\nimport { Void } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\n\nexport const discard = createDualImpl(\n  // CPU\n  (): never => {\n    throw new Error('discard() can only be used on the GPU.');\n  },\n  // GPU\n  () => snip('discard;', Void),\n  'discard',\n);\n","import type { Snippet } from '../data/dataTypes.ts';\nimport { mat4x4f } from '../data/matrix.ts';\nimport type { m4x4f, v3f } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\nimport { mul } from './numeric.ts';\n\n/**\n * Translates the given 4-by-4 matrix by the given vector.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {v3f} vector - The vector by which to translate the matrix.\n * @returns {m4x4f} The translated matrix.\n */\nexport const translate4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, vector: v3f) => {\n    return mul(mat4x4f.translation(vector), matrix);\n  },\n  // GPU implementation\n  (matrix, vector) => ({\n    value: `(${\n      (mat4x4f.translation(vector as unknown as v3f) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'translate4',\n);\n\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount given by the corresponding entry in the given vector.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {v3f} vector - A vector of three entries specifying the factor by which to scale in each dimension.\n * @returns {m4x4f} The scaled matrix.\n */\nexport const scale4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, vector: v3f) => {\n    return mul(mat4x4f.scaling(vector), matrix);\n  },\n  // GPU implementation\n  (matrix, vector) => ({\n    value: `(${\n      (mat4x4f.scaling(vector as unknown as v3f) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'scale4',\n);\n\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateX4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, angle: number) => {\n    return mul(mat4x4f.rotationX(angle), matrix);\n  },\n  // GPU implementation\n  (matrix, angle) => ({\n    value: `(${\n      (mat4x4f.rotationX(angle as unknown as number) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'rotateX4',\n);\n\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateY4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, angle: number) => {\n    return mul(mat4x4f.rotationY(angle), matrix);\n  },\n  // GPU implementation\n  (matrix, angle) => ({\n    value: `(${\n      (mat4x4f.rotationY(angle as unknown as number) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'rotateY4',\n);\n\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateZ4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, angle: number) => {\n    return mul(mat4x4f.rotationZ(angle), matrix);\n  },\n  // GPU implementation\n  (matrix, angle) => ({\n    value: `(${\n      (mat4x4f.rotationZ(angle as unknown as number) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'rotateZ4',\n);\n","import { snip, type Snippet } from '../data/dataTypes.ts';\nimport { bool, f32 } from '../data/numeric.ts';\nimport { vec2b, vec3b, vec4b } from '../data/vector.ts';\nimport { VectorOps } from '../data/vectorOps.ts';\nimport {\n  type AnyBooleanVecInstance,\n  type AnyFloatVecInstance,\n  type AnyNumericVecInstance,\n  type AnyVec2Instance,\n  type AnyVec3Instance,\n  type AnyVecInstance,\n  isVecInstance,\n  type v2b,\n  type v3b,\n  type v4b,\n} from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\nimport { isSnippetNumeric, sub } from './numeric.ts';\n\nfunction correspondingBooleanVectorSchema(value: Snippet) {\n  if (value.dataType.type.includes('2')) {\n    return vec2b;\n  }\n  if (value.dataType.type.includes('3')) {\n    return vec3b;\n  }\n  return vec4b;\n}\n\n// comparison\n\n/**\n * Checks whether `lhs == rhs` on all components.\n * Equivalent to `all(eq(lhs, rhs))`.\n * @example\n * allEq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns false\n * allEq(vec3u(0, 1, 2), vec3u(0, 1, 2)) // returns true\n */\nexport const allEq = createDualImpl(\n  // CPU implementation\n  <T extends AnyVecInstance>(lhs: T, rhs: T) => all(eq(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) => snip(`all(${lhs.value} == ${rhs.value})`, bool),\n  'allEq',\n);\n\n/**\n * Checks **component-wise** whether `lhs == rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`, or use `allEq`.\n * @example\n * eq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(true, false)\n * eq(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, false)\n * all(eq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1))) // returns true\n * allEq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1)) // returns true\n */\nexport const eq = createDualImpl(\n  // CPU implementation\n  <T extends AnyVecInstance>(lhs: T, rhs: T) =>\n    VectorOps.eq[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} == ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'eq',\n);\n\n/**\n * Checks **component-wise** whether `lhs != rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `any`.\n * @example\n * ne(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(false, true)\n * ne(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, true)\n * any(ne(vec4i(4, 3, 2, 1), vec4i(4, 2, 2, 1))) // returns true\n */\nexport const ne = createDualImpl(\n  // CPU implementation\n  <T extends AnyVecInstance>(lhs: T, rhs: T) => not(eq(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} != ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'ne',\n);\n\n/**\n * Checks **component-wise** whether `lhs < rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * lt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, true)\n * lt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, false)\n * all(lt(vec4i(1, 2, 3, 4), vec4i(2, 3, 4, 5))) // returns true\n */\nexport const lt = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    VectorOps.lt[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} < ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'lt',\n);\n\n/**\n * Checks **component-wise** whether `lhs <= rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * le(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, true)\n * le(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, true, false)\n * all(le(vec4i(1, 2, 3, 4), vec4i(2, 3, 3, 5))) // returns true\n */\nexport const le = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    or(lt(lhs, rhs), eq(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} <= ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'le',\n);\n\n/**\n * Checks **component-wise** whether `lhs > rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * gt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, false)\n * gt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, false, true)\n * all(gt(vec4i(2, 3, 4, 5), vec4i(1, 2, 3, 4))) // returns true\n */\nexport const gt = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    and(not(lt(lhs, rhs)), not(eq(lhs, rhs))),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} > ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'gt',\n);\n\n/**\n * Checks **component-wise** whether `lhs >= rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * ge(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, false)\n * ge(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, true)\n * all(ge(vec4i(2, 2, 4, 5), vec4i(1, 2, 3, 4))) // returns true\n */\nexport const ge = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) => not(lt(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} >= ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'ge',\n);\n\n// logical ops\n\n/**\n * Returns **component-wise** `!value`.\n * @example\n * not(vec2b(false, true)) // returns vec2b(true, false)\n * not(vec3b(true, true, false)) // returns vec3b(false, false, true)\n */\nexport const not = createDualImpl(\n  // CPU implementation\n  <T extends AnyBooleanVecInstance>(value: T): T =>\n    VectorOps.neg[value.kind](value),\n  // GPU implementation\n  (value) => snip(`!(${value.value})`, value.dataType),\n  'not',\n);\n\n/**\n * Returns **component-wise** logical `or` result.\n * @example\n * or(vec2b(false, true), vec2b(false, false)) // returns vec2b(false, true)\n * or(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(true, true, false)\n */\nexport const or = createDualImpl(\n  // CPU implementation\n  <T extends AnyBooleanVecInstance>(lhs: T, rhs: T) =>\n    VectorOps.or[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) => snip(`(${lhs.value} | ${rhs.value})`, lhs.dataType),\n  'or',\n);\n\n/**\n * Returns **component-wise** logical `and` result.\n * @example\n * and(vec2b(false, true), vec2b(true, true)) // returns vec2b(false, true)\n * and(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(false, true, false)\n */\nexport const and = createDualImpl(\n  // CPU implementation\n  <T extends AnyBooleanVecInstance>(lhs: T, rhs: T) =>\n    not(or(not(lhs), not(rhs))),\n  // GPU implementation\n  (lhs, rhs) => snip(`(${lhs.value} & ${rhs.value})`, lhs.dataType),\n  'and',\n);\n\n// logical aggregation\n\n/**\n * Returns `true` if each component of `value` is true.\n * @example\n * all(vec2b(false, true)) // returns false\n * all(vec3b(true, true, true)) // returns true\n */\nexport const all = createDualImpl(\n  // CPU implementation\n  (value: AnyBooleanVecInstance) => VectorOps.all[value.kind](value),\n  // GPU implementation\n  (value) => snip(`all(${value.value})`, bool),\n  'all',\n);\n\n/**\n * Returns `true` if any component of `value` is true.\n * @example\n * any(vec2b(false, true)) // returns true\n * any(vec3b(false, false, false)) // returns false\n */\nexport const any = createDualImpl(\n  // CPU implementation\n  (value: AnyBooleanVecInstance) => !all(not(value)),\n  // GPU implementation\n  (value) => snip(`any(${value.value})`, bool),\n  'any',\n);\n\n// other\n\n/**\n * Checks whether the given elements differ by at most the `precision` value.\n * Checks all elements of `lhs` and `rhs` if arguments are vectors.\n * @example\n * isCloseTo(0, 0.1) // returns false\n * isCloseTo(vec3f(0, 0, 0), vec3f(0.002, -0.009, 0)) // returns true\n *\n * @param {number} precision argument that specifies the maximum allowed difference, 0.01 by default.\n */\nexport const isCloseTo = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(\n    lhs: T,\n    rhs: T,\n    precision = 0.01,\n  ) => {\n    if (typeof lhs === 'number' && typeof rhs === 'number') {\n      return Math.abs(lhs - rhs) < precision;\n    }\n    if (isVecInstance(lhs) && isVecInstance(rhs)) {\n      return VectorOps.isCloseToZero[lhs.kind](\n        sub(lhs, rhs),\n        precision,\n      );\n    }\n    return false;\n  },\n  // GPU implementation\n  (lhs, rhs, precision = snip(0.01, f32)) => {\n    if (isSnippetNumeric(lhs) && isSnippetNumeric(rhs)) {\n      return snip(\n        `(abs(f32(${lhs.value}) - f32(${rhs.value})) <= ${precision.value})`,\n        bool,\n      );\n    }\n    if (!isSnippetNumeric(lhs) && !isSnippetNumeric(rhs)) {\n      return snip(\n        // https://www.w3.org/TR/WGSL/#vector-multi-component:~:text=Binary%20arithmetic%20expressions%20with%20mixed%20scalar%20and%20vector%20operands\n        // (a-a)+prec creates a vector of a.length elements, all equal to prec\n        `all(abs(${lhs.value} - ${rhs.value}) <= (${lhs.value} - ${lhs.value}) + ${precision.value})`,\n        bool,\n      );\n    }\n    return snip('false', bool);\n  },\n  'isCloseTo',\n);\n\nexport type SelectOverload = {\n  <T extends number | boolean | AnyVecInstance>(f: T, t: T, cond: boolean): T;\n  <T extends AnyVecInstance>(\n    f: T,\n    t: T,\n    cond: T extends AnyVec2Instance ? v2b\n      : T extends AnyVec3Instance ? v3b\n      : v4b,\n  ): T;\n};\n\n/**\n * Returns `t` if `cond` is `true`, and `f` otherwise.\n * Component-wise if `cond` is a vector.\n * @example\n * select(1, 2, false) // returns 1\n * select(1, 2, true) // returns 2\n * select(vec2i(1, 2), vec2i(3, 4), true) // returns vec2i(3, 4)\n * select(vec2i(1, 2), vec2i(3, 4), vec2b(false, true)) // returns vec2i(1, 4)\n */\nexport const select: SelectOverload = createDualImpl(\n  // CPU implementation\n  <T extends number | boolean | AnyVecInstance>(\n    f: T,\n    t: T,\n    cond: AnyBooleanVecInstance | boolean,\n  ) => {\n    if (typeof cond === 'boolean') {\n      return cond ? t : f;\n    }\n    return VectorOps.select[(f as AnyVecInstance).kind](\n      f as AnyVecInstance,\n      t as AnyVecInstance,\n      cond,\n    );\n  },\n  // GPU implementation\n  (f, t, cond) =>\n    snip(`select(${f.value}, ${t.value}, ${cond.value})`, f.dataType),\n  'select',\n);\n","import { snip, type Snippet } from '../data/dataTypes.ts';\nimport { i32, u32 } from '../data/numeric.ts';\nimport {\n  type AnyWgslData,\n  type atomicI32,\n  type atomicU32,\n  isWgslData,\n  Void,\n} from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\ntype AnyAtomic = atomicI32 | atomicU32;\n\nexport const workgroupBarrier = createDualImpl(\n  // CPU implementation\n  () => console.warn('workgroupBarrier is a no-op outside of GPU mode.'),\n  // GPU implementation\n  () => snip('workgroupBarrier()', Void),\n  'workgroupBarrier',\n);\n\nexport const storageBarrier = createDualImpl(\n  // CPU implementation\n  () => console.warn('storageBarrier is a no-op outside of GPU mode.'),\n  // GPU implementation\n  () => snip('storageBarrier()', Void),\n  'storageBarrier',\n);\n\nexport const textureBarrier = createDualImpl(\n  // CPU implementation\n  () => console.warn('textureBarrier is a no-op outside of GPU mode.'),\n  // GPU implementation\n  () => snip('textureBarrier()', Void),\n  'textureBarrier',\n);\n\nexport const atomicLoad = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicLoad(&${a.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicLoad',\n);\n\nexport const atomicStore = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): void => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (!isWgslData(a.dataType) || a.dataType.type !== 'atomic') {\n      throw new Error(\n        `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n      );\n    }\n    return snip(`atomicStore(&${a.value}, ${value.value})`, Void);\n  },\n  'atomicStore',\n);\n\nconst atomicTypeFn = (a: Snippet, _value: Snippet): AnyWgslData[] => {\n  if (a.dataType.type === 'atomic' && a.dataType.inner.type === 'i32') {\n    return [a.dataType, i32];\n  }\n  return [a.dataType as AnyWgslData, u32];\n};\n\nexport const atomicAdd = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicAdd(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicAdd',\n  atomicTypeFn,\n);\n\nexport const atomicSub = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicSub(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicSub',\n  atomicTypeFn,\n);\n\nexport const atomicMax = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicMax(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicMax',\n  atomicTypeFn,\n);\n\nexport const atomicMin = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicMin(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicMin',\n  atomicTypeFn,\n);\n\nexport const atomicAnd = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicAnd(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicAnd',\n  atomicTypeFn,\n);\n\nexport const atomicOr = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicOr(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicOr',\n  atomicTypeFn,\n);\n\nexport const atomicXor = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicXor(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicXor',\n  atomicTypeFn,\n);\n","import { snip } from '../data/dataTypes.ts';\nimport { abstractInt, u32 } from '../data/numeric.ts';\nimport { ptrFn } from '../data/ptr.ts';\nimport type { AnyWgslData } from '../data/wgslTypes.ts';\nimport { isPtr, isWgslArray } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\n\nexport const arrayLength = createDualImpl(\n  // CPU implementation\n  (a: unknown[]) => a.length,\n  // GPU implementation\n  (a) => {\n    if (\n      isPtr(a.dataType) && isWgslArray(a.dataType.inner) &&\n      a.dataType.inner.elementCount > 0\n    ) {\n      return snip(String(a.dataType.inner.elementCount), abstractInt);\n    }\n    return snip(`arrayLength(${a.value})`, u32);\n  },\n  'arrayLength',\n  (a) => [ptrFn(a.dataType as AnyWgslData)],\n);\n","import * as TB from 'typed-binary';\nimport { u32 } from '../data/numeric.ts';\nimport { vec2f, vec4f } from '../data/vector.ts';\nimport type { v2f, v4f } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\nimport { snip } from '../data/dataTypes.ts';\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#unpack2x16float-builtin\n */\nexport const unpack2x16float = createDualImpl(\n  // CPU implementation\n  (e: number): v2f => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeUint32(e);\n    const reader = new TB.BufferReader(buffer);\n    return vec2f(reader.readFloat16(), reader.readFloat16());\n  },\n  // GPU implementation\n  (e) => snip(`unpack2x16float(${e.value})`, vec2f),\n  'unpack2x16float',\n);\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#pack2x16float-builtin\n */\nexport const pack2x16float = createDualImpl(\n  // CPU implementation\n  (e: v2f): number => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeFloat16(e.x);\n    writer.writeFloat16(e.y);\n    const reader = new TB.BufferReader(buffer);\n    return u32(reader.readUint32());\n  },\n  // GPU implementation\n  (e) => snip(`pack2x16float(${e.value})`, u32),\n  'pack2x16float',\n);\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#unpack4x8unorm-builtin\n */\nexport const unpack4x8unorm = createDualImpl(\n  // CPU implementation\n  (e: number): v4f => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeUint32(e);\n    const reader = new TB.BufferReader(buffer);\n    return vec4f(\n      reader.readUint8() / 255,\n      reader.readUint8() / 255,\n      reader.readUint8() / 255,\n      reader.readUint8() / 255,\n    );\n  },\n  // GPU implementation\n  (e) => snip(`unpack4x8unorm(${e.value})`, vec4f),\n  'unpack4x8unorm',\n);\n\n/**\n * @privateRemarks\n * https://gpuweb.github.io/gpuweb/wgsl/#pack4x8unorm-builtin\n */\nexport const pack4x8unorm = createDualImpl(\n  // CPU implementation\n  (e: v4f): number => {\n    const buffer = new ArrayBuffer(4);\n    const writer = new TB.BufferWriter(buffer);\n    writer.writeUint8(e.x * 255);\n    writer.writeUint8(e.y * 255);\n    writer.writeUint8(e.z * 255);\n    writer.writeUint8(e.w * 255);\n    const reader = new TB.BufferReader(buffer);\n    return u32(reader.readUint32());\n  },\n  // GPU implementation\n  (e) => snip(`pack4x8unorm(${e.value})`, u32),\n  'pack4x8unorm',\n);\n","import type { TgpuSampler } from '../core/sampler/sampler.ts';\nimport type {\n  TgpuSampledTexture,\n  TgpuStorageTexture,\n} from '../core/texture/texture.ts';\nimport type { ChannelData, TexelData } from '../core/texture/texture.ts';\nimport { snip } from '../data/dataTypes.ts';\nimport { u32 } from '../data/numeric.ts';\nimport { vec2u, vec3u, vec4f, vec4i, vec4u } from '../data/vector.ts';\nimport {\n  type v2f,\n  type v2i,\n  type v2u,\n  type v3f,\n  type v3i,\n  type v3u,\n  type v4f,\n  type v4i,\n  type v4u,\n  Void,\n} from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\n\ntype TextureSampleOverload = {\n  <T extends TgpuSampledTexture<'1d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: number,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    offset: v2i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    arrayIndex: number,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    arrayIndex: number,\n    offset: v2i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'3d' | 'cube'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n  ): v4f;\n  <T extends TgpuSampledTexture<'3d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n    offset: v3i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'cube-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n    arrayIndex: number,\n  ): v4f;\n  // TODO: Support this\n  // <T extends TgpuSampledTexture<'depth-2d'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v2f,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-2d'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v2f,\n  //   offset: v2i,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-2d-array'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v2f,\n  //   arrayIndex: number,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-2d-array'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v2f,\n  //   arrayIndex: number,\n  //   offset: v2i,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-cube'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v3i,\n  // ): number;\n  // <T extends TgpuSampledTexture<'depth-cube-array'>>(\n  //   texture: T,\n  //   sampler: TgpuSampler,\n  //   coords: v3i,\n  //   arrayIndex: number,\n  // ): number;\n};\n\nexport const textureSample: TextureSampleOverload = createDualImpl(\n  // CPU implementation\n  (\n    _texture: TgpuSampledTexture,\n    _sampler: TgpuSampler,\n    _coords: number | v2f | v3f,\n    _offsetOrArrayIndex?: v2i | v3i | number,\n    _maybeOffset?: v2i | v3i,\n  ) => {\n    throw new Error('Texture sampling is not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (texture, sampler, coords, offsetOrArrayIndex, maybeOffset) => {\n    const args = [texture, sampler, coords];\n\n    if (offsetOrArrayIndex !== undefined) {\n      args.push(offsetOrArrayIndex);\n    }\n\n    if (maybeOffset !== undefined) {\n      args.push(maybeOffset);\n    }\n\n    return snip(`textureSample(${args.map((v) => v.value).join(', ')})`, vec4f);\n  },\n  'textureSample',\n);\n\ntype TextureSampleLevelOverload = {\n  <T extends TgpuSampledTexture<'2d'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    level: number,\n    offset?: v2i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'2d-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v2f,\n    arrayIndex: number,\n    level: number,\n    offset?: v2i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'3d' | 'cube'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n    level: number,\n    offset?: v3i,\n  ): v4f;\n  <T extends TgpuSampledTexture<'cube-array'>>(\n    texture: T,\n    sampler: TgpuSampler,\n    coords: v3f,\n    arrayIndex: number,\n    level: number,\n  ): v4f;\n};\n\nexport const textureSampleLevel: TextureSampleLevelOverload = createDualImpl(\n  // CPU implementation\n  (\n    _texture: TgpuSampledTexture,\n    _sampler: TgpuSampler,\n    _coords: number | v2f | v3f,\n    _level: number,\n    _offsetOrArrayIndex?: v2i | v3i | number,\n  ) => {\n    throw new Error('Texture sampling is not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (texture, sampler, coords, level, offsetOrArrayIndex) => {\n    const args = [texture, sampler, coords, level];\n\n    if (offsetOrArrayIndex !== undefined) {\n      args.push(offsetOrArrayIndex);\n    }\n\n    return snip(\n      `textureSampleLevel(${args.map((v) => v.value).join(', ')})`,\n      vec4f,\n    );\n  },\n  'textureSampleLevel',\n);\n\ntype TexelDataToInstance<TF extends TexelData> = {\n  vec4f: v4f;\n  vec4i: v4i;\n  vec4u: v4u;\n}[TF['type']];\n\ntype SampleTypeToInstance<TF extends ChannelData> = {\n  u32: v4u;\n  i32: v4i;\n  f32: v4f;\n}[TF['type']];\n\nconst channelDataToInstance = {\n  u32: vec4u,\n  i32: vec4i,\n  f32: vec4f,\n};\n\ntype TextureLoadOverload = {\n  <T extends TgpuStorageTexture<'1d'>>(\n    texture: T,\n    coords: number,\n  ): TexelDataToInstance<T['texelDataType']>;\n  <T extends TgpuStorageTexture<'2d'>>(\n    texture: T,\n    coords: v2i | v2u,\n  ): TexelDataToInstance<T['texelDataType']>;\n  <T extends TgpuStorageTexture<'2d-array'>>(\n    texture: T,\n    coords: v2i | v2u,\n    arrayIndex: number,\n  ): TexelDataToInstance<T['texelDataType']>;\n  <T extends TgpuStorageTexture<'3d'>>(\n    texture: T,\n    coords: v3i | v3u,\n  ): TexelDataToInstance<T['texelDataType']>;\n\n  <T extends TgpuSampledTexture<'1d'>>(\n    texture: T,\n    coords: number,\n    level: number,\n  ): SampleTypeToInstance<T['channelDataType']>;\n  <T extends TgpuSampledTexture<'2d'>>(\n    texture: T,\n    coords: v2i | v2u,\n    level: number,\n  ): SampleTypeToInstance<T['channelDataType']>;\n  <T extends TgpuSampledTexture<'2d-array'>>(\n    texture: T,\n    coords: v2i | v2u,\n    arrayIndex: number,\n    level: number,\n  ): SampleTypeToInstance<T['channelDataType']>;\n  <T extends TgpuSampledTexture<'3d'>>(\n    texture: T,\n    coords: v3i | v3u,\n    level: number,\n  ): SampleTypeToInstance<T['channelDataType']>;\n  // TODO: Support multisampled textures and depth textures\n};\n\nexport const textureLoad: TextureLoadOverload = createDualImpl(\n  // CPU implementation\n  (\n    _texture: TgpuStorageTexture | TgpuSampledTexture,\n    _coords: number | v2i | v2u | v3i | v3u,\n    _levelOrArrayIndex?: number,\n  ) => {\n    throw new Error('Texture loading is not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (texture, coords, levelOrArrayIndex) => {\n    const args = [texture, coords];\n\n    if (levelOrArrayIndex !== undefined) {\n      args.push(levelOrArrayIndex);\n    }\n\n    const textureInfo = texture.dataType as unknown as\n      | TgpuStorageTexture\n      | TgpuSampledTexture;\n\n    return snip(\n      `textureLoad(${args.map((v) => v.value).join(', ')})`,\n      'texelDataType' in textureInfo\n        ? textureInfo.texelDataType\n        : channelDataToInstance[textureInfo.channelDataType.type],\n    );\n  },\n  'textureLoad',\n);\n\ntype TextureStoreOverload = {\n  <T extends TgpuStorageTexture<'1d'>>(\n    texture: T,\n    coords: number,\n    value: TexelDataToInstance<T['texelDataType']>,\n  ): void;\n  <T extends TgpuStorageTexture<'2d'>>(\n    texture: T,\n    coords: v2i | v2u,\n    value: TexelDataToInstance<T['texelDataType']>,\n  ): void;\n  <T extends TgpuStorageTexture<'2d-array'>>(\n    texture: T,\n    coords: v2i | v2u,\n    arrayIndex: number,\n    value: TexelDataToInstance<T['texelDataType']>,\n  ): void;\n  <T extends TgpuStorageTexture<'3d'>>(\n    texture: T,\n    coords: v3i | v3u,\n    value: TexelDataToInstance<T['texelDataType']>,\n  ): void;\n};\n\nexport const textureStore: TextureStoreOverload = createDualImpl(\n  // CPU implementation\n  (\n    _texture: TgpuStorageTexture,\n    _coords: number | v2i | v2u | v3i | v3u,\n    _arrayIndexOrValue?: number | TexelData,\n    _maybeValue?: TexelData,\n  ) => {\n    throw new Error('Texture storing is not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (texture, coords, arrayIndexOrValue, maybeValue) =>\n    snip(\n      `textureStore(${\n        [texture, coords, arrayIndexOrValue, maybeValue].filter(\n          (arg) => arg !== undefined,\n        ).map((v) => v.value).join(', ')\n      })`,\n      Void,\n    ),\n  'textureStore',\n);\n\ntype TextureDimensionsOverload = {\n  <T extends TgpuSampledTexture<'1d'> | TgpuStorageTexture<'1d'>>(\n    texture: T,\n  ): number;\n  <T extends TgpuSampledTexture<'1d'>>(texture: T, level: number): number;\n\n  <\n    T extends\n      | TgpuSampledTexture<'2d'>\n      | TgpuSampledTexture<'2d-array'>\n      | TgpuSampledTexture<'cube'>\n      | TgpuSampledTexture<'cube-array'>\n      | TgpuStorageTexture<'2d'>\n      | TgpuStorageTexture<'2d-array'>,\n  >(\n    texture: T,\n  ): v2u;\n  <\n    T extends\n      | TgpuSampledTexture<'2d'>\n      | TgpuSampledTexture<'2d-array'>\n      | TgpuSampledTexture<'cube'>\n      | TgpuSampledTexture<'cube-array'>,\n  >(\n    texture: T,\n    level: number,\n  ): v2u;\n\n  <T extends TgpuSampledTexture<'3d'> | TgpuStorageTexture<'3d'>>(\n    texture: T,\n  ): v3u;\n  <T extends TgpuSampledTexture<'3d'>>(texture: T, level: number): v3u;\n};\n\nexport const textureDimensions: TextureDimensionsOverload = createDualImpl(\n  // CPU implementation\n  (_texture: TgpuSampledTexture | TgpuStorageTexture, _level?: number) => {\n    throw new Error(\n      'Texture dimensions are not supported outside of GPU mode.',\n    );\n  },\n  // GPU implementation\n  (texture, level) => {\n    const dim =\n      (texture.dataType as unknown as TgpuSampledTexture | TgpuStorageTexture)\n        .dimension;\n    return snip(\n      `textureDimensions(${texture.value}${\n        level !== undefined ? `, ${level.value}` : ''\n      })`,\n      dim === '1d' ? u32 : dim === '3d' ? vec3u : vec2u,\n    );\n  },\n  'textureDimensions',\n);\n"],"mappings":"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","names":["discard","createDualImpl","snip","Void","translate4","createDualImpl","matrix","vector","mul","mat4x4f","scale4","rotateX4","angle","rotateY4","rotateZ4","correspondingBooleanVectorSchema","value","vec2b","vec3b","vec4b","allEq","createDualImpl","lhs","rhs","all","eq","snip","bool","VectorOps","ne","not","lt","le","or","gt","and","ge","any","isCloseTo","precision","isVecInstance","sub","f32","isSnippetNumeric","select","f","cond","workgroupBarrier","createDualImpl","snip","Void","storageBarrier","textureBarrier","atomicLoad","a","isWgslData","atomicStore","value","atomicTypeFn","_value","i32","u32","atomicAdd","atomicSub","atomicMax","atomicMin","atomicAnd","atomicOr","atomicXor","arrayLength","createDualImpl","a","isPtr","isWgslArray","snip","abstractInt","u32","ptrFn","TB","unpack2x16float","createDualImpl","buffer","reader","vec2f","snip","pack2x16float","writer","u32","unpack4x8unorm","vec4f","pack4x8unorm","textureSample","createDualImpl","_texture","_sampler","_coords","_offsetOrArrayIndex","_maybeOffset","texture","sampler","coords","offsetOrArrayIndex","maybeOffset","args","snip","v","vec4f","textureSampleLevel","_level","level","channelDataToInstance","vec4u","vec4i","textureLoad","_levelOrArrayIndex","levelOrArrayIndex","textureInfo","textureStore","_arrayIndexOrValue","_maybeValue","arrayIndexOrValue","maybeValue","arg","Void","textureDimensions","dim","u32","vec3u","vec2u"]}