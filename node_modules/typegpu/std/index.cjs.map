{"version":3,"sources":["/Users/konradreczko/TypeGPU/wigsill/packages/typegpu/dist/std/index.cjs","../../src/std/discard.ts","../../src/std/matrix.ts","../../src/std/boolean.ts","../../src/std/atomic.ts"],"names":["discard","createDualImpl","snip","Void","translate4","matrix","vector","mul","mat4x4f","scale4","rotateX4","angle","rotateY4","rotateZ4","correspondingBooleanVectorSchema","value","vec2b","vec3b","vec4b","allEq","lhs","rhs","all","eq","bool","VectorOps","ne","not","lt","le","or","gt","and","ge","any","isCloseTo","precision","isVecInstance","sub","f32","isSnippetNumeric","select","f","cond","workgroupBarrier","storageBarrier","textureBarrier","atomicLoad","a","isWgslData"],"mappings":"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","file":"/Users/konradreczko/TypeGPU/wigsill/packages/typegpu/dist/std/index.cjs","sourcesContent":[null,"import { snip } from '../data/dataTypes.ts';\nimport { Void } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\n\nexport const discard = createDualImpl(\n  // CPU\n  (): never => {\n    throw new Error('discard() can only be used on the GPU.');\n  },\n  // GPU\n  () => snip('discard;', Void),\n  'discard',\n);\n","import type { Snippet } from '../data/dataTypes.ts';\nimport { mat4x4f } from '../data/matrix.ts';\nimport type { m4x4f, v3f } from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\nimport { mul } from './numeric.ts';\n\n/**\n * Translates the given 4-by-4 matrix by the given vector.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {v3f} vector - The vector by which to translate the matrix.\n * @returns {m4x4f} The translated matrix.\n */\nexport const translate4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, vector: v3f) => {\n    return mul(mat4x4f.translation(vector), matrix);\n  },\n  // GPU implementation\n  (matrix, vector) => ({\n    value: `(${\n      (mat4x4f.translation(vector as unknown as v3f) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'translate4',\n);\n\n/**\n * Scales the given 4-by-4 matrix in each dimension by an amount given by the corresponding entry in the given vector.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {v3f} vector - A vector of three entries specifying the factor by which to scale in each dimension.\n * @returns {m4x4f} The scaled matrix.\n */\nexport const scale4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, vector: v3f) => {\n    return mul(mat4x4f.scaling(vector), matrix);\n  },\n  // GPU implementation\n  (matrix, vector) => ({\n    value: `(${\n      (mat4x4f.scaling(vector as unknown as v3f) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'scale4',\n);\n\n/**\n * Rotates the given 4-by-4 matrix around the x-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateX4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, angle: number) => {\n    return mul(mat4x4f.rotationX(angle), matrix);\n  },\n  // GPU implementation\n  (matrix, angle) => ({\n    value: `(${\n      (mat4x4f.rotationX(angle as unknown as number) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'rotateX4',\n);\n\n/**\n * Rotates the given 4-by-4 matrix around the y-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateY4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, angle: number) => {\n    return mul(mat4x4f.rotationY(angle), matrix);\n  },\n  // GPU implementation\n  (matrix, angle) => ({\n    value: `(${\n      (mat4x4f.rotationY(angle as unknown as number) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'rotateY4',\n);\n\n/**\n * Rotates the given 4-by-4 matrix around the z-axis by the given angle.\n * @param {m4x4f} matrix - The matrix to be modified.\n * @param {number} angle - The angle by which to rotate (in radians).\n * @returns {m4x4f} The rotated matrix.\n */\nexport const rotateZ4 = createDualImpl(\n  // CPU implementation\n  (matrix: m4x4f, angle: number) => {\n    return mul(mat4x4f.rotationZ(angle), matrix);\n  },\n  // GPU implementation\n  (matrix, angle) => ({\n    value: `(${\n      (mat4x4f.rotationZ(angle as unknown as number) as unknown as Snippet)\n        .value\n    } * ${matrix.value})`,\n    dataType: matrix.dataType,\n  }),\n  'rotateZ4',\n);\n","import { snip, type Snippet } from '../data/dataTypes.ts';\nimport { bool, f32 } from '../data/numeric.ts';\nimport { vec2b, vec3b, vec4b } from '../data/vector.ts';\nimport { VectorOps } from '../data/vectorOps.ts';\nimport {\n  type AnyBooleanVecInstance,\n  type AnyFloatVecInstance,\n  type AnyNumericVecInstance,\n  type AnyVec2Instance,\n  type AnyVec3Instance,\n  type AnyVecInstance,\n  isVecInstance,\n  type v2b,\n  type v3b,\n  type v4b,\n} from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\nimport { isSnippetNumeric, sub } from './numeric.ts';\n\nfunction correspondingBooleanVectorSchema(value: Snippet) {\n  if (value.dataType.type.includes('2')) {\n    return vec2b;\n  }\n  if (value.dataType.type.includes('3')) {\n    return vec3b;\n  }\n  return vec4b;\n}\n\n// comparison\n\n/**\n * Checks whether `lhs == rhs` on all components.\n * Equivalent to `all(eq(lhs, rhs))`.\n * @example\n * allEq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns false\n * allEq(vec3u(0, 1, 2), vec3u(0, 1, 2)) // returns true\n */\nexport const allEq = createDualImpl(\n  // CPU implementation\n  <T extends AnyVecInstance>(lhs: T, rhs: T) => all(eq(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) => snip(`all(${lhs.value} == ${rhs.value})`, bool),\n  'allEq',\n);\n\n/**\n * Checks **component-wise** whether `lhs == rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`, or use `allEq`.\n * @example\n * eq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(true, false)\n * eq(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, false)\n * all(eq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1))) // returns true\n * allEq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1)) // returns true\n */\nexport const eq = createDualImpl(\n  // CPU implementation\n  <T extends AnyVecInstance>(lhs: T, rhs: T) =>\n    VectorOps.eq[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} == ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'eq',\n);\n\n/**\n * Checks **component-wise** whether `lhs != rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `any`.\n * @example\n * ne(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(false, true)\n * ne(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, true)\n * any(ne(vec4i(4, 3, 2, 1), vec4i(4, 2, 2, 1))) // returns true\n */\nexport const ne = createDualImpl(\n  // CPU implementation\n  <T extends AnyVecInstance>(lhs: T, rhs: T) => not(eq(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} != ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'ne',\n);\n\n/**\n * Checks **component-wise** whether `lhs < rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * lt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, true)\n * lt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, false)\n * all(lt(vec4i(1, 2, 3, 4), vec4i(2, 3, 4, 5))) // returns true\n */\nexport const lt = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    VectorOps.lt[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} < ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'lt',\n);\n\n/**\n * Checks **component-wise** whether `lhs <= rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * le(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, true)\n * le(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, true, false)\n * all(le(vec4i(1, 2, 3, 4), vec4i(2, 3, 3, 5))) // returns true\n */\nexport const le = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    or(lt(lhs, rhs), eq(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} <= ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'le',\n);\n\n/**\n * Checks **component-wise** whether `lhs > rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * gt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, false)\n * gt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, false, true)\n * all(gt(vec4i(2, 3, 4, 5), vec4i(1, 2, 3, 4))) // returns true\n */\nexport const gt = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) =>\n    and(not(lt(lhs, rhs)), not(eq(lhs, rhs))),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} > ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'gt',\n);\n\n/**\n * Checks **component-wise** whether `lhs >= rhs`.\n * This function does **not** return `bool`, for that use-case, wrap the result in `all`.\n * @example\n * ge(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, false)\n * ge(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, true)\n * all(ge(vec4i(2, 2, 4, 5), vec4i(1, 2, 3, 4))) // returns true\n */\nexport const ge = createDualImpl(\n  // CPU implementation\n  <T extends AnyNumericVecInstance>(lhs: T, rhs: T) => not(lt(lhs, rhs)),\n  // GPU implementation\n  (lhs, rhs) =>\n    snip(\n      `(${lhs.value} >= ${rhs.value})`,\n      correspondingBooleanVectorSchema(lhs),\n    ),\n  'ge',\n);\n\n// logical ops\n\n/**\n * Returns **component-wise** `!value`.\n * @example\n * not(vec2b(false, true)) // returns vec2b(true, false)\n * not(vec3b(true, true, false)) // returns vec3b(false, false, true)\n */\nexport const not = createDualImpl(\n  // CPU implementation\n  <T extends AnyBooleanVecInstance>(value: T): T =>\n    VectorOps.neg[value.kind](value),\n  // GPU implementation\n  (value) => snip(`!(${value.value})`, value.dataType),\n  'not',\n);\n\n/**\n * Returns **component-wise** logical `or` result.\n * @example\n * or(vec2b(false, true), vec2b(false, false)) // returns vec2b(false, true)\n * or(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(true, true, false)\n */\nexport const or = createDualImpl(\n  // CPU implementation\n  <T extends AnyBooleanVecInstance>(lhs: T, rhs: T) =>\n    VectorOps.or[lhs.kind](lhs, rhs),\n  // GPU implementation\n  (lhs, rhs) => snip(`(${lhs.value} | ${rhs.value})`, lhs.dataType),\n  'or',\n);\n\n/**\n * Returns **component-wise** logical `and` result.\n * @example\n * and(vec2b(false, true), vec2b(true, true)) // returns vec2b(false, true)\n * and(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(false, true, false)\n */\nexport const and = createDualImpl(\n  // CPU implementation\n  <T extends AnyBooleanVecInstance>(lhs: T, rhs: T) =>\n    not(or(not(lhs), not(rhs))),\n  // GPU implementation\n  (lhs, rhs) => snip(`(${lhs.value} & ${rhs.value})`, lhs.dataType),\n  'and',\n);\n\n// logical aggregation\n\n/**\n * Returns `true` if each component of `value` is true.\n * @example\n * all(vec2b(false, true)) // returns false\n * all(vec3b(true, true, true)) // returns true\n */\nexport const all = createDualImpl(\n  // CPU implementation\n  (value: AnyBooleanVecInstance) => VectorOps.all[value.kind](value),\n  // GPU implementation\n  (value) => snip(`all(${value.value})`, bool),\n  'all',\n);\n\n/**\n * Returns `true` if any component of `value` is true.\n * @example\n * any(vec2b(false, true)) // returns true\n * any(vec3b(false, false, false)) // returns false\n */\nexport const any = createDualImpl(\n  // CPU implementation\n  (value: AnyBooleanVecInstance) => !all(not(value)),\n  // GPU implementation\n  (value) => snip(`any(${value.value})`, bool),\n  'any',\n);\n\n// other\n\n/**\n * Checks whether the given elements differ by at most the `precision` value.\n * Checks all elements of `lhs` and `rhs` if arguments are vectors.\n * @example\n * isCloseTo(0, 0.1) // returns false\n * isCloseTo(vec3f(0, 0, 0), vec3f(0.002, -0.009, 0)) // returns true\n *\n * @param {number} precision argument that specifies the maximum allowed difference, 0.01 by default.\n */\nexport const isCloseTo = createDualImpl(\n  // CPU implementation\n  <T extends AnyFloatVecInstance | number>(\n    lhs: T,\n    rhs: T,\n    precision = 0.01,\n  ) => {\n    if (typeof lhs === 'number' && typeof rhs === 'number') {\n      return Math.abs(lhs - rhs) < precision;\n    }\n    if (isVecInstance(lhs) && isVecInstance(rhs)) {\n      return VectorOps.isCloseToZero[lhs.kind](\n        sub(lhs, rhs),\n        precision,\n      );\n    }\n    return false;\n  },\n  // GPU implementation\n  (lhs, rhs, precision = snip(0.01, f32)) => {\n    if (isSnippetNumeric(lhs) && isSnippetNumeric(rhs)) {\n      return snip(\n        `(abs(f32(${lhs.value}) - f32(${rhs.value})) <= ${precision.value})`,\n        bool,\n      );\n    }\n    if (!isSnippetNumeric(lhs) && !isSnippetNumeric(rhs)) {\n      return snip(\n        // https://www.w3.org/TR/WGSL/#vector-multi-component:~:text=Binary%20arithmetic%20expressions%20with%20mixed%20scalar%20and%20vector%20operands\n        // (a-a)+prec creates a vector of a.length elements, all equal to prec\n        `all(abs(${lhs.value} - ${rhs.value}) <= (${lhs.value} - ${lhs.value}) + ${precision.value})`,\n        bool,\n      );\n    }\n    return snip('false', bool);\n  },\n  'isCloseTo',\n);\n\nexport type SelectOverload = {\n  <T extends number | boolean | AnyVecInstance>(f: T, t: T, cond: boolean): T;\n  <T extends AnyVecInstance>(\n    f: T,\n    t: T,\n    cond: T extends AnyVec2Instance ? v2b\n      : T extends AnyVec3Instance ? v3b\n      : v4b,\n  ): T;\n};\n\n/**\n * Returns `t` if `cond` is `true`, and `f` otherwise.\n * Component-wise if `cond` is a vector.\n * @example\n * select(1, 2, false) // returns 1\n * select(1, 2, true) // returns 2\n * select(vec2i(1, 2), vec2i(3, 4), true) // returns vec2i(3, 4)\n * select(vec2i(1, 2), vec2i(3, 4), vec2b(false, true)) // returns vec2i(1, 4)\n */\nexport const select: SelectOverload = createDualImpl(\n  // CPU implementation\n  <T extends number | boolean | AnyVecInstance>(\n    f: T,\n    t: T,\n    cond: AnyBooleanVecInstance | boolean,\n  ) => {\n    if (typeof cond === 'boolean') {\n      return cond ? t : f;\n    }\n    return VectorOps.select[(f as AnyVecInstance).kind](\n      f as AnyVecInstance,\n      t as AnyVecInstance,\n      cond,\n    );\n  },\n  // GPU implementation\n  (f, t, cond) =>\n    snip(`select(${f.value}, ${t.value}, ${cond.value})`, f.dataType),\n  'select',\n);\n","import { snip, type Snippet } from '../data/dataTypes.ts';\nimport { i32, u32 } from '../data/numeric.ts';\nimport {\n  type AnyWgslData,\n  type atomicI32,\n  type atomicU32,\n  isWgslData,\n  Void,\n} from '../data/wgslTypes.ts';\nimport { createDualImpl } from '../shared/generators.ts';\ntype AnyAtomic = atomicI32 | atomicU32;\n\nexport const workgroupBarrier = createDualImpl(\n  // CPU implementation\n  () => console.warn('workgroupBarrier is a no-op outside of GPU mode.'),\n  // GPU implementation\n  () => snip('workgroupBarrier()', Void),\n  'workgroupBarrier',\n);\n\nexport const storageBarrier = createDualImpl(\n  // CPU implementation\n  () => console.warn('storageBarrier is a no-op outside of GPU mode.'),\n  // GPU implementation\n  () => snip('storageBarrier()', Void),\n  'storageBarrier',\n);\n\nexport const textureBarrier = createDualImpl(\n  // CPU implementation\n  () => console.warn('textureBarrier is a no-op outside of GPU mode.'),\n  // GPU implementation\n  () => snip('textureBarrier()', Void),\n  'textureBarrier',\n);\n\nexport const atomicLoad = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicLoad(&${a.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicLoad',\n);\n\nexport const atomicStore = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): void => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (!isWgslData(a.dataType) || a.dataType.type !== 'atomic') {\n      throw new Error(\n        `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n      );\n    }\n    return snip(`atomicStore(&${a.value}, ${value.value})`, Void);\n  },\n  'atomicStore',\n);\n\nconst atomicTypeFn = (a: Snippet, _value: Snippet): AnyWgslData[] => {\n  if (a.dataType.type === 'atomic' && a.dataType.inner.type === 'i32') {\n    return [a.dataType, i32];\n  }\n  return [a.dataType as AnyWgslData, u32];\n};\n\nexport const atomicAdd = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicAdd(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicAdd',\n  atomicTypeFn,\n);\n\nexport const atomicSub = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicSub(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicSub',\n  atomicTypeFn,\n);\n\nexport const atomicMax = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicMax(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicMax',\n  atomicTypeFn,\n);\n\nexport const atomicMin = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicMin(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicMin',\n  atomicTypeFn,\n);\n\nexport const atomicAnd = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicAnd(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicAnd',\n  atomicTypeFn,\n);\n\nexport const atomicOr = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicOr(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicOr',\n  atomicTypeFn,\n);\n\nexport const atomicXor = createDualImpl(\n  // CPU implementation\n  <T extends AnyAtomic>(a: T, value: number): number => {\n    throw new Error('Atomic operations are not supported outside of GPU mode.');\n  },\n  // GPU implementation\n  (a, value) => {\n    if (isWgslData(a.dataType) && a.dataType.type === 'atomic') {\n      return snip(`atomicXor(&${a.value}, ${value.value})`, a.dataType.inner);\n    }\n    throw new Error(\n      `Invalid atomic type: ${JSON.stringify(a.dataType, null, 2)}`,\n    );\n  },\n  'atomicXor',\n  atomicTypeFn,\n);\n"]}