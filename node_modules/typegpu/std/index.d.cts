import { c_ as TgpuDualFn, c$ as AnyNumericVecInstance, d0 as AnyMatInstance, d1 as vBaseForMat, d2 as mBaseForVec, d3 as AnyFloatVecInstance, bF as v3f, d4 as v3h, bB as v2f, d5 as v2h, bC as v2i, bG as v3i, bJ as v4f, d6 as v4h, bK as v4i, bv as m4x4f, bn as AnyVecInstance, d7 as AnyVec2Instance, bA as v2b, d8 as AnyVec3Instance, bE as v3b, bI as v4b, d9 as AnyBooleanVecInstance, da as atomicI32, db as atomicU32, ai as TgpuSampledTexture, dc as TgpuStorageTexture, bD as v2u, bH as v3u, dd as TexelData, bL as v4u, de as ChannelData, ar as TgpuSampler } from '../tgpuComputeFn-DOUjhQua.cjs';
export { i as identity2, d as identity3, e as identity4, r as rotationX4, f as rotationY4, g as rotationZ4, s as scaling4, t as translation4 } from '../matrix-BN6ObiMv.cjs';
import 'tinyest';

declare const discard: TgpuDualFn<() => never>;

type NumVec = AnyNumericVecInstance;
type Mat = AnyMatInstance;
declare function cpuAdd(lhs: number, rhs: number): number;
declare function cpuAdd<T extends NumVec>(lhs: number, rhs: T): T;
declare function cpuAdd<T extends NumVec>(lhs: T, rhs: number): T;
declare function cpuAdd<T extends NumVec | Mat>(lhs: T, rhs: T): T;
declare function cpuAdd<Lhs extends number | NumVec | Mat, Rhs extends (Lhs extends number ? number | NumVec : Lhs extends NumVec ? number | Lhs : Lhs extends Mat ? Lhs : never)>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;
declare const add: TgpuDualFn<typeof cpuAdd>;
declare function cpuSub(lhs: number, rhs: number): number;
declare function cpuSub<T extends NumVec>(lhs: number, rhs: T): T;
declare function cpuSub<T extends NumVec>(lhs: T, rhs: number): T;
declare function cpuSub<T extends NumVec | Mat>(lhs: T, rhs: T): T;
declare function cpuSub<Lhs extends number | NumVec | Mat, Rhs extends (Lhs extends number ? number | NumVec : Lhs extends NumVec ? number | Lhs : Lhs extends Mat ? Lhs : never)>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;
declare const sub: TgpuDualFn<typeof cpuSub>;
declare function cpuMul(lhs: number, rhs: number): number;
declare function cpuMul<MV extends NumVec | Mat>(lhs: number, rhs: MV): MV;
declare function cpuMul<MV extends NumVec | Mat>(lhs: MV, rhs: number): MV;
declare function cpuMul<V extends NumVec>(lhs: V, rhs: V): V;
declare function cpuMul<M extends Mat, V extends vBaseForMat<M>>(lhs: V, rhs: M): V;
declare function cpuMul<M extends Mat, V extends vBaseForMat<M>>(lhs: M, rhs: V): V;
declare function cpuMul<M extends Mat>(lhs: M, rhs: M): M;
declare function cpuMul<Lhs extends number | NumVec | Mat, Rhs extends (Lhs extends number ? number | NumVec | Mat : Lhs extends NumVec ? number | Lhs | mBaseForVec<Lhs> : Lhs extends Mat ? number | vBaseForMat<Lhs> | Lhs : never)>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;
declare const mul: TgpuDualFn<typeof cpuMul>;
declare function cpuDiv(lhs: number, rhs: number): number;
declare function cpuDiv<MV extends NumVec>(lhs: number, rhs: MV): MV;
declare function cpuDiv<MV extends NumVec>(lhs: MV, rhs: number): MV;
declare function cpuDiv<V extends NumVec>(lhs: V, rhs: V): V;
declare function cpuDiv<Lhs extends number | NumVec, Rhs extends (Lhs extends number ? number | NumVec : Lhs extends NumVec ? number | Lhs : never)>(lhs: Lhs, rhs: Rhs): Lhs | Rhs;
declare const div: TgpuDualFn<typeof cpuDiv>;
declare const abs: TgpuDualFn<(<T extends NumVec | number>(value: T) => T)>;
declare const atan2: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(y: T, x: T) => T)>;
declare const acos: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#acosh-builtin
 */
declare const acosh: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#asin-builtin
 */
declare const asin: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#ceil-builtin
 */
declare const ceil: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#clamp
 */
declare const clamp: TgpuDualFn<(<T extends NumVec | number>(value: T, low: T, high: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#cos-builtin
 */
declare const cos: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#cosh-builtin
 */
declare const cosh: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#cross-builtin
 */
declare const cross: TgpuDualFn<(<T extends v3f | v3h>(a: T, b: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#dot-builtin
 */
declare const dot: TgpuDualFn<(<T extends NumVec>(lhs: T, rhs: T) => number)>;
declare const normalize: TgpuDualFn<(<T extends AnyFloatVecInstance>(v: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#floor-builtin
 */
declare const floor: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
declare const fract: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(a: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#length-builtin
 */
declare const length: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => number)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#log-builtin
 */
declare const log: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#log2-builtin
 */
declare const log2: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#max-float-builtin
 */
declare const max: TgpuDualFn<(<T extends NumVec | number>(a: T, b: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#min-float-builtin
 */
declare const min: TgpuDualFn<(<T extends NumVec | number>(a: T, b: T) => T)>;
declare const sign: TgpuDualFn<(<T extends v2f | v2h | v2i | v3f | v3h | v3i | v4f | v4h | v4i | number>(e: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#sin-builtin
 */
declare const sin: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#exp-builtin
 */
declare const exp: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
/**
 * @privateRemarks
 * https://www.w3.org/TR/WGSL/#exp2-builtin
 */
declare const exp2: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
type PowOverload = {
    (base: number, exponent: number): number;
    <T extends AnyFloatVecInstance>(base: T, exponent: T): T;
};
declare const pow: PowOverload;
type MixOverload = {
    (e1: number, e2: number, e3: number): number;
    <T extends AnyFloatVecInstance>(e1: T, e2: T, e3: number): T;
    <T extends AnyFloatVecInstance>(e1: T, e2: T, e3: T): T;
};
declare const mix: MixOverload;
declare const reflect: TgpuDualFn<(<T extends AnyFloatVecInstance>(e1: T, e2: T) => T)>;
declare const distance: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(a: T, b: T) => number)>;
declare const neg: TgpuDualFn<(<T extends NumVec | number>(value: T) => T)>;
declare const sqrt: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;
declare const tanh: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(value: T) => T)>;

/**
 * Translates the given 4-by-4 matrix by the given vector.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {v3f} vector - The vector by which to translate the matrix.
 * @returns {m4x4f} The translated matrix.
 */
declare const translate4: TgpuDualFn<(matrix: m4x4f, vector: v3f) => m4x4f>;
/**
 * Scales the given 4-by-4 matrix in each dimension by an amount given by the corresponding entry in the given vector.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {v3f} vector - A vector of three entries specifying the factor by which to scale in each dimension.
 * @returns {m4x4f} The scaled matrix.
 */
declare const scale4: TgpuDualFn<(matrix: m4x4f, vector: v3f) => m4x4f>;
/**
 * Rotates the given 4-by-4 matrix around the x-axis by the given angle.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {number} angle - The angle by which to rotate (in radians).
 * @returns {m4x4f} The rotated matrix.
 */
declare const rotateX4: TgpuDualFn<(matrix: m4x4f, angle: number) => m4x4f>;
/**
 * Rotates the given 4-by-4 matrix around the y-axis by the given angle.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {number} angle - The angle by which to rotate (in radians).
 * @returns {m4x4f} The rotated matrix.
 */
declare const rotateY4: TgpuDualFn<(matrix: m4x4f, angle: number) => m4x4f>;
/**
 * Rotates the given 4-by-4 matrix around the z-axis by the given angle.
 * @param {m4x4f} matrix - The matrix to be modified.
 * @param {number} angle - The angle by which to rotate (in radians).
 * @returns {m4x4f} The rotated matrix.
 */
declare const rotateZ4: TgpuDualFn<(matrix: m4x4f, angle: number) => m4x4f>;

/**
 * Checks whether `lhs == rhs` on all components.
 * Equivalent to `all(eq(lhs, rhs))`.
 * @example
 * allEq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns false
 * allEq(vec3u(0, 1, 2), vec3u(0, 1, 2)) // returns true
 */
declare const allEq: TgpuDualFn<(<T extends AnyVecInstance>(lhs: T, rhs: T) => boolean)>;
/**
 * Checks **component-wise** whether `lhs == rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`, or use `allEq`.
 * @example
 * eq(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(true, false)
 * eq(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, false)
 * all(eq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1))) // returns true
 * allEq(vec4i(4, 3, 2, 1), vec4i(4, 3, 2, 1)) // returns true
 */
declare const eq: TgpuDualFn<(<T extends AnyVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs != rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `any`.
 * @example
 * ne(vec2f(0.0, 1.0), vec2f(0.0, 2.0)) // returns vec2b(false, true)
 * ne(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, true)
 * any(ne(vec4i(4, 3, 2, 1), vec4i(4, 2, 2, 1))) // returns true
 */
declare const ne: TgpuDualFn<(<T extends AnyVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs < rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`.
 * @example
 * lt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, true)
 * lt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, false, false)
 * all(lt(vec4i(1, 2, 3, 4), vec4i(2, 3, 4, 5))) // returns true
 */
declare const lt: TgpuDualFn<(<T extends AnyNumericVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs <= rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`.
 * @example
 * le(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, true)
 * le(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(true, true, false)
 * all(le(vec4i(1, 2, 3, 4), vec4i(2, 3, 3, 5))) // returns true
 */
declare const le: TgpuDualFn<(<T extends AnyNumericVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs > rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`.
 * @example
 * gt(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(false, false)
 * gt(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, false, true)
 * all(gt(vec4i(2, 3, 4, 5), vec4i(1, 2, 3, 4))) // returns true
 */
declare const gt: TgpuDualFn<(<T extends AnyNumericVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Checks **component-wise** whether `lhs >= rhs`.
 * This function does **not** return `bool`, for that use-case, wrap the result in `all`.
 * @example
 * ge(vec2f(0.0, 0.0), vec2f(0.0, 1.0)) // returns vec2b(true, false)
 * ge(vec3u(0, 1, 2), vec3u(2, 1, 0)) // returns vec3b(false, true, true)
 * all(ge(vec4i(2, 2, 4, 5), vec4i(1, 2, 3, 4))) // returns true
 */
declare const ge: TgpuDualFn<(<T extends AnyNumericVecInstance>(lhs: T, rhs: T) => T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b)>;
/**
 * Returns **component-wise** `!value`.
 * @example
 * not(vec2b(false, true)) // returns vec2b(true, false)
 * not(vec3b(true, true, false)) // returns vec3b(false, false, true)
 */
declare const not: TgpuDualFn<(<T extends AnyBooleanVecInstance>(value: T) => T)>;
/**
 * Returns **component-wise** logical `or` result.
 * @example
 * or(vec2b(false, true), vec2b(false, false)) // returns vec2b(false, true)
 * or(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(true, true, false)
 */
declare const or: TgpuDualFn<(<T extends AnyBooleanVecInstance>(lhs: T, rhs: T) => T)>;
/**
 * Returns **component-wise** logical `and` result.
 * @example
 * and(vec2b(false, true), vec2b(true, true)) // returns vec2b(false, true)
 * and(vec3b(true, true, false), vec3b(false, true, false)) // returns vec3b(false, true, false)
 */
declare const and: TgpuDualFn<(<T extends AnyBooleanVecInstance>(lhs: T, rhs: T) => T)>;
/**
 * Returns `true` if each component of `value` is true.
 * @example
 * all(vec2b(false, true)) // returns false
 * all(vec3b(true, true, true)) // returns true
 */
declare const all: TgpuDualFn<(value: AnyBooleanVecInstance) => boolean>;
/**
 * Returns `true` if any component of `value` is true.
 * @example
 * any(vec2b(false, true)) // returns true
 * any(vec3b(false, false, false)) // returns false
 */
declare const any: TgpuDualFn<(value: AnyBooleanVecInstance) => boolean>;
/**
 * Checks whether the given elements differ by at most the `precision` value.
 * Checks all elements of `lhs` and `rhs` if arguments are vectors.
 * @example
 * isCloseTo(0, 0.1) // returns false
 * isCloseTo(vec3f(0, 0, 0), vec3f(0.002, -0.009, 0)) // returns true
 *
 * @param {number} precision argument that specifies the maximum allowed difference, 0.01 by default.
 */
declare const isCloseTo: TgpuDualFn<(<T extends AnyFloatVecInstance | number>(lhs: T, rhs: T, precision?: number) => boolean)>;
type SelectOverload = {
    <T extends number | boolean | AnyVecInstance>(f: T, t: T, cond: boolean): T;
    <T extends AnyVecInstance>(f: T, t: T, cond: T extends AnyVec2Instance ? v2b : T extends AnyVec3Instance ? v3b : v4b): T;
};
/**
 * Returns `t` if `cond` is `true`, and `f` otherwise.
 * Component-wise if `cond` is a vector.
 * @example
 * select(1, 2, false) // returns 1
 * select(1, 2, true) // returns 2
 * select(vec2i(1, 2), vec2i(3, 4), true) // returns vec2i(3, 4)
 * select(vec2i(1, 2), vec2i(3, 4), vec2b(false, true)) // returns vec2i(1, 4)
 */
declare const select: SelectOverload;

type AnyAtomic = atomicI32 | atomicU32;
declare const workgroupBarrier: TgpuDualFn<() => void>;
declare const storageBarrier: TgpuDualFn<() => void>;
declare const textureBarrier: TgpuDualFn<() => void>;
declare const atomicLoad: TgpuDualFn<(<T extends AnyAtomic>(a: T) => number)>;
declare const atomicStore: TgpuDualFn<(<T extends AnyAtomic>(a: T, value: number) => void)>;
declare const atomicAdd: TgpuDualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicSub: TgpuDualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicMax: TgpuDualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicMin: TgpuDualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicAnd: TgpuDualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicOr: TgpuDualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;
declare const atomicXor: TgpuDualFn<(<T extends AnyAtomic>(a: T, value: number) => number)>;

declare const arrayLength: TgpuDualFn<(a: unknown[]) => number>;

/**
 * @privateRemarks
 * https://gpuweb.github.io/gpuweb/wgsl/#unpack2x16float-builtin
 */
declare const unpack2x16float: TgpuDualFn<(e: number) => v2f>;
/**
 * @privateRemarks
 * https://gpuweb.github.io/gpuweb/wgsl/#pack2x16float-builtin
 */
declare const pack2x16float: TgpuDualFn<(e: v2f) => number>;
/**
 * @privateRemarks
 * https://gpuweb.github.io/gpuweb/wgsl/#unpack4x8unorm-builtin
 */
declare const unpack4x8unorm: TgpuDualFn<(e: number) => v4f>;
/**
 * @privateRemarks
 * https://gpuweb.github.io/gpuweb/wgsl/#pack4x8unorm-builtin
 */
declare const pack4x8unorm: TgpuDualFn<(e: v4f) => number>;

type TextureSampleOverload = {
    <T extends TgpuSampledTexture<'1d'>>(texture: T, sampler: TgpuSampler, coords: number): v4f;
    <T extends TgpuSampledTexture<'2d'>>(texture: T, sampler: TgpuSampler, coords: v2f): v4f;
    <T extends TgpuSampledTexture<'2d'>>(texture: T, sampler: TgpuSampler, coords: v2f, offset: v2i): v4f;
    <T extends TgpuSampledTexture<'2d-array'>>(texture: T, sampler: TgpuSampler, coords: v2f, arrayIndex: number): v4f;
    <T extends TgpuSampledTexture<'2d-array'>>(texture: T, sampler: TgpuSampler, coords: v2f, arrayIndex: number, offset: v2i): v4f;
    <T extends TgpuSampledTexture<'3d' | 'cube'>>(texture: T, sampler: TgpuSampler, coords: v3f): v4f;
    <T extends TgpuSampledTexture<'3d'>>(texture: T, sampler: TgpuSampler, coords: v3f, offset: v3i): v4f;
    <T extends TgpuSampledTexture<'cube-array'>>(texture: T, sampler: TgpuSampler, coords: v3f, arrayIndex: number): v4f;
};
declare const textureSample: TextureSampleOverload;
type TextureSampleLevelOverload = {
    <T extends TgpuSampledTexture<'2d'>>(texture: T, sampler: TgpuSampler, coords: v2f, level: number, offset?: v2i): v4f;
    <T extends TgpuSampledTexture<'2d-array'>>(texture: T, sampler: TgpuSampler, coords: v2f, arrayIndex: number, level: number, offset?: v2i): v4f;
    <T extends TgpuSampledTexture<'3d' | 'cube'>>(texture: T, sampler: TgpuSampler, coords: v3f, level: number, offset?: v3i): v4f;
    <T extends TgpuSampledTexture<'cube-array'>>(texture: T, sampler: TgpuSampler, coords: v3f, arrayIndex: number, level: number): v4f;
};
declare const textureSampleLevel: TextureSampleLevelOverload;
type TexelDataToInstance<TF extends TexelData> = {
    vec4f: v4f;
    vec4i: v4i;
    vec4u: v4u;
}[TF['type']];
type SampleTypeToInstance<TF extends ChannelData> = {
    u32: v4u;
    i32: v4i;
    f32: v4f;
}[TF['type']];
type TextureLoadOverload = {
    <T extends TgpuStorageTexture<'1d'>>(texture: T, coords: number): TexelDataToInstance<T['texelDataType']>;
    <T extends TgpuStorageTexture<'2d'>>(texture: T, coords: v2i | v2u): TexelDataToInstance<T['texelDataType']>;
    <T extends TgpuStorageTexture<'2d-array'>>(texture: T, coords: v2i | v2u, arrayIndex: number): TexelDataToInstance<T['texelDataType']>;
    <T extends TgpuStorageTexture<'3d'>>(texture: T, coords: v3i | v3u): TexelDataToInstance<T['texelDataType']>;
    <T extends TgpuSampledTexture<'1d'>>(texture: T, coords: number, level: number): SampleTypeToInstance<T['channelDataType']>;
    <T extends TgpuSampledTexture<'2d'>>(texture: T, coords: v2i | v2u, level: number): SampleTypeToInstance<T['channelDataType']>;
    <T extends TgpuSampledTexture<'2d-array'>>(texture: T, coords: v2i | v2u, arrayIndex: number, level: number): SampleTypeToInstance<T['channelDataType']>;
    <T extends TgpuSampledTexture<'3d'>>(texture: T, coords: v3i | v3u, level: number): SampleTypeToInstance<T['channelDataType']>;
};
declare const textureLoad: TextureLoadOverload;
type TextureStoreOverload = {
    <T extends TgpuStorageTexture<'1d'>>(texture: T, coords: number, value: TexelDataToInstance<T['texelDataType']>): void;
    <T extends TgpuStorageTexture<'2d'>>(texture: T, coords: v2i | v2u, value: TexelDataToInstance<T['texelDataType']>): void;
    <T extends TgpuStorageTexture<'2d-array'>>(texture: T, coords: v2i | v2u, arrayIndex: number, value: TexelDataToInstance<T['texelDataType']>): void;
    <T extends TgpuStorageTexture<'3d'>>(texture: T, coords: v3i | v3u, value: TexelDataToInstance<T['texelDataType']>): void;
};
declare const textureStore: TextureStoreOverload;
type TextureDimensionsOverload = {
    <T extends TgpuSampledTexture<'1d'> | TgpuStorageTexture<'1d'>>(texture: T): number;
    <T extends TgpuSampledTexture<'1d'>>(texture: T, level: number): number;
    <T extends TgpuSampledTexture<'2d'> | TgpuSampledTexture<'2d-array'> | TgpuSampledTexture<'cube'> | TgpuSampledTexture<'cube-array'> | TgpuStorageTexture<'2d'> | TgpuStorageTexture<'2d-array'>>(texture: T): v2u;
    <T extends TgpuSampledTexture<'2d'> | TgpuSampledTexture<'2d-array'> | TgpuSampledTexture<'cube'> | TgpuSampledTexture<'cube-array'>>(texture: T, level: number): v2u;
    <T extends TgpuSampledTexture<'3d'> | TgpuStorageTexture<'3d'>>(texture: T): v3u;
    <T extends TgpuSampledTexture<'3d'>>(texture: T, level: number): v3u;
};
declare const textureDimensions: TextureDimensionsOverload;

export { abs, acos, acosh, add, all, allEq, and, any, arrayLength, asin, atan2, atomicAdd, atomicAnd, atomicLoad, atomicMax, atomicMin, atomicOr, atomicStore, atomicSub, atomicXor, ceil, clamp, cos, cosh, cross, discard, distance, div, dot, eq, exp, exp2, floor, fract, ge, gt, isCloseTo, le, length, log, log2, lt, max, min, mix, mul, ne, neg, normalize, not, or, pack2x16float, pack4x8unorm, pow, reflect, rotateX4, rotateY4, rotateZ4, scale4, select, sign, sin, sqrt, storageBarrier, sub, tanh, textureBarrier, textureDimensions, textureLoad, textureSample, textureSampleLevel, textureStore, translate4, unpack2x16float, unpack4x8unorm, workgroupBarrier };
