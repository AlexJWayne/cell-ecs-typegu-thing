{"version":3,"sources":["../src/data/utils.ts","../src/data/struct.ts","../src/mathUtils.ts","../src/data/vertexFormatData.ts","../src/data/alignmentOf.ts","../src/data/sizeOf.ts","../src/data/array.ts","../src/data/disarray.ts","../src/data/unstruct.ts","../src/data/atomic.ts","../src/data/attributes.ts","../src/builtin.ts"],"sourcesContent":["/**\n * A wrapper for `schema(item)` call.\n * Logs a warning if the schema is not callable.\n */\nexport function schemaCallWrapper<T>(schema: unknown, item: T): T {\n  let result = item;\n  try {\n    result = (\n      schema as unknown as ((item: typeof result) => typeof result)\n    )(item);\n  } catch {\n    const maybeType = (schema as { type: string })?.type;\n    console.warn(`Schema of type ${maybeType ?? '<unknown>'} is not callable.`);\n  }\n  return result;\n}\n","import { getName, setName } from '../shared/meta.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { schemaCallWrapper } from './utils.ts';\nimport type { AnyWgslData, WgslStruct } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates a struct schema that can be used to construct GPU buffers.\n * Ensures proper alignment and padding of properties (as opposed to a `d.unstruct` schema).\n * The order of members matches the passed in properties object.\n *\n * @example\n * const CircleStruct = d.struct({ radius: d.f32, pos: d.vec3f });\n *\n * @param props Record with `string` keys and `TgpuData` values,\n * each entry describing one struct member.\n */\nexport function struct<TProps extends Record<string, AnyWgslData>>(\n  props: TProps,\n): WgslStruct<TProps> {\n  // in the schema call, create and return a deep copy\n  // by wrapping all the values in corresponding schema calls\n  const structSchema = <T extends TProps>(instanceProps: T) =>\n    Object.fromEntries(\n      Object.entries(props).map((\n        [key, schema],\n      ) => [key, schemaCallWrapper(schema, instanceProps[key])]),\n    );\n  Object.setPrototypeOf(structSchema, WgslStructImpl);\n  structSchema.propTypes = props;\n\n  return structSchema as WgslStruct<TProps>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst WgslStructImpl = {\n  [$internal]: true,\n  type: 'struct',\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  },\n\n  toString(): string {\n    return `struct:${getName(this) ?? '<unnamed>'}`;\n  },\n};\n","/**\n * @param value\n * @param modulo has to be power of 2\n */\nexport const roundUp = (value: number, modulo: number) => {\n  const bitMask = modulo - 1;\n  const invBitMask = ~bitMask;\n  return (value & bitMask) === 0 ? value : (value & invBitMask) + modulo;\n};\n","import type { Infer } from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { $repr } from '../shared/symbols.ts';\nimport type { VertexFormat } from '../shared/vertexFormat.ts';\nimport { f32, i32, u32 } from './numeric.ts';\nimport {\n  vec2f,\n  vec2i,\n  vec2u,\n  vec3f,\n  vec3i,\n  vec3u,\n  vec4f,\n  vec4i,\n  vec4u,\n} from './vector.ts';\n\nexport type FormatToWGSLType<T extends VertexFormat> =\n  (typeof formatToWGSLType)[T];\n\nexport interface TgpuVertexFormatData<T extends VertexFormat> {\n  readonly [$internal]: true;\n  readonly type: T;\n  readonly [$repr]: Infer<FormatToWGSLType<T>>;\n}\n\nclass TgpuVertexFormatDataImpl<T extends VertexFormat>\n  implements TgpuVertexFormatData<T> {\n  public readonly [$internal] = true;\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<FormatToWGSLType<T>>;\n  // ---\n\n  constructor(public readonly type: T) {}\n}\n\nexport const formatToWGSLType = {\n  uint8: u32,\n  uint8x2: vec2u,\n  uint8x4: vec4u,\n  sint8: i32,\n  sint8x2: vec2i,\n  sint8x4: vec4i,\n  unorm8: f32,\n  unorm8x2: vec2f,\n  unorm8x4: vec4f,\n  snorm8: f32,\n  snorm8x2: vec2f,\n  snorm8x4: vec4f,\n  uint16: u32,\n  uint16x2: vec2u,\n  uint16x4: vec4u,\n  sint16: i32,\n  sint16x2: vec2i,\n  sint16x4: vec4i,\n  unorm16: f32,\n  unorm16x2: vec2f,\n  unorm16x4: vec4f,\n  snorm16: f32,\n  snorm16x2: vec2f,\n  snorm16x4: vec4f,\n  float16: f32,\n  float16x2: vec2f,\n  float16x4: vec4f,\n  float32: f32,\n  float32x2: vec2f,\n  float32x3: vec3f,\n  float32x4: vec4f,\n  uint32: u32,\n  uint32x2: vec2u,\n  uint32x3: vec3u,\n  uint32x4: vec4u,\n  sint32: i32,\n  sint32x2: vec2i,\n  sint32x3: vec3i,\n  sint32x4: vec4i,\n  'unorm10-10-10-2': vec4f,\n  'unorm8x4-bgra': vec4f,\n} as const;\n\nexport const packedFormats = Object.keys(formatToWGSLType);\n\nexport type uint8 = TgpuVertexFormatData<'uint8'>;\nexport const uint8 = new TgpuVertexFormatDataImpl('uint8') as uint8;\n\nexport type uint8x2 = TgpuVertexFormatData<'uint8x2'>;\nexport const uint8x2 = new TgpuVertexFormatDataImpl('uint8x2') as uint8x2;\n\nexport type uint8x4 = TgpuVertexFormatData<'uint8x4'>;\nexport const uint8x4 = new TgpuVertexFormatDataImpl('uint8x4') as uint8x4;\n\nexport type sint8 = TgpuVertexFormatData<'sint8'>;\nexport const sint8 = new TgpuVertexFormatDataImpl('sint8') as sint8;\n\nexport type sint8x2 = TgpuVertexFormatData<'sint8x2'>;\nexport const sint8x2 = new TgpuVertexFormatDataImpl('sint8x2') as sint8x2;\n\nexport type sint8x4 = TgpuVertexFormatData<'sint8x4'>;\nexport const sint8x4 = new TgpuVertexFormatDataImpl('sint8x4') as sint8x4;\n\nexport type unorm8 = TgpuVertexFormatData<'unorm8'>;\nexport const unorm8 = new TgpuVertexFormatDataImpl('unorm8') as unorm8;\n\nexport type unorm8x2 = TgpuVertexFormatData<'unorm8x2'>;\nexport const unorm8x2 = new TgpuVertexFormatDataImpl('unorm8x2') as unorm8x2;\n\nexport type unorm8x4 = TgpuVertexFormatData<'unorm8x4'>;\nexport const unorm8x4 = new TgpuVertexFormatDataImpl('unorm8x4') as unorm8x4;\n\nexport type snorm8 = TgpuVertexFormatData<'snorm8'>;\nexport const snorm8 = new TgpuVertexFormatDataImpl('snorm8') as snorm8;\n\nexport type snorm8x2 = TgpuVertexFormatData<'snorm8x2'>;\nexport const snorm8x2 = new TgpuVertexFormatDataImpl('snorm8x2') as snorm8x2;\n\nexport type snorm8x4 = TgpuVertexFormatData<'snorm8x4'>;\nexport const snorm8x4 = new TgpuVertexFormatDataImpl('snorm8x4') as snorm8x4;\n\nexport type uint16 = TgpuVertexFormatData<'uint16'>;\nexport const uint16 = new TgpuVertexFormatDataImpl('uint16') as uint16;\n\nexport type uint16x2 = TgpuVertexFormatData<'uint16x2'>;\nexport const uint16x2 = new TgpuVertexFormatDataImpl('uint16x2') as uint16x2;\n\nexport type uint16x4 = TgpuVertexFormatData<'uint16x4'>;\nexport const uint16x4 = new TgpuVertexFormatDataImpl('uint16x4') as uint16x4;\n\nexport type sint16 = TgpuVertexFormatData<'sint16'>;\nexport const sint16 = new TgpuVertexFormatDataImpl('sint16') as sint16;\n\nexport type sint16x2 = TgpuVertexFormatData<'sint16x2'>;\nexport const sint16x2 = new TgpuVertexFormatDataImpl('sint16x2') as sint16x2;\n\nexport type sint16x4 = TgpuVertexFormatData<'sint16x4'>;\nexport const sint16x4 = new TgpuVertexFormatDataImpl('sint16x4') as sint16x4;\n\nexport type unorm16 = TgpuVertexFormatData<'unorm16'>;\nexport const unorm16 = new TgpuVertexFormatDataImpl('unorm16') as unorm16;\n\nexport type unorm16x2 = TgpuVertexFormatData<'unorm16x2'>;\nexport const unorm16x2 = new TgpuVertexFormatDataImpl('unorm16x2') as unorm16x2;\n\nexport type unorm16x4 = TgpuVertexFormatData<'unorm16x4'>;\nexport const unorm16x4 = new TgpuVertexFormatDataImpl('unorm16x4') as unorm16x4;\n\nexport type snorm16 = TgpuVertexFormatData<'snorm16'>;\nexport const snorm16 = new TgpuVertexFormatDataImpl('snorm16') as snorm16;\n\nexport type snorm16x2 = TgpuVertexFormatData<'snorm16x2'>;\nexport const snorm16x2 = new TgpuVertexFormatDataImpl('snorm16x2') as snorm16x2;\n\nexport type snorm16x4 = TgpuVertexFormatData<'snorm16x4'>;\nexport const snorm16x4 = new TgpuVertexFormatDataImpl('snorm16x4') as snorm16x4;\n\nexport type float16 = TgpuVertexFormatData<'float16'>;\nexport const float16 = new TgpuVertexFormatDataImpl('float16') as float16;\n\nexport type float16x2 = TgpuVertexFormatData<'float16x2'>;\nexport const float16x2 = new TgpuVertexFormatDataImpl('float16x2') as float16x2;\n\nexport type float16x4 = TgpuVertexFormatData<'float16x4'>;\nexport const float16x4 = new TgpuVertexFormatDataImpl('float16x4') as float16x4;\n\nexport type float32 = TgpuVertexFormatData<'float32'>;\nexport const float32 = new TgpuVertexFormatDataImpl('float32') as float32;\n\nexport type float32x2 = TgpuVertexFormatData<'float32x2'>;\nexport const float32x2 = new TgpuVertexFormatDataImpl('float32x2') as float32x2;\n\nexport type float32x3 = TgpuVertexFormatData<'float32x3'>;\nexport const float32x3 = new TgpuVertexFormatDataImpl('float32x3') as float32x3;\n\nexport type float32x4 = TgpuVertexFormatData<'float32x4'>;\nexport const float32x4 = new TgpuVertexFormatDataImpl('float32x4') as float32x4;\n\nexport type uint32 = TgpuVertexFormatData<'uint32'>;\nexport const uint32 = new TgpuVertexFormatDataImpl('uint32') as uint32;\n\nexport type uint32x2 = TgpuVertexFormatData<'uint32x2'>;\nexport const uint32x2 = new TgpuVertexFormatDataImpl('uint32x2') as uint32x2;\n\nexport type uint32x3 = TgpuVertexFormatData<'uint32x3'>;\nexport const uint32x3 = new TgpuVertexFormatDataImpl('uint32x3') as uint32x3;\n\nexport type uint32x4 = TgpuVertexFormatData<'uint32x4'>;\nexport const uint32x4 = new TgpuVertexFormatDataImpl('uint32x4') as uint32x4;\n\nexport type sint32 = TgpuVertexFormatData<'sint32'>;\nexport const sint32 = new TgpuVertexFormatDataImpl('sint32') as sint32;\n\nexport type sint32x2 = TgpuVertexFormatData<'sint32x2'>;\nexport const sint32x2 = new TgpuVertexFormatDataImpl('sint32x2') as sint32x2;\n\nexport type sint32x3 = TgpuVertexFormatData<'sint32x3'>;\nexport const sint32x3 = new TgpuVertexFormatDataImpl('sint32x3') as sint32x3;\n\nexport type sint32x4 = TgpuVertexFormatData<'sint32x4'>;\nexport const sint32x4 = new TgpuVertexFormatDataImpl('sint32x4') as sint32x4;\n\nexport type unorm10_10_10_2 = TgpuVertexFormatData<'unorm10-10-10-2'>;\nexport const unorm10_10_10_2 = new TgpuVertexFormatDataImpl(\n  'unorm10-10-10-2',\n) as unorm10_10_10_2;\n\nexport type unorm8x4_bgra = TgpuVertexFormatData<'unorm8x4-bgra'>;\nexport const unorm8x4_bgra = new TgpuVertexFormatDataImpl(\n  'unorm8x4-bgra',\n) as unorm8x4_bgra;\n\nexport type PackedData =\n  | uint8\n  | uint8x2\n  | uint8x4\n  | sint8\n  | sint8x2\n  | sint8x4\n  | unorm8\n  | unorm8x2\n  | unorm8x4\n  | snorm8\n  | snorm8x2\n  | snorm8x4\n  | uint16\n  | uint16x2\n  | uint16x4\n  | sint16\n  | sint16x2\n  | sint16x4\n  | unorm16\n  | unorm16x2\n  | unorm16x4\n  | snorm16\n  | snorm16x2\n  | snorm16x4\n  | float16\n  | float16x2\n  | float16x4\n  | float32\n  | float32x2\n  | float32x3\n  | float32x4\n  | uint32\n  | uint32x2\n  | uint32x3\n  | uint32x4\n  | sint32\n  | sint32x2\n  | sint32x3\n  | sint32x4\n  | unorm10_10_10_2\n  | unorm8x4_bgra;\n","import {\n  type AnyData,\n  getCustomAlignment,\n  isDisarray,\n  isLooseDecorated,\n  isUnstruct,\n} from './dataTypes.ts';\nimport { packedFormats } from './vertexFormatData.ts';\nimport {\n  type BaseData,\n  isDecorated,\n  isWgslArray,\n  isWgslStruct,\n} from './wgslTypes.ts';\n\nconst knownAlignmentMap: Record<string, number> = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4,\n  u16: 2,\n  vec2f: 8,\n  vec2h: 4,\n  vec2i: 8,\n  vec2u: 8,\n  vec3f: 16,\n  vec3h: 8,\n  vec3i: 16,\n  vec3u: 16,\n  vec4f: 16,\n  vec4h: 8,\n  vec4i: 16,\n  vec4u: 16,\n  mat2x2f: 8,\n  mat3x3f: 16,\n  mat4x4f: 16,\n  atomic: 4,\n};\n\nfunction computeAlignment(data: object): number {\n  const dataType = (data as BaseData)?.type;\n  const knownAlignment = knownAlignmentMap[dataType];\n  if (knownAlignment !== undefined) {\n    return knownAlignment;\n  }\n\n  if (isWgslStruct(data)) {\n    return Object.values(data.propTypes)\n      .map(alignmentOf)\n      .reduce((a, b) => (a > b ? a : b));\n  }\n\n  if (isWgslArray(data)) {\n    return alignmentOf(data.elementType);\n  }\n\n  if (isUnstruct(data)) {\n    // A loose struct is aligned to its first property.\n    const firstProp = Object.values(data.propTypes)[0];\n    return firstProp ? (getCustomAlignment(firstProp) ?? 1) : 1;\n  }\n\n  if (isDisarray(data)) {\n    return getCustomAlignment(data.elementType) ?? 1;\n  }\n\n  if (isDecorated(data) || isLooseDecorated(data)) {\n    return getCustomAlignment(data) ?? alignmentOf(data.inner);\n  }\n\n  if (packedFormats.includes(dataType)) {\n    return 1;\n  }\n\n  throw new Error(\n    `Cannot determine alignment of data: ${JSON.stringify(data)}`,\n  );\n}\n\nfunction computeCustomAlignment(data: BaseData): number {\n  if (isUnstruct(data)) {\n    // A loose struct is aligned to its first property.\n    const firstProp = Object.values(data.propTypes)[0];\n    return firstProp ? customAlignmentOf(firstProp) : 1;\n  }\n\n  if (isDisarray(data)) {\n    return customAlignmentOf(data.elementType);\n  }\n\n  if (isLooseDecorated(data)) {\n    return getCustomAlignment(data) ?? customAlignmentOf(data.inner);\n  }\n\n  return getCustomAlignment(data) ?? 1;\n}\n\n/**\n * Since alignments can be inferred from data types, they are not stored on them.\n * Instead, this weak map acts as an extended property of those data types.\n */\nconst cachedAlignments = new WeakMap<object, number>();\n\nconst cachedCustomAlignments = new WeakMap<object, number>();\n\nexport function alignmentOf(data: BaseData): number {\n  let alignment = cachedAlignments.get(data);\n  if (alignment === undefined) {\n    alignment = computeAlignment(data);\n    cachedAlignments.set(data, alignment);\n  }\n\n  return alignment;\n}\n\nexport function customAlignmentOf(data: BaseData): number {\n  let alignment = cachedCustomAlignments.get(data);\n  if (alignment === undefined) {\n    alignment = computeCustomAlignment(data);\n    cachedCustomAlignments.set(data, alignment);\n  }\n\n  return alignment;\n}\n\n/**\n * Returns the alignment (in bytes) of data represented by the `schema`.\n */\nexport function PUBLIC_alignmentOf(schema: AnyData): number {\n  return alignmentOf(schema);\n}\n","import { roundUp } from '../mathUtils.ts';\nimport { alignmentOf, customAlignmentOf } from './alignmentOf.ts';\nimport type { AnyData, LooseTypeLiteral, Unstruct } from './dataTypes.ts';\nimport {\n  getCustomSize,\n  isDisarray,\n  isLooseDecorated,\n  isUnstruct,\n} from './dataTypes.ts';\nimport type { BaseData, WgslStruct, WgslTypeLiteral } from './wgslTypes.ts';\nimport { isDecorated, isWgslArray, isWgslStruct } from './wgslTypes.ts';\n\nconst knownSizesMap: Record<string, number> = {\n  f32: 4,\n  f16: 2,\n  i32: 4,\n  u32: 4,\n  u16: 2,\n  vec2f: 8,\n  vec2h: 4,\n  vec2i: 8,\n  vec2u: 8,\n  vec3f: 12,\n  vec3h: 6,\n  vec3i: 12,\n  vec3u: 12,\n  vec4f: 16,\n  vec4h: 8,\n  vec4i: 16,\n  vec4u: 16,\n  mat2x2f: 16,\n  mat3x3f: 48,\n  mat4x4f: 64,\n  uint8: 1,\n  uint8x2: 2,\n  uint8x4: 4,\n  sint8: 1,\n  sint8x2: 2,\n  sint8x4: 4,\n  unorm8: 1,\n  unorm8x2: 2,\n  unorm8x4: 4,\n  snorm8: 1,\n  snorm8x2: 2,\n  snorm8x4: 4,\n  uint16: 2,\n  uint16x2: 4,\n  uint16x4: 8,\n  sint16: 2,\n  sint16x2: 4,\n  sint16x4: 8,\n  unorm16: 2,\n  unorm16x2: 4,\n  unorm16x4: 8,\n  snorm16: 2,\n  snorm16x2: 4,\n  snorm16x4: 8,\n  float16: 2,\n  float16x2: 4,\n  float16x4: 8,\n  float32: 4,\n  float32x2: 8,\n  float32x3: 12,\n  float32x4: 16,\n  uint32: 4,\n  uint32x2: 8,\n  uint32x3: 12,\n  uint32x4: 16,\n  sint32: 4,\n  sint32x2: 8,\n  sint32x3: 12,\n  sint32x4: 16,\n  'unorm10-10-10-2': 4,\n  'unorm8x4-bgra': 4,\n  atomic: 4,\n} satisfies Partial<Record<WgslTypeLiteral | LooseTypeLiteral, number>>;\n\nfunction sizeOfStruct(struct: WgslStruct) {\n  let size = 0;\n  for (const property of Object.values(struct.propTypes)) {\n    if (Number.isNaN(size)) {\n      throw new Error('Only the last property of a struct can be unbounded');\n    }\n\n    size = roundUp(size, alignmentOf(property));\n    size += sizeOf(property);\n\n    if (Number.isNaN(size) && property.type !== 'array') {\n      throw new Error('Cannot nest unbounded struct within another struct');\n    }\n  }\n\n  return roundUp(size, alignmentOf(struct));\n}\n\nfunction sizeOfUnstruct(data: Unstruct) {\n  let size = 0;\n\n  for (const property of Object.values(data.propTypes)) {\n    const alignment = customAlignmentOf(property);\n    size = roundUp(size, alignment);\n    size += sizeOf(property);\n  }\n\n  return size;\n}\n\nfunction computeSize(data: object): number {\n  const knownSize = knownSizesMap[(data as BaseData)?.type];\n\n  if (knownSize !== undefined) {\n    return knownSize;\n  }\n\n  if (isWgslStruct(data)) {\n    return sizeOfStruct(data);\n  }\n\n  if (isUnstruct(data)) {\n    return sizeOfUnstruct(data);\n  }\n\n  if (isWgslArray(data)) {\n    if (data.elementCount === 0) {\n      return Number.NaN;\n    }\n\n    const alignment = alignmentOf(data.elementType);\n    const stride = roundUp(sizeOf(data.elementType), alignment);\n    return stride * data.elementCount;\n  }\n\n  if (isDisarray(data)) {\n    const alignment = customAlignmentOf(data.elementType);\n    const stride = roundUp(sizeOf(data.elementType), alignment);\n    return stride * data.elementCount;\n  }\n\n  if (isDecorated(data) || isLooseDecorated(data)) {\n    return getCustomSize(data) ?? sizeOf(data.inner);\n  }\n\n  throw new Error(`Cannot determine size of data: ${data}`);\n}\n\n/**\n * Since sizes can be inferred from data types, they are not stored on them.\n * Instead, this weak map acts as an extended property of those data types.\n */\nconst cachedSizes = new WeakMap<BaseData, number>();\n\nexport function sizeOf(schema: BaseData): number {\n  let size = cachedSizes.get(schema);\n\n  if (size === undefined) {\n    size = computeSize(schema);\n    cachedSizes.set(schema, size);\n  }\n\n  return size;\n}\n\n/**\n * Returns the size (in bytes) of data represented by the `schema`.\n */\nexport function PUBLIC_sizeOf(schema: AnyData): number {\n  return sizeOf(schema);\n}\n","import type {\n  Infer,\n  InferGPU,\n  InferPartial,\n  MemIdentity,\n} from '../shared/repr.ts';\nimport type {\n  $gpuRepr,\n  $memIdent,\n  $repr,\n  $reprPartial,\n} from '../shared/symbols.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport type { AnyWgslData, BaseData, WgslArray } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates an array schema that can be used to construct gpu buffers.\n * Describes arrays with fixed-size length, storing elements of the same type.\n *\n * @example\n * const LENGTH = 3;\n * const array = d.arrayOf(d.u32, LENGTH);\n *\n * @param elementType The type of elements in the array.\n * @param elementCount The number of elements in the array.\n */\nexport function arrayOf<TElement extends AnyWgslData>(\n  elementType: TElement,\n  elementCount: number,\n): WgslArray<TElement> {\n  return new WgslArrayImpl(elementType, elementCount);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass WgslArrayImpl<TElement extends BaseData> implements WgslArray<TElement> {\n  public readonly [$internal] = true;\n  public readonly type = 'array';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TElement>[];\n  declare readonly [$gpuRepr]: InferGPU<TElement>[];\n  declare readonly [$reprPartial]: {\n    idx: number;\n    value: InferPartial<TElement>;\n  }[];\n  declare readonly [$memIdent]: WgslArray<MemIdentity<TElement>>;\n  // ---\n\n  constructor(\n    public readonly elementType: TElement,\n    public readonly elementCount: number,\n  ) {\n    if (Number.isNaN(sizeOf(elementType))) {\n      throw new Error('Cannot nest runtime sized arrays.');\n    }\n\n    if (!Number.isInteger(elementCount) || elementCount < 0) {\n      throw new Error(\n        `Cannot create array schema with invalid element count: ${elementCount}.`,\n      );\n    }\n  }\n\n  toString() {\n    return `arrayOf(${this.elementType})`;\n  }\n}\n","import type { Infer, InferPartial } from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { $repr, $reprPartial } from '../shared/symbols.ts';\nimport type { AnyData, Disarray } from './dataTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates an array schema that can be used to construct vertex buffers.\n * Describes arrays with fixed-size length, storing elements of the same type.\n *\n * Elements in the schema are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n *\n * @example\n * const disarray = d.disarrayOf(d.vec3f, 3); // packed array of vec3f\n *\n * @example\n * const disarray = d.disarrayOf(d.align(16, d.vec3f), 3);\n *\n * @param elementType The type of elements in the array.\n * @param count The number of elements in the array.\n */\nexport function disarrayOf<TElement extends AnyData>(\n  elementType: TElement,\n  count: number,\n): Disarray<TElement> {\n  return new DisarrayImpl(elementType, count);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass DisarrayImpl<TElement extends AnyData> implements Disarray<TElement> {\n  public readonly [$internal] = true;\n  public readonly type = 'disarray';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TElement>[];\n  declare readonly [$reprPartial]: {\n    idx: number;\n    value: InferPartial<TElement>;\n  }[];\n  // ---\n\n  constructor(\n    public readonly elementType: TElement,\n    public readonly elementCount: number,\n  ) {\n    if (!Number.isInteger(elementCount) || elementCount < 0) {\n      throw new Error(\n        `Cannot create disarray schema with invalid element count: ${elementCount}.`,\n      );\n    }\n  }\n}\n","import { getName, setName } from '../shared/meta.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { Unstruct } from './dataTypes.ts';\nimport type { BaseData } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates a loose struct schema that can be used to construct vertex buffers.\n * Describes structs with members of both loose and non-loose types.\n *\n * The order of members matches the passed in properties object.\n * Members are not aligned in respect to their `byteAlignment`,\n * unless they are explicitly decorated with the custom align attribute\n * via `d.align` function.\n *\n * @example\n * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.vec3f }); // packed struct with no padding\n *\n * @example\n * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.align(16, d.vec3f) });\n *\n * @param properties Record with `string` keys and `TgpuData` or `TgpuLooseData` values,\n * each entry describing one struct member.\n */\nexport function unstruct<TProps extends Record<string, BaseData>>(\n  properties: TProps,\n): Unstruct<TProps> {\n  const unstruct = <T>(props: T) => props;\n  Object.setPrototypeOf(unstruct, UnstructImpl);\n  unstruct.propTypes = properties;\n\n  return unstruct as unknown as Unstruct<TProps>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst UnstructImpl = {\n  [$internal]: true,\n  type: 'unstruct',\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  },\n\n  toString(): string {\n    return `unstruct:${getName(this) ?? '<unnamed>'}`;\n  },\n};\n","import type { Infer, MemIdentity } from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type { $gpuRepr, $memIdent, $repr } from '../shared/symbols.ts';\nimport type { Atomic, atomicI32, atomicU32, I32, U32 } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Marks a concrete integer scalar type schema (u32 or i32) as a WGSL atomic.\n *\n * @example\n * const atomicU32 = d.atomic(d.u32);\n * const atomicI32 = d.atomic(d.i32);\n *\n * @param data Underlying type schema.\n */\nexport function atomic<TSchema extends U32 | I32>(\n  data: TSchema,\n): Atomic<TSchema> {\n  return new AtomicImpl(data);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass AtomicImpl<TSchema extends U32 | I32> implements Atomic<TSchema> {\n  public readonly [$internal] = true;\n  public readonly type = 'atomic';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TSchema>;\n  declare readonly [$memIdent]: MemIdentity<TSchema>;\n  declare readonly [$gpuRepr]: TSchema extends U32 ? atomicU32 : atomicI32;\n  // ---\n\n  constructor(public readonly inner: TSchema) {}\n}\n","import type {\n  Infer,\n  InferGPU,\n  InferPartial,\n  MemIdentity,\n} from '../shared/repr.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport type {\n  $gpuRepr,\n  $memIdent,\n  $repr,\n  $reprPartial,\n} from '../shared/symbols.ts';\nimport { alignmentOf } from './alignmentOf.ts';\nimport {\n  type AnyData,\n  type AnyLooseData,\n  isLooseData,\n  isLooseDecorated,\n  type LooseDecorated,\n  type LooseTypeLiteral,\n} from './dataTypes.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport {\n  type Align,\n  type AnyWgslData,\n  type BaseData,\n  type Builtin,\n  type Decorated,\n  type FlatInterpolatableData,\n  type FlatInterpolationType,\n  type Interpolate,\n  type InterpolationType,\n  isAlignAttrib,\n  isBuiltinAttrib,\n  isDecorated,\n  isSizeAttrib,\n  isWgslData,\n  type Location,\n  type PerspectiveOrLinearInterpolatableData,\n  type PerspectiveOrLinearInterpolationType,\n  type Size,\n  type WgslTypeLiteral,\n} from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport const builtinNames = [\n  'vertex_index',\n  'instance_index',\n  'position',\n  'clip_distances',\n  'front_facing',\n  'frag_depth',\n  'sample_index',\n  'sample_mask',\n  'fragment',\n  'local_invocation_id',\n  'local_invocation_index',\n  'global_invocation_id',\n  'workgroup_id',\n  'num_workgroups',\n  'subgroup_invocation_id',\n  'subgroup_size',\n] as const;\n\nexport type BuiltinName = (typeof builtinNames)[number];\n\nexport type AnyAttribute<\n  AllowedBuiltins extends Builtin<BuiltinName> = Builtin<BuiltinName>,\n> =\n  | Align<number>\n  | Size<number>\n  | Location<number>\n  | Interpolate<InterpolationType>\n  | AllowedBuiltins;\n\nexport type ExtractAttributes<T> = T extends {\n  readonly attribs: unknown[];\n} ? T['attribs']\n  : [];\n\nexport type Undecorate<T> = T extends { readonly inner: infer TInner } ? TInner\n  : T;\n\nexport type UndecorateRecord<T extends Record<string, unknown>> = {\n  [Key in keyof T]: Undecorate<T[Key]>;\n};\n\n/**\n * Decorates a data-type `TData` with an attribute `TAttrib`.\n *\n * - if `TData` is loose\n *   - if `TData` is already `LooseDecorated`\n *     - Prepend `TAttrib` to the existing attribute tuple.\n *   - else\n *     - Wrap `TData` with `LooseDecorated` and a single attribute `[TAttrib]`\n * - else\n *   - if `TData` is already `Decorated`\n *     - Prepend `TAttrib` to the existing attribute tuple.\n *   - else\n *     - Wrap `TData` with `Decorated` and a single attribute `[TAttrib]`\n */\nexport type Decorate<\n  TData extends BaseData,\n  TAttrib extends AnyAttribute,\n> = TData['type'] extends WgslTypeLiteral\n  ? Decorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]>\n  : TData['type'] extends LooseTypeLiteral\n    ? LooseDecorated<Undecorate<TData>, [TAttrib, ...ExtractAttributes<TData>]>\n  : never;\n\nexport type IsBuiltin<T> = ExtractAttributes<T>[number] extends [] ? false\n  : ExtractAttributes<T>[number] extends Builtin<BuiltinName> ? true\n  : false;\n\nexport type HasCustomLocation<T> = ExtractAttributes<T>[number] extends []\n  ? false\n  : ExtractAttributes<T>[number] extends Location ? true\n  : false;\n\nexport function attribute<TData extends BaseData, TAttrib extends AnyAttribute>(\n  data: TData,\n  attrib: TAttrib,\n): Decorated | LooseDecorated {\n  if (isDecorated(data)) {\n    return new DecoratedImpl(data.inner, [\n      attrib,\n      ...data.attribs,\n    ]) as Decorated;\n  }\n\n  if (isLooseDecorated(data)) {\n    return new LooseDecoratedImpl(data.inner, [\n      attrib,\n      ...data.attribs,\n    ]) as LooseDecorated;\n  }\n\n  if (isLooseData(data)) {\n    return new LooseDecoratedImpl(data, [attrib]) as unknown as LooseDecorated;\n  }\n\n  return new DecoratedImpl(data, [attrib]) as unknown as Decorated;\n}\n\n/**\n * Gives the wrapped data-type a custom byte alignment. Useful in order to\n * fulfill uniform alignment requirements.\n *\n * @example\n * const Data = d.struct({\n *   a: u32, // takes up 4 bytes\n *   // 12 bytes of padding, because `b` is custom aligned to multiples of 16 bytes\n *   b: d.align(16, u32),\n * });\n *\n * @param alignment The multiple of bytes this data should align itself to.\n * @param data The data-type to align.\n */\nexport function align<TAlign extends number, TData extends AnyData>(\n  alignment: TAlign,\n  data: TData,\n): Decorate<TData, Align<TAlign>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@align',\n    value: alignment,\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Adds padding bytes after the wrapped data-type, until the whole value takes up `size` bytes.\n *\n * @example\n * const Data = d.struct({\n *   a: d.size(16, u32), // takes up 16 bytes, instead of 4\n *   b: u32, // starts at byte 16, because `a` has a custom size\n * });\n *\n * @param size The amount of bytes that should be reserved for this data-type.\n * @param data The data-type to wrap.\n */\nexport function size<TSize extends number, TData extends AnyData>(\n  size: TSize,\n  data: TData,\n): Decorate<TData, Size<TSize>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@size',\n    value: size,\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Assigns an explicit numeric location to a struct member or a parameter that has this type.\n *\n * @example\n * const VertexOutput = {\n *   a: d.u32, // has implicit location 0\n *   b: d.location(5, d.u32),\n *   c: d.u32, // has implicit location 6\n * };\n *\n * @param location The explicit numeric location.\n * @param data The data-type to wrap.\n */\nexport function location<TLocation extends number, TData extends AnyData>(\n  location: TLocation,\n  data: TData,\n): Decorate<TData, Location<TLocation>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@location',\n    value: location,\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\n/**\n * Specifies how user-defined vertex shader output (fragment shader input)\n * must be interpolated.\n *\n * Tip: Integer outputs cannot be interpolated.\n *\n * @example\n * const VertexOutput = {\n *   a: d.f32, // has implicit 'perspective, center' interpolation\n *   b: d.interpolate('linear, sample', d.f32),\n * };\n *\n * @param interpolationType How data should be interpolated.\n * @param data The data-type to wrap.\n */\nexport function interpolate<\n  TInterpolation extends PerspectiveOrLinearInterpolationType,\n  TData extends PerspectiveOrLinearInterpolatableData,\n>(\n  interpolationType: TInterpolation,\n  data: TData,\n): Decorate<TData, Interpolate<TInterpolation>>;\n\n/**\n * Specifies how user-defined vertex shader output (fragment shader input)\n * must be interpolated.\n *\n * Tip: Default sampling method of `flat` is `first`. Unless you specifically\n * need deterministic behavior provided by `'flat, first'`, prefer explicit\n * `'flat, either'` as it could be slightly faster in hardware.\n *\n * @example\n * const VertexOutput = {\n *   a: d.f32, // has implicit 'perspective, center' interpolation\n *   b: d.interpolate('flat, either', d.u32), // integer outputs cannot interpolate\n * };\n *\n * @param interpolationType How data should be interpolated.\n * @param data The data-type to wrap.\n */\nexport function interpolate<\n  TInterpolation extends FlatInterpolationType,\n  TData extends FlatInterpolatableData,\n>(\n  interpolationType: TInterpolation,\n  data: TData,\n): Decorate<TData, Interpolate<TInterpolation>>;\n\nexport function interpolate<\n  TInterpolation extends InterpolationType,\n  TData extends AnyData,\n>(\n  interpolationType: TInterpolation,\n  data: TData,\n): Decorate<TData, Interpolate<TInterpolation>> {\n  return attribute(data, {\n    [$internal]: true,\n    type: '@interpolate',\n    value: interpolationType,\n    // biome-ignore lint/suspicious/noExplicitAny: <tired of lying to types>\n  }) as any;\n}\n\nexport function isBuiltin<\n  T extends\n    | Decorated<AnyWgslData, AnyAttribute[]>\n    | LooseDecorated<AnyLooseData, AnyAttribute[]>,\n>(value: T | unknown): value is T {\n  return (\n    (isDecorated(value) || isLooseDecorated(value)) &&\n    value.attribs.find(isBuiltinAttrib) !== undefined\n  );\n}\n\nexport function getAttributesString<T extends BaseData>(field: T): string {\n  if (!isDecorated(field) && !isLooseDecorated(field)) {\n    return '';\n  }\n\n  return (field.attribs as AnyAttribute[])\n    .map((attrib) => `${attrib.type}(${attrib.value}) `)\n    .join('');\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass BaseDecoratedImpl<TInner extends BaseData, TAttribs extends unknown[]> {\n  public readonly [$internal] = true;\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<TInner>;\n  // ---\n\n  constructor(\n    public readonly inner: TInner,\n    public readonly attribs: TAttribs,\n  ) {\n    const alignAttrib = attribs.find(isAlignAttrib)?.value;\n    const sizeAttrib = attribs.find(isSizeAttrib)?.value;\n\n    if (alignAttrib !== undefined) {\n      if (alignAttrib <= 0) {\n        throw new Error(\n          `Custom data alignment must be a positive number, got: ${alignAttrib}.`,\n        );\n      }\n\n      if (Math.log2(alignAttrib) % 1 !== 0) {\n        throw new Error(\n          `Alignment has to be a power of 2, got: ${alignAttrib}.`,\n        );\n      }\n\n      if (isWgslData(this.inner)) {\n        if (alignAttrib % alignmentOf(this.inner) !== 0) {\n          throw new Error(\n            `Custom alignment has to be a multiple of the standard data alignment. Got: ${alignAttrib}, expected multiple of: ${\n              alignmentOf(this.inner)\n            }.`,\n          );\n        }\n      }\n    }\n\n    if (sizeAttrib !== undefined) {\n      if (sizeAttrib < sizeOf(this.inner)) {\n        throw new Error(\n          `Custom data size cannot be smaller then the standard data size. Got: ${sizeAttrib}, expected at least: ${\n            sizeOf(this.inner)\n          }.`,\n        );\n      }\n\n      if (sizeAttrib <= 0) {\n        throw new Error(\n          `Custom data size must be a positive number. Got: ${sizeAttrib}.`,\n        );\n      }\n    }\n  }\n}\n\nclass DecoratedImpl<TInner extends BaseData, TAttribs extends unknown[]>\n  extends BaseDecoratedImpl<TInner, TAttribs>\n  implements Decorated<TInner, TAttribs> {\n  public readonly [$internal] = true;\n  public readonly type = 'decorated';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$gpuRepr]: InferGPU<TInner>;\n  declare readonly [$reprPartial]: InferPartial<TInner>;\n  declare readonly [$memIdent]: TAttribs extends Location[]\n    ? MemIdentity<TInner> | Decorated<MemIdentity<TInner>, TAttribs>\n    : Decorated<MemIdentity<TInner>, TAttribs>;\n  // ---\n}\n\nclass LooseDecoratedImpl<TInner extends BaseData, TAttribs extends unknown[]>\n  extends BaseDecoratedImpl<TInner, TAttribs>\n  implements LooseDecorated<TInner, TAttribs> {\n  public readonly [$internal] = true;\n  public readonly type = 'loose-decorated';\n}\n","import { arrayOf } from './data/array.ts';\nimport { attribute } from './data/attributes.ts';\nimport type { LooseDecorated } from './data/dataTypes.ts';\nimport { bool, f32, u32 } from './data/numeric.ts';\nimport { vec3u, vec4f } from './data/vector.ts';\nimport type {\n  AnyWgslData,\n  BaseData,\n  Bool,\n  Builtin,\n  Decorated,\n  F32,\n  U32,\n  Vec3u,\n  Vec4f,\n  WgslArray,\n} from './data/wgslTypes.ts';\nimport { $internal } from './shared/symbols.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type BuiltinVertexIndex = Decorated<U32, [Builtin<'vertex_index'>]>;\nexport type BuiltinInstanceIndex = Decorated<U32, [Builtin<'instance_index'>]>;\nexport type BuiltinPosition = Decorated<Vec4f, [Builtin<'position'>]>;\nexport type BuiltinClipDistances = Decorated<\n  WgslArray<U32>,\n  [Builtin<'clip_distances'>]\n>;\nexport type BuiltinFrontFacing = Decorated<Bool, [Builtin<'front_facing'>]>;\nexport type BuiltinFragDepth = Decorated<F32, [Builtin<'frag_depth'>]>;\nexport type BuiltinSampleIndex = Decorated<U32, [Builtin<'sample_index'>]>;\nexport type BuiltinSampleMask = Decorated<U32, [Builtin<'sample_mask'>]>;\nexport type BuiltinLocalInvocationId = Decorated<\n  Vec3u,\n  [Builtin<'local_invocation_id'>]\n>;\nexport type BuiltinLocalInvocationIndex = Decorated<\n  U32,\n  [Builtin<'local_invocation_index'>]\n>;\nexport type BuiltinGlobalInvocationId = Decorated<\n  Vec3u,\n  [Builtin<'global_invocation_id'>]\n>;\nexport type BuiltinWorkgroupId = Decorated<Vec3u, [Builtin<'workgroup_id'>]>;\nexport type BuiltinNumWorkgroups = Decorated<\n  Vec3u,\n  [Builtin<'num_workgroups'>]\n>;\nexport type BuiltinSubgroupInvocationId = Decorated<\n  U32,\n  [Builtin<'subgroup_invocation_id'>]\n>;\nexport type BuiltinSubgroupSize = Decorated<U32, [Builtin<'subgroup_size'>]>;\n\nfunction defineBuiltin<T extends Decorated | LooseDecorated>(\n  dataType: AnyWgslData,\n  value: T['attribs'][0] extends { value: infer TValue } ? TValue : never,\n): T {\n  return attribute(dataType, {\n    [$internal]: true,\n    type: '@builtin',\n    // biome-ignore lint/suspicious/noExplicitAny: it's fine\n    value: value as any,\n  }) as T;\n}\n\nexport const builtin = {\n  vertexIndex: defineBuiltin<BuiltinVertexIndex>(u32, 'vertex_index'),\n  instanceIndex: defineBuiltin<BuiltinInstanceIndex>(u32, 'instance_index'),\n  position: defineBuiltin<BuiltinPosition>(vec4f, 'position'),\n  clipDistances: defineBuiltin<BuiltinClipDistances>(\n    arrayOf(u32, 8),\n    'clip_distances',\n  ),\n  frontFacing: defineBuiltin<BuiltinFrontFacing>(bool, 'front_facing'),\n  fragDepth: defineBuiltin<BuiltinFragDepth>(f32, 'frag_depth'),\n  sampleIndex: defineBuiltin<BuiltinSampleIndex>(u32, 'sample_index'),\n  sampleMask: defineBuiltin<BuiltinSampleMask>(u32, 'sample_mask'),\n  localInvocationId: defineBuiltin<BuiltinLocalInvocationId>(\n    vec3u,\n    'local_invocation_id',\n  ),\n  localInvocationIndex: defineBuiltin<BuiltinLocalInvocationIndex>(\n    u32,\n    'local_invocation_index',\n  ),\n  globalInvocationId: defineBuiltin<BuiltinGlobalInvocationId>(\n    vec3u,\n    'global_invocation_id',\n  ),\n  workgroupId: defineBuiltin<BuiltinWorkgroupId>(vec3u, 'workgroup_id'),\n  numWorkgroups: defineBuiltin<BuiltinNumWorkgroups>(vec3u, 'num_workgroups'),\n  subgroupInvocationId: defineBuiltin<BuiltinSubgroupInvocationId>(\n    u32,\n    'subgroup_invocation_id',\n  ),\n  subgroupSize: defineBuiltin<BuiltinSubgroupSize>(u32, 'subgroup_size'),\n} as const;\n\nexport type AnyBuiltin = (typeof builtin)[keyof typeof builtin];\nexport type AnyComputeBuiltin =\n  | BuiltinLocalInvocationId\n  | BuiltinLocalInvocationIndex\n  | BuiltinGlobalInvocationId\n  | BuiltinWorkgroupId\n  | BuiltinNumWorkgroups\n  | BuiltinSubgroupInvocationId\n  | BuiltinSubgroupSize;\nexport type AnyVertexInputBuiltin = BuiltinVertexIndex | BuiltinInstanceIndex;\nexport type AnyVertexOutputBuiltin = BuiltinClipDistances | BuiltinPosition;\nexport type AnyFragmentInputBuiltin =\n  | BuiltinPosition\n  | BuiltinFrontFacing\n  | BuiltinSampleIndex\n  | BuiltinSampleMask\n  | BuiltinSubgroupInvocationId\n  | BuiltinSubgroupSize;\nexport type AnyFragmentOutputBuiltin = BuiltinFragDepth | BuiltinSampleMask;\n\nexport type OmitBuiltins<S> = S extends AnyBuiltin ? never\n  : S extends BaseData ? S\n  : {\n    [Key in keyof S as S[Key] extends AnyBuiltin ? never : Key]: S[Key];\n  };\n"],"mappings":"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","names":["schemaCallWrapper","schema","item","result","maybeType","struct","props","structSchema","instanceProps","key","schema","schemaCallWrapper","WgslStructImpl","$internal","label","setName","getName","roundUp","value","modulo","bitMask","invBitMask","TgpuVertexFormatDataImpl","type","$internal","formatToWGSLType","u32","vec2u","vec4u","i32","vec2i","vec4i","f32","vec2f","vec4f","vec3f","vec3u","vec3i","packedFormats","uint8","uint8x2","uint8x4","sint8","sint8x2","sint8x4","unorm8","unorm8x2","unorm8x4","snorm8","snorm8x2","snorm8x4","uint16","uint16x2","uint16x4","sint16","sint16x2","sint16x4","unorm16","unorm16x2","unorm16x4","snorm16","snorm16x2","snorm16x4","float16","float16x2","float16x4","float32","float32x2","float32x3","float32x4","uint32","uint32x2","uint32x3","uint32x4","sint32","sint32x2","sint32x3","sint32x4","unorm10_10_10_2","unorm8x4_bgra","knownAlignmentMap","computeAlignment","data","dataType","knownAlignment","isWgslStruct","alignmentOf","a","b","isWgslArray","isUnstruct","firstProp","getCustomAlignment","isDisarray","isDecorated","isLooseDecorated","packedFormats","computeCustomAlignment","customAlignmentOf","cachedAlignments","cachedCustomAlignments","alignment","PUBLIC_alignmentOf","schema","knownSizesMap","sizeOfStruct","struct","size","property","roundUp","alignmentOf","sizeOf","sizeOfUnstruct","data","alignment","customAlignmentOf","computeSize","knownSize","isWgslStruct","isUnstruct","isWgslArray","isDisarray","isDecorated","isLooseDecorated","getCustomSize","cachedSizes","schema","PUBLIC_sizeOf","arrayOf","elementType","elementCount","WgslArrayImpl","sizeOf","$internal","disarrayOf","elementType","count","DisarrayImpl","elementCount","$internal","unstruct","properties","props","UnstructImpl","$internal","label","setName","getName","atomic","data","AtomicImpl","inner","$internal","attribute","data","attrib","isDecorated","DecoratedImpl","isLooseDecorated","LooseDecoratedImpl","isLooseData","align","alignment","$internal","size","location","interpolate","interpolationType","isBuiltin","value","isBuiltinAttrib","getAttributesString","field","BaseDecoratedImpl","inner","attribs","alignAttrib","isAlignAttrib","sizeAttrib","isSizeAttrib","isWgslData","alignmentOf","sizeOf","defineBuiltin","dataType","value","attribute","$internal","builtin","u32","vec4f","arrayOf","bool","f32","vec3u"]}