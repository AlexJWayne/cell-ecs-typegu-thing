import { aM as Bool, aN as F16, aO as F32, aP as I32, aQ as U16, aR as U32, A as AnyWgslData, aS as WgslStruct, i as WgslArray, k as AnyData, aT as Ptr, aU as Vec2b, aV as Vec2f, aW as Vec2h, aX as Vec2i, aY as Vec2u, aZ as Vec3b, a_ as Vec3f, a$ as Vec3h, b0 as Vec3i, b1 as Vec3u, b2 as Vec4b, b3 as Vec4f, b4 as Vec4h, b5 as Vec4i, b6 as Vec4u, D as Disarray, b7 as BaseData, b8 as Unstruct, b9 as Atomic } from '../tgpuComputeFn-DOUjhQua.js';
export { bm as Align, bP as AnyAttribute, c0 as AnyBuiltin, bM as AnyLooseData, bn as AnyVecInstance, bo as AnyWgslStruct, bp as Builtin, c1 as BuiltinClipDistances, c2 as BuiltinFragDepth, c3 as BuiltinFrontFacing, c4 as BuiltinGlobalInvocationId, c5 as BuiltinInstanceIndex, c6 as BuiltinLocalInvocationId, c7 as BuiltinLocalInvocationIndex, c8 as BuiltinNumWorkgroups, c9 as BuiltinPosition, ca as BuiltinSampleIndex, cb as BuiltinSampleMask, cc as BuiltinVertexIndex, cd as BuiltinWorkgroupId, bq as Decorated, cg as FormatToWGSLType, bQ as HasCustomLocation, I as Infer, ce as InferGPU, cf as InferPartial, br as Interpolate, bS as IsBuiltin, bs as Location, bN as LooseDecorated, bw as Mat2x2f, bx as Mat3x3f, by as Mat4x4f, cZ as PackedData, bz as Size, ch as TgpuVertexFormatData, bl as Void, bO as align, b$ as builtin, cI as float16, cJ as float16x2, cK as float16x4, cL as float32, cM as float32x2, cN as float32x3, cO as float32x4, ci as formatToWGSLType, bR as interpolate, ba as isAlignAttrib, bb as isAtomic, bT as isBuiltin, bc as isBuiltinAttrib, bW as isData, bd as isDecorated, bX as isDisarray, be as isInterpolateAttrib, bf as isLocationAttrib, bY as isLooseData, bZ as isLooseDecorated, bg as isPtr, bh as isSizeAttrib, b_ as isUnstruct, bi as isWgslArray, bj as isWgslData, bk as isWgslStruct, bU as location, bt as m2x2f, bu as m3x3f, bv as m4x4f, cj as packedFormats, cz as sint16, cA as sint16x2, cB as sint16x4, cT as sint32, cU as sint32x2, cV as sint32x3, cW as sint32x4, cn as sint8, co as sint8x2, cp as sint8x4, bV as size, cF as snorm16, cG as snorm16x2, cH as snorm16x4, ct as snorm8, cu as snorm8x2, cv as snorm8x4, cw as uint16, cx as uint16x2, cy as uint16x4, cP as uint32, cQ as uint32x2, cR as uint32x3, cS as uint32x4, ck as uint8, cl as uint8x2, cm as uint8x4, cX as unorm10_10_10_2, cC as unorm16, cD as unorm16x2, cE as unorm16x4, cq as unorm8, cr as unorm8x2, cs as unorm8x4, cY as unorm8x4_bgra, bA as v2b, bB as v2f, bC as v2i, bD as v2u, bE as v3b, bF as v3f, bG as v3i, bH as v3u, bI as v4b, bJ as v4f, bK as v4i, bL as v4u } from '../tgpuComputeFn-DOUjhQua.js';
export { m as mat2x2f, a as mat3x3f, b as mat4x4f, c as matToArray } from '../matrix-S8W4dk8I.js';
import 'tinyest';

/**
 * A schema that represents a boolean value. (equivalent to `bool` in WGSL)
 *
 * Can also be called to cast a value to a bool in accordance with WGSL casting rules.
 *
 * @example
 * const value = bool(); // false
 * @example
 * const value = bool(0); // false
 * @example
 * const value = bool(-0); // false
 * @example
 * const value = bool(21.37); // true
 */
declare const bool: Bool;
/**
 * A schema that represents an unsigned 32-bit integer value. (equivalent to `u32` in WGSL)
 *
 * Can also be called to cast a value to an u32 in accordance with WGSL casting rules.
 *
 * @example
 * const value = u32(); // 0
 * @example
 * const value = u32(7); // 7
 * @example
 * const value = u32(3.14); // 3
 * @example
 * const value = u32(-1); // 4294967295
 * @example
 * const value = u32(-3.1); // 0
 */
declare const u32: U32;
declare const u16: U16;
/**
 * A schema that represents a signed 32-bit integer value. (equivalent to `i32` in WGSL)
 *
 * Can also be called to cast a value to an i32 in accordance with WGSL casting rules.
 *
 * @example
 * const value = i32(); // 0
 * @example
 * const value = i32(3.14); // 3
 * @example
 * const value = i32(-3.9); // -3
 * @example
 * const value = i32(10000000000) // 1410065408
 */
declare const i32: I32;
/**
 * A schema that represents a 32-bit float value. (equivalent to `f32` in WGSL)
 *
 * Can also be called to cast a value to an f32.
 *
 * @example
 * const value = f32(); // 0
 * @example
 * const value = f32(1.23); // 1.23
 * @example
 * const value = f32(true); // 1
 */
declare const f32: F32;
/**
 * A schema that represents a 16-bit float value. (equivalent to `f16` in WGSL)
 *
 * Can also be called to cast a value to an f16.
 *
 * @example
 * const value = f16(); // 0
 * @example
 * const value = f32(1.23); // 1.23
 * @example
 * const value = f16(true); // 1
 * @example
 * const value = f16(21877.5); // 21872
 */
declare const f16: F16;

/**
 * Creates a struct schema that can be used to construct GPU buffers.
 * Ensures proper alignment and padding of properties (as opposed to a `d.unstruct` schema).
 * The order of members matches the passed in properties object.
 *
 * @example
 * const CircleStruct = d.struct({ radius: d.f32, pos: d.vec3f });
 *
 * @param props Record with `string` keys and `TgpuData` values,
 * each entry describing one struct member.
 */
declare function struct<TProps extends Record<string, AnyWgslData>>(props: TProps): WgslStruct<TProps>;

/**
 * Creates an array schema that can be used to construct gpu buffers.
 * Describes arrays with fixed-size length, storing elements of the same type.
 *
 * @example
 * const LENGTH = 3;
 * const array = d.arrayOf(d.u32, LENGTH);
 *
 * @param elementType The type of elements in the array.
 * @param elementCount The number of elements in the array.
 */
declare function arrayOf<TElement extends AnyWgslData>(elementType: TElement, elementCount: number): WgslArray<TElement>;

declare function ptrFn<T extends AnyData>(inner: T): Ptr<'function', T, 'read-write'>;
declare function ptrPrivate<T extends AnyData>(inner: T): Ptr<'private', T, 'read-write'>;
declare function ptrWorkgroup<T extends AnyData>(inner: T): Ptr<'workgroup', T, 'read-write'>;
declare function ptrStorage<T extends AnyData, TAccess extends 'read' | 'read-write' = 'read'>(inner: T, access?: TAccess): Ptr<'storage', T, TAccess>;
declare function ptrUniform<T extends AnyData>(inner: T): Ptr<'uniform', T, 'read'>;
declare function ptrHandle<T extends AnyData>(inner: T): Ptr<'handle', T, 'read'>;

/**
 * Schema representing vec2f - a vector with 2 elements of type f32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2f(); // (0.0, 0.0)
 * const vector = d.vec2f(1); // (1.0, 1.0)
 * const vector = d.vec2f(0.5, 0.1); // (0.5, 0.1)
 *
 * @example
 * const buffer = root.createBuffer(d.vec2f, d.vec2f(0, 1)); // buffer holding a d.vec2f value, with an initial value of vec2f(0, 1);
 */
declare const vec2f: Vec2f;
/**
 * Schema representing vec2h - a vector with 2 elements of type f16.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2h(); // (0.0, 0.0)
 * const vector = d.vec2h(1); // (1.0, 1.0)
 * const vector = d.vec2h(0.5, 0.1); // (0.5, 0.1)
 *
 * @example
 * const buffer = root.createBuffer(d.vec2h, d.vec2h(0, 1)); // buffer holding a d.vec2h value, with an initial value of vec2h(0, 1);
 */
declare const vec2h: Vec2h;
/**
 * Schema representing vec2i - a vector with 2 elements of type i32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2i(); // (0, 0)
 * const vector = d.vec2i(1); // (1, 1)
 * const vector = d.vec2i(-1, 1); // (-1, 1)
 *
 * @example
 * const buffer = root.createBuffer(d.vec2i, d.vec2i(0, 1)); // buffer holding a d.vec2i value, with an initial value of vec2i(0, 1);
 */
declare const vec2i: Vec2i;
/**
 * Schema representing vec2u - a vector with 2 elements of type u32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2u(); // (0, 0)
 * const vector = d.vec2u(1); // (1, 1)
 * const vector = d.vec2u(1, 2); // (1, 2)
 *
 * @example
 * const buffer = root.createBuffer(d.vec2u, d.vec2u(0, 1)); // buffer holding a d.vec2u value, with an initial value of vec2u(0, 1);
 */
declare const vec2u: Vec2u;
/**
 * Schema representing `vec2<bool>` - a vector with 2 elements of type `bool`.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec2b(); // (false, false)
 * const vector = d.vec2b(true); // (true, true)
 * const vector = d.vec2b(false, true); // (false, true)
 */
declare const vec2b: Vec2b;
/**
 * Schema representing vec3f - a vector with 3 elements of type f32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3f(); // (0.0, 0.0, 0.0)
 * const vector = d.vec3f(1); // (1.0, 1.0, 1.0)
 * const vector = d.vec3f(1, 2, 3.5); // (1.0, 2.0, 3.5)
 *
 * @example
 * const buffer = root.createBuffer(d.vec3f, d.vec3f(0, 1, 2)); // buffer holding a d.vec3f value, with an initial value of vec3f(0, 1, 2);
 */
declare const vec3f: Vec3f;
/**
 * Schema representing vec3h - a vector with 3 elements of type f16.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3h(); // (0.0, 0.0, 0.0)
 * const vector = d.vec3h(1); // (1.0, 1.0, 1.0)
 * const vector = d.vec3h(1, 2, 3.5); // (1.0, 2.0, 3.5)
 *
 * @example
 * const buffer = root.createBuffer(d.vec3h, d.vec3h(0, 1, 2)); // buffer holding a d.vec3h value, with an initial value of vec3h(0, 1, 2);
 */
declare const vec3h: Vec3h;
/**
 * Schema representing vec3i - a vector with 3 elements of type i32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3i(); // (0, 0, 0)
 * const vector = d.vec3i(1); // (1, 1, 1)
 * const vector = d.vec3i(1, 2, -3); // (1, 2, -3)
 *
 * @example
 * const buffer = root.createBuffer(d.vec3i, d.vec3i(0, 1, 2)); // buffer holding a d.vec3i value, with an initial value of vec3i(0, 1, 2);
 */
declare const vec3i: Vec3i;
/**
 * Schema representing vec3u - a vector with 3 elements of type u32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3u(); // (0, 0, 0)
 * const vector = d.vec3u(1); // (1, 1, 1)
 * const vector = d.vec3u(1, 2, 3); // (1, 2, 3)
 *
 * @example
 * const buffer = root.createBuffer(d.vec3u, d.vec3u(0, 1, 2)); // buffer holding a d.vec3u value, with an initial value of vec3u(0, 1, 2);
 */
declare const vec3u: Vec3u;
/**
 * Schema representing `vec3<bool>` - a vector with 3 elements of type `bool`.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec3b(); // (false, false, false)
 * const vector = d.vec3b(true); // (true, true, true)
 * const vector = d.vec3b(false, true, false); // (false, true, false)
 */
declare const vec3b: Vec3b;
/**
 * Schema representing vec4f - a vector with 4 elements of type f32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4f(); // (0.0, 0.0, 0.0, 0.0)
 * const vector = d.vec4f(1); // (1.0, 1.0, 1.0, 1.0)
 * const vector = d.vec4f(1, 2, 3, 4.5); // (1.0, 2.0, 3.0, 4.5)
 *
 * @example
 * const buffer = root.createBuffer(d.vec4f, d.vec4f(0, 1, 2, 3)); // buffer holding a d.vec4f value, with an initial value of vec4f(0, 1, 2, 3);
 */
declare const vec4f: Vec4f;
/**
 * Schema representing vec4h - a vector with 4 elements of type f16.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4h(); // (0.0, 0.0, 0.0, 0.0)
 * const vector = d.vec4h(1); // (1.0, 1.0, 1.0, 1.0)
 * const vector = d.vec4h(1, 2, 3, 4.5); // (1.0, 2.0, 3.0, 4.5)
 *
 * @example
 * const buffer = root.createBuffer(d.vec4h, d.vec4h(0, 1, 2, 3)); // buffer holding a d.vec4h value, with an initial value of vec4h(0, 1, 2, 3);
 */
declare const vec4h: Vec4h;
/**
 * Schema representing vec4i - a vector with 4 elements of type i32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4i(); // (0, 0, 0, 0)
 * const vector = d.vec4i(1); // (1, 1, 1, 1)
 * const vector = d.vec4i(1, 2, 3, -4); // (1, 2, 3, -4)
 *
 * @example
 * const buffer = root.createBuffer(d.vec4i, d.vec4i(0, 1, 2, 3)); // buffer holding a d.vec4i value, with an initial value of vec4i(0, 1, 2, 3);
 */
declare const vec4i: Vec4i;
/**
 * Schema representing vec4u - a vector with 4 elements of type u32.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4u(); // (0, 0, 0, 0)
 * const vector = d.vec4u(1); // (1, 1, 1, 1)
 * const vector = d.vec4u(1, 2, 3, 4); // (1, 2, 3, 4)
 *
 * @example
 * const buffer = root.createBuffer(d.vec4u, d.vec4u(0, 1, 2, 3)); // buffer holding a d.vec4u value, with an initial value of vec4u(0, 1, 2, 3);
 */
declare const vec4u: Vec4u;
/**
 * Schema representing `vec4<bool>` - a vector with 4 elements of type `bool`.
 * Also a constructor function for this vector value.
 *
 * @example
 * const vector = d.vec4b(); // (false, false, false, false)
 * const vector = d.vec4b(true); // (true, true, true, true)
 * const vector = d.vec4b(false, true, false, true); // (false, true, false, true)
 */
declare const vec4b: Vec4b;

/**
 * Creates an array schema that can be used to construct vertex buffers.
 * Describes arrays with fixed-size length, storing elements of the same type.
 *
 * Elements in the schema are not aligned in respect to their `byteAlignment`,
 * unless they are explicitly decorated with the custom align attribute
 * via `d.align` function.
 *
 * @example
 * const disarray = d.disarrayOf(d.vec3f, 3); // packed array of vec3f
 *
 * @example
 * const disarray = d.disarrayOf(d.align(16, d.vec3f), 3);
 *
 * @param elementType The type of elements in the array.
 * @param count The number of elements in the array.
 */
declare function disarrayOf<TElement extends AnyData>(elementType: TElement, count: number): Disarray<TElement>;

/**
 * Creates a loose struct schema that can be used to construct vertex buffers.
 * Describes structs with members of both loose and non-loose types.
 *
 * The order of members matches the passed in properties object.
 * Members are not aligned in respect to their `byteAlignment`,
 * unless they are explicitly decorated with the custom align attribute
 * via `d.align` function.
 *
 * @example
 * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.vec3f }); // packed struct with no padding
 *
 * @example
 * const CircleStruct = d.unstruct({ radius: d.f32, pos: d.align(16, d.vec3f) });
 *
 * @param properties Record with `string` keys and `TgpuData` or `TgpuLooseData` values,
 * each entry describing one struct member.
 */
declare function unstruct<TProps extends Record<string, BaseData>>(properties: TProps): Unstruct<TProps>;

/**
 * Marks a concrete integer scalar type schema (u32 or i32) as a WGSL atomic.
 *
 * @example
 * const atomicU32 = d.atomic(d.u32);
 * const atomicI32 = d.atomic(d.i32);
 *
 * @param data Underlying type schema.
 */
declare function atomic<TSchema extends U32 | I32>(data: TSchema): Atomic<TSchema>;

/**
 * Returns the size (in bytes) of data represented by the `schema`.
 */
declare function PUBLIC_sizeOf(schema: AnyData): number;

/**
 * Returns the alignment (in bytes) of data represented by the `schema`.
 */
declare function PUBLIC_alignmentOf(schema: AnyData): number;

export { AnyData, AnyWgslData, Atomic, BaseData, BaseData as BaseWgslData, Bool, Disarray, F16, F32, I32, Ptr, U16, U32, Unstruct, Vec2b, Vec2f, Vec2h, Vec2i, Vec2u, Vec3b, Vec3f, Vec3h, Vec3i, Vec3u, Vec4b, Vec4f, Vec4h, Vec4i, Vec4u, WgslArray, WgslStruct, PUBLIC_alignmentOf as alignmentOf, arrayOf, atomic, bool, disarrayOf, f16, f32, i32, ptrFn, ptrHandle, ptrPrivate, ptrStorage, ptrUniform, ptrWorkgroup, PUBLIC_sizeOf as sizeOf, struct, u16, u32, unstruct, vec2b, vec2f, vec2h, vec2i, vec2u, vec3b, vec3f, vec3h, vec3i, vec3u, vec4b, vec4f, vec4h, vec4i, vec4u };
