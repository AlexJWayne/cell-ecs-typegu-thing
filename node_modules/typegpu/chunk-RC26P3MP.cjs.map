{"version":3,"sources":["/Users/konradreczko/TypeGPU/wigsill/packages/typegpu/dist/chunk-RC26P3MP.cjs","../src/data/utils.ts","../src/data/struct.ts"],"names":["schemaCallWrapper","schema","item","result","maybeType","struct","props","structSchema","instanceProps","key","WgslStructImpl","$internal","label","setName","getName"],"mappings":"AAAA,m0BAA2P,SCI3OA,CAAAA,CAAqBC,CAAAA,CAAiBC,CAAAA,CAAY,CAChE,IAAIC,CAAAA,CAASD,CAAAA,CACb,GAAI,CACFC,CAAAA,CACEF,CAAAA,CACAC,CAAI,CACR,CAAA,UAAQ,CACN,IAAME,CAAAA,iBAAaH,CAAAA,6BAA6B,MAAA,CAChD,OAAA,CAAQ,IAAA,CAAK,CAAA,eAAA,mBAAkBG,CAAAA,SAAa,aAAW,CAAA,iBAAA,CAAmB,CAC5E,CACA,OAAOD,CACT,CCKO,SAASE,CAAAA,CACdC,CAAAA,CACoB,CAGpB,IAAMC,CAAAA,CAAkCC,CAAAA,EACtC,MAAA,CAAO,WAAA,CACL,MAAA,CAAO,OAAA,CAAQF,CAAK,CAAA,CAAE,GAAA,CAAI,CACxB,CAACG,CAAAA,CAAKR,CAAM,CAAA,CAAA,EACT,CAACQ,CAAAA,CAAKT,CAAAA,CAAkBC,CAAAA,CAAQO,CAAAA,CAAcC,CAAG,CAAC,CAAC,CAAC,CAC3D,CAAA,CACF,OAAA,MAAA,CAAO,cAAA,CAAeF,CAAAA,CAAcG,EAAc,CAAA,CAClDH,CAAAA,CAAa,SAAA,CAAYD,CAAAA,CAElBC,CACT,CAMA,IAAMG,EAAAA,CAAiB,CACrB,CAACC,mBAAS,CAAA,CAAG,CAAA,CAAA,CACb,IAAA,CAAM,QAAA,CAEN,KAAA,CAAMC,CAAAA,CAAe,CACnB,OAAAC,iCAAAA,IAAQ,CAAMD,CAAK,CAAA,CACZ,IACT,CAAA,CAEA,QAAA,CAAA,CAAmB,CACjB,MAAO,CAAA,OAAA,mBAAUE,iCAAAA,IAAY,CAAA,SAAK,aAAW,CAAA,CAAA","file":"/Users/konradreczko/TypeGPU/wigsill/packages/typegpu/dist/chunk-RC26P3MP.cjs","sourcesContent":[null,"/**\n * A wrapper for `schema(item)` call.\n * Logs a warning if the schema is not callable.\n */\nexport function schemaCallWrapper<T>(schema: unknown, item: T): T {\n  let result = item;\n  try {\n    result = (\n      schema as unknown as ((item: typeof result) => typeof result)\n    )(item);\n  } catch {\n    const maybeType = (schema as { type: string })?.type;\n    console.warn(`Schema of type ${maybeType ?? '<unknown>'} is not callable.`);\n  }\n  return result;\n}\n","import { getName, setName } from '../shared/meta.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { schemaCallWrapper } from './utils.ts';\nimport type { AnyWgslData, WgslStruct } from './wgslTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Creates a struct schema that can be used to construct GPU buffers.\n * Ensures proper alignment and padding of properties (as opposed to a `d.unstruct` schema).\n * The order of members matches the passed in properties object.\n *\n * @example\n * const CircleStruct = d.struct({ radius: d.f32, pos: d.vec3f });\n *\n * @param props Record with `string` keys and `TgpuData` values,\n * each entry describing one struct member.\n */\nexport function struct<TProps extends Record<string, AnyWgslData>>(\n  props: TProps,\n): WgslStruct<TProps> {\n  // in the schema call, create and return a deep copy\n  // by wrapping all the values in corresponding schema calls\n  const structSchema = <T extends TProps>(instanceProps: T) =>\n    Object.fromEntries(\n      Object.entries(props).map((\n        [key, schema],\n      ) => [key, schemaCallWrapper(schema, instanceProps[key])]),\n    );\n  Object.setPrototypeOf(structSchema, WgslStructImpl);\n  structSchema.propTypes = props;\n\n  return structSchema as WgslStruct<TProps>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst WgslStructImpl = {\n  [$internal]: true,\n  type: 'struct',\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  },\n\n  toString(): string {\n    return `struct:${getName(this) ?? '<unnamed>'}`;\n  },\n};\n"]}