{"version":3,"sources":["../src/extractGpuValueGetter.ts","../src/shared/utilityTypes.ts","../src/tgsl/generationHelpers.ts","../src/core/valueProxyUtils.ts","../src/core/constant/tgpuConstant.ts","../src/core/slot/slotTypes.ts","../src/types.ts","../src/core/resolve/externals.ts","../src/core/declare/tgpuDeclare.ts","../src/core/function/fnCore.ts","../src/core/function/extractArgs.ts","../src/core/function/ioSchema.ts","../src/core/function/templateUtils.ts","../src/core/function/tgpuComputeFn.ts","../src/core/function/tgpuFn.ts","../src/core/function/tgpuFragmentFn.ts","../src/core/function/tgpuVertexFn.ts","../src/nameRegistry.ts","../src/core/vertexLayout/connectAttributesToShader.ts","../src/core/resolve/resolveData.ts","../src/core/buffer/buffer.ts","../src/data/offsets.ts","../src/data/alignIO.ts","../src/data/compiledIO.ts","../src/data/dataIO.ts","../src/data/partialIO.ts","../src/extension.ts","../src/core/buffer/bufferUsage.ts","../src/core/sampler/sampler.ts","../src/core/texture/externalTexture.ts","../src/core/texture/textureFormats.ts","../src/core/texture/texture.ts","../src/core/texture/usageExtension.ts","../src/tgpuBindGroupLayout.ts","../src/tgsl/wgslGenerator.ts","../src/resolutionCtx.ts","../src/core/resolve/tgpuResolve.ts","../src/core/querySet/querySet.ts","../src/memo.ts","../src/core/pipeline/timeable.ts","../src/core/pipeline/computePipeline.ts","../src/core/vertexLayout/vertexLayout.ts","../src/core/pipeline/connectAttachmentToShader.ts","../src/core/pipeline/connectTargetsToShader.ts","../src/core/pipeline/renderPipeline.ts","../src/core/buffer/bufferShorthand.ts","../src/core/root/init.ts","../src/core/slot/slot.ts","../src/core/slot/accessor.ts","../src/core/slot/derived.ts","../src/core/variable/tgpuVariable.ts","../src/index.ts"],"sourcesContent":["import { $gpuValueOf } from './shared/symbols.ts';\nimport type { ResolutionCtx } from './types.ts';\n\nexport type GpuValueGetter = (ctx: ResolutionCtx) => unknown;\n\nexport function extractGpuValueGetter(\n  object: unknown,\n): GpuValueGetter | undefined {\n  // biome-ignore lint/suspicious/noExplicitAny: we're inspecting the value\n  if (typeof (object as any)?.[$gpuValueOf] === 'function') {\n    return (object as { [$gpuValueOf]: GpuValueGetter })[$gpuValueOf].bind(\n      object,\n    );\n  }\n  return undefined;\n}\n","export type Default<T, TDefault> = unknown extends T ? TDefault\n  : T extends undefined ? TDefault\n  : T;\n\nexport type UnionToIntersection<U> =\n  // biome-ignore lint/suspicious/noExplicitAny: <had to be done>\n  (U extends any ? (x: U) => void : never) extends (x: infer I) => void ? I\n    : never;\n\nexport type Prettify<T> =\n  & {\n    [K in keyof T]: T[K];\n  }\n  & {};\n\n/**\n * Removes properties from record type that extend `Prop`\n */\nexport type OmitProps<T extends Record<string, unknown>, Prop> = Pick<\n  T,\n  {\n    [Key in keyof T]: T[Key] extends Prop ? never : Key;\n  }[keyof T]\n>;\n\n/**\n * Removes properties from record type that equal `Prop`\n */\nexport type OmitPropsExact<T extends Record<string, unknown>, Prop> = Pick<\n  T,\n  {\n    [Key in keyof T]: [T[Key], Prop] extends [Prop, T[Key]] ? never : Key;\n  }[keyof T]\n>;\n\nexport type NullableToOptional<T> =\n  & {\n    // Props where the value extends `null` -> make them optional and remove null from the type\n    [K in keyof T as T[K] extends null ? K : never]?: T[K];\n  }\n  & {\n    // All other props remain unchanged\n    [K in keyof T as T[K] extends null ? never : K]: T[K];\n  };\n\n/**\n * The opposite of Readonly<T>\n */\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n/**\n * Any typed array\n */\nexport type TypedArray =\n  | Uint8Array\n  | Uint16Array\n  | Uint32Array\n  | Int32Array\n  | Float32Array\n  | Float64Array;\n\nexport function assertExhaustive(x: never, location: string): never {\n  throw new Error(`Failed to handle ${x} at ${location}`);\n}\n","import { arrayOf } from '../data/array.ts';\nimport {\n  type AnyData,\n  isDisarray,\n  isSnippet,\n  isUnstruct,\n  snip,\n  type Snippet,\n  UnknownData,\n} from '../data/dataTypes.ts';\nimport { mat2x2f, mat3x3f, mat4x4f } from '../data/matrix.ts';\nimport {\n  abstractFloat,\n  abstractInt,\n  bool,\n  f16,\n  f32,\n  i32,\n  u32,\n} from '../data/numeric.ts';\nimport {\n  vec2b,\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3b,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4b,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n  vecTypeToPrimitive,\n} from '../data/vector.ts';\nimport {\n  type AnyWgslData,\n  type AnyWgslStruct,\n  type F16,\n  type F32,\n  hasInternalDataType,\n  type I32,\n  isMat,\n  isMatInstance,\n  isVec,\n  isVecInstance,\n  isWgslArray,\n  isWgslStruct,\n  type U32,\n} from '../data/wgslTypes.ts';\nimport { invariant } from '../errors.ts';\nimport { getResolutionCtx } from '../gpuMode.ts';\nimport { $wgslDataType } from '../shared/symbols.ts';\nimport { assertExhaustive } from '../shared/utilityTypes.ts';\nimport { isNumericSchema } from '../std/numeric.ts';\nimport type { ResolutionCtx } from '../types.ts';\n\ntype SwizzleableType = 'f' | 'h' | 'i' | 'u' | 'b';\ntype SwizzleLength = 1 | 2 | 3 | 4;\n\nconst swizzleLenToType: Record<\n  SwizzleableType,\n  Record<SwizzleLength, AnyData>\n> = {\n  f: {\n    1: f32,\n    2: vec2f,\n    3: vec3f,\n    4: vec4f,\n  },\n  h: {\n    1: f16,\n    2: vec2h,\n    3: vec3h,\n    4: vec4h,\n  },\n  i: {\n    1: i32,\n    2: vec2i,\n    3: vec3i,\n    4: vec4i,\n  },\n  u: {\n    1: u32,\n    2: vec2u,\n    3: vec3u,\n    4: vec4u,\n  },\n  b: {\n    1: bool,\n    2: vec2b,\n    3: vec3b,\n    4: vec4b,\n  },\n} as const;\n\nconst kindToSchema = {\n  vec2f: vec2f,\n  vec2h: vec2h,\n  vec2i: vec2i,\n  vec2u: vec2u,\n  'vec2<bool>': vec2b,\n  vec3f: vec3f,\n  vec3h: vec3h,\n  vec3i: vec3i,\n  vec3u: vec3u,\n  'vec3<bool>': vec3b,\n  vec4f: vec4f,\n  vec4h: vec4h,\n  vec4i: vec4i,\n  vec4u: vec4u,\n  'vec4<bool>': vec4b,\n  mat2x2f: mat2x2f,\n  mat3x3f: mat3x3f,\n  mat4x4f: mat4x4f,\n} as const;\n\nconst indexableTypeToResult = {\n  vec2f: f32,\n  vec2h: f16,\n  vec2i: i32,\n  vec2u: u32,\n  'vec2<bool>': bool,\n  vec3f: f32,\n  vec3h: f16,\n  vec3i: i32,\n  vec3u: u32,\n  'vec3<bool>': bool,\n  vec4f: f32,\n  vec4h: f16,\n  vec4i: i32,\n  vec4u: u32,\n  'vec4<bool>': bool,\n  mat2x2f: vec2f,\n  mat3x3f: vec3f,\n  mat4x4f: vec4f,\n} as const;\n\nexport function getTypeForPropAccess(\n  targetType: AnyData,\n  propName: string,\n): AnyData | UnknownData {\n  if (isWgslStruct(targetType) || isUnstruct(targetType)) {\n    return targetType.propTypes[propName] as AnyData ?? UnknownData;\n  }\n\n  if (targetType === bool || isNumericSchema(targetType)) {\n    // No props to be accessed here\n    return UnknownData;\n  }\n\n  const propLength = propName.length;\n  if (\n    isVec(targetType) &&\n    propLength >= 1 &&\n    propLength <= 4\n  ) {\n    const swizzleTypeChar = targetType.type.includes('bool')\n      ? 'b'\n      : (targetType.type[4] as SwizzleableType);\n    const swizzleType =\n      swizzleLenToType[swizzleTypeChar][propLength as SwizzleLength];\n    if (swizzleType) {\n      return swizzleType;\n    }\n  }\n\n  return UnknownData;\n}\n\nexport function getTypeForIndexAccess(\n  dataType: AnyData,\n): AnyData | UnknownData {\n  // array\n  if (isWgslArray(dataType) || isDisarray(dataType)) {\n    return dataType.elementType as AnyData;\n  }\n\n  // vector or matrix\n  if (dataType.type in indexableTypeToResult) {\n    return indexableTypeToResult[\n      dataType.type as keyof typeof indexableTypeToResult\n    ];\n  }\n\n  return UnknownData;\n}\n\nexport function numericLiteralToSnippet(value: string): Snippet | undefined {\n  // Hex literals\n  if (/^0x[0-9a-f]+$/i.test(value)) {\n    return snip(value, abstractInt);\n  }\n\n  // Binary literals\n  if (/^0b[01]+$/i.test(value)) {\n    return snip(`${Number.parseInt(value.slice(2), 2)}`, abstractInt);\n  }\n\n  // Floating point literals\n  if (/^-?(?:\\d+\\.\\d*|\\d*\\.\\d+)$/i.test(value)) {\n    return snip(value, abstractFloat);\n  }\n\n  // Floating point literals with scientific notation\n  if (/^-?\\d+(?:\\.\\d+)?e-?\\d+$/i.test(value)) {\n    return snip(value, abstractFloat);\n  }\n\n  // Integer literals\n  if (/^-?\\d+$/i.test(value)) {\n    return snip(value, abstractInt);\n  }\n\n  return undefined;\n}\n\ntype ConversionAction = 'ref' | 'deref' | 'cast' | 'none';\n\ntype ConversionRankInfo =\n  | { rank: number; action: 'cast'; targetType: AnyData }\n  | { rank: number; action: Exclude<ConversionAction, 'cast'> };\n\nconst INFINITE_RANK: ConversionRankInfo = {\n  rank: Number.POSITIVE_INFINITY,\n  action: 'none',\n};\n\nfunction unwrapDecorated(data: AnyData): AnyData {\n  if (data.type === 'decorated') {\n    return data.inner as AnyData;\n  }\n  return data;\n}\n\nfunction getVectorComponent(type: AnyData): AnyData | undefined {\n  return isVec(type) ? vecTypeToPrimitive[type.type] : undefined;\n}\n\nfunction getAutoConversionRank(\n  src: AnyData,\n  dest: AnyData,\n): ConversionRankInfo {\n  const trueSrc = unwrapDecorated(src);\n  const trueDst = unwrapDecorated(dest);\n\n  if (trueSrc.type === trueDst.type) {\n    return { rank: 0, action: 'none' };\n  }\n\n  if (trueSrc.type === 'abstractFloat') {\n    if (trueDst.type === 'f32') return { rank: 1, action: 'none' };\n    if (trueDst.type === 'f16') return { rank: 2, action: 'none' };\n  }\n\n  if (trueSrc.type === 'abstractInt') {\n    if (trueDst.type === 'i32') return { rank: 3, action: 'none' };\n    if (trueDst.type === 'u32') return { rank: 4, action: 'none' };\n    if (trueDst.type === 'abstractFloat') return { rank: 5, action: 'none' };\n    if (trueDst.type === 'f32') return { rank: 6, action: 'none' };\n    if (trueDst.type === 'f16') return { rank: 7, action: 'none' };\n  }\n\n  if (isVec(trueSrc) && isVec(trueDst)) {\n    const compSrc = getVectorComponent(trueSrc);\n    const compDest = getVectorComponent(trueDst);\n    if (compSrc && compDest) {\n      return getAutoConversionRank(compSrc, compDest);\n    }\n  }\n\n  if (isMat(trueSrc) && isMat(trueDst)) {\n    // Matrix conversion rank depends only on component type (always f32 for now)\n    return { rank: 0, action: 'none' };\n  }\n\n  return INFINITE_RANK;\n}\n\nfunction getImplicitConversionRank(\n  src: AnyData,\n  dest: AnyData,\n): ConversionRankInfo {\n  const trueSrc = unwrapDecorated(src);\n  const trueDst = unwrapDecorated(dest);\n\n  if (\n    trueSrc.type === 'ptr' &&\n    getAutoConversionRank(trueSrc.inner as AnyData, trueDst).rank <\n      Number.POSITIVE_INFINITY\n  ) {\n    return { rank: 0, action: 'deref' };\n  }\n\n  if (\n    trueDst.type === 'ptr' &&\n    getAutoConversionRank(trueSrc, trueDst.inner as AnyData).rank <\n      Number.POSITIVE_INFINITY\n  ) {\n    return { rank: 1, action: 'ref' };\n  }\n\n  const primitivePreference = {\n    f32: 0,\n    f16: 1,\n    i32: 2,\n    u32: 3,\n    bool: 4,\n  } as const;\n  type PrimitiveType = keyof typeof primitivePreference;\n\n  if (\n    trueSrc.type in primitivePreference &&\n    trueDst.type in primitivePreference\n  ) {\n    const srcType = trueSrc.type as PrimitiveType;\n    const destType = trueDst.type as PrimitiveType;\n\n    if (srcType !== destType) {\n      const srcPref = primitivePreference[srcType];\n      const destPref = primitivePreference[destType];\n\n      const rank = destPref < srcPref ? 10 : 20;\n\n      return { rank: rank, action: 'cast', targetType: trueDst };\n    }\n  }\n\n  return INFINITE_RANK;\n}\n\nfunction getConversionRank(\n  src: AnyData,\n  dest: AnyData,\n  allowImplicit: boolean,\n): ConversionRankInfo {\n  const autoRank = getAutoConversionRank(src, dest);\n  if (autoRank.rank < Number.POSITIVE_INFINITY) {\n    return autoRank;\n  }\n  if (allowImplicit) {\n    return getImplicitConversionRank(src, dest);\n  }\n  return INFINITE_RANK;\n}\n\nexport type ConversionResultAction = {\n  sourceIndex: number;\n  action: ConversionAction;\n  targetType?: U32 | F32 | I32 | F16;\n};\n\nexport type ConversionResult = {\n  targetType: AnyData;\n  actions: ConversionResultAction[];\n  hasImplicitConversions?: boolean;\n};\n\nfunction findBestType(\n  types: AnyData[],\n  uniqueTypes: AnyData[],\n  allowImplicit: boolean,\n): ConversionResult | undefined {\n  let bestType: AnyData | undefined;\n  let minSum = Number.POSITIVE_INFINITY;\n  const conversionDetails = new Map<AnyData, ConversionRankInfo[]>();\n\n  for (const targetType of uniqueTypes) {\n    let currentSum = 0;\n    const currentDetails: ConversionRankInfo[] = [];\n    let possible = true;\n\n    for (const sourceType of types) {\n      const conversion = getConversionRank(\n        sourceType,\n        targetType,\n        allowImplicit,\n      );\n      if (conversion.rank === Number.POSITIVE_INFINITY) {\n        possible = false;\n        break;\n      }\n      currentSum += conversion.rank;\n      currentDetails.push(conversion);\n    }\n\n    if (possible && currentSum < minSum) {\n      minSum = currentSum;\n      bestType = targetType;\n      conversionDetails.set(bestType, currentDetails);\n    }\n  }\n\n  if (!bestType) {\n    return undefined;\n  }\n\n  const bestDetails = conversionDetails.get(bestType) as ConversionRankInfo[];\n  const actions: ConversionResultAction[] = bestDetails.map(\n    (detail, index) => ({\n      sourceIndex: index,\n      action: detail.action,\n      ...(detail.action === 'cast' && {\n        targetType: detail.targetType as U32 | F32 | I32 | F16,\n      }),\n    }),\n  );\n\n  const hasCasts = actions.some((action) => action.action === 'cast');\n\n  return { targetType: bestType, actions, hasImplicitConversions: hasCasts };\n}\n\nexport function concretize(type: AnyWgslData): AnyWgslData {\n  if (type.type === 'abstractFloat') {\n    return f32;\n  }\n\n  if (type.type === 'abstractInt') {\n    return i32;\n  }\n\n  return type;\n}\n\nexport function getBestConversion(\n  types: AnyData[],\n  targetTypes?: AnyData[],\n): ConversionResult | undefined {\n  if (types.length === 0) return undefined;\n\n  const uniqueTypes = [...new Set(types.map(unwrapDecorated))];\n  const uniqueTargetTypes = targetTypes\n    ? [...new Set(targetTypes.map(unwrapDecorated))]\n    : uniqueTypes;\n\n  const explicitResult = findBestType(types, uniqueTargetTypes, false);\n  if (explicitResult) {\n    return explicitResult;\n  }\n\n  const implicitResult = findBestType(types, uniqueTargetTypes, true);\n  if (implicitResult) {\n    implicitResult.hasImplicitConversions = implicitResult.actions.some(\n      (action) => action.action === 'cast',\n    );\n    return implicitResult;\n  }\n\n  return undefined;\n}\n\nexport function convertType(\n  sourceType: AnyData,\n  targetType: AnyData,\n  allowImplicit = true,\n): ConversionResult | undefined {\n  const conversion = getConversionRank(sourceType, targetType, allowImplicit);\n\n  if (conversion.rank < Number.POSITIVE_INFINITY) {\n    const actionDetail: ConversionResultAction = {\n      sourceIndex: 0,\n      action: conversion.action,\n    };\n    if (conversion.action === 'cast') {\n      actionDetail.targetType = conversion.targetType as U32 | F32 | I32 | F16;\n    }\n    return {\n      targetType: unwrapDecorated(targetType),\n      actions: [actionDetail],\n      hasImplicitConversions: conversion.action === 'cast',\n    };\n  }\n\n  return undefined;\n}\n\nexport type GenerationCtx = ResolutionCtx & {\n  readonly pre: string;\n  readonly callStack: unknown[];\n  indent(): string;\n  dedent(): string;\n  pushBlockScope(): void;\n  popBlockScope(): void;\n  getById(id: string): Snippet | null;\n  defineVariable(id: string, dataType: AnyWgslData | UnknownData): Snippet;\n};\n\nfunction applyActionToSnippet(\n  ctx: GenerationCtx,\n  value: Snippet,\n  action: ConversionResultAction,\n  targetType: AnyData,\n): Snippet {\n  if (action.action === 'none') {\n    return snip(value.value, targetType);\n  }\n\n  const resolvedValue = ctx.resolve(value.value);\n\n  switch (action.action) {\n    case 'ref':\n      return snip(`&${resolvedValue}`, targetType);\n    case 'deref':\n      return snip(`*${resolvedValue}`, targetType);\n    case 'cast': {\n      return snip(`${ctx.resolve(targetType)}(${resolvedValue})`, targetType);\n    }\n    default: {\n      assertExhaustive(action.action, 'applyActionToSnippet');\n    }\n  }\n}\n\nexport function convertToCommonType(\n  ctx: GenerationCtx,\n  values: Snippet[],\n  restrictTo?: AnyData[],\n): Snippet[] | undefined {\n  const types = values.map((value) => value.dataType);\n\n  if (types.some((type) => type === UnknownData)) {\n    return undefined;\n  }\n\n  const conversion = getBestConversion(types as AnyData[], restrictTo);\n  if (!conversion) {\n    return undefined;\n  }\n\n  if (conversion.hasImplicitConversions) {\n    console.warn(\n      `Implicit conversions from [\\n${\n        values\n          .map((v) => `  ${v.value}: ${v.dataType.type}`)\n          .join(\n            ',\\n',\n          )\n      }\\n] to ${conversion.targetType.type} are supported, but not recommended.\nConsider using explicit conversions instead.`,\n    );\n  }\n\n  return values.map((value, index) => {\n    const action = conversion.actions[index];\n    invariant(action, 'Action should not be undefined');\n    return applyActionToSnippet(ctx, value, action, conversion.targetType);\n  });\n}\n\nexport function convertStructValues(\n  ctx: GenerationCtx,\n  structType: AnyWgslStruct,\n  values: Record<string, Snippet>,\n): Snippet[] {\n  const propKeys = Object.keys(structType.propTypes);\n\n  return propKeys.map((key) => {\n    const val = values[key];\n    if (!val) {\n      throw new Error(`Missing property ${key}`);\n    }\n\n    const targetType = structType.propTypes[key];\n    const converted = convertToCommonType(ctx, [val], [targetType as AnyData]);\n    return converted?.[0] ?? val;\n  });\n}\n\nexport function coerceToSnippet(value: unknown): Snippet {\n  if (isSnippet(value)) {\n    // Already a snippet\n    return value;\n  }\n\n  if (hasInternalDataType(value)) {\n    // The value knows better about what type it is\n    return snip(value, value[$wgslDataType] as AnyData);\n  }\n\n  if (isVecInstance(value) || isMatInstance(value)) {\n    return snip(value, kindToSchema[value.kind]);\n  }\n\n  if (Array.isArray(value)) {\n    const coerced = value.map(coerceToSnippet).filter(Boolean);\n    const context = getResolutionCtx() as GenerationCtx | undefined;\n    if (!context) {\n      throw new Error('Tried to coerce array without a context');\n    }\n\n    const converted = convertToCommonType(context, coerced as Snippet[]);\n    const commonType = getBestConversion(\n      coerced.map((v) => v.dataType as AnyData),\n    )?.targetType as AnyWgslData | undefined;\n\n    if (!converted || !commonType) {\n      return snip(value, UnknownData);\n    }\n\n    return snip(\n      converted.map((v) => v.value).join(', '),\n      arrayOf(concretize(commonType), value.length),\n    );\n  }\n\n  if (\n    typeof value === 'string' || typeof value === 'function' ||\n    typeof value === 'object' || typeof value === 'symbol' ||\n    typeof value === 'undefined' || value === null\n  ) {\n    // Nothing representable in WGSL as-is, so unknown\n    return snip(value, UnknownData);\n  }\n\n  if (typeof value === 'number' || typeof value === 'bigint') {\n    return snip(\n      value,\n      numericLiteralToSnippet(String(value))?.dataType ?? UnknownData,\n    );\n  }\n\n  if (typeof value === 'boolean') {\n    return snip(value, bool);\n  }\n\n  return snip(value, UnknownData);\n}\n","import type { AnyData } from '../data/dataTypes.ts';\nimport type { BaseData } from '../data/wgslTypes.ts';\nimport {\n  extractGpuValueGetter,\n  type GpuValueGetter,\n} from '../extractGpuValueGetter.ts';\nimport { getName } from '../shared/meta.ts';\nimport { $providing, $wgslDataType } from '../shared/symbols.ts';\nimport { getTypeForPropAccess } from '../tgsl/generationHelpers.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../types.ts';\n\nexport const valueProxyHandler: ProxyHandler<\n  & SelfResolvable\n  & { readonly [$wgslDataType]: BaseData }\n> = {\n  get(target, prop) {\n    if (prop in target) {\n      return Reflect.get(target, prop);\n    }\n\n    if (prop === $providing) {\n      return undefined;\n    }\n\n    if (\n      prop === 'toString' ||\n      prop === Symbol.toStringTag ||\n      prop === Symbol.toPrimitive\n    ) {\n      return () => target.toString();\n    }\n\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) =>\n          `${ctx.resolve(target)}.${String(prop)}`,\n\n        toString: () =>\n          `.value(...).${String(prop)}:${getName(target) ?? '<unnamed>'}`,\n\n        [$wgslDataType]: getTypeForPropAccess(\n          target[$wgslDataType] as AnyData,\n          String(prop),\n        ) as BaseData,\n      },\n      valueProxyHandler,\n    );\n  },\n};\n\nexport function getGpuValueRecursively<T>(\n  ctx: ResolutionCtx,\n  value: unknown,\n): T {\n  let unwrapped = value;\n  let valueGetter: GpuValueGetter | undefined;\n\n  // biome-ignore lint/suspicious/noAssignInExpressions: it's exactly what we want biome\n  while (valueGetter = extractGpuValueGetter(unwrapped)) {\n    unwrapped = valueGetter(ctx);\n  }\n\n  return unwrapped as T;\n}\n","import type { AnyWgslData } from '../../data/wgslTypes.ts';\nimport { inGPUMode } from '../../gpuMode.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { InferGPU } from '../../shared/repr.ts';\nimport { $gpuValueOf, $internal, $wgslDataType } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuConst<TDataType extends AnyWgslData = AnyWgslData>\n  extends TgpuNamable {\n  readonly value: InferGPU<TDataType>;\n  readonly $: InferGPU<TDataType>;\n\n  readonly [$internal]: {\n    readonly dataType: TDataType;\n  };\n}\n\n/**\n * Creates a module constant with specified value.\n */\nexport function constant<TDataType extends AnyWgslData>(\n  dataType: TDataType,\n  value: InferGPU<TDataType>,\n): TgpuConst<TDataType> {\n  return new TgpuConstImpl(dataType, value);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuConstImpl<TDataType extends AnyWgslData>\n  implements TgpuConst<TDataType>, SelfResolvable {\n  public readonly [$internal]: {\n    readonly dataType: TDataType;\n  };\n\n  constructor(\n    public readonly dataType: TDataType,\n    private readonly _value: InferGPU<TDataType>,\n  ) {\n    this[$internal] = { dataType };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const resolvedValue = ctx.resolveValue(this._value, this.dataType);\n    const resolvedDataType = ctx.resolve(this.dataType);\n\n    ctx.addDeclaration(`const ${id}: ${resolvedDataType} = ${resolvedValue};`);\n\n    return id;\n  }\n\n  toString() {\n    return `const:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): InferGPU<TDataType> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this.dataType,\n      },\n      valueProxyHandler,\n    ) as InferGPU<TDataType>;\n  }\n\n  get value(): InferGPU<TDataType> {\n    if (!inGPUMode()) {\n      return this._value;\n    }\n\n    return this[$gpuValueOf]();\n  }\n\n  get $(): InferGPU<TDataType> {\n    return this.value;\n  }\n}\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $gpuRepr,\n  $internal,\n  $providing,\n  $repr,\n} from '../../shared/symbols.ts';\nimport type { TgpuFn } from '../function/tgpuFn.ts';\nimport type { TgpuBufferUsage } from './../buffer/bufferUsage.ts';\n\nexport interface TgpuSlot<T> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'slot';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<T>;\n  readonly [$gpuRepr]: InferGPU<T>;\n  // ---\n\n  readonly defaultValue: T | undefined;\n\n  /**\n   * Used to determine if code generated using either value `a` or `b` in place\n   * of the slot will be equivalent. Defaults to `Object.is`.\n   */\n  areEqual(a: T, b: T): boolean;\n\n  readonly value: InferGPU<T>;\n  readonly $: InferGPU<T>;\n}\n\nexport interface TgpuDerived<T> {\n  readonly resourceType: 'derived';\n  readonly value: InferGPU<T>;\n  readonly $: InferGPU<T>;\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<T>;\n  readonly [$gpuRepr]: InferGPU<T>;\n  readonly [$providing]?: Providing | undefined;\n  // ---\n\n  with<TValue>(slot: TgpuSlot<TValue>, value: Eventual<TValue>): TgpuDerived<T>;\n\n  /**\n   * @internal\n   */\n  '~compute'(): T;\n}\n\nexport interface TgpuAccessor<T extends AnyData = AnyData> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'accessor';\n\n  // Type-tokens, not available at runtime\n  readonly [$repr]: Infer<T>;\n  readonly [$gpuRepr]: InferGPU<T>;\n  // ---\n\n  readonly schema: T;\n  readonly defaultValue:\n    | TgpuFn<() => T>\n    | TgpuBufferUsage<T>\n    | Infer<T>\n    | undefined;\n  readonly slot: TgpuSlot<TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>>;\n\n  readonly value: InferGPU<T>;\n  readonly $: InferGPU<T>;\n}\n\n/**\n * Represents a value that is available at resolution time.\n */\nexport type Eventual<T> = T | TgpuSlot<T> | TgpuDerived<T>;\n\nexport type SlotValuePair<T = unknown> = [TgpuSlot<T>, T];\n\nexport type Providing = {\n  inner: unknown;\n  pairs: SlotValuePair[];\n};\n\nexport function isSlot<T>(value: unknown | TgpuSlot<T>): value is TgpuSlot<T> {\n  return (value as TgpuSlot<T>)?.resourceType === 'slot';\n}\n\nexport function isDerived<T extends TgpuDerived<unknown>>(\n  value: T | unknown,\n): value is T {\n  return (value as T)?.resourceType === 'derived';\n}\n\nexport function isProviding(\n  value: unknown,\n): value is { [$providing]: Providing } {\n  return (value as { [$providing]: Providing })?.[$providing] !== undefined;\n}\n\nexport function isAccessor<T extends AnyData>(\n  value: unknown | TgpuAccessor<T>,\n): value is TgpuAccessor<T> {\n  return (value as TgpuAccessor<T>)?.resourceType === 'accessor';\n}\n","import type { Block } from 'tinyest';\nimport type {\n  TgpuBufferMutable,\n  TgpuBufferReadonly,\n  TgpuBufferUniform,\n  TgpuBufferUsage,\n} from './core/buffer/bufferUsage.ts';\nimport type { TgpuConst } from './core/constant/tgpuConstant.ts';\nimport type { TgpuDeclare } from './core/declare/tgpuDeclare.ts';\nimport type { TgpuComputeFn } from './core/function/tgpuComputeFn.ts';\nimport type { TgpuFn } from './core/function/tgpuFn.ts';\nimport type { TgpuFragmentFn } from './core/function/tgpuFragmentFn.ts';\nimport type { TgpuVertexFn } from './core/function/tgpuVertexFn.ts';\nimport type { TgpuComputePipeline } from './core/pipeline/computePipeline.ts';\nimport type { TgpuRenderPipeline } from './core/pipeline/renderPipeline.ts';\nimport type { TgpuSampler } from './core/sampler/sampler.ts';\nimport {\n  type Eventual,\n  isDerived,\n  isProviding,\n  isSlot,\n  type SlotValuePair,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from './core/slot/slotTypes.ts';\nimport type { TgpuExternalTexture } from './core/texture/externalTexture.ts';\nimport type {\n  TgpuAnyTextureView,\n  TgpuTexture,\n} from './core/texture/texture.ts';\nimport type { TgpuVar } from './core/variable/tgpuVariable.ts';\nimport type { AnyData, Snippet, UnknownData } from './data/dataTypes.ts';\nimport {\n  type AnyMatInstance,\n  type AnyVecInstance,\n  type AnyWgslData,\n  type BaseData,\n  isWgslData,\n} from './data/wgslTypes.ts';\nimport type { NameRegistry } from './nameRegistry.ts';\nimport type { Infer, InferGPU } from './shared/repr.ts';\nimport { $internal } from './shared/symbols.ts';\nimport type {\n  TgpuBindGroupLayout,\n  TgpuLayoutEntry,\n} from './tgpuBindGroupLayout.ts';\n\nexport type ResolvableObject =\n  | SelfResolvable\n  | TgpuBufferUsage\n  | TgpuConst\n  | TgpuDeclare\n  | TgpuFn\n  | TgpuComputeFn\n  | TgpuFragmentFn\n  | TgpuComputePipeline\n  | TgpuRenderPipeline\n  | TgpuVertexFn\n  | TgpuSampler\n  | TgpuAccessor\n  | TgpuExternalTexture\n  | TgpuTexture\n  | TgpuAnyTextureView\n  | TgpuVar\n  | AnyVecInstance\n  | AnyMatInstance\n  | AnyData\n  | TgpuFn;\n\nexport type Wgsl = Eventual<string | number | boolean | ResolvableObject>;\n\nexport type TgpuShaderStage = 'compute' | 'vertex' | 'fragment';\n\nexport interface FnToWgslOptions {\n  args: Snippet[];\n  argAliases: Record<string, Snippet>;\n  returnType: AnyData;\n  body: Block;\n  externalMap: Record<string, unknown>;\n}\n\nexport type ItemLayer = {\n  type: 'item';\n  usedSlots: Set<TgpuSlot<unknown>>;\n};\n\nexport interface ItemStateStack {\n  readonly itemDepth: number;\n  readonly topItem: ItemLayer;\n\n  pushItem(): void;\n  popItem(): void;\n  pushSlotBindings(pairs: SlotValuePair<unknown>[]): void;\n  popSlotBindings(): void;\n  pushFunctionScope(\n    args: Snippet[],\n    argAliases: Record<string, Snippet>,\n    returnType: AnyData,\n    externalMap: Record<string, unknown>,\n  ): void;\n  popFunctionScope(): void;\n  pushBlockScope(): void;\n  popBlockScope(): void;\n  pop(type?: 'functionScope' | 'blockScope' | 'slotBinding' | 'item'): void;\n  readSlot<T>(slot: TgpuSlot<T>): T | undefined;\n  getSnippetById(id: string): Snippet | undefined;\n  defineBlockVariable(id: string, type: AnyWgslData | UnknownData): Snippet;\n}\n\n/**\n * Passed into each resolvable item. All items in a tree share a resolution ctx,\n * but there can be layers added and removed from the item stack when going down\n * and up the tree.\n */\nexport interface ResolutionCtx {\n  readonly names: NameRegistry;\n\n  addDeclaration(declaration: string): void;\n\n  /**\n   * Reserves a bind group number, and returns a placeholder that will be replaced\n   * with a concrete number at the end of the resolution process.\n   */\n  allocateLayoutEntry(layout: TgpuBindGroupLayout): string;\n\n  /**\n   * Reserves a spot in the catch-all bind group, without the indirection of a bind-group.\n   * This means the resource is 'fixed', and cannot be swapped between code execution.\n   */\n  allocateFixedEntry(\n    layoutEntry: TgpuLayoutEntry,\n    resource: object,\n  ): {\n    group: string;\n    binding: number;\n  };\n\n  withSlots<T>(pairs: SlotValuePair<unknown>[], callback: () => T): T;\n\n  /**\n   * Unwraps all layers of slot/derived indirection and returns the concrete value if available.\n   * @throws {MissingSlotValueError}\n   */\n  unwrap<T>(eventual: Eventual<T>): T;\n\n  resolve(item: unknown): string;\n  resolveValue<T extends BaseData>(\n    value: Infer<T> | InferGPU<T>,\n    schema: T,\n  ): string;\n\n  fnToWgsl(options: FnToWgslOptions): {\n    head: Wgsl;\n    body: Wgsl;\n  };\n\n  withVaryingLocations<T>(\n    locations: Record<string, number>,\n    callback: () => T,\n  ): T;\n  get varyingLocations(): Record<string, number> | undefined;\n\n  [$internal]: {\n    itemStateStack: ItemStateStack;\n  };\n}\n\n/**\n * Houses a method '~resolve` that returns a code string\n * representing it, as opposed to offloading the resolution\n * to another mechanism.\n */\nexport interface SelfResolvable {\n  '~resolve'(ctx: ResolutionCtx): string;\n  toString(): string;\n}\n\nexport function isSelfResolvable(value: unknown): value is SelfResolvable {\n  return typeof (value as SelfResolvable)?.['~resolve'] === 'function';\n}\n\nexport function isWgsl(value: unknown): value is Wgsl {\n  return (\n    typeof value === 'number' ||\n    typeof value === 'boolean' ||\n    typeof value === 'string' ||\n    isSelfResolvable(value) ||\n    isWgslData(value) ||\n    isSlot(value) ||\n    isDerived(value) ||\n    isProviding(value)\n  );\n}\n\nexport type BindableBufferUsage = 'uniform' | 'readonly' | 'mutable';\nexport type BufferUsage = 'uniform' | 'readonly' | 'mutable' | 'vertex';\nexport type DefaultConversionStrategy = 'keep' | 'coerce';\n\nexport type FnArgsConversionHint =\n  | AnyData[]\n  | ((...args: Snippet[]) => AnyWgslData[])\n  | DefaultConversionStrategy\n  | undefined;\n\nexport function isGPUBuffer(value: unknown): value is GPUBuffer {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'getMappedRange' in value &&\n    'mapAsync' in value\n  );\n}\n\nexport function isBufferUsage<\n  T extends\n    | TgpuBufferUniform<BaseData>\n    | TgpuBufferReadonly<BaseData>\n    | TgpuBufferMutable<BaseData>,\n>(value: T | unknown): value is T {\n  return (value as T)?.resourceType === 'buffer-usage';\n}\n\nexport function isMarkedInternal(\n  value: unknown,\n): value is { [$internal]: Record<string, unknown> } {\n  return !!(value as { [$internal]: Record<string, unknown> })?.[$internal];\n}\n","import { isLooseData } from '../../data/dataTypes.ts';\nimport { isWgslStruct } from '../../data/wgslTypes.ts';\nimport { getName, isNamable } from '../../shared/meta.ts';\nimport { isWgsl, type ResolutionCtx } from '../../types.ts';\n\n/**\n * A key-value mapping where keys represent identifiers within shader code,\n * and values can be any type that can be resolved to a code string.\n */\nexport type ExternalMap = Record<string, unknown>;\n\n/**\n * Merges two external maps into one. If a key is present in both maps, the value from the new map is used.\n * If the external value is a namable object, it is given a name if it does not already have one.\n * @param existing - The existing external map.\n * @param newExternals - The new external map.\n */\nexport function applyExternals(\n  existing: ExternalMap,\n  newExternals: ExternalMap,\n) {\n  for (const [key, value] of Object.entries(newExternals)) {\n    existing[key] = value;\n\n    // Giving name to external value, if it does not already have one.\n    if (isNamable(value) && getName(value) === undefined) {\n      value.$name(key);\n    }\n  }\n}\n\nexport function addArgTypesToExternals(\n  implementation: string,\n  argTypes: unknown[],\n  applyExternals: (externals: ExternalMap) => void,\n) {\n  const argTypeNames = [\n    ...implementation.matchAll(/:\\s*(?<arg>.*?)\\s*[,)]/g),\n  ].map((found) => (found ? found[1] : undefined));\n\n  applyExternals(\n    Object.fromEntries(\n      argTypes.flatMap((argType, i) => {\n        const argTypeName = argTypeNames ? argTypeNames[i] : undefined;\n        return isWgslStruct(argType) && argTypeName !== undefined\n          ? [[argTypeName, argType]]\n          : [];\n      }),\n    ),\n  );\n}\n\nexport function addReturnTypeToExternals(\n  implementation: string,\n  returnType: unknown,\n  applyExternals: (externals: ExternalMap) => void,\n) {\n  const matched = implementation.match(/->\\s(?<output>[\\w\\d_]+)\\s{/);\n  const outputName = matched ? matched[1]?.trim() : undefined;\n\n  if (isWgslStruct(returnType) && outputName && !/\\s/g.test(outputName)) {\n    applyExternals({ [outputName]: returnType });\n  }\n}\n\nfunction identifierRegex(name: string) {\n  return new RegExp(\n    `(?<![\\\\w\\\\$_.])${\n      name.replaceAll('.', '\\\\.').replaceAll('$', '\\\\$')\n    }(?![\\\\w\\\\$_])`,\n    'g',\n  );\n}\n\n/**\n * Replaces all occurrences of external names in WGSL code with their resolved values.\n * It adds all necessary definitions to the resolution context.\n * @param ctx - The resolution context.\n * @param externalMap - The external map.\n * @param wgsl - The WGSL code.\n *\n * @returns The WGSL code with all external names replaced with their resolved values.\n */\nexport function replaceExternalsInWgsl(\n  ctx: ResolutionCtx,\n  externalMap: ExternalMap,\n  wgsl: string,\n): string {\n  return Object.entries(externalMap).reduce((acc, [externalName, external]) => {\n    if (isWgsl(external) || isLooseData(external)) {\n      return acc.replaceAll(\n        identifierRegex(externalName),\n        ctx.resolve(external),\n      );\n    }\n\n    if (external !== null && typeof external === 'object') {\n      const foundProperties = [\n        ...wgsl.matchAll(\n          new RegExp(\n            `${\n              externalName.replaceAll('.', '\\\\.').replaceAll('$', '\\\\$')\n            }\\\\.(?<prop>.*?)(?![\\\\w\\\\$_])`,\n            'g',\n          ),\n        ),\n      ].map((found) => found[1]) ?? [];\n\n      return foundProperties.reduce(\n        (innerAcc: string, prop) =>\n          prop && prop in external\n            ? replaceExternalsInWgsl(\n              ctx,\n              {\n                [`${externalName}.${prop}`]:\n                  external[prop as keyof typeof external],\n              },\n              innerAcc,\n            )\n            : innerAcc,\n        acc,\n      );\n    }\n\n    return acc;\n  }, wgsl);\n}\n","import type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport {\n  applyExternals,\n  type ExternalMap,\n  replaceExternalsInWgsl,\n} from '../resolve/externals.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Extra declaration that shall be included in final WGSL code,\n * when resolving objects that use it.\n */\nexport interface TgpuDeclare {\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\n/**\n * Allows defining extra declarations that shall be included in the final WGSL code,\n * when resolving objects that use them.\n *\n * Using this API is generally discouraged, as it shouldn't be necessary in any common scenario.\n * It was developed to ensure full compatibility of TypeGPU programs with current and future versions of WGSL.\n */\nexport function declare(declaration: string): TgpuDeclare {\n  return new TgpuDeclareImpl(declaration);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuDeclareImpl implements TgpuDeclare, SelfResolvable {\n  private externalsToApply: ExternalMap[] = [];\n\n  constructor(private declaration: string) {}\n\n  $uses(dependencyMap: Record<string, unknown>): this {\n    this.externalsToApply.push(dependencyMap);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const externalMap: ExternalMap = {};\n\n    for (const externals of this.externalsToApply) {\n      applyExternals(externalMap, externals);\n    }\n\n    const replacedDeclaration = replaceExternalsInWgsl(\n      ctx,\n      externalMap,\n      this.declaration,\n    );\n\n    ctx.addDeclaration(replacedDeclaration);\n    return '';\n  }\n\n  toString() {\n    return `declare: ${this.declaration}`;\n  }\n}\n","import { FuncParameterType } from 'tinyest';\nimport { getAttributesString } from '../../data/attributes.ts';\nimport { type AnyData, snip } from '../../data/dataTypes.ts';\nimport {\n  type AnyWgslStruct,\n  isWgslData,\n  isWgslStruct,\n  Void,\n} from '../../data/wgslTypes.ts';\nimport { MissingLinksError } from '../../errors.ts';\nimport { getMetaData, getName, setName } from '../../shared/meta.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport {\n  applyExternals,\n  type ExternalMap,\n  replaceExternalsInWgsl,\n} from '../resolve/externals.ts';\nimport { extractArgs } from './extractArgs.ts';\nimport type { Implementation } from './fnTypes.ts';\n\nexport interface FnCore {\n  applyExternals(newExternals: ExternalMap): void;\n  resolve(\n    ctx: ResolutionCtx,\n    argTypes: AnyData[],\n    returnType: AnyData,\n  ): string;\n}\n\nexport function createFnCore(\n  implementation: Implementation,\n  fnAttribute = '',\n): FnCore {\n  /**\n   * External application has to be deferred until resolution because\n   * some externals can reference the owner function which has not been\n   * initialized yet (like when accessing the Output struct of a vertex\n   * entry fn).\n   */\n  const externalsToApply: ExternalMap[] = [];\n\n  const core = {\n    applyExternals(newExternals: ExternalMap): void {\n      externalsToApply.push(newExternals);\n    },\n\n    resolve(\n      ctx: ResolutionCtx,\n      argTypes: AnyData[],\n      returnType: AnyData,\n    ): string {\n      const externalMap: ExternalMap = {};\n\n      for (const externals of externalsToApply) {\n        applyExternals(externalMap, externals);\n      }\n\n      const id = ctx.names.makeUnique(getName(this));\n\n      if (typeof implementation === 'string') {\n        const replacedImpl = replaceExternalsInWgsl(\n          ctx,\n          externalMap,\n          implementation,\n        );\n\n        let header = '';\n        let body = '';\n\n        if (fnAttribute !== '') {\n          const input = isWgslStruct(argTypes[0])\n            ? `(in: ${ctx.resolve(argTypes[0])})`\n            : '()';\n\n          const attributes = isWgslData(returnType)\n            ? getAttributesString(returnType)\n            : '';\n          const output = returnType !== Void\n            ? isWgslStruct(returnType)\n              ? `-> ${ctx.resolve(returnType)}`\n              : `-> ${attributes !== '' ? attributes : '@location(0)'} ${\n                ctx.resolve(returnType)\n              }`\n            : '';\n\n          header = `${input} ${output} `;\n          body = replacedImpl;\n        } else {\n          const providedArgs = extractArgs(replacedImpl);\n\n          if (providedArgs.args.length !== argTypes.length) {\n            throw new Error(\n              `WGSL implementation has ${providedArgs.args.length} arguments, while the shell has ${argTypes.length} arguments.`,\n            );\n          }\n\n          const input = providedArgs.args.map((argInfo, i) =>\n            `${argInfo.identifier}: ${\n              checkAndReturnType(\n                ctx,\n                `parameter ${argInfo.identifier}`,\n                argInfo.type,\n                argTypes[i],\n              )\n            }`\n          ).join(', ');\n\n          const output = returnType === Void ? '' : `-> ${\n            checkAndReturnType(\n              ctx,\n              'return type',\n              providedArgs.ret?.type,\n              returnType,\n            )\n          }`;\n\n          header = `(${input}) ${output}`;\n\n          body = replacedImpl.slice(providedArgs.range.end);\n        }\n\n        ctx.addDeclaration(`${fnAttribute}fn ${id}${header}${body}`);\n      } else {\n        // get data generated by the plugin\n        const pluginData = getMetaData(implementation);\n\n        if (pluginData?.externals) {\n          const missing = Object.fromEntries(\n            Object.entries(pluginData.externals).filter(\n              ([name]) => !(name in externalMap),\n            ),\n          );\n\n          applyExternals(externalMap, missing);\n        }\n\n        const ast = pluginData?.ast;\n        if (!ast) {\n          throw new Error(\n            \"Missing metadata for tgpu.fn function body (either missing 'kernel' directive, or misconfigured `unplugin-typegpu`)\",\n          );\n        }\n\n        // verify all required externals are present\n        const missingExternals = ast.externalNames.filter(\n          (name) => !(name in externalMap),\n        );\n        if (missingExternals.length > 0) {\n          throw new MissingLinksError(getName(this), missingExternals);\n        }\n\n        // generate wgsl string\n        const { head, body } = ctx.fnToWgsl({\n          args: argTypes.map((arg, i) =>\n            snip(\n              ast.params[i]?.type === FuncParameterType.identifier\n                ? ast.params[i].name\n                : `_arg_${i}`,\n              arg,\n            )\n          ),\n          argAliases: Object.fromEntries(\n            ast.params.flatMap((param, i) =>\n              param.type === FuncParameterType.destructuredObject\n                ? param.props.map(({ name, alias }) => [\n                  alias,\n                  snip(\n                    `_arg_${i}.${name}`,\n                    (argTypes[i] as AnyWgslStruct)\n                      .propTypes[name],\n                  ),\n                ])\n                : []\n            ),\n          ),\n          returnType,\n          body: ast.body,\n          externalMap,\n        });\n\n        ctx.addDeclaration(\n          `${fnAttribute}fn ${id}${ctx.resolve(head)}${ctx.resolve(body)}`,\n        );\n      }\n\n      return id;\n    },\n  };\n\n  // The implementation could have been given a name by a bundler plugin,\n  // so we try to transfer it to the core.\n  const maybeName = getName(implementation);\n  if (maybeName !== undefined) {\n    setName(core, maybeName);\n  }\n\n  return core;\n}\n\nfunction checkAndReturnType(\n  ctx: ResolutionCtx,\n  name: string,\n  wgslType: string | undefined,\n  jsType: unknown,\n) {\n  const resolvedJsType = ctx.resolve(jsType).replace(/\\s/g, '');\n\n  if (!wgslType) {\n    return resolvedJsType;\n  }\n\n  const resolvedWgslType = wgslType.replace(/\\s/g, '');\n\n  if (resolvedWgslType !== resolvedJsType) {\n    throw new Error(\n      `Type mismatch between TGPU shell and WGSL code string: ${name}, JS type \"${resolvedJsType}\", WGSL type \"${resolvedWgslType}\".`,\n    );\n  }\n\n  return wgslType;\n}\n","interface FunctionArgsInfo {\n  args: ArgInfo[];\n  ret: ReturnInfo | undefined;\n  range: {\n    begin: number;\n    end: number;\n  };\n}\n\ninterface ArgInfo {\n  identifier: string;\n  attributes: string[];\n  type: string | undefined;\n}\n\ninterface ReturnInfo {\n  attributes: string[];\n  type: string;\n}\n\n/**\n * Extracts info about arguments of a given WGSL function string.\n * @example\n * const code = `\n *   fn add(a: i32, ＠location(0) b: i32, c) -> i32 {\n *     return a + b + c;\n *   }`;\n *\n * extractArgs(code);\n * // {\n * //   args: [\n * //     { identifier: 'a', attributes: [], type: 'i32' },\n * //     { identifier: 'b', attributes: ['＠location(0)'], type: 'i32' },\n * //     { identifier: 'c', attributes: [], type: undefined }\n * //   ],\n * //   ret: { type: 'i32', attributes: [] },\n * //   range: { begin: 11, end: 51 }\n * // }\n */\nexport function extractArgs(rawCode: string): FunctionArgsInfo {\n  const { strippedCode, argRange: range } = strip(rawCode);\n  const code = new ParsableString(strippedCode);\n  code.consume('(');\n\n  const args: ArgInfo[] = [];\n  while (!code.isAt(')')) {\n    // In each loop iteration, process all the attributes, the identifier and the potential type of a single argument.\n\n    const attributes = [];\n    while (code.isAt('@')) {\n      code.parseUntil(closingParenthesis, parentheses);\n      code.consume(')');\n      attributes.push(code.lastParsed);\n    }\n\n    code.parseUntil(identifierEndSymbols);\n    const identifier = code.lastParsed;\n\n    let maybeType: string | undefined;\n    if (code.isAt(':')) {\n      code.consume(':');\n      code.parseUntil(typeEndSymbols, angleBrackets);\n      maybeType = code.lastParsed;\n    }\n\n    args.push({\n      identifier,\n      attributes,\n      type: maybeType,\n    });\n\n    if (code.isAt(',')) {\n      code.consume(',');\n    }\n  }\n  code.consume(')');\n\n  let maybeRet: ReturnInfo | undefined;\n  if (code.isAt('->')) {\n    code.consume('->');\n\n    const attributes = [];\n    while (code.isAt('@')) {\n      code.parseUntil(closingParenthesis, parentheses);\n      code.consume(')');\n      attributes.push(code.lastParsed);\n    }\n\n    maybeRet = { type: code.str.slice(code.pos), attributes };\n  }\n\n  return {\n    args,\n    ret: maybeRet,\n    range: { begin: range[0], end: range[1] },\n  };\n}\n\n/**\n * Strips comments, whitespaces, the name and the body of the function.\n * @example\n * const code = `\n *    fn add( a,  // first argument\n *            ＠location(0) b : i32 ) -> i32   {\n *        return a + b; // returns the sum\n *  }`;\n *\n * strip(code); // \"(a,@location(0)b:i32)->i32\"\n */\nfunction strip(\n  rawCode: string,\n): { strippedCode: string; argRange: [number, number] } {\n  const code = new ParsableString(rawCode);\n  let strippedCode = '';\n  let argsStart: number | undefined;\n\n  while (!code.isFinished()) {\n    // parse character by character while ignoring comments and blankspaces until you find a `{`.\n\n    // skip any blankspace\n    if (code.isAt(blankSpaces)) {\n      code.advanceBy(1); // the blankspace character\n      continue;\n    }\n\n    // skip line comments\n    if (code.isAt('//')) {\n      code.consume('//');\n      code.parseUntil(lineBreaks);\n      code.advanceBy(1); // the line break\n      continue;\n    }\n\n    // skip block comments\n    if (code.isAt('/*')) {\n      code.parseUntil(openingCommentBlock, commentBlocks);\n      code.consume('*/');\n      continue;\n    }\n\n    if (code.isAt('{')) {\n      return {\n        strippedCode,\n        argRange: [argsStart as number, code.pos],\n      };\n    }\n\n    if (code.isAt('(') && argsStart === undefined) {\n      argsStart = code.pos;\n    }\n\n    if (argsStart !== undefined) {\n      strippedCode += code.str[code.pos];\n    }\n    code.advanceBy(1); // parsed character\n  }\n  throw new Error('Invalid wgsl code!');\n}\n\nclass ParsableString {\n  #parseStartPos: number | undefined;\n  #pos: number;\n  constructor(public readonly str: string) {\n    this.#pos = 0;\n  }\n\n  get pos(): number {\n    return this.#pos;\n  }\n\n  /**\n   * This property is equivalent to the substring of `this.str`\n   * from the position of the last `parseUntil` call, to the current position.\n   */\n  get lastParsed(): string {\n    if (this.#parseStartPos === undefined) {\n      throw new Error('Parse was not called yet!');\n    }\n    return this.str.slice(this.#parseStartPos, this.pos);\n  }\n\n  isFinished() {\n    return this.#pos >= this.str.length;\n  }\n\n  isAt(substr: string | Set<string>): boolean {\n    if (typeof substr === 'string') {\n      for (let i = 0; i < substr.length; i++) {\n        if (this.str[this.#pos + i] !== substr[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    for (const elem of substr) {\n      if (this.isAt(elem)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @param toFind a set of strings either of which satisfy the search.\n   * @param brackets a pair of brackets that has to be closed for result to be valid. This includes the found character(s).\n   * @example\n   * // internal state:\n   * // '(@attribute(0) identifier: type)'\n   * //   ^\n   * this.parse(new Set(')'), ['(', ')']);\n   * // internal state:\n   * // '(@attribute(0) identifier: type)'\n   * //               ^\n   */\n  parseUntil(\n    toFind: Set<string>,\n    brackets?: readonly [string, string],\n  ): number {\n    this.#parseStartPos = this.#pos;\n    let openedBrackets = 0;\n    while (this.#pos < this.str.length) {\n      if (brackets && this.isAt(brackets[0])) {\n        openedBrackets += 1;\n      }\n      if (brackets && this.isAt(brackets[1])) {\n        openedBrackets -= 1;\n      }\n      if (openedBrackets === 0) {\n        if (this.isAt(toFind)) {\n          return this.#pos;\n        }\n      }\n      this.#pos += 1;\n    }\n    throw new Error('Reached the end of the string without finding a match!');\n  }\n\n  advanceBy(steps: number) {\n    this.#pos += steps;\n  }\n\n  consume(str: string): void {\n    if (!this.isAt(str)) {\n      throw new Error(\n        `Expected '${str}' at position ${this.#pos}, but found '${\n          this.str.slice(this.#pos, this.#pos + str.length)\n        }'`,\n      );\n    }\n    this.advanceBy(str.length);\n  }\n}\n\nconst lineBreaks = new Set<string>([\n  '\\u000A', // line feed\n  '\\u000B', // vertical tab\n  '\\u000C', // form feed\n  '\\u000D', // carriage return\n  '\\u0085', // next line\n  '\\u2028', // line separator\n  '\\u2029', // paragraph separator\n]);\nconst blankSpaces = new Set<string>([\n  ...lineBreaks,\n  '\\u0020', // space\n  '\\u0009', // horizontal tab\n  '\\u200E', // left-to-right mark\n  '\\u200F', // right-to-left mark\n]);\nconst closingParenthesis = new Set<string>([')']);\nconst identifierEndSymbols = new Set([':', ',', ')']);\nconst typeEndSymbols = new Set([',', ')']);\nconst openingCommentBlock = new Set(['*/']);\n\nconst parentheses = ['(', ')'] as const;\nconst angleBrackets = ['<', '>'] as const;\nconst commentBlocks = ['/*', '*/'] as const;\n","import {\n  type Decorate,\n  type HasCustomLocation,\n  type IsBuiltin,\n  location,\n} from '../../data/attributes.ts';\nimport { isBuiltin } from '../../data/attributes.ts';\nimport { getCustomLocation, isData } from '../../data/dataTypes.ts';\nimport { struct } from '../../data/struct.ts';\nimport {\n  type BaseData,\n  isVoid,\n  type Location,\n  type WgslStruct,\n} from '../../data/wgslTypes.ts';\nimport type { IOData, IOLayout, IORecord } from './fnTypes.ts';\n\nexport type WithLocations<T extends IORecord> = {\n  [Key in keyof T]: IsBuiltin<T[Key]> extends true ? T[Key]\n    : HasCustomLocation<T[Key]> extends true ? T[Key]\n    : Decorate<T[Key], Location>;\n};\n\nexport type IOLayoutToSchema<T extends IOLayout> = T extends BaseData\n  ? Decorate<T, Location<0>>\n  : T extends IORecord ? WgslStruct<WithLocations<T>>\n  // biome-ignore lint/suspicious/noConfusingVoidType: <it actually is void>\n  : T extends { type: 'void' } ? void\n  : never;\n\nexport function withLocations<T extends IOData>(\n  members: IORecord<T> | undefined,\n  locations: Record<string, number> = {},\n): WithLocations<IORecord<T>> {\n  let nextLocation = 0;\n  const usedCustomLocations = new Set<number>();\n\n  return Object.fromEntries(\n    Object.entries(members ?? {}).map(([key, member]) => {\n      const customLocation = getCustomLocation(member);\n\n      if (customLocation !== undefined) {\n        if (usedCustomLocations.has(customLocation)) {\n          throw new Error('Duplicate custom location attributes found');\n        }\n        usedCustomLocations.add(customLocation);\n      }\n\n      return [key, member] as const;\n    }).map(([key, member]) => {\n      if (isBuiltin(member)) { // skipping builtins\n        return [key, member];\n      }\n\n      if (getCustomLocation(member) !== undefined) { // this member is already marked\n        return [key, member];\n      }\n\n      if (locations[key]) { // location has been determined by a previous procedure\n        return [key, location(locations[key], member)];\n      }\n\n      while (usedCustomLocations.has(nextLocation)) {\n        nextLocation++;\n      }\n      return [key, location(nextLocation++, member)];\n    }),\n  );\n}\n\nexport function createIoSchema<\n  T extends IOData,\n  Layout extends IORecord<T> | IOLayout<T>,\n>(layout: Layout, locations: Record<string, number> = {}) {\n  return (\n    isData(layout)\n      ? isVoid(layout)\n        ? layout\n        : getCustomLocation(layout) !== undefined\n        ? layout\n        : location(0, layout)\n      : struct(withLocations(layout, locations) as Record<string, T>)\n  ) as IOLayoutToSchema<Layout>;\n}\n","import type { Implementation } from './fnTypes.ts';\n\nexport function stripTemplate(\n  arg: Implementation | TemplateStringsArray,\n  ...values: unknown[]\n): Implementation {\n  return isTemplateStringsArray(arg)\n    ? templateLiteralIdentity(arg, ...values)\n    : arg;\n}\n\nfunction isTemplateStringsArray(value: unknown): value is TemplateStringsArray {\n  return (\n    Array.isArray(value) &&\n    'raw' in value &&\n    Array.isArray(value.raw) &&\n    value.raw.every((item) => typeof item === 'string')\n  );\n}\n\nfunction templateLiteralIdentity(\n  strings: TemplateStringsArray,\n  ...values: unknown[]\n): string {\n  return strings\n    .slice(1)\n    .reduce(\n      (acc, elem, index) => `${acc}${values[index]}${elem}`,\n      strings[0] as string,\n    );\n}\n","import type { AnyComputeBuiltin } from '../../builtin.ts';\nimport { Void } from '../../data/wgslTypes.ts';\nimport {\n  getName,\n  isNamable,\n  setName,\n  type TgpuNamable,\n} from '../../shared/meta.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type { Implementation, InferIO, IORecord } from './fnTypes.ts';\nimport { createIoSchema, type IOLayoutToSchema } from './ioSchema.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Describes a compute entry function signature (its arguments, return type and workgroup size)\n */\ntype TgpuComputeFnShellHeader<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n> = {\n  readonly argTypes: [IOLayoutToSchema<ComputeIn>] | [];\n  readonly returnType: Void;\n  readonly workgroupSize: [number, number, number];\n  readonly isEntry: true;\n};\n\n/**\n * Describes a compute entry function signature (its arguments, return type and workgroup size).\n * Allows creating tgpu compute functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuComputeFnShell<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n> =\n  & TgpuComputeFnShellHeader<ComputeIn>\n  /**\n   * Creates a type-safe implementation of this signature\n   */\n  & ((\n    implementation: (input: InferIO<ComputeIn>) => undefined,\n  ) => TgpuComputeFn<ComputeIn>)\n  & /**\n   * @param implementation\n   *   Raw WGSL function implementation with header and body\n   *   without `fn` keyword and function name\n   *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n   */ ((implementation: string) => TgpuComputeFn<ComputeIn>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuComputeFn<ComputeIn>)\n  & {\n    /**\n     * @deprecated Invoke the shell as a function instead.\n     */\n    does:\n      & ((\n        implementation: (input: InferIO<ComputeIn>) => undefined,\n      ) => TgpuComputeFn<ComputeIn>)\n      & /**\n       * @param implementation\n       *   Raw WGSL function implementation with header and body\n       *   without `fn` keyword and function name\n       *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n       */ ((implementation: string) => TgpuComputeFn<ComputeIn>);\n  };\n\nexport interface TgpuComputeFn<\n  // biome-ignore lint/suspicious/noExplicitAny: to allow assigning any compute fn to TgpuComputeFn (non-generic) type\n  ComputeIn extends IORecord<AnyComputeBuiltin> = any,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly shell: TgpuComputeFnShellHeader<ComputeIn>;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\nexport interface ComputeFnOptions {\n  workgroupSize: number[];\n}\n\nexport function computeFn(options: {\n  workgroupSize: number[];\n  // biome-ignore lint/complexity/noBannedTypes: it's fine\n}): TgpuComputeFnShell<{}>;\n\nexport function computeFn<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n>(options: {\n  in: ComputeIn;\n  workgroupSize: number[];\n}): TgpuComputeFnShell<ComputeIn>;\n\n/**\n * Creates a shell of a typed entry function for the compute shader stage. Any function\n * that implements this shell can perform general-purpose computation.\n *\n * @param options.in\n *   Record with builtins used by the compute shader.\n * @param options.workgroupSize\n *   Size of blocks that the thread grid will be divided into (up to 3 dimensions).\n */\nexport function computeFn<\n  ComputeIn extends IORecord<AnyComputeBuiltin>,\n>(options: {\n  in?: ComputeIn;\n  workgroupSize: number[];\n}): TgpuComputeFnShell<ComputeIn> {\n  const shell: TgpuComputeFnShellHeader<ComputeIn> = {\n    argTypes: options.in && Object.keys(options.in).length !== 0\n      ? [createIoSchema(options.in)]\n      : [],\n    returnType: Void,\n    workgroupSize: [\n      options.workgroupSize[0] ?? 1,\n      options.workgroupSize[1] ?? 1,\n      options.workgroupSize[2] ?? 1,\n    ],\n    isEntry: true,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) =>\n    createComputeFn(\n      shell,\n      options.workgroupSize,\n      stripTemplate(arg, ...values),\n    );\n\n  return Object.assign(Object.assign(call, shell), {\n    does: call,\n  }) as TgpuComputeFnShell<ComputeIn>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction createComputeFn<ComputeIn extends IORecord<AnyComputeBuiltin>>(\n  shell: TgpuComputeFnShellHeader<ComputeIn>,\n  workgroupSize: number[],\n  implementation: Implementation,\n): TgpuComputeFn<ComputeIn> {\n  type This = TgpuComputeFn<ComputeIn> & SelfResolvable & {\n    [$internal]: true;\n    [$getNameForward]: FnCore;\n  };\n\n  const core = createFnCore(\n    implementation,\n    `@compute @workgroup_size(${workgroupSize.join(', ')}) `,\n  );\n  const inputType = shell.argTypes[0];\n\n  const result: This = {\n    shell,\n\n    $uses(newExternals) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$internal]: true,\n    [$getNameForward]: core,\n    $name(newLabel: string): This {\n      setName(core, newLabel);\n      if (isNamable(inputType)) {\n        inputType.$name(`${newLabel}_Input`);\n      }\n      return this;\n    },\n\n    '~resolve'(ctx: ResolutionCtx): string {\n      return core.resolve(\n        ctx,\n        shell.argTypes,\n        shell.returnType,\n      );\n    },\n\n    toString() {\n      return `computeFn:${getName(core) ?? '<unnamed>'}`;\n    },\n  };\n  return result;\n}\n","import { type AnyData, snip, UnknownData } from '../../data/dataTypes.ts';\nimport { schemaCallWrapper } from '../../data/utils.ts';\nimport { Void } from '../../data/wgslTypes.ts';\nimport { createDualImpl } from '../../shared/generators.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $internal,\n  $providing,\n} from '../../shared/symbols.ts';\nimport type { Prettify } from '../../shared/utilityTypes.ts';\nimport type { GenerationCtx } from '../../tgsl/generationHelpers.ts';\nimport type {\n  FnArgsConversionHint,\n  ResolutionCtx,\n  SelfResolvable,\n  Wgsl,\n} from '../../types.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport {\n  addArgTypesToExternals,\n  addReturnTypeToExternals,\n} from '../resolve/externals.ts';\nimport {\n  type Eventual,\n  isAccessor,\n  type Providing,\n  type SlotValuePair,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from '../slot/slotTypes.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type {\n  AnyFn,\n  Implementation,\n  InferArgs,\n  InferImplSchema,\n  InheritArgNames,\n} from './fnTypes.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\n/**\n * Describes a function signature (its arguments and return type)\n */\ntype TgpuFnShellHeader<\n  Args extends AnyData[],\n  Return extends AnyData,\n> = {\n  readonly [$internal]: true;\n  readonly argTypes: Args;\n  readonly returnType: Return;\n  readonly isEntry: false;\n};\n\n/**\n * Describes a function signature (its arguments and return type).\n * Allows creating tgpu functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuFnShell<\n  Args extends AnyData[],\n  Return extends AnyData,\n> =\n  & TgpuFnShellHeader<Args, Return>\n  & (<T extends (...args: InferArgs<Args>) => Infer<Return>>(\n    implementation: T,\n  ) => TgpuFn<\n    Prettify<InheritArgNames<(...args: Args) => Return, T>>['result']\n  >)\n  & ((implementation: string) => TgpuFn<(...args: Args) => Return>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuFn<(...args: Args) => Return>);\n\ninterface TgpuFnBase<ImplSchema extends AnyFn> extends TgpuNamable {\n  readonly [$internal]: {\n    implementation: Implementation<ImplSchema>;\n    argTypes: FnArgsConversionHint;\n  };\n  readonly resourceType: 'function';\n  readonly shell: TgpuFnShellHeader<\n    Parameters<ImplSchema>,\n    Extract<ReturnType<ImplSchema>, AnyData>\n  >;\n  readonly [$providing]?: Providing | undefined;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n  with<T>(slot: TgpuSlot<T>, value: Eventual<T>): TgpuFn<ImplSchema>;\n  with<T extends AnyData>(\n    accessor: TgpuAccessor<T>,\n    value: TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n  ): TgpuFn<ImplSchema>;\n}\n\n// biome-ignore lint/suspicious/noExplicitAny: the widest type requires `any`\nexport type TgpuFn<ImplSchema extends AnyFn = (...args: any[]) => any> =\n  & TgpuFnBase<ImplSchema>\n  & InferImplSchema<ImplSchema>;\n\nexport function fn<\n  Args extends AnyData[] | [],\n>(argTypes: Args, returnType?: undefined): TgpuFnShell<Args, Void>;\n\nexport function fn<\n  Args extends AnyData[] | [],\n  Return extends AnyData,\n>(argTypes: Args, returnType: Return): TgpuFnShell<Args, Return>;\n\nexport function fn<\n  Args extends AnyData[] | [],\n  Return extends AnyData = Void,\n>(argTypes: Args, returnType?: Return | undefined): TgpuFnShell<Args, Return> {\n  const shell: TgpuFnShellHeader<Args, Return> = {\n    [$internal]: true,\n    argTypes,\n    returnType: returnType ?? Void as Return,\n    isEntry: false,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) =>\n    createFn(\n      shell as unknown as TgpuFnShellHeader<never[], never>,\n      stripTemplate(arg, ...values),\n    );\n\n  return Object.assign(call, shell) as unknown as TgpuFnShell<Args, Return>;\n}\n\nexport function isTgpuFn<Args extends AnyData[] | [], Return extends AnyData>(\n  value: unknown | TgpuFn<(...args: Args) => Return>,\n): value is TgpuFn<(...args: Args) => Return> {\n  return !!(value as TgpuFn<(...args: Args) => Return>)?.[$internal] &&\n    (value as TgpuFn<(...args: Args) => Return>)?.resourceType === 'function';\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction stringifyPair([slot, value]: SlotValuePair): string {\n  return `${getName(slot) ?? '<unnamed>'}=${value}`;\n}\n\nfunction createFn<ImplSchema extends AnyFn>(\n  shell: TgpuFnShellHeader<\n    Parameters<ImplSchema>,\n    Extract<ReturnType<ImplSchema>, AnyData>\n  >,\n  implementation: Implementation<ImplSchema>,\n): TgpuFn<ImplSchema> {\n  type This = TgpuFnBase<ImplSchema> & SelfResolvable & {\n    [$getNameForward]: FnCore;\n  };\n\n  const core = createFnCore(implementation as Implementation, '');\n\n  const fnBase: This = {\n    [$internal]: {\n      implementation,\n      argTypes: shell.argTypes,\n    },\n    shell,\n    resourceType: 'function' as const,\n\n    $uses(newExternals: Record<string, unknown>) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$getNameForward]: core,\n    $name(label: string): This {\n      setName(core, label);\n      return this;\n    },\n\n    with(\n      slot: TgpuSlot<unknown> | TgpuAccessor,\n      value: unknown,\n    ): TgpuFn<ImplSchema> {\n      return createBoundFunction(fn, [\n        [isAccessor(slot) ? slot.slot : slot, value],\n      ]);\n    },\n\n    '~resolve'(ctx: ResolutionCtx): string {\n      if (typeof implementation === 'string') {\n        addArgTypesToExternals(\n          implementation,\n          shell.argTypes,\n          core.applyExternals,\n        );\n        addReturnTypeToExternals(\n          implementation,\n          shell.returnType,\n          core.applyExternals,\n        );\n\n        return core.resolve(ctx, shell.argTypes, shell.returnType);\n      }\n\n      const generationCtx = ctx as GenerationCtx;\n      if (generationCtx.callStack === undefined) {\n        throw new Error(\n          'Cannot resolve a TGSL function outside of a generation context',\n        );\n      }\n\n      try {\n        generationCtx.callStack.push(shell.returnType);\n        return core.resolve(ctx, shell.argTypes, shell.returnType);\n      } finally {\n        generationCtx.callStack.pop();\n      }\n    },\n  };\n\n  const call = createDualImpl<InferImplSchema<ImplSchema>>(\n    (...args) => {\n      if (typeof implementation === 'string') {\n        throw new Error(\n          'Cannot execute on the CPU functions constructed with raw WGSL',\n        );\n      }\n\n      const castAndCopiedArgs = args.map((arg, index) =>\n        schemaCallWrapper(shell.argTypes[index], arg)\n      ) as InferArgs<Parameters<ImplSchema>>;\n\n      return implementation(...castAndCopiedArgs);\n    },\n    (...args) =>\n      snip(\n        new FnCall(fn, args.map((arg) => arg.value) as Wgsl[]),\n        shell.returnType ?? UnknownData,\n      ),\n    'tgpuFnCall',\n    shell.argTypes,\n  );\n\n  call[$internal].implementation = implementation;\n\n  const fn = Object.assign(call, fnBase as This) as unknown as TgpuFn<\n    ImplSchema\n  >;\n\n  Object.defineProperty(fn, 'toString', {\n    value() {\n      return `fn:${getName(core) ?? '<unnamed>'}`;\n    },\n  });\n\n  return fn;\n}\n\nfunction createBoundFunction<ImplSchema extends AnyFn>(\n  innerFn: TgpuFn<ImplSchema>,\n  pairs: SlotValuePair[],\n): TgpuFn<ImplSchema> {\n  type This = TgpuFnBase<ImplSchema> & {\n    [$getNameForward]: TgpuFn<ImplSchema>;\n  };\n\n  const fnBase: This = {\n    [$internal]: {\n      implementation: innerFn[$internal].implementation,\n      argTypes: innerFn[$internal].argTypes,\n    },\n    resourceType: 'function',\n    shell: innerFn.shell,\n    [$providing]: {\n      inner: innerFn,\n      pairs,\n    },\n\n    $uses(newExternals) {\n      innerFn.$uses(newExternals);\n      return this;\n    },\n\n    [$getNameForward]: innerFn,\n    $name(label: string): This {\n      innerFn.$name(label);\n      return this;\n    },\n\n    with(\n      slot: TgpuSlot<unknown> | TgpuAccessor,\n      value: unknown,\n    ): TgpuFn<ImplSchema> {\n      return createBoundFunction(fn, [\n        ...pairs,\n        [isAccessor(slot) ? slot.slot : slot, value],\n      ]);\n    },\n  };\n\n  const call = createDualImpl<InferImplSchema<ImplSchema>>(\n    (...args) => innerFn(...args),\n    (...args) =>\n      snip(\n        new FnCall(fn, args.map((arg) => arg.value) as Wgsl[]),\n        innerFn.shell.returnType ?? UnknownData,\n      ),\n    'tgpuFnCall',\n    innerFn.shell.argTypes as AnyData[],\n  );\n\n  const fn = Object.assign(call, fnBase) as TgpuFn<ImplSchema>;\n\n  Object.defineProperty(fn, 'toString', {\n    value() {\n      const fnLabel = getName(innerFn) ?? '<unnamed>';\n\n      return `fn:${fnLabel}[${pairs.map(stringifyPair).join(', ')}]`;\n    },\n  });\n\n  fn[$internal].implementation = innerFn[$internal].implementation;\n\n  return fn;\n}\n\nclass FnCall<ImplSchema extends AnyFn> implements SelfResolvable {\n  readonly [$getNameForward]: TgpuFnBase<ImplSchema>;\n\n  constructor(\n    private readonly _fn: TgpuFnBase<ImplSchema>,\n    private readonly _params: Wgsl[],\n  ) {\n    this[$getNameForward] = _fn;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    return ctx.resolve(\n      `${ctx.resolve(this._fn)}(${\n        this._params.map((param) => ctx.resolve(param)).join(', ')\n      })`,\n    );\n  }\n\n  toString() {\n    return `call:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n","import type {\n  AnyFragmentInputBuiltin,\n  AnyFragmentOutputBuiltin,\n  OmitBuiltins,\n} from '../../builtin.ts';\nimport type {\n  Decorated,\n  Interpolate,\n  Location,\n  Vec4f,\n} from '../../data/wgslTypes.ts';\nimport {\n  getName,\n  isNamable,\n  setName,\n  type TgpuNamable,\n} from '../../shared/meta.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { GenerationCtx } from '../../tgsl/generationHelpers.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { addReturnTypeToExternals } from '../resolve/externals.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type {\n  BaseIOData,\n  Implementation,\n  InferIO,\n  IOLayout,\n  IORecord,\n} from './fnTypes.ts';\nimport { createIoSchema, type IOLayoutToSchema } from './ioSchema.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type FragmentInConstrained = IORecord<\n  | BaseIOData\n  | Decorated<BaseIOData, (Location | Interpolate)[]>\n  | AnyFragmentInputBuiltin\n>;\n\nexport type FragmentOutConstrained = IOLayout<\n  | Vec4f\n  | Decorated<Vec4f, (Location | Interpolate)[]>\n  | AnyFragmentOutputBuiltin\n>;\n\n/**\n * Describes a fragment entry function signature (its arguments, return type and targets)\n */\ntype TgpuFragmentFnShellHeader<\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n> = {\n  readonly in: FragmentIn | undefined;\n  readonly out: FragmentOut;\n  readonly returnType: IOLayoutToSchema<FragmentOut>;\n  readonly isEntry: true;\n};\n\n/**\n * Describes a fragment entry function signature (its arguments, return type and targets).\n * Allows creating tgpu fragment functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuFragmentFnShell<\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n> =\n  & TgpuFragmentFnShellHeader<FragmentIn, FragmentOut> /**\n   * Creates a type-safe implementation of this signature\n   */\n  & ((\n    implementation: (input: InferIO<FragmentIn>) => InferIO<FragmentOut>,\n  ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>)\n  & /**\n   * @param implementation\n   *   Raw WGSL function implementation with header and body\n   *   without `fn` keyword and function name\n   *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n   */ ((\n    implementation: string,\n  ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>)\n  & {\n    /**\n     * @deprecated Invoke the shell as a function instead.\n     */\n    does:\n      & ((\n        implementation: (input: InferIO<FragmentIn>) => InferIO<FragmentOut>,\n      ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>)\n      & /**\n       * @param implementation\n       *   Raw WGSL function implementation with header and body\n       *   without `fn` keyword and function name\n       *   e.g. `\"(x: f32) -> f32 { return x; }\"`;\n       */ ((\n        implementation: string,\n      ) => TgpuFragmentFn<OmitBuiltins<FragmentIn>, OmitBuiltins<FragmentOut>>);\n  };\n\nexport interface TgpuFragmentFn<\n  Varying extends FragmentInConstrained = FragmentInConstrained,\n  Output extends FragmentOutConstrained = FragmentOutConstrained,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly shell: TgpuFragmentFnShellHeader<Varying, Output>;\n  readonly outputType: IOLayoutToSchema<Output>;\n\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\nexport function fragmentFn<\n  FragmentOut extends FragmentOutConstrained,\n>(options: {\n  out: FragmentOut;\n  // biome-ignore lint/complexity/noBannedTypes: it's fine\n}): TgpuFragmentFnShell<{}, FragmentOut>;\n\nexport function fragmentFn<\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n>(options: {\n  in: FragmentIn;\n  out: FragmentOut;\n}): TgpuFragmentFnShell<FragmentIn, FragmentOut>;\n\n/**\n * Creates a shell of a typed entry function for the fragment shader stage. Any function\n * that implements this shell can run for each fragment (pixel), allowing the inner code\n * to process information received from the vertex shader stage and builtins to determine\n * the final color of the pixel (many pixels in case of multiple targets).\n *\n * @param options.in\n *  Values computed in the vertex stage and builtins to be made available to functions that implement this shell.\n * @param options.out\n *  A `vec4f`, signaling this function outputs a color for one target, or a record containing colors for multiple targets.\n */\nexport function fragmentFn<\n  // Not allowing single-value input, as using objects here is more\n  // readable, and refactoring to use a builtin argument is too much hassle.\n  FragmentIn extends FragmentInConstrained,\n  FragmentOut extends FragmentOutConstrained,\n>(options: {\n  in?: FragmentIn;\n  out: FragmentOut;\n}): TgpuFragmentFnShell<FragmentIn, FragmentOut> {\n  const shell: TgpuFragmentFnShellHeader<FragmentIn, FragmentOut> = {\n    in: options.in,\n    out: options.out,\n    returnType: createIoSchema(options.out),\n    isEntry: true,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) => createFragmentFn(shell, stripTemplate(arg, ...values));\n\n  return Object.assign(Object.assign(call, shell), {\n    does: call,\n  }) as TgpuFragmentFnShell<FragmentIn, FragmentOut>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction createFragmentFn(\n  shell: TgpuFragmentFnShellHeader<\n    FragmentInConstrained,\n    FragmentOutConstrained\n  >,\n  implementation: Implementation,\n): TgpuFragmentFn {\n  type This = TgpuFragmentFn & SelfResolvable & {\n    [$internal]: true;\n    [$getNameForward]: FnCore;\n  };\n\n  const core = createFnCore(implementation, '@fragment ');\n  const outputType = shell.returnType;\n  if (typeof implementation === 'string') {\n    addReturnTypeToExternals(\n      implementation,\n      outputType,\n      (externals) => core.applyExternals(externals),\n    );\n  }\n\n  const result: This = {\n    shell,\n    outputType,\n\n    $uses(newExternals) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$internal]: true,\n    [$getNameForward]: core,\n    $name(newLabel: string): This {\n      setName(core, newLabel);\n      if (isNamable(outputType)) {\n        outputType.$name(`${newLabel}_Output`);\n      }\n      return this;\n    },\n\n    '~resolve'(ctx: ResolutionCtx): string {\n      const inputWithLocation = shell.in\n        ? createIoSchema(shell.in, ctx.varyingLocations)\n          .$name(`${getName(this) ?? ''}_Input`)\n        : undefined;\n\n      if (inputWithLocation) {\n        core.applyExternals({ In: inputWithLocation });\n      }\n      core.applyExternals({ Out: outputType });\n\n      if (typeof implementation === 'string') {\n        return core.resolve(\n          ctx,\n          inputWithLocation ? [inputWithLocation] : [],\n          shell.returnType,\n        );\n      }\n\n      const generationCtx = ctx as GenerationCtx;\n      if (generationCtx.callStack === undefined) {\n        throw new Error(\n          'Cannot resolve a TGSL function outside of a generation context',\n        );\n      }\n\n      try {\n        generationCtx.callStack.push(outputType);\n        return core.resolve(\n          ctx,\n          inputWithLocation ? [inputWithLocation] : [],\n          shell.returnType,\n        );\n      } finally {\n        generationCtx.callStack.pop();\n      }\n    },\n\n    toString() {\n      return `fragmentFn:${getName(core) ?? '<unnamed>'}`;\n    },\n  };\n\n  return result;\n}\n","import type {\n  AnyVertexInputBuiltin,\n  AnyVertexOutputBuiltin,\n  OmitBuiltins,\n} from '../../builtin.ts';\nimport type { Decorated, Interpolate, Location } from '../../data/wgslTypes.ts';\nimport {\n  getName,\n  isNamable,\n  setName,\n  type TgpuNamable,\n} from '../../shared/meta.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { GenerationCtx } from '../../tgsl/generationHelpers.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { createFnCore, type FnCore } from './fnCore.ts';\nimport type {\n  BaseIOData,\n  Implementation,\n  InferIO,\n  IORecord,\n} from './fnTypes.ts';\nimport { createIoSchema, type IOLayoutToSchema } from './ioSchema.ts';\nimport { stripTemplate } from './templateUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type VertexInConstrained = IORecord<\n  BaseIOData | Decorated<BaseIOData, Location[]> | AnyVertexInputBuiltin\n>;\n\nexport type VertexOutConstrained = IORecord<\n  | BaseIOData\n  | Decorated<BaseIOData, (Location | Interpolate)[]>\n  | AnyVertexOutputBuiltin\n>;\n\n/**\n * Describes a vertex entry function signature (its arguments, return type and attributes)\n */\ntype TgpuVertexFnShellHeader<\n  VertexIn extends VertexInConstrained,\n  VertexOut extends VertexOutConstrained,\n> = {\n  readonly in: VertexIn | undefined;\n  readonly out: VertexOut;\n  readonly argTypes: [IOLayoutToSchema<VertexIn>] | [];\n  readonly isEntry: true;\n};\n\n/**\n * Describes a vertex entry function signature (its arguments, return type and attributes).\n * Allows creating tgpu vertex functions by calling this shell\n * and passing the implementation (as WGSL string or JS function) as the argument.\n */\nexport type TgpuVertexFnShell<\n  VertexIn extends VertexInConstrained,\n  VertexOut extends VertexOutConstrained,\n> =\n  & TgpuVertexFnShellHeader<VertexIn, VertexOut>\n  & ((\n    implementation: (input: InferIO<VertexIn>) => InferIO<VertexOut>,\n  ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n  & ((\n    implementation: string,\n  ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n  & ((\n    strings: TemplateStringsArray,\n    ...values: unknown[]\n  ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n  & {\n    /**\n     * @deprecated Invoke the shell as a function instead.\n     */\n    does:\n      & ((\n        implementation: (input: InferIO<VertexIn>) => InferIO<VertexOut>,\n      ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>)\n      & ((\n        implementation: string,\n      ) => TgpuVertexFn<OmitBuiltins<VertexIn>, OmitBuiltins<VertexOut>>);\n  };\n\nexport interface TgpuVertexFn<\n  VertexIn extends VertexInConstrained = VertexInConstrained,\n  VertexOut extends VertexOutConstrained = VertexOutConstrained,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly shell: TgpuVertexFnShellHeader<VertexIn, VertexOut>;\n  $uses(dependencyMap: Record<string, unknown>): this;\n}\n\nexport function vertexFn<VertexOut extends VertexOutConstrained>(options: {\n  out: VertexOut;\n  // biome-ignore lint/complexity/noBannedTypes: it's fine\n}): TgpuVertexFnShell<{}, VertexOut>;\n\nexport function vertexFn<\n  VertexIn extends VertexInConstrained,\n  // Not allowing single-value output, as it is better practice\n  // to properly label what the vertex shader is outputting.\n  VertexOut extends VertexOutConstrained,\n>(options: {\n  in: VertexIn;\n  out: VertexOut;\n}): TgpuVertexFnShell<VertexIn, VertexOut>;\n\n/**\n * Creates a shell of a typed entry function for the vertex shader stage. Any function\n * that implements this shell can run for each vertex, allowing the inner code to process\n * attributes and determine the final position of the vertex.\n *\n * @param options.in\n *   Vertex attributes and builtins to be made available to functions that implement this shell.\n * @param options.out\n *   A record containing the final position of the vertex, and any information\n *   passed onto the fragment shader stage.\n */\nexport function vertexFn<\n  VertexIn extends VertexInConstrained,\n  // Not allowing single-value output, as it is better practice\n  // to properly label what the vertex shader is outputting.\n  VertexOut extends VertexOutConstrained,\n>(options: {\n  in?: VertexIn;\n  out: VertexOut;\n}): TgpuVertexFnShell<VertexIn, VertexOut> {\n  if (Object.keys(options.out).length === 0) {\n    throw new Error(\n      `A vertexFn output cannot be empty since it must include the 'position' builtin.`,\n    );\n  }\n  const shell: TgpuVertexFnShellHeader<VertexIn, VertexOut> = {\n    in: options.in,\n    out: options.out,\n    argTypes: options.in && Object.keys(options.in).length !== 0\n      ? [createIoSchema(options.in)]\n      : [],\n    isEntry: true,\n  };\n\n  const call = (\n    arg: Implementation | TemplateStringsArray,\n    ...values: unknown[]\n  ) => createVertexFn(shell, stripTemplate(arg, ...values));\n\n  return Object.assign(Object.assign(call, shell), {\n    does: call,\n  }) as TgpuVertexFnShell<VertexIn, VertexOut>;\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction createVertexFn(\n  shell: TgpuVertexFnShellHeader<VertexInConstrained, VertexOutConstrained>,\n  implementation: Implementation,\n): TgpuVertexFn<VertexInConstrained, VertexOutConstrained> {\n  type This =\n    & TgpuVertexFn<VertexInConstrained, VertexOutConstrained>\n    & SelfResolvable\n    & {\n      [$internal]: true;\n      [$getNameForward]: FnCore;\n    };\n\n  const core = createFnCore(implementation, '@vertex ');\n  const inputType = shell.argTypes[0];\n\n  const result: This = {\n    shell,\n\n    $uses(newExternals) {\n      core.applyExternals(newExternals);\n      return this;\n    },\n\n    [$internal]: true,\n    [$getNameForward]: core,\n    $name(newLabel: string): This {\n      setName(core, newLabel);\n      if (isNamable(inputType)) {\n        inputType.$name(`${newLabel}_Input`);\n      }\n      return this;\n    },\n\n    '~resolve'(ctx: ResolutionCtx): string {\n      const outputWithLocation = createIoSchema(\n        shell.out,\n        ctx.varyingLocations,\n      ).$name(`${getName(this) ?? ''}_Output`);\n\n      if (typeof implementation === 'string') {\n        if (inputType) {\n          core.applyExternals({ In: inputType });\n        }\n        core.applyExternals({ Out: outputWithLocation });\n\n        return core.resolve(\n          ctx,\n          shell.argTypes,\n          outputWithLocation,\n        );\n      }\n\n      const generationCtx = ctx as GenerationCtx;\n      if (generationCtx.callStack === undefined) {\n        throw new Error(\n          'Cannot resolve a TGSL function outside of a generation context',\n        );\n      }\n\n      try {\n        generationCtx.callStack.push(outputWithLocation);\n        return core.resolve(\n          ctx,\n          shell.argTypes,\n          outputWithLocation,\n        );\n      } finally {\n        generationCtx.callStack.pop();\n      }\n    },\n\n    toString() {\n      return `vertexFn:${getName(core) ?? '<unnamed>'}`;\n    },\n  };\n  return result;\n}\n","export interface NameRegistry {\n  /**\n   * Creates a valid WGSL identifier, each guaranteed to be unique\n   * in the lifetime of a single resolution process.\n   * @param primer Used in the generation process, makes the identifier more recognizable.\n   */\n  makeUnique(primer?: string): string;\n}\n\nexport class RandomNameRegistry implements NameRegistry {\n  private lastUniqueId = 0;\n\n  makeUnique(primer?: string | undefined): string {\n    let label: string;\n    if (primer) {\n      // sanitizing\n      label = primer.replaceAll(/\\s/g, '_'); // whitespace -> _\n      label = label.replaceAll(/[^\\w\\d]/g, ''); // removing illegal characters\n    } else {\n      label = 'item';\n    }\n\n    return `${label}_${this.lastUniqueId++}`;\n  }\n}\n\nexport class StrictNameRegistry implements NameRegistry {\n  /**\n   * Allows to provide a good fallback for instances of the\n   * same function that are bound to different slot values.\n   */\n  private readonly _usedNames = new Set<string>();\n\n  makeUnique(primer?: string | undefined): string {\n    if (primer === undefined) {\n      throw new Error('Unnamed item found when using a strict name registry');\n    }\n\n    let index = 0;\n    let unusedName = primer;\n    while (this._usedNames.has(unusedName)) {\n      index++;\n      unusedName = `${primer}_${index}`;\n    }\n\n    this._usedNames.add(unusedName);\n    return unusedName;\n  }\n}\n","import { isBuiltin } from '../../data/attributes.ts';\nimport { getCustomLocation } from '../../data/dataTypes.ts';\nimport { isData } from '../../data/dataTypes.ts';\nimport type {\n  AnyVertexAttribs,\n  TgpuVertexAttrib,\n} from '../../shared/vertexFormat.ts';\nimport type { IOData, IOLayout } from '../function/fnTypes.ts';\nimport type {\n  INTERNAL_TgpuVertexAttrib,\n  TgpuVertexLayout,\n} from './vertexLayout.ts';\n\nexport interface ConnectAttributesToShaderResult {\n  usedVertexLayouts: TgpuVertexLayout[];\n  bufferDefinitions: GPUVertexBufferLayout[];\n}\n\nexport function isAttribute<\n  T extends TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib,\n>(value: unknown | T): value is T {\n  return typeof (value as T)?.format === 'string';\n}\n\nexport function connectAttributesToShader(\n  shaderInputLayout: IOLayout,\n  attributes: AnyVertexAttribs,\n): ConnectAttributesToShaderResult {\n  const usedVertexLayouts: TgpuVertexLayout[] = [];\n\n  if (isData(shaderInputLayout)) {\n    // Expecting a single attribute, no record.\n    if (!isAttribute(attributes)) {\n      throw new Error(\n        'Shader expected a single attribute, not a record of attributes to be passed in.',\n      );\n    }\n\n    usedVertexLayouts.push(attributes._layout);\n\n    return {\n      usedVertexLayouts,\n      bufferDefinitions: [\n        {\n          arrayStride: attributes._layout.stride,\n          stepMode: attributes._layout.stepMode,\n          attributes: [\n            {\n              format: attributes.format,\n              offset: attributes.offset,\n              shaderLocation: getCustomLocation(shaderInputLayout) ?? 0,\n            },\n          ],\n        },\n      ],\n    };\n  }\n\n  const bufferDefinitions: GPUVertexBufferLayout[] = [];\n  const layoutToAttribListMap = new WeakMap<\n    TgpuVertexLayout,\n    GPUVertexAttribute[]\n  >();\n  let nextShaderLocation = 0;\n\n  for (\n    const [key, member] of Object.entries(\n      shaderInputLayout as Record<string, IOData>,\n    )\n  ) {\n    if (isBuiltin(member)) {\n      continue;\n    }\n\n    const matchingAttribute = (attributes as Record<string, TgpuVertexAttrib>)[\n      key\n    ] as (TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib) | undefined;\n\n    if (!matchingAttribute) {\n      throw new Error(\n        `An attribute by the name of '${key}' was not provided to the shader.`,\n      );\n    }\n\n    const layout = matchingAttribute._layout;\n    let attribList = layoutToAttribListMap.get(layout);\n    if (!attribList) {\n      // First time seeing this layout\n      usedVertexLayouts.push(layout);\n\n      attribList = [];\n      bufferDefinitions.push({\n        arrayStride: layout.stride,\n        stepMode: layout.stepMode,\n        attributes: attribList,\n      });\n      layoutToAttribListMap.set(layout, attribList);\n    }\n\n    nextShaderLocation = getCustomLocation(member) ?? nextShaderLocation;\n\n    attribList.push({\n      format: matchingAttribute.format,\n      offset: matchingAttribute.offset,\n      shaderLocation: nextShaderLocation++,\n    });\n  }\n\n  return { usedVertexLayouts, bufferDefinitions };\n}\n","import { getAttributesString } from '../../data/attributes.ts';\nimport {\n  type AnyData,\n  type Disarray,\n  isLooseData,\n  type Unstruct,\n} from '../../data/dataTypes.ts';\nimport { formatToWGSLType } from '../../data/vertexFormatData.ts';\nimport type {\n  AnyWgslData,\n  BaseData,\n  Bool,\n  F16,\n  F32,\n  I32,\n  Mat2x2f,\n  Mat3x3f,\n  Mat4x4f,\n  U32,\n  Vec2b,\n  Vec2f,\n  Vec2h,\n  Vec2i,\n  Vec2u,\n  Vec3b,\n  Vec3f,\n  Vec3h,\n  Vec3i,\n  Vec3u,\n  Vec4b,\n  Vec4f,\n  Vec4h,\n  Vec4i,\n  Vec4u,\n  WgslArray,\n  WgslStruct,\n} from '../../data/wgslTypes.ts';\nimport { getName } from '../../shared/meta.ts';\nimport { assertExhaustive } from '../../shared/utilityTypes.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport { isAttribute } from '../vertexLayout/connectAttributesToShader.ts';\n\n/**\n * Schemas for which their `type` property directly\n * translates to the resulting WGSL code.\n */\nconst identityTypes = [\n  'bool',\n  'f32',\n  'f16',\n  'i32',\n  'u32',\n  'vec2f',\n  'vec3f',\n  'vec4f',\n  'vec2h',\n  'vec3h',\n  'vec4h',\n  'vec2i',\n  'vec3i',\n  'vec4i',\n  'vec2u',\n  'vec3u',\n  'vec4u',\n  'vec2<bool>',\n  'vec3<bool>',\n  'vec4<bool>',\n  'mat2x2f',\n  'mat3x3f',\n  'mat4x4f',\n];\n\ntype IdentityType =\n  | Bool\n  | F32\n  | F16\n  | I32\n  | U32\n  | Vec2f\n  | Vec3f\n  | Vec4f\n  | Vec2h\n  | Vec3h\n  | Vec4h\n  | Vec2i\n  | Vec3i\n  | Vec4i\n  | Vec2u\n  | Vec3u\n  | Vec4u\n  | Vec2b\n  | Vec3b\n  | Vec4b\n  | Mat2x2f\n  | Mat3x3f\n  | Mat4x4f;\n\nfunction isIdentityType(data: AnyWgslData): data is IdentityType {\n  return identityTypes.includes(data.type);\n}\n\n/**\n * Resolves a single property of a struct.\n * @param ctx - The resolution context.\n * @param key - The key of the property.\n * @param property - The property itself.\n *\n * @returns The resolved property string.\n */\nfunction resolveStructProperty(\n  ctx: ResolutionCtx,\n  [key, property]: [string, BaseData],\n) {\n  return `  ${getAttributesString(property)}${key}: ${\n    ctx.resolve(property as AnyWgslData)\n  },\\n`;\n}\n\n/**\n * Resolves a struct and adds its declaration to the resolution context.\n * @param ctx - The resolution context.\n * @param struct - The struct to resolve.\n *\n * @returns The resolved struct name.\n */\nfunction resolveStruct(ctx: ResolutionCtx, struct: WgslStruct) {\n  const id = ctx.names.makeUnique(getName(struct));\n\n  ctx.addDeclaration(`\nstruct ${id} {\n${\n    Object.entries(struct.propTypes)\n      .map((prop) => resolveStructProperty(ctx, prop))\n      .join('')\n  }\\\n}\\n`);\n\n  return id;\n}\n\n/**\n * Resolves an unstruct (struct that does not align data by default) to its struct data counterpart.\n * @param ctx - The resolution context.\n * @param unstruct - The unstruct to resolve.\n *\n * @returns The resolved unstruct name.\n *\n * @example\n * ```ts\n * resolveUnstruct(ctx, {\n *   uv: d.float16x2, // -> d.vec2f after resolution\n *   color: d.snorm8x4, -> d.vec4f after resolution\n * });\n * ```\n */\nfunction resolveUnstruct(ctx: ResolutionCtx, unstruct: Unstruct) {\n  const id = ctx.names.makeUnique(getName(unstruct));\n\n  ctx.addDeclaration(`\nstruct ${id} {\n${\n    Object.entries(unstruct.propTypes)\n      .map((prop) =>\n        isAttribute(prop[1])\n          ? resolveStructProperty(ctx, [\n            prop[0],\n            formatToWGSLType[prop[1].format],\n          ])\n          : resolveStructProperty(ctx, prop)\n      )\n      .join('')\n  }\n}\\n`);\n\n  return id;\n}\n\n/**\n * Resolves an array.\n * @param ctx - The resolution context.\n * @param array - The array to resolve.\n *\n * @returns The resolved array name along with its element type and count (if not runtime-sized).\n *\n * @example\n * ```ts\n * resolveArray(ctx, d.arrayOf(d.u32, 0)); // 'array<u32>' (not a real pattern, a function is preferred)\n * resolveArray(ctx, d.arrayOf(d.u32, 5)); // 'array<u32, 5>'\n * ```\n */\nfunction resolveArray(ctx: ResolutionCtx, array: WgslArray) {\n  const element = ctx.resolve(array.elementType as AnyWgslData);\n\n  return array.elementCount === 0\n    ? `array<${element}>`\n    : `array<${element}, ${array.elementCount}>`;\n}\n\nfunction resolveDisarray(ctx: ResolutionCtx, disarray: Disarray) {\n  const element = ctx.resolve(\n    isAttribute(disarray.elementType)\n      ? formatToWGSLType[disarray.elementType.format]\n      : (disarray.elementType as AnyWgslData),\n  );\n\n  return disarray.elementCount === 0\n    ? `array<${element}>`\n    : `array<${element}, ${disarray.elementCount}>`;\n}\n\n/**\n * Resolves a WGSL data-type schema to a string.\n * @param ctx - The resolution context.\n * @param data - The data-type to resolve.\n *\n * @returns The resolved data-type string.\n */\nexport function resolveData(ctx: ResolutionCtx, data: AnyData): string {\n  if (isLooseData(data)) {\n    if (data.type === 'unstruct') {\n      return resolveUnstruct(ctx, data);\n    }\n\n    if (data.type === 'disarray') {\n      return resolveDisarray(ctx, data);\n    }\n\n    if (data.type === 'loose-decorated') {\n      return ctx.resolve(\n        isAttribute(data.inner)\n          ? formatToWGSLType[data.inner.format]\n          : data.inner,\n      );\n    }\n\n    return ctx.resolve(formatToWGSLType[data.type]);\n  }\n\n  if (isIdentityType(data)) {\n    return data.type;\n  }\n\n  if (data.type === 'struct') {\n    return resolveStruct(ctx, data);\n  }\n\n  if (data.type === 'array') {\n    return resolveArray(ctx, data);\n  }\n\n  if (data.type === 'atomic') {\n    return `atomic<${resolveData(ctx, data.inner)}>`;\n  }\n\n  if (data.type === 'decorated') {\n    return ctx.resolve(data.inner as AnyWgslData);\n  }\n\n  if (data.type === 'ptr') {\n    if (data.addressSpace === 'storage') {\n      return `ptr<storage, ${ctx.resolve(data.inner)}, ${\n        data.access === 'read-write' ? 'read_write' : data.access\n      }>`;\n    }\n    return `ptr<${data.addressSpace}, ${ctx.resolve(data.inner)}>`;\n  }\n\n  if (\n    data.type === 'abstractInt' || data.type === 'abstractFloat' ||\n    data.type === 'void' || data.type === 'u16'\n  ) {\n    throw new Error(`${data.type} has no representation in WGSL`);\n  }\n\n  assertExhaustive(data, 'resolveData');\n}\n","import { BufferReader, BufferWriter, getSystemEndianness } from 'typed-binary';\nimport {\n  EVAL_ALLOWED_IN_ENV,\n  getCompiledWriterForSchema,\n} from '../../data/compiledIO.ts';\nimport { readData, writeData } from '../../data/dataIO.ts';\nimport { getWriteInstructions } from '../../data/partialIO.ts';\nimport { sizeOf } from '../../data/sizeOf.ts';\nimport type { BaseData, WgslTypeLiteral } from '../../data/wgslTypes.ts';\nimport { isWgslData } from '../../data/wgslTypes.ts';\nimport type { StorageFlag } from '../../extension.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer, InferPartial, MemIdentity } from '../../shared/repr.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport type { UnionToIntersection } from '../../shared/utilityTypes.ts';\nimport { isGPUBuffer } from '../../types.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport {\n  asMutable,\n  asReadonly,\n  asUniform,\n  type TgpuBufferMutable,\n  type TgpuBufferReadonly,\n  type TgpuBufferUniform,\n  type TgpuFixedBufferUsage,\n} from './bufferUsage.ts';\nimport type { AnyData, UnwrapDecorated } from '../../data/dataTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface UniformFlag {\n  usableAsUniform: true;\n}\n\n/**\n * @deprecated Use UniformFlag instead.\n */\nexport type Uniform = UniformFlag;\n\nexport interface VertexFlag {\n  usableAsVertex: true;\n}\n\nexport interface IndexFlag {\n  usableAsIndex: true;\n}\n\n/**\n * @deprecated Use VertexFlag instead.\n */\nexport type Vertex = VertexFlag;\n\ntype LiteralToUsageType<T extends 'uniform' | 'storage' | 'vertex' | 'index'> =\n  T extends 'uniform' ? UniformFlag\n    : T extends 'storage' ? StorageFlag\n    : T extends 'vertex' ? VertexFlag\n    : T extends 'index' ? IndexFlag\n    : never;\n\ntype ViewUsages<TBuffer extends TgpuBuffer<BaseData>> =\n  | (boolean extends TBuffer['usableAsUniform'] ? never : 'uniform')\n  | (boolean extends TBuffer['usableAsStorage'] ? never\n    : 'readonly' | 'mutable');\n\ntype UsageTypeToBufferUsage<TData extends BaseData> = {\n  uniform: TgpuBufferUniform<TData> & TgpuFixedBufferUsage<TData>;\n  mutable: TgpuBufferMutable<TData> & TgpuFixedBufferUsage<TData>;\n  readonly: TgpuBufferReadonly<TData> & TgpuFixedBufferUsage<TData>;\n};\n\nconst usageToUsageConstructor = {\n  uniform: asUniform,\n  mutable: asMutable,\n  readonly: asReadonly,\n};\n\ntype IsIndexCompatible<TData extends BaseData> = UnwrapDecorated<TData> extends\n  {\n    readonly type: 'array';\n    readonly elementType: infer TElement;\n  }\n  ? TElement extends BaseData\n    ? UnwrapDecorated<TElement> extends { readonly type: 'u32' | 'u16' } ? true\n    : false\n  : false\n  : false;\n\nexport interface TgpuBuffer<TData extends BaseData> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'buffer';\n  readonly dataType: TData;\n  readonly initial?: Infer<TData> | undefined;\n\n  readonly buffer: GPUBuffer;\n  readonly destroyed: boolean;\n\n  usableAsUniform: boolean;\n  usableAsStorage: boolean;\n  usableAsVertex: boolean;\n  usableAsIndex: boolean;\n\n  $usage<T extends RestrictUsages<TData>>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToUsageType<T[number]>>;\n  $addFlags(flags: GPUBufferUsageFlags): this;\n\n  as<T extends ViewUsages<this>>(usage: T): UsageTypeToBufferUsage<TData>[T];\n\n  compileWriter(): void;\n  write(data: Infer<TData>): void;\n  writePartial(data: InferPartial<TData>): void;\n  copyFrom(srcBuffer: TgpuBuffer<MemIdentity<TData>>): void;\n  read(): Promise<Infer<TData>>;\n  destroy(): void;\n}\n\nexport function INTERNAL_createBuffer<TData extends AnyData>(\n  group: ExperimentalTgpuRoot,\n  typeSchema: TData,\n  initialOrBuffer?: Infer<TData> | GPUBuffer,\n): TgpuBuffer<TData> {\n  if (!isWgslData(typeSchema)) {\n    return new TgpuBufferImpl(group, typeSchema, initialOrBuffer, [\n      'storage',\n      'uniform',\n    ]);\n  }\n\n  return new TgpuBufferImpl(group, typeSchema, initialOrBuffer);\n}\n\nexport function isBuffer<T extends TgpuBuffer<AnyData>>(\n  value: T | unknown,\n): value is T {\n  return (value as TgpuBuffer<AnyData>).resourceType === 'buffer';\n}\n\nexport function isUsableAsVertex<T extends TgpuBuffer<AnyData>>(\n  buffer: T,\n): buffer is T & VertexFlag {\n  return !!(buffer as unknown as VertexFlag).usableAsVertex;\n}\n\nexport function isUsableAsIndex<T extends TgpuBuffer<AnyData>>(\n  buffer: T,\n): buffer is T & IndexFlag {\n  return !!(buffer as unknown as IndexFlag).usableAsIndex;\n}\n\n// --------------\n// Implementation\n// --------------\nconst endianness = getSystemEndianness();\n\ntype IsArrayOfU32<TData extends BaseData> = UnwrapDecorated<TData> extends {\n  readonly type: 'array';\n  readonly elementType: infer TElement;\n}\n  ? TElement extends BaseData\n    ? UnwrapDecorated<TElement> extends { readonly type: 'u32' } ? true\n    : false\n  : false\n  : false;\n\ntype IsWgslLiteral<TData extends BaseData> = TData extends {\n  readonly type: WgslTypeLiteral;\n} ? true\n  : false;\n\ntype RestrictUsages<TData extends BaseData> = string extends TData['type']\n  ? ('uniform' | 'storage' | 'vertex' | 'index')[]\n  : IsIndexCompatible<TData> extends true\n    ? IsArrayOfU32<TData> extends true\n      ? ('uniform' | 'storage' | 'vertex' | 'index')[]\n    : ['index']\n  : IsWgslLiteral<TData> extends true ? ('uniform' | 'storage' | 'vertex')[]\n  : ['vertex'];\n\nclass TgpuBufferImpl<TData extends AnyData> implements TgpuBuffer<TData> {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'buffer';\n  public flags: GPUBufferUsageFlags = GPUBufferUsage.COPY_DST |\n    GPUBufferUsage.COPY_SRC;\n  private _buffer: GPUBuffer | null = null;\n  private _ownBuffer: boolean;\n  private _destroyed = false;\n  private _hostBuffer: ArrayBuffer | undefined;\n\n  readonly initial: Infer<TData> | undefined;\n\n  usableAsUniform = false;\n  usableAsStorage = false;\n  usableAsVertex = false;\n  usableAsIndex = false;\n\n  constructor(\n    private readonly _group: ExperimentalTgpuRoot,\n    public readonly dataType: TData,\n    public readonly initialOrBuffer?: Infer<TData> | GPUBuffer | undefined,\n    private readonly _disallowedUsages?:\n      ('uniform' | 'storage' | 'vertex' | 'index')[],\n  ) {\n    if (isGPUBuffer(initialOrBuffer)) {\n      this._ownBuffer = false;\n      this._buffer = initialOrBuffer;\n    } else {\n      this._ownBuffer = true;\n      this.initial = initialOrBuffer;\n    }\n  }\n\n  get buffer() {\n    const device = this._group.device;\n\n    if (this._destroyed) {\n      throw new Error('This buffer has been destroyed');\n    }\n\n    if (!this._buffer) {\n      this._buffer = device.createBuffer({\n        size: sizeOf(this.dataType),\n        usage: this.flags,\n        mappedAtCreation: !!this.initial,\n        label: getName(this) ?? '<unnamed>',\n      });\n\n      if (this.initial) {\n        const writer = new BufferWriter(this._buffer.getMappedRange());\n        writeData(writer, this.dataType, this.initial);\n        this._buffer.unmap();\n      }\n    }\n\n    return this._buffer;\n  }\n\n  get destroyed() {\n    return this._destroyed;\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    if (this._buffer) {\n      this._buffer.label = label;\n    }\n    return this;\n  }\n\n  $usage<T extends ('uniform' | 'storage' | 'vertex' | 'index')[]>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToUsageType<T[number]>> {\n    for (const usage of usages) {\n      if (this._disallowedUsages?.includes(usage)) {\n        throw new Error(\n          `Buffer of type ${this.dataType.type} cannot be used as ${usage}`,\n        );\n      }\n\n      this.flags |= usage === 'uniform' ? GPUBufferUsage.UNIFORM : 0;\n      this.flags |= usage === 'storage' ? GPUBufferUsage.STORAGE : 0;\n      this.flags |= usage === 'vertex' ? GPUBufferUsage.VERTEX : 0;\n      this.flags |= usage === 'index' ? GPUBufferUsage.INDEX : 0;\n      this.usableAsUniform = this.usableAsUniform || usage === 'uniform';\n      this.usableAsStorage = this.usableAsStorage || usage === 'storage';\n      this.usableAsVertex = this.usableAsVertex || usage === 'vertex';\n      this.usableAsIndex = this.usableAsIndex || usage === 'index';\n    }\n    return this as this & UnionToIntersection<LiteralToUsageType<T[number]>>;\n  }\n\n  $addFlags(flags: GPUBufferUsageFlags) {\n    if (!this._ownBuffer) {\n      throw new Error(\n        'Cannot add flags to a buffer that is not managed by TypeGPU.',\n      );\n    }\n\n    if (flags & GPUBufferUsage.MAP_READ) {\n      this.flags = GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ;\n      return this;\n    }\n\n    if (flags & GPUBufferUsage.MAP_WRITE) {\n      this.flags = GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE;\n      return this;\n    }\n\n    this.flags |= flags;\n    return this;\n  }\n\n  compileWriter(): void {\n    if (EVAL_ALLOWED_IN_ENV) {\n      getCompiledWriterForSchema(this.dataType);\n    } else {\n      throw new Error('This environment does not allow eval');\n    }\n  }\n\n  write(data: Infer<TData>): void {\n    const gpuBuffer = this.buffer;\n    const device = this._group.device;\n\n    if (gpuBuffer.mapState === 'mapped') {\n      const mapped = gpuBuffer.getMappedRange();\n      if (EVAL_ALLOWED_IN_ENV) {\n        const writer = getCompiledWriterForSchema(this.dataType);\n        writer(new DataView(mapped), 0, data, endianness === 'little');\n        return;\n      }\n      writeData(new BufferWriter(mapped), this.dataType, data);\n      return;\n    }\n\n    const size = sizeOf(this.dataType);\n    if (!this._hostBuffer) {\n      this._hostBuffer = new ArrayBuffer(size);\n    }\n\n    // Flushing any commands yet to be encoded.\n    this._group.flush();\n\n    if (EVAL_ALLOWED_IN_ENV) {\n      const writer = getCompiledWriterForSchema(this.dataType);\n      writer(new DataView(this._hostBuffer), 0, data, endianness === 'little');\n    } else {\n      writeData(new BufferWriter(this._hostBuffer), this.dataType, data);\n    }\n    device.queue.writeBuffer(gpuBuffer, 0, this._hostBuffer, 0, size);\n  }\n\n  public writePartial(data: InferPartial<TData>): void {\n    const gpuBuffer = this.buffer;\n    const device = this._group.device;\n\n    const instructions = getWriteInstructions(this.dataType, data);\n\n    if (gpuBuffer.mapState === 'mapped') {\n      const mappedRange = gpuBuffer.getMappedRange();\n      const mappedView = new Uint8Array(mappedRange);\n\n      for (const instruction of instructions) {\n        mappedView.set(instruction.data, instruction.data.byteOffset);\n      }\n    } else {\n      for (const instruction of instructions) {\n        device.queue.writeBuffer(\n          gpuBuffer,\n          instruction.data.byteOffset,\n          instruction.data,\n          0,\n          instruction.data.byteLength,\n        );\n      }\n    }\n  }\n\n  copyFrom(srcBuffer: TgpuBuffer<MemIdentity<TData>>): void {\n    if (this.buffer.mapState === 'mapped') {\n      throw new Error('Cannot copy to a mapped buffer.');\n    }\n\n    const size = sizeOf(this.dataType);\n    const encoder = this._group.commandEncoder;\n    encoder.copyBufferToBuffer(srcBuffer.buffer, 0, this.buffer, 0, size);\n  }\n\n  async read(): Promise<Infer<TData>> {\n    // Flushing any commands yet to be encoded.\n    this._group.flush();\n\n    const gpuBuffer = this.buffer;\n    const device = this._group.device;\n\n    if (gpuBuffer.mapState === 'mapped') {\n      const mapped = gpuBuffer.getMappedRange();\n      return readData(new BufferReader(mapped), this.dataType);\n    }\n\n    if (gpuBuffer.usage & GPUBufferUsage.MAP_READ) {\n      await gpuBuffer.mapAsync(GPUMapMode.READ);\n      const mapped = gpuBuffer.getMappedRange();\n      const res = readData(new BufferReader(mapped), this.dataType);\n      gpuBuffer.unmap();\n      return res;\n    }\n\n    const stagingBuffer = device.createBuffer({\n      size: sizeOf(this.dataType),\n      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n    });\n\n    const commandEncoder = device.createCommandEncoder();\n    commandEncoder.copyBufferToBuffer(\n      gpuBuffer,\n      0,\n      stagingBuffer,\n      0,\n      sizeOf(this.dataType),\n    );\n\n    device.queue.submit([commandEncoder.finish()]);\n    await device.queue.onSubmittedWorkDone();\n    await stagingBuffer.mapAsync(GPUMapMode.READ, 0, sizeOf(this.dataType));\n\n    const res = readData(\n      new BufferReader(stagingBuffer.getMappedRange()),\n      this.dataType,\n    );\n\n    stagingBuffer.unmap();\n    stagingBuffer.destroy();\n\n    return res;\n  }\n\n  as<T extends ViewUsages<this>>(usage: T): UsageTypeToBufferUsage<TData>[T] {\n    return usageToUsageConstructor[usage]?.(\n      this as never,\n    ) as UsageTypeToBufferUsage<TData>[T];\n  }\n\n  destroy() {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    if (this._ownBuffer) {\n      this._buffer?.destroy();\n    }\n  }\n\n  toString(): string {\n    return `buffer:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n","import { Measurer } from 'typed-binary';\nimport { roundUp } from '../mathUtils.ts';\nimport alignIO from './alignIO.ts';\nimport { alignmentOf, customAlignmentOf } from './alignmentOf.ts';\nimport { type AnyUnstruct, isUnstruct, type Unstruct } from './dataTypes.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport type { AnyWgslStruct, BaseData, WgslStruct } from './wgslTypes.ts';\n\nexport interface OffsetInfo {\n  offset: number;\n  size: number;\n  padding?: number | undefined;\n}\n\nconst cachedOffsets = new WeakMap<\n  AnyWgslStruct | AnyUnstruct,\n  Record<string, OffsetInfo>\n>();\n\nexport function offsetsForProps<T extends Record<string, BaseData>>(\n  struct: WgslStruct<T> | Unstruct<T>,\n): Record<keyof T, OffsetInfo> {\n  const cached = cachedOffsets.get(struct);\n  if (cached) {\n    return cached as Record<keyof T, OffsetInfo>;\n  }\n\n  const measurer = new Measurer();\n  const offsets = {} as Record<keyof T, OffsetInfo>;\n  let lastEntry: OffsetInfo | undefined = undefined;\n\n  for (const key in struct.propTypes) {\n    const prop = struct.propTypes[key];\n    if (prop === undefined) {\n      throw new Error(`Property ${key} is undefined in struct`);\n    }\n\n    const beforeAlignment = measurer.size;\n\n    alignIO(\n      measurer,\n      isUnstruct(struct) ? customAlignmentOf(prop) : alignmentOf(prop),\n    );\n\n    if (lastEntry) {\n      lastEntry.padding = measurer.size - beforeAlignment;\n    }\n\n    const propSize = sizeOf(prop);\n    offsets[key] = { offset: measurer.size, size: propSize };\n    lastEntry = offsets[key];\n    measurer.add(propSize);\n  }\n\n  if (lastEntry) {\n    lastEntry.padding = roundUp(sizeOf(struct), alignmentOf(struct)) -\n      measurer.size;\n  }\n\n  cachedOffsets.set(\n    struct as\n      | WgslStruct<Record<string, BaseData>>\n      | Unstruct<Record<string, BaseData>>,\n    offsets,\n  );\n\n  return offsets;\n}\n","import type { IMeasurer, ISerialInput, ISerialOutput } from 'typed-binary';\n\n/**\n * @param io the IO to align\n * @param baseAlignment must be power of 2\n */\nfunction alignIO(\n  io: ISerialInput | ISerialOutput | IMeasurer,\n  baseAlignment: number,\n) {\n  const currentPos = 'size' in io ? io.size : io.currentByteOffset;\n\n  const bitMask = baseAlignment - 1;\n  const offset = currentPos & bitMask;\n\n  if ('skipBytes' in io) {\n    io.skipBytes((baseAlignment - offset) & bitMask);\n  } else {\n    io.add((baseAlignment - offset) & bitMask);\n  }\n}\n\nexport default alignIO;\n","import { roundUp } from '../mathUtils.ts';\nimport type { Infer } from '../shared/repr.ts';\nimport { alignmentOf } from './alignmentOf.ts';\nimport { isDisarray, isUnstruct } from './dataTypes.ts';\nimport { offsetsForProps } from './offsets.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport * as wgsl from './wgslTypes.ts';\n\nexport const EVAL_ALLOWED_IN_ENV: boolean = (() => {\n  try {\n    new Function('return true');\n    return true;\n  } catch {\n    return false;\n  }\n})();\n\nconst compiledWriters = new WeakMap<\n  wgsl.BaseData,\n  (\n    output: DataView,\n    offset: number,\n    value: unknown,\n    littleEndian?: boolean,\n  ) => void\n>();\n\nconst typeToPrimitive = {\n  u32: 'u32',\n  vec2u: 'u32',\n  vec3u: 'u32',\n  vec4u: 'u32',\n  u16: 'u16',\n\n  i32: 'i32',\n  vec2i: 'i32',\n  vec3i: 'i32',\n  vec4i: 'i32',\n\n  f32: 'f32',\n  vec2f: 'f32',\n  vec3f: 'f32',\n  vec4f: 'f32',\n\n  vec2h: 'f32',\n  vec3h: 'f32',\n  vec4h: 'f32',\n\n  mat2x2f: 'f32',\n  mat3x3f: 'f32',\n  mat4x4f: 'f32',\n} as const;\n\nconst primitiveToWriteFunction = {\n  u32: 'setUint32',\n  i32: 'setInt32',\n  f32: 'setFloat32',\n  u16: 'setUint16',\n} as const;\n\nexport function buildWriter(\n  node: wgsl.BaseData,\n  offsetExpr: string,\n  valueExpr: string,\n): string {\n  if (wgsl.isAtomic(node) || wgsl.isDecorated(node)) {\n    return buildWriter(node.inner, offsetExpr, valueExpr);\n  }\n\n  if (wgsl.isWgslStruct(node) || isUnstruct(node)) {\n    const propOffsets = offsetsForProps(node);\n    const sortedProps = Object.entries(propOffsets).sort(\n      (a, b) => a[1].offset - b[1].offset,\n    );\n    let code = '';\n    for (const [key, propOffset] of sortedProps) {\n      const subSchema = node.propTypes[key];\n      if (!subSchema) continue;\n      code += buildWriter(\n        subSchema,\n        `(${offsetExpr} + ${propOffset.offset})`,\n        `${valueExpr}.${key}`,\n      );\n    }\n    return code;\n  }\n\n  if (wgsl.isWgslArray(node) || isDisarray(node)) {\n    const arrSchema = node as wgsl.WgslArray;\n    const elementSize = roundUp(\n      sizeOf(arrSchema.elementType),\n      alignmentOf(arrSchema.elementType),\n    );\n    let code = '';\n\n    code += `for (let i = 0; i < ${arrSchema.elementCount}; i++) {\\n`;\n    code += buildWriter(\n      arrSchema.elementType,\n      `(${offsetExpr} + i * ${elementSize})`,\n      `${valueExpr}[i]`,\n    );\n    code += '}\\n';\n\n    return code;\n  }\n\n  if (wgsl.isVec(node)) {\n    const primitive = typeToPrimitive[node.type];\n    let code = '';\n    const writeFunc = primitiveToWriteFunction[primitive];\n    const components = ['x', 'y', 'z', 'w'];\n    const count = wgsl.isVec2(node) ? 2 : wgsl.isVec3(node) ? 3 : 4;\n\n    for (let i = 0; i < count; i++) {\n      code += `output.${writeFunc}((${offsetExpr} + ${i * 4}), ${valueExpr}.${\n        components[i]\n      }, littleEndian);\\n`;\n    }\n    return code;\n  }\n\n  if (wgsl.isMat(node)) {\n    const primitive = typeToPrimitive[node.type];\n    const writeFunc = primitiveToWriteFunction[primitive];\n\n    const matSize = wgsl.isMat2x2f(node) ? 2 : wgsl.isMat3x3f(node) ? 3 : 4;\n    const elementCount = matSize * matSize;\n    const rowStride = roundUp(matSize * 4, 8);\n\n    let code = '';\n    for (let i = 0; i < elementCount; i++) {\n      const colIndex = Math.floor(i / matSize);\n      const rowIndex = i % matSize;\n      const byteOffset = colIndex * rowStride + rowIndex * 4;\n\n      code +=\n        `output.${writeFunc}((${offsetExpr} + ${byteOffset}), ${valueExpr}.columns[${colIndex}].${\n          ['x', 'y', 'z', 'w'][rowIndex]\n        }, littleEndian);\\n`;\n    }\n\n    return code;\n  }\n\n  const primitive = typeToPrimitive[node.type as keyof typeof typeToPrimitive];\n  return `output.${\n    primitiveToWriteFunction[primitive]\n  }(${offsetExpr}, ${valueExpr}, littleEndian);\\n`;\n}\n\nexport function getCompiledWriterForSchema<T extends wgsl.BaseData>(\n  schema: T,\n): (\n  output: DataView,\n  offset: number,\n  value: Infer<T>,\n  littleEndian?: boolean,\n) => void {\n  if (compiledWriters.has(schema)) {\n    return compiledWriters.get(schema) as (\n      output: DataView,\n      offset: number,\n      value: Infer<T>,\n      littleEndian?: boolean,\n    ) => void;\n  }\n\n  const body = buildWriter(schema, 'offset', 'value');\n\n  const fn = new Function(\n    'output',\n    'offset',\n    'value',\n    'littleEndian=true',\n    body,\n  ) as (\n    output: DataView,\n    offset: number,\n    value: Infer<T> | unknown,\n    littleEndian?: boolean,\n  ) => void;\n\n  compiledWriters.set(schema, fn);\n\n  return fn;\n}\n","import type { ISerialInput, ISerialOutput } from 'typed-binary';\nimport type { Infer, InferRecord } from '../shared/repr.ts';\nimport alignIO from './alignIO.ts';\nimport { alignmentOf, customAlignmentOf } from './alignmentOf.ts';\nimport type {\n  AnyConcreteData,\n  AnyData,\n  Disarray,\n  LooseDecorated,\n  Unstruct,\n} from './dataTypes.ts';\nimport { mat2x2f, mat3x3f, mat4x4f } from './matrix.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport {\n  vec2f,\n  vec2h,\n  vec2i,\n  vec2u,\n  vec3f,\n  vec3h,\n  vec3i,\n  vec3u,\n  vec4f,\n  vec4h,\n  vec4i,\n  vec4u,\n} from './vector.ts';\nimport type * as wgsl from './wgslTypes.ts';\n\ntype DataWriter<TSchema extends wgsl.BaseData> = (\n  output: ISerialOutput,\n  schema: TSchema,\n  value: Infer<TSchema>,\n) => void;\n\ntype DataReader<TSchema extends wgsl.BaseData> = (\n  input: ISerialInput,\n  schema: TSchema,\n) => Infer<TSchema>;\n\ntype CompleteDataWriters = {\n  [TType in AnyConcreteData['type']]: DataWriter<\n    Extract<AnyData, { readonly type: TType }>\n  >;\n};\n\ntype CompleteDataReaders = {\n  [TType in AnyConcreteData['type']]: DataReader<\n    Extract<AnyData, { readonly type: TType }>\n  >;\n};\n\nconst dataWriters = {\n  bool() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  f32(output, _schema: wgsl.F32, value: number) {\n    output.writeFloat32(value);\n  },\n\n  f16(output, _schema: wgsl.F16, value: number) {\n    output.writeFloat16(value);\n  },\n\n  i32(output, _schema: wgsl.I32, value: number) {\n    output.writeInt32(value);\n  },\n\n  u32(output, _schema: wgsl.U32, value: number) {\n    output.writeUint32(value);\n  },\n\n  u16(output, _schema: wgsl.U16, value: number) {\n    output.writeUint16(value);\n  },\n\n  vec2f(output, _, value: wgsl.v2f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n  },\n\n  vec2h(output, _, value: wgsl.v2h) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n  },\n\n  vec2i(output, _, value: wgsl.v2i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n  },\n\n  vec2u(output, _, value: wgsl.v2u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n  },\n\n  'vec2<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  vec3f(output, _, value: wgsl.v3f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n  },\n\n  vec3h(output, _, value: wgsl.v3h) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n    output.writeFloat16(value.z);\n  },\n\n  vec3i(output, _, value: wgsl.v3i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n  },\n\n  vec3u(output, _, value: wgsl.v3u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n  },\n\n  'vec3<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  vec4f(output, _, value: wgsl.v4f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n    output.writeFloat32(value.w);\n  },\n\n  vec4h(output, _, value: wgsl.v4h) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n    output.writeFloat16(value.z);\n    output.writeFloat16(value.w);\n  },\n\n  vec4i(output, _, value: wgsl.v4i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n    output.writeInt32(value.w);\n  },\n\n  vec4u(output, _, value: wgsl.v4u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n    output.writeUint32(value.w);\n  },\n\n  'vec4<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  mat2x2f(output, _, value: wgsl.m2x2f) {\n    for (let i = 0; i < value.length; ++i) {\n      output.writeFloat32(value[i] as number);\n    }\n  },\n\n  mat3x3f(output, _, value: wgsl.m3x3f) {\n    for (let i = 0; i < value.length; ++i) {\n      output.writeFloat32(value[i] as number);\n    }\n  },\n\n  mat4x4f(output, _, value: wgsl.m4x4f) {\n    for (let i = 0; i < value.length; ++i) {\n      output.writeFloat32(value[i] as number);\n    }\n  },\n\n  struct(\n    output,\n    schema: wgsl.WgslStruct,\n    value: InferRecord<Record<string, wgsl.BaseData>>,\n  ) {\n    const alignment = alignmentOf(schema);\n    alignIO(output, alignment);\n\n    for (const [key, property] of Object.entries(schema.propTypes)) {\n      alignIO(output, alignmentOf(property));\n      writeData(output, property, value[key] as wgsl.BaseData);\n    }\n\n    alignIO(output, alignment);\n  },\n\n  array(output, schema: wgsl.WgslArray, value: Infer<wgsl.BaseData>[]) {\n    if (schema.elementCount === 0) {\n      throw new Error('Cannot write using a runtime-sized schema.');\n    }\n\n    const alignment = alignmentOf(schema);\n    alignIO(output, alignment);\n    const beginning = output.currentByteOffset;\n    for (let i = 0; i < Math.min(schema.elementCount, value.length); i++) {\n      alignIO(output, alignment);\n      writeData(output, schema.elementType, value[i]);\n    }\n    output.seekTo(beginning + sizeOf(schema));\n  },\n\n  ptr() {\n    throw new Error('Pointers are not host-shareable');\n  },\n\n  atomic(output, schema: wgsl.Atomic, value: number) {\n    dataWriters[schema.inner.type]?.(output, schema, value);\n  },\n\n  decorated(output, schema: wgsl.Decorated, value: unknown) {\n    const alignment = customAlignmentOf(schema);\n    alignIO(output, alignment);\n\n    const beginning = output.currentByteOffset;\n    dataWriters[(schema.inner as AnyData)?.type]?.(output, schema.inner, value);\n    output.seekTo(beginning + sizeOf(schema));\n  },\n\n  // Loose Types\n\n  uint8(output, _, value: number) {\n    output.writeUint8(value);\n  },\n  uint8x2(output, _, value: wgsl.v2u) {\n    output.writeUint8(value.x);\n    output.writeUint8(value.y);\n  },\n  uint8x4(output, _, value: wgsl.v4u) {\n    output.writeUint8(value.x);\n    output.writeUint8(value.y);\n    output.writeUint8(value.z);\n    output.writeUint8(value.w);\n  },\n  sint8(output, _, value: number) {\n    output.writeInt8(value);\n  },\n  sint8x2(output, _, value: wgsl.v2i) {\n    output.writeInt8(value.x);\n    output.writeInt8(value.y);\n  },\n  sint8x4(output, _, value: wgsl.v4i) {\n    output.writeInt8(value.x);\n    output.writeInt8(value.y);\n    output.writeInt8(value.z);\n    output.writeInt8(value.w);\n  },\n  unorm8(output, _, value: number) {\n    output.writeUint8(value * 255);\n  },\n  unorm8x2(output, _, value: wgsl.v2f) {\n    output.writeUint8(value.x * 255);\n    output.writeUint8(value.y * 255);\n  },\n  unorm8x4(output, _, value: wgsl.v4f) {\n    output.writeUint8(value.x * 255);\n    output.writeUint8(value.y * 255);\n    output.writeUint8(value.z * 255);\n    output.writeUint8(value.w * 255);\n  },\n  snorm8(output, _, value: number) {\n    output.writeUint8(value * 127 + 128);\n  },\n  snorm8x2(output, _, value: wgsl.v2f) {\n    output.writeUint8(value.x * 127 + 128);\n    output.writeUint8(value.y * 127 + 128);\n  },\n  snorm8x4(output, _, value: wgsl.v4f) {\n    output.writeUint8(value.x * 127 + 128);\n    output.writeUint8(value.y * 127 + 128);\n    output.writeUint8(value.z * 127 + 128);\n    output.writeUint8(value.w * 127 + 128);\n  },\n  uint16(output, _, value: number) {\n    output.writeUint16(value);\n  },\n  uint16x2(output, _, value: wgsl.v2u) {\n    output.writeUint16(value.x);\n    output.writeUint16(value.y);\n  },\n  uint16x4(output, _, value: wgsl.v4u) {\n    output.writeUint16(value.x);\n    output.writeUint16(value.y);\n    output.writeUint16(value.z);\n    output.writeUint16(value.w);\n  },\n  sint16(output, _, value: number) {\n    output.writeInt16(value);\n  },\n  sint16x2(output, _, value: wgsl.v2i) {\n    output.writeInt16(value.x);\n    output.writeInt16(value.y);\n  },\n  sint16x4(output, _, value: wgsl.v4i) {\n    output.writeInt16(value.x);\n    output.writeInt16(value.y);\n    output.writeInt16(value.z);\n    output.writeInt16(value.w);\n  },\n  unorm16(output, _, value: number) {\n    output.writeUint16(value * 65535);\n  },\n  unorm16x2(output, _, value: wgsl.v2f) {\n    output.writeUint16(value.x * 65535);\n    output.writeUint16(value.y * 65535);\n  },\n  unorm16x4(output, _, value: wgsl.v4f) {\n    output.writeUint16(value.x * 65535);\n    output.writeUint16(value.y * 65535);\n    output.writeUint16(value.z * 65535);\n    output.writeUint16(value.w * 65535);\n  },\n  snorm16(output, _, value: number) {\n    output.writeUint16(value * 32767 + 32768);\n  },\n  snorm16x2(output, _, value: wgsl.v2f) {\n    output.writeUint16(value.x * 32767 + 32768);\n    output.writeUint16(value.y * 32767 + 32768);\n  },\n  snorm16x4(output, _, value: wgsl.v4f) {\n    output.writeUint16(value.x * 32767 + 32768);\n    output.writeUint16(value.y * 32767 + 32768);\n    output.writeUint16(value.z * 32767 + 32768);\n    output.writeUint16(value.w * 32767 + 32768);\n  },\n  float16(output, _, value: number) {\n    output.writeFloat16(value);\n  },\n  float16x2(output, _, value: wgsl.v2f) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n  },\n  float16x4(output, _, value: wgsl.v4f) {\n    output.writeFloat16(value.x);\n    output.writeFloat16(value.y);\n    output.writeFloat16(value.z);\n    output.writeFloat16(value.w);\n  },\n  float32(output, _, value: number) {\n    output.writeFloat32(value);\n  },\n  float32x2(output, _, value: wgsl.v2f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n  },\n  float32x3(output, _, value: wgsl.v3f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n  },\n  float32x4(output, _, value: wgsl.v4f) {\n    output.writeFloat32(value.x);\n    output.writeFloat32(value.y);\n    output.writeFloat32(value.z);\n    output.writeFloat32(value.w);\n  },\n  uint32(output, _, value: number) {\n    output.writeUint32(value);\n  },\n  uint32x2(output, _, value: wgsl.v2u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n  },\n  uint32x3(output, _, value: wgsl.v3u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n  },\n  uint32x4(output, _, value: wgsl.v4u) {\n    output.writeUint32(value.x);\n    output.writeUint32(value.y);\n    output.writeUint32(value.z);\n    output.writeUint32(value.w);\n  },\n  sint32(output, _, value: number) {\n    output.writeInt32(value);\n  },\n  sint32x2(output, _, value: wgsl.v2i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n  },\n  sint32x3(output, _, value: wgsl.v3i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n  },\n  sint32x4(output, _, value: wgsl.v4i) {\n    output.writeInt32(value.x);\n    output.writeInt32(value.y);\n    output.writeInt32(value.z);\n    output.writeInt32(value.w);\n  },\n  'unorm10-10-10-2'(output, _, value: wgsl.v4f) {\n    let packed = 0;\n    packed |= ((value.x * 1023) & 1023) << 22; // r (10 bits)\n    packed |= ((value.x * 1023) & 1023) << 12; // g (10 bits)\n    packed |= ((value.y * 1023) & 1023) << 2; // b (10 bits)\n    packed |= (value.z * 3) & 3; // a (2 bits)\n    output.writeUint32(packed);\n  },\n  'unorm8x4-bgra'(output, _, value: wgsl.v4f) {\n    output.writeUint8(value.z * 255);\n    output.writeUint8(value.y * 255);\n    output.writeUint8(value.x * 255);\n    output.writeUint8(value.w * 255);\n  },\n\n  disarray(output, schema: Disarray, value: unknown[]) {\n    const alignment = alignmentOf(schema);\n\n    alignIO(output, alignment);\n    const beginning = output.currentByteOffset;\n    for (let i = 0; i < Math.min(schema.elementCount, value.length); i++) {\n      alignIO(output, alignment);\n      dataWriters[(schema.elementType as AnyData)?.type]?.(\n        output,\n        schema.elementType,\n        value[i],\n      );\n    }\n\n    output.seekTo(beginning + sizeOf(schema));\n  },\n\n  unstruct(output, schema: Unstruct, value) {\n    for (const [key, property] of Object.entries(schema.propTypes)) {\n      dataWriters[property.type]?.(output, property, value[key]);\n    }\n  },\n\n  'loose-decorated'(output, schema: LooseDecorated, value: unknown) {\n    const alignment = customAlignmentOf(schema);\n    alignIO(output, alignment);\n\n    const beginning = output.currentByteOffset;\n    const writer = dataWriters[(schema.inner as AnyData)?.type];\n    writer?.(output, schema.inner, value);\n    output.seekTo(beginning + sizeOf(schema));\n    return value;\n  },\n} satisfies CompleteDataWriters as Record<\n  string,\n  (output: ISerialOutput, schema: unknown, value: unknown) => void\n>;\n\nexport function writeData<TData extends wgsl.BaseData>(\n  output: ISerialOutput,\n  schema: TData,\n  value: Infer<TData>,\n): void {\n  const writer = dataWriters[schema.type];\n  if (!writer) {\n    throw new Error(`Cannot write data of type '${schema.type}'.`);\n  }\n\n  writer(output, schema, value);\n}\n\nconst dataReaders = {\n  bool(): boolean {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  f32(input: ISerialInput): number {\n    return input.readFloat32();\n  },\n\n  f16(input: ISerialInput): number {\n    return input.readFloat16();\n  },\n\n  i32(input: ISerialInput): number {\n    return input.readInt32();\n  },\n\n  u32(input: ISerialInput): number {\n    return input.readUint32();\n  },\n\n  u16(input: ISerialInput): number {\n    return input.readUint16();\n  },\n\n  vec2f(input: ISerialInput): wgsl.v2f {\n    return vec2f(input.readFloat32(), input.readFloat32());\n  },\n\n  vec3f(input: ISerialInput): wgsl.v3f {\n    return vec3f(input.readFloat32(), input.readFloat32(), input.readFloat32());\n  },\n\n  vec4f(input: ISerialInput): wgsl.v4f {\n    return vec4f(\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n    );\n  },\n\n  vec2h(input): wgsl.v2h {\n    return vec2h(input.readFloat16(), input.readFloat16());\n  },\n\n  vec3h(input: ISerialInput): wgsl.v3h {\n    return vec3h(input.readFloat16(), input.readFloat16(), input.readFloat16());\n  },\n\n  vec4h(input: ISerialInput): wgsl.v4h {\n    return vec4h(\n      input.readFloat16(),\n      input.readFloat16(),\n      input.readFloat16(),\n      input.readFloat16(),\n    );\n  },\n\n  vec2i(input): wgsl.v2i {\n    return vec2i(input.readInt32(), input.readInt32());\n  },\n\n  vec3i(input: ISerialInput): wgsl.v3i {\n    return vec3i(input.readInt32(), input.readInt32(), input.readInt32());\n  },\n\n  vec4i(input: ISerialInput): wgsl.v4i {\n    return vec4i(\n      input.readInt32(),\n      input.readInt32(),\n      input.readInt32(),\n      input.readInt32(),\n    );\n  },\n\n  vec2u(input): wgsl.v2u {\n    return vec2u(input.readUint32(), input.readUint32());\n  },\n\n  vec3u(input: ISerialInput): wgsl.v3u {\n    return vec3u(input.readUint32(), input.readUint32(), input.readUint32());\n  },\n\n  vec4u(input: ISerialInput): wgsl.v4u {\n    return vec4u(\n      input.readUint32(),\n      input.readUint32(),\n      input.readUint32(),\n      input.readUint32(),\n    );\n  },\n\n  'vec2<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  'vec3<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  'vec4<bool>'() {\n    throw new Error('Booleans are not host-shareable');\n  },\n\n  mat2x2f(input: ISerialInput): wgsl.m2x2f {\n    return mat2x2f(\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n    );\n  },\n\n  mat3x3f(input: ISerialInput): wgsl.m3x3f {\n    const skipOneAfter = () => {\n      const value = input.readFloat32();\n      input.readFloat32(); // skipping;\n      return value;\n    };\n\n    return mat3x3f(\n      input.readFloat32(),\n      input.readFloat32(),\n      skipOneAfter(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      skipOneAfter(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      skipOneAfter(),\n    );\n  },\n\n  mat4x4f(input: ISerialInput): wgsl.m4x4f {\n    return mat4x4f(\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      //\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n      input.readFloat32(),\n    );\n  },\n\n  struct(input: ISerialInput, schema: wgsl.WgslStruct) {\n    const alignment = alignmentOf(schema);\n    alignIO(input, alignment);\n    const result = {} as Record<string, unknown>;\n\n    for (const [key, property] of Object.entries(schema.propTypes)) {\n      alignIO(input, alignmentOf(property));\n      result[key] = readData(input, property);\n    }\n\n    alignIO(input, alignment);\n    return result as InferRecord<Record<string, wgsl.BaseData>>;\n  },\n\n  array(input, schema) {\n    if (schema.elementCount === 0) {\n      throw new Error('Cannot read using a runtime-sized schema.');\n    }\n\n    const alignment = alignmentOf(schema);\n    const elements: unknown[] = [];\n\n    for (let i = 0; i < schema.elementCount; i++) {\n      alignIO(input, alignment);\n      const elementType = schema.elementType as wgsl.AnyWgslData;\n      const value = readData(input, elementType);\n      elements.push(value);\n    }\n\n    alignIO(input, alignment);\n    return elements as never[];\n  },\n\n  ptr() {\n    throw new Error('Pointers are not host-shareable');\n  },\n\n  atomic(input, schema: wgsl.Atomic): number {\n    return readData(input, schema.inner);\n  },\n\n  decorated(input, schema: wgsl.Decorated) {\n    const alignment = customAlignmentOf(schema);\n    alignIO(input, alignment);\n\n    const beginning = input.currentByteOffset;\n    const value = readData(input, schema.inner);\n    input.seekTo(beginning + sizeOf(schema));\n    return value as never;\n  },\n\n  // Loose Types\n\n  uint8: (i) => i.readUint8(),\n  uint8x2: (i) => vec2u(i.readUint8(), i.readUint8()),\n  uint8x4: (i) =>\n    vec4u(i.readUint8(), i.readUint8(), i.readUint8(), i.readUint8()),\n  sint8: (i) => i.readInt8(),\n  sint8x2: (i) => {\n    return vec2i(i.readInt8(), i.readInt8());\n  },\n  sint8x4: (i) => vec4i(i.readInt8(), i.readInt8(), i.readInt8(), i.readInt8()),\n  unorm8: (i) => i.readUint8() / 255,\n  unorm8x2: (i) => vec2f(i.readUint8() / 255, i.readUint8() / 255),\n  unorm8x4: (i) =>\n    vec4f(\n      i.readUint8() / 255,\n      i.readUint8() / 255,\n      i.readUint8() / 255,\n      i.readUint8() / 255,\n    ),\n  snorm8: (i) => (i.readUint8() - 128) / 127,\n  snorm8x2: (i) =>\n    vec2f((i.readUint8() - 128) / 127, (i.readUint8() - 128) / 127),\n  snorm8x4: (i) =>\n    vec4f(\n      (i.readUint8() - 128) / 127,\n      (i.readUint8() - 128) / 127,\n      (i.readUint8() - 128) / 127,\n      (i.readUint8() - 128) / 127,\n    ),\n  uint16: (i) => i.readUint16(),\n  uint16x2: (i) => vec2u(i.readUint16(), i.readUint16()),\n  uint16x4: (i) =>\n    vec4u(i.readUint16(), i.readUint16(), i.readUint16(), i.readUint16()),\n  sint16: (i) => i.readInt16(),\n  sint16x2: (i) => vec2i(i.readInt16(), i.readInt16()),\n  sint16x4: (i) =>\n    vec4i(i.readInt16(), i.readInt16(), i.readInt16(), i.readInt16()),\n  unorm16: (i) => i.readUint16() / 65535,\n  unorm16x2: (i) => vec2f(i.readUint16() / 65535, i.readUint16() / 65535),\n  unorm16x4: (i) =>\n    vec4f(\n      i.readUint16() / 65535,\n      i.readUint16() / 65535,\n      i.readUint16() / 65535,\n      i.readUint16() / 65535,\n    ),\n  snorm16: (i) => (i.readUint16() - 32768) / 32767,\n  snorm16x2: (i): wgsl.v2f =>\n    vec2f(dataReaders.snorm16(i), dataReaders.snorm16(i)),\n  snorm16x4: (i): wgsl.v4f =>\n    vec4f(\n      dataReaders.snorm16(i),\n      dataReaders.snorm16(i),\n      dataReaders.snorm16(i),\n      dataReaders.snorm16(i),\n    ),\n  float16(i) {\n    return i.readFloat16();\n  },\n  float16x2: (i) => vec2f(i.readFloat16(), i.readFloat16()),\n  float16x4: (i) =>\n    vec4f(i.readFloat16(), i.readFloat16(), i.readFloat16(), i.readFloat16()),\n  float32: (i) => i.readFloat32(),\n  float32x2: (i) => vec2f(i.readFloat32(), i.readFloat32()),\n  float32x3: (i) => vec3f(i.readFloat32(), i.readFloat32(), i.readFloat32()),\n  float32x4: (i) =>\n    vec4f(i.readFloat32(), i.readFloat32(), i.readFloat32(), i.readFloat32()),\n  uint32: (i) => i.readUint32(),\n  uint32x2: (i) => vec2u(i.readUint32(), i.readUint32()),\n  uint32x3: (i) => vec3u(i.readUint32(), i.readUint32(), i.readUint32()),\n  uint32x4: (i) =>\n    vec4u(i.readUint32(), i.readUint32(), i.readUint32(), i.readUint32()),\n  sint32: (i) => i.readInt32(),\n  sint32x2: (i) => vec2i(i.readInt32(), i.readInt32()),\n  sint32x3: (i) => vec3i(i.readInt32(), i.readInt32(), i.readInt32()),\n  sint32x4: (i) =>\n    vec4i(i.readInt32(), i.readInt32(), i.readInt32(), i.readInt32()),\n  'unorm10-10-10-2'(i) {\n    const packed = i.readUint32();\n    const r = (packed >> 22) / 1023;\n    const g = ((packed >> 12) & 1023) / 1023;\n    const b = ((packed >> 2) & 1023) / 1023;\n    const a = (packed & 3) / 3;\n    return vec4f(r, g, b, a);\n  },\n  'unorm8x4-bgra'(i) {\n    const b = i.readByte() / 255;\n    const g = i.readByte() / 255;\n    const r = i.readByte() / 255;\n    const a = i.readByte() / 255;\n    return vec4f(r, g, b, a);\n  },\n\n  unstruct(input, schema: Unstruct) {\n    const result = {} as Record<string, unknown>;\n\n    for (const [key, property] of Object.entries(schema.propTypes)) {\n      result[key] = readData(input, property);\n    }\n\n    return result as InferRecord<Record<string, wgsl.BaseData>>;\n  },\n\n  disarray(input, schema: Disarray) {\n    const alignment = alignmentOf(schema);\n    const elements: unknown[] = [];\n\n    for (let i = 0; i < schema.elementCount; i++) {\n      alignIO(input, alignment);\n      elements.push(readData(input, schema.elementType));\n    }\n\n    alignIO(input, alignment);\n    return elements;\n  },\n\n  'loose-decorated'(input, schema: LooseDecorated) {\n    alignIO(input, customAlignmentOf(schema));\n\n    const beginning = input.currentByteOffset;\n    const value = readData(input, schema.inner);\n    input.seekTo(beginning + sizeOf(schema));\n    return value;\n  },\n} satisfies CompleteDataReaders;\n\nexport function readData<TData extends wgsl.BaseData>(\n  input: ISerialInput,\n  schema: TData,\n): Infer<TData> {\n  const reader = (dataReaders as Record<string, unknown>)[\n    schema.type\n  ] as DataReader<TData>;\n  if (!reader) {\n    throw new Error(`Cannot read data of type '${schema.type}'.`);\n  }\n\n  return reader(input, schema);\n}\n","import { BufferWriter } from 'typed-binary';\nimport { roundUp } from '../mathUtils.ts';\nimport type { Infer, InferPartial } from '../shared/repr.ts';\nimport { alignmentOf } from './alignmentOf.ts';\nimport { writeData } from './dataIO.ts';\nimport { isDisarray, isUnstruct } from './dataTypes.ts';\nimport { offsetsForProps } from './offsets.ts';\nimport { sizeOf } from './sizeOf.ts';\nimport type * as wgsl from './wgslTypes.ts';\nimport { isWgslArray, isWgslStruct } from './wgslTypes.ts';\n\nexport interface WriteInstruction {\n  data: Uint8Array;\n}\n\nexport function getWriteInstructions<TData extends wgsl.BaseData>(\n  schema: TData,\n  data: InferPartial<TData>,\n): WriteInstruction[] {\n  const totalSize = sizeOf(schema);\n  if (totalSize === 0 || data === undefined || data === null) {\n    return [];\n  }\n\n  const bigBuffer = new ArrayBuffer(totalSize);\n  const writer = new BufferWriter(bigBuffer);\n\n  const segments: Array<{\n    start: number;\n    end: number;\n    padding?: number | undefined;\n  }> = [];\n\n  function gatherAndWrite<T extends wgsl.BaseData>(\n    node: T,\n    partialValue: InferPartial<T> | undefined,\n    offset: number,\n    padding?: number | undefined,\n  ) {\n    if (partialValue === undefined || partialValue === null) {\n      return;\n    }\n\n    if (isWgslStruct(node) || isUnstruct(node)) {\n      const propOffsets = offsetsForProps(node);\n\n      for (const [key, propOffset] of Object.entries(propOffsets)) {\n        const subSchema = node.propTypes[key];\n        if (!subSchema) {\n          continue;\n        }\n\n        const childValue = partialValue[key as keyof typeof partialValue];\n        if (childValue !== undefined) {\n          gatherAndWrite(\n            subSchema,\n            childValue,\n            offset + propOffset.offset,\n            propOffset.padding ?? padding,\n          );\n        }\n      }\n      return;\n    }\n\n    if (isWgslArray(node) || isDisarray(node)) {\n      const arrSchema = node as wgsl.WgslArray;\n      const elementSize = roundUp(\n        sizeOf(arrSchema.elementType),\n        alignmentOf(arrSchema.elementType),\n      );\n\n      if (!Array.isArray(partialValue)) {\n        throw new Error('Partial value for array must be an array');\n      }\n      const arrayPartialValue =\n        (partialValue as InferPartial<wgsl.WgslArray>) ?? [];\n\n      arrayPartialValue.sort((a, b) => a.idx - b.idx);\n\n      for (const { idx, value } of arrayPartialValue) {\n        gatherAndWrite(\n          arrSchema.elementType,\n          value,\n          offset + idx * elementSize,\n          elementSize - sizeOf(arrSchema.elementType),\n        );\n      }\n    } else {\n      const leafSize = sizeOf(node);\n      writer.seekTo(offset);\n      writeData(writer, node, partialValue as Infer<T>);\n\n      segments.push({ start: offset, end: offset + leafSize, padding });\n    }\n  }\n\n  gatherAndWrite(schema, data, 0);\n\n  if (segments.length === 0) {\n    return [];\n  }\n\n  const instructions: WriteInstruction[] = [];\n  let current = segments[0];\n\n  for (let i = 1; i < segments.length; i++) {\n    const next = segments[i];\n    if (!next || !current) {\n      throw new Error('Internal error: missing segment');\n    }\n    if (next.start === current.end + (current.padding ?? 0)) {\n      current.end = next.end;\n      current.padding = next.padding;\n    } else {\n      instructions.push({\n        data: new Uint8Array(\n          bigBuffer,\n          current.start,\n          current.end - current.start,\n        ),\n      });\n      current = next;\n    }\n  }\n\n  if (!current) {\n    throw new Error('Internal error: missing segment');\n  }\n\n  instructions.push({\n    data: new Uint8Array(bigBuffer, current.start, current.end - current.start),\n  });\n\n  return instructions;\n}\n","import { getName } from './shared/meta.ts';\n\nexport interface NotAllowed<TMsg> {\n  reason: TMsg;\n}\n\nexport type ExtensionGuard<TFlag, TMsg, TAllowed> = boolean extends TFlag\n  ? NotAllowed<TMsg> | TAllowed\n  : TAllowed;\n\n// #region Shared usage extensions\n\nexport interface StorageFlag {\n  usableAsStorage: true;\n}\n\n/**\n * @deprecated Use StorageFlag instead.\n */\nexport type Storage = StorageFlag;\n\nexport function isUsableAsStorage<T>(value: T): value is T & StorageFlag {\n  return !!(value as unknown as StorageFlag)?.usableAsStorage;\n}\n\n/**\n * @category Errors\n */\nexport class NotStorageError extends Error {\n  constructor(value: object) {\n    super(\n      `Resource '${\n        getName(value) ?? '<unnamed>'\n      }' cannot be bound as 'storage'. Use .$usage('storage') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotStorageError.prototype);\n  }\n}\n\n// #endregion\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport type { AnyWgslData, BaseData } from '../../data/wgslTypes.ts';\nimport { isUsableAsStorage, type StorageFlag } from '../../extension.ts';\nimport { inGPUMode } from '../../gpuMode.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $gpuValueOf,\n  $internal,\n  $repr,\n  $wgslDataType,\n} from '../../shared/symbols.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type {\n  BindableBufferUsage,\n  ResolutionCtx,\n  SelfResolvable,\n} from '../../types.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\nimport type { TgpuBuffer, UniformFlag } from './buffer.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuBufferUsage<\n  TData extends BaseData = BaseData,\n  TUsage extends BindableBufferUsage = BindableBufferUsage,\n> {\n  readonly resourceType: 'buffer-usage';\n  readonly usage: TUsage;\n  readonly [$repr]: Infer<TData>;\n  value: InferGPU<TData>;\n  $: InferGPU<TData>;\n\n  readonly [$internal]: {\n    readonly dataType: TData;\n  };\n}\n\nexport interface TgpuBufferUniform<TData extends BaseData>\n  extends TgpuBufferUsage<TData, 'uniform'> {\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n}\n\nexport interface TgpuBufferReadonly<TData extends BaseData>\n  extends TgpuBufferUsage<TData, 'readonly'> {\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n}\n\nexport interface TgpuFixedBufferUsage<TData extends BaseData>\n  extends TgpuNamable {\n  readonly buffer: TgpuBuffer<TData>;\n}\n\nexport interface TgpuBufferMutable<TData extends BaseData>\n  extends TgpuBufferUsage<TData, 'mutable'> {}\n\nexport function isUsableAsUniform<T extends TgpuBuffer<AnyData>>(\n  buffer: T,\n): buffer is T & UniformFlag {\n  return !!(buffer as unknown as UniformFlag).usableAsUniform;\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst usageToVarTemplateMap: Record<BindableBufferUsage, string> = {\n  uniform: 'uniform',\n  mutable: 'storage, read_write',\n  readonly: 'storage, read',\n};\n\nclass TgpuFixedBufferImpl<\n  TData extends AnyWgslData,\n  TUsage extends BindableBufferUsage,\n> implements\n  TgpuBufferUsage<TData, TUsage>,\n  SelfResolvable,\n  TgpuFixedBufferUsage<TData> {\n  /** Type-token, not available at runtime */\n  declare public readonly [$repr]: Infer<TData>;\n  public readonly resourceType = 'buffer-usage' as const;\n  public readonly [$internal]: { readonly dataType: TData };\n  public readonly [$getNameForward]: TgpuBuffer<TData>;\n\n  constructor(\n    public readonly usage: TUsage,\n    public readonly buffer: TgpuBuffer<TData>,\n  ) {\n    this[$internal] = { dataType: buffer.dataType };\n    this[$getNameForward] = buffer;\n  }\n\n  $name(label: string) {\n    this.buffer.$name(label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const { group, binding } = ctx.allocateFixedEntry(\n      this.usage === 'uniform'\n        ? { uniform: this.buffer.dataType }\n        : { storage: this.buffer.dataType, access: this.usage },\n      this.buffer,\n    );\n    const usage = usageToVarTemplateMap[this.usage];\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var<${usage}> ${id}: ${\n        ctx.resolve(\n          this.buffer.dataType,\n        )\n      };`,\n    );\n\n    return id;\n  }\n\n  toString(): string {\n    return `${this.usage}:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): InferGPU<TData> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this.buffer.dataType,\n      },\n      valueProxyHandler,\n    ) as InferGPU<TData>;\n  }\n\n  get value(): InferGPU<TData> {\n    if (!inGPUMode()) {\n      throw new Error(`Cannot access buffer's value directly in JS.`);\n    }\n\n    return this[$gpuValueOf]();\n  }\n\n  get $(): InferGPU<TData> {\n    return this.value;\n  }\n}\n\nexport class TgpuLaidOutBufferImpl<\n  TData extends BaseData,\n  TUsage extends BindableBufferUsage,\n> implements TgpuBufferUsage<TData, TUsage>, SelfResolvable {\n  /** Type-token, not available at runtime */\n  declare public readonly [$repr]: Infer<TData>;\n  public readonly resourceType = 'buffer-usage' as const;\n  public readonly [$internal]: { readonly dataType: TData };\n\n  constructor(\n    public readonly usage: TUsage,\n    public readonly dataType: TData,\n    private readonly _membership: LayoutMembership,\n  ) {\n    this[$internal] = { dataType };\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n    const usage = usageToVarTemplateMap[this.usage];\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var<${usage}> ${id}: ${\n        ctx.resolve(this.dataType as AnyWgslData)\n      };`,\n    );\n\n    return id;\n  }\n\n  toString(): string {\n    return `${this.usage}:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): InferGPU<TData> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this.dataType,\n      },\n      valueProxyHandler,\n    ) as InferGPU<TData>;\n  }\n\n  get value(): InferGPU<TData> {\n    if (!inGPUMode()) {\n      throw new Error(`Cannot access buffer's value directly in JS.`);\n    }\n\n    return this[$gpuValueOf]();\n  }\n\n  get $(): InferGPU<TData> {\n    return this.value;\n  }\n}\n\nconst mutableUsageMap = new WeakMap<\n  TgpuBuffer<AnyWgslData>,\n  TgpuFixedBufferImpl<AnyWgslData, 'mutable'>\n>();\n\n/**\n * @deprecated Use buffer.as('mutable') instead.\n */\nexport function asMutable<TData extends AnyWgslData>(\n  buffer: TgpuBuffer<TData> & StorageFlag,\n): TgpuBufferMutable<TData> & TgpuFixedBufferUsage<TData> {\n  if (!isUsableAsStorage(buffer)) {\n    throw new Error(\n      `Cannot pass ${buffer} to asMutable, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`,\n    );\n  }\n\n  let usage = mutableUsageMap.get(buffer);\n  if (!usage) {\n    usage = new TgpuFixedBufferImpl('mutable', buffer);\n    mutableUsageMap.set(buffer, usage);\n  }\n  return usage as unknown as\n    & TgpuBufferMutable<TData>\n    & TgpuFixedBufferUsage<TData>;\n}\n\nconst readonlyUsageMap = new WeakMap<\n  TgpuBuffer<AnyWgslData>,\n  TgpuFixedBufferImpl<AnyWgslData, 'readonly'>\n>();\n\n/**\n * @deprecated Use buffer.as('readonly') instead.\n */\nexport function asReadonly<TData extends AnyWgslData>(\n  buffer: TgpuBuffer<TData> & StorageFlag,\n): TgpuBufferReadonly<TData> & TgpuFixedBufferUsage<TData> {\n  if (!isUsableAsStorage(buffer)) {\n    throw new Error(\n      `Cannot pass ${buffer} to asReadonly, as it is not allowed to be used as storage. To allow it, call .$usage('storage') when creating the buffer.`,\n    );\n  }\n\n  let usage = readonlyUsageMap.get(buffer);\n  if (!usage) {\n    usage = new TgpuFixedBufferImpl('readonly', buffer);\n    readonlyUsageMap.set(buffer, usage);\n  }\n  return usage as unknown as\n    & TgpuBufferReadonly<TData>\n    & TgpuFixedBufferUsage<TData>;\n}\n\nconst uniformUsageMap = new WeakMap<\n  TgpuBuffer<AnyWgslData>,\n  TgpuFixedBufferImpl<AnyWgslData, 'uniform'>\n>();\n\n/**\n * @deprecated Use buffer.as('uniform') instead.\n */\nexport function asUniform<TData extends AnyWgslData>(\n  buffer: TgpuBuffer<TData> & UniformFlag,\n): TgpuBufferUniform<TData> & TgpuFixedBufferUsage<TData> {\n  if (!isUsableAsUniform(buffer)) {\n    throw new Error(\n      `Cannot pass ${buffer} to asUniform, as it is not allowed to be used as a uniform. To allow it, call .$usage('uniform') when creating the buffer.`,\n    );\n  }\n\n  let usage = uniformUsageMap.get(buffer);\n  if (!usage) {\n    usage = new TgpuFixedBufferImpl('uniform', buffer);\n    uniformUsageMap.set(buffer, usage);\n  }\n  return usage as unknown as\n    & TgpuBufferUniform<TData>\n    & TgpuFixedBufferUsage<TData>;\n}\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport { $internal, $wgslDataType } from '../../shared/symbols.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { Unwrapper } from '../../unwrapper.ts';\n\ninterface SamplerInternals {\n  readonly unwrap?: ((branch: Unwrapper) => GPUSampler) | undefined;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport interface SamplerProps {\n  addressModeU?: GPUAddressMode;\n  addressModeV?: GPUAddressMode;\n  /**\n   * Specifies the address modes for the texture width, height, and depth\n   * coordinates, respectively.\n   */\n  addressModeW?: GPUAddressMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is smaller than or equal to one\n   * texel.\n   */\n  magFilter?: GPUFilterMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is larger than one texel.\n   */\n  minFilter?: GPUFilterMode;\n  /**\n   * Specifies behavior for sampling between mipmap levels.\n   */\n  mipmapFilter?: GPUMipmapFilterMode;\n  lodMinClamp?: number;\n  /**\n   * Specifies the minimum and maximum levels of detail, respectively, used internally when\n   * sampling a texture.\n   */\n  lodMaxClamp?: number;\n  /**\n   * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is\n   * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.\n   * Anisotropic filtering improves the image quality of textures sampled at oblique viewing\n   * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of\n   * anisotropy supported when filtering.\n   *\n   * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range\n   * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}\n   * will be clamped to the maximum value that the platform supports.\n   * The precise filtering behavior is implementation-dependent.\n   */\n  maxAnisotropy?: number;\n}\n\nexport interface ComparisonSamplerProps {\n  compare: GPUCompareFunction;\n  addressModeU?: GPUAddressMode;\n  addressModeV?: GPUAddressMode;\n  /**\n   * Specifies the address modes for the texture width, height, and depth\n   * coordinates, respectively.\n   */\n  addressModeW?: GPUAddressMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is smaller than or equal to one\n   * texel.\n   */\n  magFilter?: GPUFilterMode;\n  /**\n   * Specifies the sampling behavior when the sample footprint is larger than one texel.\n   */\n  minFilter?: GPUFilterMode;\n  /**\n   * Specifies behavior for sampling between mipmap levels.\n   */\n  mipmapFilter?: GPUMipmapFilterMode;\n  lodMinClamp?: number;\n  /**\n   * Specifies the minimum and maximum levels of detail, respectively, used internally when\n   * sampling a texture.\n   */\n  lodMaxClamp?: number;\n  /**\n   * Specifies the maximum anisotropy value clamp used by the sampler. Anisotropic filtering is\n   * enabled when {@link GPUSamplerDescriptor.maxAnisotropy} is > 1 and the implementation supports it.\n   * Anisotropic filtering improves the image quality of textures sampled at oblique viewing\n   * angles. Higher {@link GPUSamplerDescriptor.maxAnisotropy} values indicate the maximum ratio of\n   * anisotropy supported when filtering.\n   *\n   * Most implementations support {@link GPUSamplerDescriptor.maxAnisotropy} values in range\n   * between 1 and 16, inclusive. The used value of {@link GPUSamplerDescriptor.maxAnisotropy}\n   * will be clamped to the maximum value that the platform supports.\n   * The precise filtering behavior is implementation-dependent.\n   */\n  maxAnisotropy?: number;\n}\n\nexport interface TgpuSampler {\n  readonly [$internal]: SamplerInternals;\n  readonly resourceType: 'sampler';\n}\n\nexport interface TgpuComparisonSampler {\n  readonly [$internal]: SamplerInternals;\n  readonly resourceType: 'sampler-comparison';\n}\n\nexport interface TgpuFixedSampler extends TgpuSampler, TgpuNamable {}\n\nexport interface TgpuFixedComparisonSampler\n  extends TgpuComparisonSampler, TgpuNamable {}\n\nexport function sampler(props: SamplerProps): TgpuFixedSampler {\n  return new TgpuFixedSamplerImpl(props);\n}\n\nexport function comparisonSampler(\n  props: ComparisonSamplerProps,\n): TgpuFixedComparisonSampler {\n  return new TgpuFixedComparisonSamplerImpl(props);\n}\n\nexport function isSampler(resource: unknown): resource is TgpuSampler {\n  const maybe = resource as TgpuSampler | undefined;\n  return maybe?.resourceType === 'sampler' && !!maybe[$internal];\n}\n\nexport function isComparisonSampler(\n  resource: unknown,\n): resource is TgpuComparisonSampler {\n  const maybe = resource as TgpuComparisonSampler | undefined;\n  return maybe?.resourceType === 'sampler-comparison' && !!maybe[$internal];\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuLaidOutSamplerImpl implements TgpuSampler, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: SamplerInternals;\n  public readonly resourceType = 'sampler';\n\n  constructor(private readonly _membership: LayoutMembership) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper sampler schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have sampler schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {};\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: sampler;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nexport class TgpuLaidOutComparisonSamplerImpl\n  implements TgpuComparisonSampler, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: SamplerInternals;\n  public readonly resourceType = 'sampler-comparison';\n\n  constructor(private readonly _membership: LayoutMembership) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper sampler schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have sampler schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {};\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: sampler_comparison;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nclass TgpuFixedSamplerImpl implements TgpuFixedSampler, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: SamplerInternals;\n  public readonly resourceType = 'sampler';\n\n  private _filtering: boolean;\n  private _sampler: GPUSampler | null = null;\n\n  constructor(private readonly _props: SamplerProps) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper sampler schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have sampler schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {\n      unwrap: (branch) => {\n        if (!this._sampler) {\n          this._sampler = branch.device.createSampler({\n            ...this._props,\n            label: getName(this) ?? '<unnamed>',\n          });\n        }\n\n        return this._sampler;\n      },\n    };\n\n    // Based on https://www.w3.org/TR/webgpu/#sampler-creation\n    this._filtering = _props.minFilter === 'linear' ||\n      _props.magFilter === 'linear' ||\n      _props.mipmapFilter === 'linear';\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n\n    const { group, binding } = ctx.allocateFixedEntry(\n      {\n        sampler: this._filtering ? 'filtering' : 'non-filtering',\n      },\n      this,\n    );\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: sampler;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nclass TgpuFixedComparisonSamplerImpl\n  implements TgpuFixedComparisonSampler, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: SamplerInternals;\n  public readonly resourceType = 'sampler-comparison';\n\n  private _sampler: GPUSampler | null = null;\n\n  constructor(private readonly _props: ComparisonSamplerProps) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper sampler schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have sampler schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {\n      unwrap: (branch) => {\n        if (!this._sampler) {\n          this._sampler = branch.device.createSampler({\n            ...this._props,\n            label: getName(this) ?? '<unnamed>',\n          });\n        }\n\n        return this._sampler;\n      },\n    };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const { group, binding } = ctx.allocateFixedEntry(\n      { sampler: 'comparison' },\n      this,\n    );\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: sampler_comparison;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n","import { getName, setName } from '../../shared/meta.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuExternalTexture {\n  readonly resourceType: 'external-texture';\n}\n\nexport function isExternalTexture<T extends TgpuExternalTexture>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.resourceType === 'external-texture';\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuExternalTextureImpl\n  implements TgpuExternalTexture, SelfResolvable {\n  public readonly resourceType = 'external-texture';\n\n  constructor(private readonly _membership: LayoutMembership) {\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: texture_external;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n","import { f32, i32, u32 } from '../../data/numeric.ts';\nimport { vec4f, vec4i, vec4u } from '../../data/vector.ts';\nimport type {\n  F32,\n  I32,\n  U32,\n  Vec4f,\n  Vec4i,\n  Vec4u,\n} from '../../data/wgslTypes.ts';\nimport type { Default } from '../../shared/utilityTypes.ts';\nimport type { TextureProps } from './textureProps.ts';\n\nexport const texelFormatToChannelType = {\n  r8unorm: f32,\n  r8snorm: f32,\n  r8uint: u32,\n  r8sint: i32,\n  r16uint: u32,\n  r16sint: i32,\n  r16float: f32,\n  rg8unorm: f32,\n  rg8snorm: f32,\n  rg8uint: u32,\n  rg8sint: i32,\n  r32uint: u32,\n  r32sint: i32,\n  r32float: f32,\n  rg16uint: u32,\n  rg16sint: i32,\n  rg16float: f32,\n  rgba8unorm: f32,\n  'rgba8unorm-srgb': f32,\n  rgba8snorm: f32,\n  rgba8uint: u32,\n  rgba8sint: i32,\n  bgra8unorm: f32,\n  'bgra8unorm-srgb': f32,\n  rgb9e5ufloat: f32,\n  rgb10a2uint: u32,\n  rgb10a2unorm: f32,\n  rg11b10ufloat: f32,\n  rg32uint: u32,\n  rg32sint: i32,\n  rg32float: f32,\n  rgba16uint: u32,\n  rgba16sint: i32,\n  rgba16float: f32,\n  rgba32uint: u32,\n  rgba32sint: i32,\n  rgba32float: f32,\n  stencil8: f32, // NOTE: Honestly have no idea if this is right\n  depth16unorm: f32,\n  depth24plus: f32, // NOTE: Honestly have no idea if this is right\n  'depth24plus-stencil8': f32, // NOTE: Honestly have no idea if this is right\n  depth32float: f32,\n  'depth32float-stencil8': f32,\n  'bc1-rgba-unorm': f32,\n  'bc1-rgba-unorm-srgb': f32,\n  'bc2-rgba-unorm': f32,\n  'bc2-rgba-unorm-srgb': f32,\n  'bc3-rgba-unorm': f32,\n  'bc3-rgba-unorm-srgb': f32,\n  'bc4-r-unorm': f32,\n  'bc4-r-snorm': f32,\n  'bc5-rg-unorm': f32,\n  'bc5-rg-snorm': f32,\n  'bc6h-rgb-ufloat': f32,\n  'bc6h-rgb-float': f32,\n  'bc7-rgba-unorm': f32,\n  'bc7-rgba-unorm-srgb': f32,\n  'etc2-rgb8unorm': f32,\n  'etc2-rgb8unorm-srgb': f32,\n  'etc2-rgb8a1unorm': f32,\n  'etc2-rgb8a1unorm-srgb': f32,\n  'etc2-rgba8unorm': f32,\n  'etc2-rgba8unorm-srgb': f32,\n  'eac-r11unorm': f32,\n  'eac-r11snorm': f32,\n  'eac-rg11unorm': f32,\n  'eac-rg11snorm': f32,\n  'astc-4x4-unorm': f32,\n  'astc-4x4-unorm-srgb': f32,\n  'astc-5x4-unorm': f32,\n  'astc-5x4-unorm-srgb': f32,\n  'astc-5x5-unorm': f32,\n  'astc-5x5-unorm-srgb': f32,\n  'astc-6x5-unorm': f32,\n  'astc-6x5-unorm-srgb': f32,\n  'astc-6x6-unorm': f32,\n  'astc-6x6-unorm-srgb': f32,\n  'astc-8x5-unorm': f32,\n  'astc-8x5-unorm-srgb': f32,\n  'astc-8x6-unorm': f32,\n  'astc-8x6-unorm-srgb': f32,\n  'astc-8x8-unorm': f32,\n  'astc-8x8-unorm-srgb': f32,\n  'astc-10x5-unorm': f32,\n  'astc-10x5-unorm-srgb': f32,\n  'astc-10x6-unorm': f32,\n  'astc-10x6-unorm-srgb': f32,\n  'astc-10x8-unorm': f32,\n  'astc-10x8-unorm-srgb': f32,\n  'astc-10x10-unorm': f32,\n  'astc-10x10-unorm-srgb': f32,\n  'astc-12x10-unorm': f32,\n  'astc-12x10-unorm-srgb': f32,\n  'astc-12x12-unorm': f32,\n  'astc-12x12-unorm-srgb': f32,\n  'r16snorm': f32,\n  'r16unorm': f32,\n  'rg16unorm': f32,\n  'rg16snorm': f32,\n  'rgba16unorm': f32,\n  'rgba16snorm': f32,\n} satisfies Record<GPUTextureFormat, U32 | I32 | F32>;\n\nexport type TexelFormatToChannelType = typeof texelFormatToChannelType;\n\ntype TexelFormatToStringChannels = {\n  [Key in keyof TexelFormatToChannelType]:\n    TexelFormatToChannelType[Key]['type'];\n};\ntype KeysWithValue<T extends Record<string, unknown>, TValue> = keyof {\n  [Key in keyof T as T[Key] extends TValue ? Key : never]: Key;\n};\nexport type ChannelTypeToLegalFormats = {\n  [Key in TexelFormatToChannelType[keyof TexelFormatToChannelType]['type']]:\n    KeysWithValue<\n      TexelFormatToStringChannels,\n      Key\n    >;\n};\n\nexport type SampleTypeToStringChannelType = {\n  float: 'f32';\n  'unfilterable-float': 'f32';\n  depth: 'f32';\n  sint: 'i32';\n  uint: 'u32';\n};\n\nexport type ViewDimensionToDimension = {\n  '1d': '1d';\n  '2d': '2d';\n  '2d-array': '2d';\n  '3d': '3d';\n  cube: '2d';\n  'cube-array': '2d';\n};\n\n/**\n * https://www.w3.org/TR/WGSL/#storage-texel-formats\n */\nexport type StorageTextureTexelFormat =\n  | 'rgba8unorm'\n  | 'rgba8snorm'\n  | 'rgba8uint'\n  | 'rgba8sint'\n  | 'rgba16uint'\n  | 'rgba16sint'\n  | 'rgba16float'\n  | 'r32uint'\n  | 'r32sint'\n  | 'r32float'\n  | 'rg32uint'\n  | 'rg32sint'\n  | 'rg32float'\n  | 'rgba32uint'\n  | 'rgba32sint'\n  | 'rgba32float'\n  | 'bgra8unorm';\n\nexport const texelFormatToDataType = {\n  rgba8unorm: vec4f as Vec4f,\n  rgba8snorm: vec4f as Vec4f,\n  rgba8uint: vec4u as Vec4u,\n  rgba8sint: vec4i as Vec4i,\n  rgba16uint: vec4u as Vec4u,\n  rgba16sint: vec4i as Vec4i,\n  rgba16float: vec4f as Vec4f,\n  r32uint: vec4u as Vec4u,\n  r32sint: vec4i as Vec4i,\n  r32float: vec4f as Vec4f,\n  rg32uint: vec4u as Vec4u,\n  rg32sint: vec4i as Vec4i,\n  rg32float: vec4f as Vec4f,\n  rgba32uint: vec4u as Vec4u,\n  rgba32sint: vec4i as Vec4i,\n  rgba32float: vec4f as Vec4f,\n  bgra8unorm: vec4f as Vec4f,\n} as const;\n\nexport const channelKindToFormat = {\n  f32: 'float',\n  u32: 'uint',\n  i32: 'sint',\n} as const;\n\nexport const channelFormatToSchema = {\n  float: f32,\n  'unfilterable-float': f32,\n  uint: u32,\n  sint: i32,\n  depth: f32, // I guess?\n};\nexport type ChannelFormatToSchema = typeof channelFormatToSchema;\n\nexport type TexelFormatToDataType = typeof texelFormatToDataType;\nexport type TexelFormatToDataTypeOrNever<T> = T extends\n  keyof TexelFormatToDataType ? TexelFormatToDataType[T] : never;\n\n/**\n * Represents what formats a storage view can choose from based on its owner texture's props.\n */\nexport type StorageFormatOptions<TProps extends TextureProps> = Extract<\n  TProps['format'] | Default<TProps['viewFormats'], []>[number],\n  StorageTextureTexelFormat\n>;\n\n/**\n * Represents what formats a sampled view can choose from based on its owner texture's props.\n */\nexport type SampledFormatOptions<TProps extends TextureProps> =\n  | TProps['format']\n  | Default<TProps['viewFormats'], []>[number];\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport type {\n  F32,\n  I32,\n  U32,\n  Vec4f,\n  Vec4i,\n  Vec4u,\n} from '../../data/wgslTypes.ts';\nimport { invariant } from '../../errors.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport {\n  $getNameForward,\n  $internal,\n  $wgslDataType,\n} from '../../shared/symbols.ts';\nimport type {\n  Default,\n  UnionToIntersection,\n} from '../../shared/utilityTypes.ts';\nimport type { LayoutMembership } from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport {\n  channelFormatToSchema,\n  channelKindToFormat,\n  type SampledFormatOptions,\n  type StorageFormatOptions,\n  type StorageTextureTexelFormat,\n  type TexelFormatToChannelType,\n  texelFormatToChannelType,\n  type TexelFormatToDataType,\n  texelFormatToDataType,\n  type TexelFormatToDataTypeOrNever,\n} from './textureFormats.ts';\nimport type { TextureProps } from './textureProps.ts';\nimport type { AllowedUsages, LiteralToExtensionMap } from './usageExtension.ts';\n\ntype ResolveStorageDimension<\n  TDimension extends GPUTextureViewDimension,\n  TProps extends TextureProps,\n> = StorageTextureDimension extends TDimension\n  ? Default<TProps['dimension'], '2d'>\n  : TDimension extends StorageTextureDimension ? TDimension\n  : '2d';\n\ntype ViewUsages<\n  TProps extends TextureProps,\n  TTexture extends TgpuTexture<TProps>,\n> = boolean extends TTexture['usableAsSampled']\n  ? boolean extends TTexture['usableAsStorage'] ? never\n  : 'readonly' | 'writeonly' | 'mutable'\n  : boolean extends TTexture['usableAsStorage'] ? 'sampled'\n  : 'readonly' | 'writeonly' | 'mutable' | 'sampled';\n\ninterface TextureInternals {\n  unwrap(): GPUTexture;\n}\n\ninterface TextureViewInternals {\n  readonly unwrap?: (() => GPUTextureView) | undefined;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport type ChannelData = U32 | I32 | F32;\nexport type TexelData = Vec4u | Vec4i | Vec4f;\n\n/**\n * @param TProps all properties that distinguish this texture apart from other textures on the type level.\n */\nexport interface TgpuTexture<TProps extends TextureProps = TextureProps>\n  extends TgpuNamable {\n  readonly [$internal]: TextureInternals;\n  readonly resourceType: 'texture';\n  readonly props: TProps; // <- storing to be able to differentiate structurally between different textures.\n\n  // Extensions\n  readonly usableAsStorage: boolean;\n  readonly usableAsSampled: boolean;\n  readonly usableAsRender: boolean;\n\n  $usage<T extends AllowedUsages<TProps>[]>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToExtensionMap[T[number]]>;\n\n  createView<\n    TUsage extends ViewUsages<TProps, this>,\n    TDimension extends 'sampled' extends TUsage ? GPUTextureViewDimension\n      : StorageTextureDimension,\n    TFormat extends 'sampled' extends TUsage ? SampledFormatOptions<TProps>\n      : StorageFormatOptions<TProps>,\n  >(\n    access: TUsage,\n    params?: TextureViewParams<TDimension, TFormat>,\n  ): {\n    mutable: TgpuMutableTexture<\n      ResolveStorageDimension<TDimension, TProps>,\n      TexelFormatToDataTypeOrNever<\n        StorageFormatOptions<TProps> extends TFormat ? TProps['format']\n          : TFormat\n      >\n    >;\n    readonly: TgpuReadonlyTexture<\n      ResolveStorageDimension<TDimension, TProps>,\n      TexelFormatToDataTypeOrNever<\n        StorageFormatOptions<TProps> extends TFormat ? TProps['format']\n          : TFormat\n      >\n    >;\n    writeonly: TgpuWriteonlyTexture<\n      ResolveStorageDimension<TDimension, TProps>,\n      TexelFormatToDataTypeOrNever<\n        StorageFormatOptions<TProps> extends TFormat ? TProps['format']\n          : TFormat\n      >\n    >;\n    sampled: TgpuSampledTexture<\n      GPUTextureViewDimension extends TDimension\n        ? Default<TProps['dimension'], '2d'>\n        : TDimension,\n      TexelFormatToChannelType[\n        SampledFormatOptions<TProps> extends TFormat ? TProps['format']\n          : TFormat\n      ]\n    >;\n  }[TUsage];\n\n  destroy(): void;\n}\n\nexport type StorageTextureAccess = 'readonly' | 'writeonly' | 'mutable';\n\n/**\n * Based on @see GPUTextureViewDimension\n * https://www.w3.org/TR/WGSL/#texture-depth\n */\nexport type StorageTextureDimension =\n  | '1d'\n  | '2d'\n  | '2d-array'\n  // | 'cube' <- not supported by storage textures\n  // | 'cube-array' <- not supported by storage textures\n  | '3d';\n\nexport type TextureViewParams<\n  TDimension extends GPUTextureViewDimension | undefined,\n  TFormat extends GPUTextureFormat | undefined,\n> = {\n  format?: TFormat;\n  dimension?: TDimension;\n  aspect?: GPUTextureAspect;\n  baseMipLevel?: number;\n  mipLevelCount?: number;\n  baseArrayLayout?: number;\n  arrayLayerCount?: number;\n};\n\nexport interface TgpuStorageTexture<\n  TDimension extends StorageTextureDimension = StorageTextureDimension,\n  TData extends TexelData = TexelData,\n> {\n  readonly [$internal]: TextureViewInternals;\n  readonly resourceType: 'texture-storage-view';\n  readonly dimension: TDimension;\n  readonly texelDataType: TData;\n  readonly access: StorageTextureAccess;\n}\n\n/**\n * A texture accessed as \"readonly\" storage on the GPU.\n */\nexport interface TgpuReadonlyTexture<\n  TDimension extends StorageTextureDimension = StorageTextureDimension,\n  TData extends TexelData = TexelData,\n> extends TgpuStorageTexture<TDimension, TData> {\n  readonly access: 'readonly';\n}\n\n/**\n * A texture accessed as \"writeonly\" storage on the GPU.\n */\nexport interface TgpuWriteonlyTexture<\n  TDimension extends StorageTextureDimension = StorageTextureDimension,\n  TData extends TexelData = TexelData,\n> extends TgpuStorageTexture<TDimension, TData> {\n  readonly access: 'writeonly';\n}\n\n/**\n * A texture accessed as \"mutable\" (or read_write) storage on the GPU.\n */\nexport interface TgpuMutableTexture<\n  TDimension extends StorageTextureDimension = StorageTextureDimension,\n  TData extends TexelData = TexelData,\n> extends TgpuStorageTexture<TDimension, TData> {\n  readonly access: 'mutable';\n}\n\n/**\n * A texture accessed as sampled on the GPU.\n */\nexport interface TgpuSampledTexture<\n  TDimension extends GPUTextureViewDimension = GPUTextureViewDimension,\n  TData extends ChannelData = ChannelData,\n> {\n  readonly [$internal]: TextureViewInternals;\n  readonly resourceType: 'texture-sampled-view';\n  readonly dimension: TDimension;\n  readonly channelDataType: TData;\n}\n\nexport function INTERNAL_createTexture(\n  props: TextureProps,\n  branch: ExperimentalTgpuRoot,\n): TgpuTexture<TextureProps> {\n  return new TgpuTextureImpl(props, branch);\n}\n\nexport function isTexture<T extends TgpuTexture>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.resourceType === 'texture' && !!(value as T)[$internal];\n}\n\nexport function isStorageTextureView<\n  T extends TgpuReadonlyTexture | TgpuWriteonlyTexture | TgpuMutableTexture,\n>(value: unknown | T): value is T {\n  return (\n    (value as T)?.resourceType === 'texture-storage-view' &&\n    !!(value as T)[$internal]\n  );\n}\n\nexport function isSampledTextureView<T extends TgpuSampledTexture>(\n  value: unknown | T,\n): value is T {\n  return (\n    (value as T)?.resourceType === 'texture-sampled-view' &&\n    !!(value as T)[$internal]\n  );\n}\n\nexport type TgpuAnyTextureView =\n  | TgpuReadonlyTexture\n  | TgpuWriteonlyTexture\n  | TgpuMutableTexture\n  | TgpuSampledTexture;\n\n// --------------\n// Implementation\n// --------------\n\nconst accessMap = {\n  mutable: 'read_write',\n  readonly: 'read',\n  writeonly: 'write',\n} as const;\n\nclass TgpuTextureImpl implements TgpuTexture {\n  public readonly [$internal]: TextureInternals;\n  public readonly resourceType = 'texture';\n  public usableAsSampled = false;\n  public usableAsStorage = false;\n  public usableAsRender = false;\n\n  private _destroyed = false;\n  private _flags = GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;\n  private _texture: GPUTexture | null = null;\n\n  constructor(\n    public readonly props: TextureProps,\n    private readonly _branch: ExperimentalTgpuRoot,\n  ) {\n    this[$internal] = {\n      unwrap: () => {\n        if (this._destroyed) {\n          throw new Error('This texture has been destroyed');\n        }\n\n        if (!this._texture) {\n          this._texture = this._branch.device.createTexture({\n            label: getName(this) ?? '<unnamed>',\n            format: this.props.format,\n            size: this.props.size,\n            usage: this._flags,\n            dimension: this.props.dimension ?? '2d',\n            viewFormats: this.props.viewFormats ?? [],\n            mipLevelCount: this.props.mipLevelCount ?? 1,\n            sampleCount: this.props.sampleCount ?? 1,\n          });\n        }\n\n        return this._texture;\n      },\n    };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  $usage<T extends ('sampled' | 'storage' | 'render')[]>(\n    ...usages: T\n  ): this & UnionToIntersection<LiteralToExtensionMap[T[number]]> {\n    const hasStorage = usages.includes('storage');\n    const hasSampled = usages.includes('sampled');\n    const hasRender = usages.includes('render');\n    this._flags |= hasSampled ? GPUTextureUsage.TEXTURE_BINDING : 0;\n    this._flags |= hasStorage ? GPUTextureUsage.STORAGE_BINDING : 0;\n    this._flags |= hasRender ? GPUTextureUsage.RENDER_ATTACHMENT : 0;\n    this.usableAsStorage ||= hasStorage;\n    this.usableAsSampled ||= hasSampled;\n    this.usableAsRender ||= hasRender;\n\n    return this as this & UnionToIntersection<LiteralToExtensionMap[T[number]]>;\n  }\n\n  createView(\n    access: 'mutable' | 'readonly' | 'writeonly' | 'sampled',\n    params?: TextureViewParams<GPUTextureViewDimension, GPUTextureFormat>,\n  ) {\n    if (access === 'sampled') {\n      return this._asSampled(params);\n    }\n\n    const storageParams = params as TextureViewParams<\n      StorageTextureDimension,\n      StorageTextureTexelFormat\n    >;\n\n    switch (access) {\n      case 'mutable':\n        return this._asMutable(storageParams);\n      case 'readonly':\n        return this._asReadonly(storageParams);\n      case 'writeonly':\n        return this._asWriteonly(storageParams);\n    }\n  }\n\n  private _asStorage(\n    params:\n      | TextureViewParams<StorageTextureDimension, StorageTextureTexelFormat>\n      | undefined,\n    access: StorageTextureAccess,\n  ): TgpuFixedStorageTextureImpl {\n    if (!this.usableAsStorage) {\n      throw new Error('Unusable as storage');\n    }\n\n    const format = params?.format ?? this.props.format;\n    const type = texelFormatToDataType[format as keyof TexelFormatToDataType];\n    invariant(!!type, `Unsupported storage texture format: ${format}`);\n\n    return new TgpuFixedStorageTextureImpl(params ?? {}, access, this);\n  }\n\n  private _asReadonly(\n    params?: TextureViewParams<\n      StorageTextureDimension,\n      StorageTextureTexelFormat\n    >,\n  ) {\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n    return this._asStorage(params, 'readonly') as any;\n  }\n\n  private _asWriteonly(\n    params?: TextureViewParams<\n      StorageTextureDimension,\n      StorageTextureTexelFormat\n    >,\n  ) {\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n    return this._asStorage(params, 'writeonly') as any;\n  }\n\n  private _asMutable(\n    params?: TextureViewParams<\n      StorageTextureDimension,\n      StorageTextureTexelFormat\n    >,\n  ) {\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n    return this._asStorage(params, 'mutable') as any;\n  }\n\n  private _asSampled(\n    params?: TextureViewParams<GPUTextureViewDimension, GPUTextureFormat>,\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n  ): any {\n    if (!this.usableAsSampled) {\n      throw new Error('Unusable as sampled');\n    }\n\n    const format = params?.format ?? this.props.format;\n    const type = texelFormatToDataType[format as keyof TexelFormatToDataType];\n\n    if (!type) {\n      throw new Error(`Unsupported storage texture format: ${format}`);\n    }\n\n    return new TgpuFixedSampledTextureImpl(params, this);\n  }\n\n  destroy() {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n    this._texture?.destroy();\n  }\n}\n\nconst dimensionToCodeMap = {\n  '1d': '1d',\n  '2d': '2d',\n  '2d-array': '2d_array',\n  cube: 'cube',\n  'cube-array': 'cube_array',\n  '3d': '3d',\n} satisfies Record<GPUTextureViewDimension, string>;\n\nclass TgpuFixedStorageTextureImpl\n  implements TgpuStorageTexture, SelfResolvable, TgpuNamable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: TextureViewInternals;\n  public readonly [$getNameForward]: TgpuTexture<TextureProps>;\n  public readonly resourceType = 'texture-storage-view';\n  public readonly texelDataType: TexelData;\n  public readonly dimension: StorageTextureDimension;\n\n  private _view: GPUTextureView | undefined;\n  private readonly _format: StorageTextureTexelFormat;\n\n  constructor(\n    props:\n      | TextureViewParams<StorageTextureDimension, StorageTextureTexelFormat>\n      | undefined,\n    public readonly access: StorageTextureAccess,\n    private readonly _texture: TgpuTexture,\n  ) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper texture schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have texture schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {\n      unwrap: () => {\n        if (!this._view) {\n          this._view = this._texture[$internal].unwrap().createView({\n            label: `${getName(this) ?? '<unnamed>'} - View`,\n            format: this._format,\n            dimension: this.dimension,\n          });\n        }\n\n        return this._view;\n      },\n    };\n    this[$getNameForward] = _texture;\n\n    this.dimension = props?.dimension ?? _texture.props.dimension ?? '2d';\n    this._format = props?.format ??\n      (_texture.props.format as StorageTextureTexelFormat);\n    this.texelDataType = texelFormatToDataType[this._format];\n  }\n\n  $name(label: string): this {\n    this._texture.$name(label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const { group, binding } = ctx.allocateFixedEntry(\n      {\n        storageTexture: this._format,\n        access: this.access,\n        viewDimension: this.dimension,\n      },\n      this,\n    );\n    const type = `texture_storage_${dimensionToCodeMap[this.dimension]}`;\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: ${type}<${this._format}, ${\n        accessMap[this.access]\n      }>;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nexport class TgpuLaidOutStorageTextureImpl\n  implements TgpuStorageTexture, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: TextureViewInternals;\n  public readonly resourceType = 'texture-storage-view';\n  public readonly texelDataType: TexelData;\n\n  constructor(\n    private readonly _format: StorageTextureTexelFormat,\n    public readonly dimension: StorageTextureDimension,\n    public readonly access: StorageTextureAccess,\n    private readonly _membership: LayoutMembership,\n  ) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper texture schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have texture schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {};\n    this.texelDataType = texelFormatToDataType[this._format];\n    setName(this, _membership.key);\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n    const type = `texture_storage_${dimensionToCodeMap[this.dimension]}`;\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: ${type}<${this._format}, ${\n        accessMap[this.access]\n      }>;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nclass TgpuFixedSampledTextureImpl\n  implements TgpuSampledTexture, SelfResolvable, TgpuNamable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: TextureViewInternals;\n  public readonly [$getNameForward]: TgpuTexture<TextureProps>;\n  public readonly resourceType = 'texture-sampled-view';\n  public readonly channelDataType: ChannelData;\n  public readonly dimension: GPUTextureViewDimension;\n\n  private _format: GPUTextureFormat;\n  private _view: GPUTextureView | undefined;\n\n  constructor(\n    private readonly _props:\n      | TextureViewParams<GPUTextureViewDimension, GPUTextureFormat>\n      | undefined,\n    private readonly _texture: TgpuTexture,\n  ) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper texture schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have texture schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {\n      unwrap: () => {\n        if (!this._view) {\n          this._view = this._texture[$internal].unwrap().createView({\n            label: `${getName(this) ?? '<unnamed>'} - View`,\n            ...this._props,\n          });\n        }\n\n        return this._view;\n      },\n    };\n    this[$getNameForward] = _texture;\n    this.dimension = _props?.dimension ?? _texture.props.dimension ?? '2d';\n    this._format = _props?.format ??\n      (_texture.props.format as GPUTextureFormat);\n    this.channelDataType = texelFormatToChannelType[this._format];\n  }\n\n  $name(label: string): this {\n    this._texture.$name(label);\n    return this;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n\n    const multisampled = (this._texture.props.sampleCount ?? 1) > 1;\n    const { group, binding } = ctx.allocateFixedEntry(\n      {\n        texture: channelKindToFormat[this.channelDataType.type],\n        viewDimension: this.dimension,\n        multisampled,\n      },\n      this,\n    );\n\n    const type = multisampled\n      ? 'texture_multisampled_2d'\n      : `texture_${dimensionToCodeMap[this.dimension]}`;\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${binding}) var ${id}: ${type}<${\n        ctx.resolve(this.channelDataType)\n      }>;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n\nexport class TgpuLaidOutSampledTextureImpl\n  implements TgpuSampledTexture, SelfResolvable {\n  public readonly [$wgslDataType]: AnyData;\n  public readonly [$internal]: TextureViewInternals;\n  public readonly resourceType = 'texture-sampled-view';\n  public readonly channelDataType: ChannelData;\n\n  constructor(\n    sampleType: GPUTextureSampleType,\n    public readonly dimension: GPUTextureViewDimension,\n    private readonly _multisampled: boolean,\n    private readonly _membership: LayoutMembership,\n  ) {\n    // TODO: do not treat self-resolvable as wgsl data (when we have proper texture schemas)\n    // biome-ignore lint/suspicious/noExplicitAny: This is necessary until we have texture schemas\n    this[$wgslDataType] = this as any;\n    this[$internal] = {};\n    setName(this, _membership.key);\n    this.channelDataType = channelFormatToSchema[sampleType];\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n    const group = ctx.allocateLayoutEntry(this._membership.layout);\n\n    const type = this._multisampled\n      ? 'texture_multisampled_2d'\n      : `texture_${dimensionToCodeMap[this.dimension]}`;\n\n    ctx.addDeclaration(\n      `@group(${group}) @binding(${this._membership.idx}) var ${id}: ${type}<${\n        ctx.resolve(this.channelDataType)\n      }>;`,\n    );\n\n    return id;\n  }\n\n  toString() {\n    return `${this.resourceType}:${getName(this) ?? '<unnamed>'}`;\n  }\n}\n","import type { StorageFlag } from '../../extension.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { StorageTextureTexelFormat } from './textureFormats.ts';\nimport type { TextureProps } from './textureProps.ts';\n\nexport interface Sampled {\n  usableAsSampled: true;\n}\n\nexport interface Render {\n  usableAsRender: true;\n}\n\nexport type LiteralToExtensionMap = {\n  storage: StorageFlag; // <- shared between buffers and textures\n  sampled: Sampled;\n  render: Render;\n};\n\nexport type TextureExtensionLiteral = keyof LiteralToExtensionMap;\n\nexport type AllowedUsages<TProps extends TextureProps> =\n  | 'sampled'\n  | 'render'\n  | (TProps['format'] extends StorageTextureTexelFormat ? 'storage' : never);\n\nexport function isUsableAsSampled<T>(value: T): value is T & Sampled {\n  return !!(value as unknown as Sampled)?.usableAsSampled;\n}\n\nexport function isUsableAsRender<T>(value: T): value is T & Render {\n  return !!(value as unknown as Render)?.usableAsRender;\n}\n\n/**\n * @category Errors\n */\nexport class NotSampledError extends Error {\n  constructor(value: object) {\n    super(\n      `Resource '${\n        getName(value) ?? '<unnamed>'\n      }' cannot be bound as 'sampled'. Use .$usage('sampled') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotSampledError.prototype);\n  }\n}\n\n/**\n * @category Errors\n */\nexport class NotRenderError extends Error {\n  constructor(value: object) {\n    super(\n      `Resource '${\n        getName(value) ?? '<unnamed>'\n      }' cannot be bound as 'render'. Use .$usage('render') to allow it.`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, NotRenderError.prototype);\n  }\n}\n","import {\n  isBuffer,\n  type TgpuBuffer,\n  type UniformFlag,\n} from './core/buffer/buffer.ts';\nimport {\n  isUsableAsUniform,\n  type TgpuBufferMutable,\n  type TgpuBufferReadonly,\n  type TgpuBufferUniform,\n  TgpuLaidOutBufferImpl,\n} from './core/buffer/bufferUsage.ts';\nimport {\n  isComparisonSampler,\n  isSampler,\n  type TgpuComparisonSampler,\n  TgpuLaidOutComparisonSamplerImpl,\n  TgpuLaidOutSamplerImpl,\n  type TgpuSampler,\n} from './core/sampler/sampler.ts';\nimport { TgpuExternalTextureImpl } from './core/texture/externalTexture.ts';\nimport {\n  isSampledTextureView,\n  isStorageTextureView,\n  isTexture,\n  type StorageTextureDimension,\n  TgpuLaidOutSampledTextureImpl,\n  TgpuLaidOutStorageTextureImpl,\n  type TgpuMutableTexture,\n  type TgpuReadonlyTexture,\n  type TgpuSampledTexture,\n  type TgpuTexture,\n  type TgpuWriteonlyTexture,\n} from './core/texture/texture.ts';\nimport type {\n  ChannelFormatToSchema,\n  ChannelTypeToLegalFormats,\n  SampleTypeToStringChannelType,\n  StorageTextureTexelFormat,\n  TexelFormatToDataType,\n  ViewDimensionToDimension,\n} from './core/texture/textureFormats.ts';\nimport type { TextureProps } from './core/texture/textureProps.ts';\nimport {\n  isUsableAsSampled,\n  NotSampledError,\n  type Sampled,\n} from './core/texture/usageExtension.ts';\nimport type { AnyData } from './data/dataTypes.ts';\nimport type { AnyWgslData, BaseData } from './data/wgslTypes.ts';\nimport { NotUniformError } from './errors.ts';\nimport {\n  isUsableAsStorage,\n  NotStorageError,\n  type StorageFlag,\n} from './extension.ts';\nimport type { TgpuNamable } from './shared/meta.ts';\nimport { getName, setName } from './shared/meta.ts';\nimport type { Infer, MemIdentity } from './shared/repr.ts';\nimport { $internal } from './shared/symbols.ts';\nimport type {\n  Default,\n  NullableToOptional,\n  Prettify,\n} from './shared/utilityTypes.ts';\nimport type { TgpuShaderStage } from './types.ts';\nimport type { Unwrapper } from './unwrapper.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface LayoutMembership {\n  layout: TgpuBindGroupLayout;\n  key: string;\n  idx: number;\n}\n\nexport type TgpuLayoutEntryBase = {\n  /**\n   * Limits this resource's visibility to specific shader stages.\n   *\n   * By default, each resource is visible to all shader stage types, but\n   * depending on the underlying implementation, this may have performance implications.\n   *\n   * @default ['compute'] for mutable resources\n   * @default ['compute','vertex','fragment'] for everything else\n   */\n  visibility?: TgpuShaderStage[];\n};\n\nexport type TgpuLayoutUniform = TgpuLayoutEntryBase & {\n  uniform: AnyWgslData;\n};\n\nexport type TgpuLayoutStorage = TgpuLayoutEntryBase & {\n  storage: AnyWgslData | ((arrayLength: number) => AnyWgslData);\n  /** @default 'readonly' */\n  access?: 'mutable' | 'readonly';\n};\n\nexport type TgpuLayoutSampler = TgpuLayoutEntryBase & {\n  sampler: 'filtering' | 'non-filtering';\n};\n\nexport type TgpuLayoutComparisonSampler = TgpuLayoutEntryBase & {\n  sampler: 'comparison';\n};\n\nexport type TgpuLayoutTexture<\n  TSampleType extends GPUTextureSampleType = GPUTextureSampleType,\n> = TgpuLayoutEntryBase & {\n  /**\n   * - 'float' - f32\n   * - 'unfilterable-float' - f32, cannot be used with filtering samplers\n   * - 'depth' - f32\n   * - 'sint' - i32\n   * - 'uint' - u32\n   */\n  texture: TSampleType;\n  /**\n   * @default '2d'\n   */\n  viewDimension?: GPUTextureViewDimension;\n  /**\n   * @default false\n   */\n  multisampled?: boolean;\n};\nexport type TgpuLayoutStorageTexture<\n  TFormat extends StorageTextureTexelFormat = StorageTextureTexelFormat,\n> = TgpuLayoutEntryBase & {\n  storageTexture: TFormat;\n  /** @default 'writeonly' */\n  access?: 'readonly' | 'writeonly' | 'mutable';\n  /** @default '2d' */\n  viewDimension?: StorageTextureDimension;\n};\nexport type TgpuLayoutExternalTexture = TgpuLayoutEntryBase & {\n  externalTexture: Record<string, never>;\n};\n\nexport type TgpuLayoutEntry =\n  | TgpuLayoutUniform\n  | TgpuLayoutStorage\n  | TgpuLayoutSampler\n  | TgpuLayoutComparisonSampler\n  | TgpuLayoutTexture\n  | TgpuLayoutStorageTexture\n  | TgpuLayoutExternalTexture;\n\ntype UnwrapRuntimeConstructorInner<\n  T extends BaseData | ((_: number) => BaseData),\n> = T extends (_: number) => BaseData ? ReturnType<T> : T;\n\nexport type UnwrapRuntimeConstructor<\n  T extends AnyData | ((_: number) => AnyData),\n> = T extends unknown ? UnwrapRuntimeConstructorInner<T> : never;\n\nexport interface TgpuBindGroupLayout<\n  Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n    string,\n    TgpuLayoutEntry | null\n  >,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'bind-group-layout';\n  readonly entries: Entries;\n  readonly bound: {\n    [K in keyof Entries]: BindLayoutEntry<Entries[K]>;\n  };\n  readonly value: {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n  readonly $: {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n\n  /**\n   * An explicit numeric index assigned to this bind group layout. If undefined, a unique\n   * index is assigned automatically during resolution. This can be changed with the\n   * `.$idx()` method.\n   */\n  readonly index: number | undefined;\n\n  /**\n   * Associates this bind group layout with an explicit numeric index. When a call to this\n   * method is omitted, a unique numeric index is assigned to it automatically.\n   *\n   * Used when generating WGSL code: `@group(${index}) @binding(...) ...;`\n   */\n  $idx(index?: number): this;\n\n  /**\n   * Creates a raw WebGPU resource based on the typed descriptor.\n   * NOTE: This creates a new resource every time, better to use `root.unwrap(...)` instead.\n   * @param unwrapper Used to unwrap any resources that this resource depends on.\n   */\n  unwrap(unwrapper: Unwrapper): GPUBindGroupLayout;\n}\n\ntype StorageUsageForEntry<T extends TgpuLayoutStorage> = T extends {\n  access?: infer Access;\n} // Is the access defined on the type?\n  ? 'mutable' | 'readonly' extends Access // Is the access ambiguous?\n    ?\n      | TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>\n      | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>>\n  : 'readonly' extends Access // Is the access strictly 'readonly'?\n    ? TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>\n  : 'mutable' extends Access // Is the access strictly 'mutable'?\n    ? TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>>\n  :\n    | TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>\n    | TgpuBufferMutable<UnwrapRuntimeConstructor<T['storage']>>\n  : TgpuBufferReadonly<UnwrapRuntimeConstructor<T['storage']>>; // <- access is undefined, so default to 'readonly';\n\ntype GetUsageForStorageTexture<\n  T extends TgpuLayoutStorageTexture,\n  TAccess extends 'readonly' | 'writeonly' | 'mutable',\n> = {\n  mutable: TgpuMutableTexture<\n    Default<GetDimension<T['viewDimension']>, '2d'>,\n    TexelFormatToDataType[T['storageTexture']]\n  >;\n  readonly: TgpuReadonlyTexture<\n    Default<GetDimension<T['viewDimension']>, '2d'>,\n    TexelFormatToDataType[T['storageTexture']]\n  >;\n  writeonly: TgpuWriteonlyTexture<\n    Default<GetDimension<T['viewDimension']>, '2d'>,\n    TexelFormatToDataType[T['storageTexture']]\n  >;\n}[TAccess];\n\ntype StorageTextureUsageForEntry<T extends TgpuLayoutStorageTexture> = T extends\n  unknown ? GetUsageForStorageTexture<T, Default<T['access'], 'writeonly'>>\n  : never;\n\ntype GetDimension<T extends GPUTextureViewDimension | undefined> = T extends\n  keyof ViewDimensionToDimension ? ViewDimensionToDimension[T]\n  : undefined;\n\ntype GetTextureRestriction<T extends TgpuLayoutTexture> = Default<\n  GetDimension<T['viewDimension']>,\n  '2d'\n> extends infer Dimension ? Dimension extends '2d' ? {\n      format:\n        ChannelTypeToLegalFormats[SampleTypeToStringChannelType[T['texture']]];\n      dimension?: Dimension;\n    }\n  : {\n    format:\n      ChannelTypeToLegalFormats[SampleTypeToStringChannelType[T['texture']]];\n    dimension: Dimension;\n  }\n  : never;\n\ntype GetStorageTextureRestriction<T extends TgpuLayoutStorageTexture> = Default<\n  GetDimension<T['viewDimension']>,\n  '2d'\n> extends infer Dimension ? Dimension extends '2d' ? {\n      format: T['storageTexture'];\n      dimension?: Dimension;\n    }\n  : {\n    format: T['storageTexture'];\n    dimension: Dimension;\n  }\n  : never;\n\nexport type LayoutEntryToInput<T extends TgpuLayoutEntry | null> =\n  // Widest type\n  TgpuLayoutEntry | null extends T ?\n      | TgpuBuffer<AnyWgslData>\n      | GPUBuffer\n      | TgpuSampler\n      | GPUSampler\n      | TgpuComparisonSampler\n      | GPUSampler\n      | TgpuTexture\n      | TgpuSampledTexture\n      | TgpuMutableTexture\n      | TgpuReadonlyTexture\n      | TgpuWriteonlyTexture\n      | GPUTextureView\n      | GPUExternalTexture\n    // Strict type-checking\n    : T extends TgpuLayoutUniform ?\n        | (\n          & TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['uniform']>>>\n          & UniformFlag\n        )\n        | GPUBuffer\n    : T extends TgpuLayoutStorage ?\n        | (\n          & TgpuBuffer<MemIdentity<UnwrapRuntimeConstructor<T['storage']>>>\n          & StorageFlag\n        )\n        | GPUBuffer\n    : T extends TgpuLayoutSampler ? TgpuSampler | GPUSampler\n    : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler | GPUSampler\n    : T extends TgpuLayoutTexture ?\n        | GPUTextureView\n        | (\n          & Sampled\n          & TgpuTexture<\n            Prettify<TextureProps & GetTextureRestriction<T>>\n          >\n        )\n        | TgpuSampledTexture<\n          Default<T['viewDimension'], '2d'>,\n          ChannelFormatToSchema[T['texture']]\n        >\n    : T extends TgpuLayoutStorageTexture ?\n        | GPUTextureView\n        | (\n          & StorageFlag\n          & TgpuTexture<\n            Prettify<TextureProps & GetStorageTextureRestriction<T>>\n          >\n        )\n        | StorageTextureUsageForEntry<T>\n    : T extends TgpuLayoutExternalTexture ? GPUExternalTexture\n    : never;\n\nexport type BindLayoutEntry<T extends TgpuLayoutEntry | null> = T extends\n  TgpuLayoutUniform ? TgpuBufferUniform<T['uniform']>\n  : T extends TgpuLayoutStorage ? StorageUsageForEntry<T>\n  : T extends TgpuLayoutSampler ? TgpuSampler\n  : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler\n  : T extends TgpuLayoutTexture ? TgpuSampledTexture<\n      Default<T['viewDimension'], '2d'>,\n      ChannelFormatToSchema[T['texture']]\n    >\n  : T extends TgpuLayoutStorageTexture ? StorageTextureUsageForEntry<T>\n  : never;\n\nexport type InferLayoutEntry<T extends TgpuLayoutEntry | null> = T extends\n  TgpuLayoutUniform ? Infer<T['uniform']>\n  : T extends TgpuLayoutStorage ? Infer<UnwrapRuntimeConstructor<T['storage']>>\n  : T extends TgpuLayoutSampler ? TgpuSampler\n  : T extends TgpuLayoutComparisonSampler ? TgpuComparisonSampler\n  : T extends TgpuLayoutTexture ? TgpuSampledTexture<\n      Default<T['viewDimension'], '2d'>,\n      ChannelFormatToSchema[T['texture']]\n    >\n  : T extends TgpuLayoutStorageTexture ? StorageTextureUsageForEntry<T>\n  : never;\n\nexport type ExtractBindGroupInputFromLayout<\n  T extends Record<string, TgpuLayoutEntry | null>,\n> = NullableToOptional<\n  { [K in keyof T]: LayoutEntryToInput<T[K]> }\n>;\n\nexport type TgpuBindGroup<\n  Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n    string,\n    TgpuLayoutEntry | null\n  >,\n> = {\n  readonly resourceType: 'bind-group';\n  readonly layout: TgpuBindGroupLayout<Entries>;\n  unwrap(unwrapper: Unwrapper): GPUBindGroup;\n};\n\nexport function bindGroupLayout<\n  Entries extends Record<string, TgpuLayoutEntry | null>,\n>(entries: Entries): TgpuBindGroupLayout<Prettify<Entries>> {\n  return new TgpuBindGroupLayoutImpl(entries);\n}\n\nexport function isBindGroupLayout<T extends TgpuBindGroupLayout>(\n  value: T | unknown,\n): value is T {\n  return !!value && (value as T).resourceType === 'bind-group-layout';\n}\n\nexport function isBindGroup<T extends TgpuBindGroup>(\n  value: T | unknown,\n): value is T {\n  return !!value && (value as T).resourceType === 'bind-group';\n}\n\n/**\n * @category Errors\n */\nexport class MissingBindingError extends Error {\n  constructor(groupLabel: string | undefined, key: string) {\n    super(\n      `Bind group '${\n        groupLabel ?? '<unnamed>'\n      }' is missing a required binding '${key}'`,\n    );\n\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, MissingBindingError.prototype);\n  }\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst DEFAULT_MUTABLE_VISIBILITY: TgpuShaderStage[] = ['compute'];\nconst DEFAULT_READONLY_VISIBILITY: TgpuShaderStage[] = [\n  'compute',\n  'vertex',\n  'fragment',\n];\n\nclass TgpuBindGroupLayoutImpl<\n  Entries extends Record<string, TgpuLayoutEntry | null>,\n> implements TgpuBindGroupLayout<Entries> {\n  public readonly [$internal] = true;\n  private _index: number | undefined;\n\n  public readonly resourceType = 'bind-group-layout' as const;\n\n  public readonly bound = {} as {\n    [K in keyof Entries]: BindLayoutEntry<Entries[K]>;\n  };\n\n  public readonly value = {} as {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n\n  public readonly $ = this.value as {\n    [K in keyof Entries]: InferLayoutEntry<Entries[K]>;\n  };\n\n  constructor(public readonly entries: Entries) {\n    let idx = 0;\n\n    for (const [key, entry] of Object.entries(entries)) {\n      if (entry === null) {\n        idx++;\n        continue;\n      }\n\n      const membership: LayoutMembership = { layout: this, key, idx };\n\n      if ('uniform' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutBufferImpl(\n          'uniform',\n          entry.uniform,\n          membership,\n        );\n      }\n\n      if ('storage' in entry) {\n        const dataType = 'type' in entry.storage\n          ? entry.storage\n          : entry.storage(0);\n\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutBufferImpl(\n          entry.access ?? 'readonly',\n          dataType,\n          membership,\n        );\n      }\n\n      if ('texture' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutSampledTextureImpl(\n          entry.texture,\n          entry.viewDimension ?? '2d',\n          entry.multisampled ?? false,\n          membership,\n        );\n      }\n\n      if ('storageTexture' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuLaidOutStorageTextureImpl(\n          entry.storageTexture,\n          entry.viewDimension ?? '2d',\n          entry.access ?? 'writeonly',\n          membership,\n        );\n      }\n\n      if ('externalTexture' in entry) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.bound[key] as any) = new TgpuExternalTextureImpl(membership);\n      }\n\n      if ('sampler' in entry) {\n        if (entry.sampler === 'comparison') {\n          // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n          (this.bound[key] as any) = new TgpuLaidOutComparisonSamplerImpl(\n            membership,\n          );\n        } else {\n          // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n          (this.bound[key] as any) = new TgpuLaidOutSamplerImpl(membership);\n        }\n      }\n\n      if (\n        'texture' in entry ||\n        'storageTexture' in entry ||\n        'externalTexture' in entry ||\n        'sampler' in entry\n      ) {\n        // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n        (this.value as any)[key] = this.bound[key];\n      } else {\n        Object.defineProperty(this.value, key, {\n          get: () => {\n            // biome-ignore lint/suspicious/noExplicitAny: <no need for type magic>\n            return (this.bound[key] as any).value;\n          },\n        });\n      }\n\n      idx++;\n    }\n  }\n\n  toString(): string {\n    return `bindGroupLayout:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get index(): number | undefined {\n    return this._index;\n  }\n\n  $name(label: string): this {\n    setName(this, label);\n    return this;\n  }\n\n  $idx(index?: number): this {\n    this._index = index;\n    return this;\n  }\n\n  unwrap(unwrapper: Unwrapper) {\n    const unwrapped = unwrapper.device.createBindGroupLayout({\n      label: getName(this) ?? '<unnamed>',\n      entries: Object.values(this.entries)\n        .map((entry, idx) => {\n          if (entry === null) {\n            return null;\n          }\n\n          let visibility = entry.visibility;\n\n          const binding: GPUBindGroupLayoutEntry = {\n            binding: idx,\n            visibility: 0,\n          };\n\n          if ('uniform' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n\n            binding.buffer = {\n              type: 'uniform' as const,\n            };\n          } else if ('storage' in entry) {\n            visibility = visibility ??\n              (entry.access === 'mutable'\n                ? DEFAULT_MUTABLE_VISIBILITY\n                : DEFAULT_READONLY_VISIBILITY);\n\n            binding.buffer = {\n              type: entry.access === 'mutable'\n                ? ('storage' as const)\n                : ('read-only-storage' as const),\n            };\n          } else if ('sampler' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n\n            binding.sampler = {\n              type: entry.sampler,\n            };\n          } else if ('texture' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n\n            binding.texture = {\n              sampleType: entry.texture,\n              viewDimension: entry.viewDimension ?? '2d',\n              multisampled: entry.multisampled ?? false,\n            };\n          } else if ('storageTexture' in entry) {\n            const access = entry.access ?? 'writeonly';\n\n            visibility = visibility ??\n              (access === 'readonly'\n                ? DEFAULT_READONLY_VISIBILITY\n                : DEFAULT_MUTABLE_VISIBILITY);\n\n            binding.storageTexture = {\n              format: entry.storageTexture,\n              access: {\n                mutable: 'read-write' as const,\n                readonly: 'read-only' as const,\n                writeonly: 'write-only' as const,\n              }[access],\n              viewDimension: entry.viewDimension ?? '2d',\n            };\n          } else if ('externalTexture' in entry) {\n            visibility = visibility ?? DEFAULT_READONLY_VISIBILITY;\n            binding.externalTexture = {};\n          }\n\n          if (visibility?.includes('compute')) {\n            binding.visibility |= GPUShaderStage.COMPUTE;\n          }\n          if (visibility?.includes('vertex')) {\n            binding.visibility |= GPUShaderStage.VERTEX;\n          }\n          if (visibility?.includes('fragment')) {\n            binding.visibility |= GPUShaderStage.FRAGMENT;\n          }\n\n          return binding;\n        })\n        .filter((v): v is Exclude<typeof v, null> => v !== null),\n    });\n\n    return unwrapped;\n  }\n}\n\nexport class TgpuBindGroupImpl<\n  Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n    string,\n    TgpuLayoutEntry | null\n  >,\n> implements TgpuBindGroup<Entries> {\n  public readonly resourceType = 'bind-group' as const;\n\n  constructor(\n    public readonly layout: TgpuBindGroupLayout<Entries>,\n    public readonly entries: ExtractBindGroupInputFromLayout<Entries>,\n  ) {\n    // Checking if all entries are present.\n    for (const key of Object.keys(layout.entries)) {\n      if (layout.entries[key] !== null && !(key in entries)) {\n        throw new MissingBindingError(getName(layout), key);\n      }\n    }\n  }\n\n  public unwrap(unwrapper: Unwrapper): GPUBindGroup {\n    const unwrapped = unwrapper.device.createBindGroup({\n      label: getName(this.layout) ?? '<unnamed>',\n      layout: unwrapper.unwrap(this.layout),\n      entries: Object.entries(this.layout.entries)\n        .map(([key, entry], idx) => {\n          if (entry === null) {\n            return null;\n          }\n\n          const value = this.entries[key as keyof typeof this.entries];\n\n          if (value === undefined) {\n            throw new Error(\n              `'${key}' is a resource required to populate bind group layout '${\n                getName(this.layout) ?? '<unnamed>'\n              }'.`,\n            );\n          }\n\n          if ('uniform' in entry) {\n            let resource: GPUBufferBinding;\n\n            if (isBuffer(value)) {\n              if (!isUsableAsUniform(value)) {\n                throw new NotUniformError(value);\n              }\n              resource = { buffer: unwrapper.unwrap(value) };\n            } else {\n              resource = { buffer: value as GPUBuffer };\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('storage' in entry) {\n            let resource: GPUBufferBinding;\n\n            if (isBuffer(value)) {\n              if (!isUsableAsStorage(value)) {\n                throw new NotStorageError(value);\n              }\n              resource = { buffer: unwrapper.unwrap(value) };\n            } else {\n              resource = { buffer: value as GPUBuffer };\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('texture' in entry) {\n            let resource: GPUTextureView;\n\n            if (isTexture(value)) {\n              if (!isUsableAsSampled(value)) {\n                throw new NotSampledError(value);\n              }\n\n              resource = unwrapper.unwrap(\n                (value as TgpuTexture & Sampled).createView('sampled'),\n              );\n            } else if (isSampledTextureView(value)) {\n              resource = unwrapper.unwrap(value);\n            } else {\n              resource = value as GPUTextureView;\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('storageTexture' in entry) {\n            let resource: GPUTextureView;\n\n            if (isTexture(value)) {\n              if (!isUsableAsStorage(value)) {\n                throw new NotStorageError(value);\n              }\n\n              if (entry.access === 'readonly') {\n                resource = unwrapper.unwrap(\n                  (value as TgpuTexture & StorageFlag).createView('readonly'),\n                );\n              } else if (entry.access === 'mutable') {\n                resource = unwrapper.unwrap(\n                  (value as TgpuTexture & StorageFlag).createView('mutable'),\n                );\n              } else {\n                resource = unwrapper.unwrap(\n                  (value as TgpuTexture & StorageFlag).createView('writeonly'),\n                );\n              }\n            } else if (isStorageTextureView(value)) {\n              resource = unwrapper.unwrap(value);\n            } else {\n              resource = value as GPUTextureView;\n            }\n\n            return {\n              binding: idx,\n              resource,\n            };\n          }\n\n          if ('sampler' in entry) {\n            if (isSampler(value) || isComparisonSampler(value)) {\n              return {\n                binding: idx,\n                resource: unwrapper.unwrap(value as TgpuSampler),\n              };\n            }\n\n            return {\n              binding: idx,\n              resource: value as GPUSampler,\n            };\n          }\n\n          if ('externalTexture' in entry) {\n            return {\n              binding: idx,\n              resource: value as GPUExternalTexture,\n            };\n          }\n\n          throw new Error(\n            `Malformed bind group entry: ${value} (${JSON.stringify(value)})`,\n          );\n        })\n        .filter((v): v is Exclude<typeof v, null> => v !== null),\n    });\n\n    return unwrapped;\n  }\n}\n","import * as tinyest from 'tinyest';\nimport { arrayOf } from '../data/array.ts';\nimport {\n  type AnyData,\n  isData,\n  isLooseData,\n  snip,\n  type Snippet,\n  UnknownData,\n} from '../data/dataTypes.ts';\nimport * as d from '../data/index.ts';\nimport { abstractInt } from '../data/numeric.ts';\nimport * as wgsl from '../data/wgslTypes.ts';\nimport { getName } from '../shared/meta.ts';\nimport { $internal } from '../shared/symbols.ts';\nimport { type FnArgsConversionHint, isMarkedInternal } from '../types.ts';\nimport {\n  coerceToSnippet,\n  concretize,\n  convertStructValues,\n  convertToCommonType,\n  type GenerationCtx,\n  getTypeForIndexAccess,\n  getTypeForPropAccess,\n  numericLiteralToSnippet,\n} from './generationHelpers.ts';\nimport { ResolutionError } from '../errors.ts';\n\nconst { NodeTypeCatalog: NODE } = tinyest;\n\nconst parenthesizedOps = [\n  '==',\n  '!=',\n  '<',\n  '<=',\n  '>',\n  '>=',\n  '<<',\n  '>>',\n  '+',\n  '-',\n  '*',\n  '/',\n  '%',\n  '|',\n  '^',\n  '&',\n  '&&',\n  '||',\n];\n\nconst binaryLogicalOps = ['&&', '||', '==', '!=', '<', '<=', '>', '>='];\n\ntype Operator =\n  | tinyest.BinaryOperator\n  | tinyest.AssignmentOperator\n  | tinyest.LogicalOperator\n  | tinyest.UnaryOperator;\n\nfunction operatorToType<\n  TL extends AnyData | UnknownData,\n  TR extends AnyData | UnknownData,\n>(lhs: TL, op: Operator, rhs?: TR): TL | TR | wgsl.Bool {\n  if (!rhs) {\n    if (op === '!' || op === '~') {\n      return d.bool;\n    }\n\n    return lhs;\n  }\n\n  if (binaryLogicalOps.includes(op)) {\n    return d.bool;\n  }\n\n  if (op === '=') {\n    return rhs;\n  }\n\n  return lhs;\n}\n\nfunction assertExhaustive(value: never): never {\n  throw new Error(\n    `'${JSON.stringify(value)}' was not handled by the WGSL generator.`,\n  );\n}\n\nexport function generateBlock(\n  ctx: GenerationCtx,\n  [_, statements]: tinyest.Block,\n): string {\n  ctx.pushBlockScope();\n  try {\n    return `${ctx.indent()}{\n${statements.map((statement) => generateStatement(ctx, statement)).join('\\n')}\n${ctx.dedent()}}`;\n  } finally {\n    ctx.popBlockScope();\n  }\n}\n\nexport function registerBlockVariable(\n  ctx: GenerationCtx,\n  id: string,\n  dataType: wgsl.AnyWgslData | UnknownData,\n): Snippet {\n  return ctx.defineVariable(id, dataType);\n}\n\nexport function generateIdentifier(ctx: GenerationCtx, id: string): Snippet {\n  const res = ctx.getById(id);\n  if (!res) {\n    throw new Error(`Identifier ${id} not found`);\n  }\n\n  return res;\n}\n\nexport function generateExpression(\n  ctx: GenerationCtx,\n  expression: tinyest.Expression,\n): Snippet {\n  if (typeof expression === 'string') {\n    return generateIdentifier(ctx, expression);\n  }\n\n  if (typeof expression === 'boolean') {\n    return snip(expression ? 'true' : 'false', d.bool);\n  }\n\n  if (\n    expression[0] === NODE.logicalExpr ||\n    expression[0] === NODE.binaryExpr ||\n    expression[0] === NODE.assignmentExpr\n  ) {\n    // Logical/Binary/Assignment Expression\n    const [_, lhs, op, rhs] = expression;\n    const lhsExpr = generateExpression(ctx, lhs);\n    const rhsExpr = generateExpression(ctx, rhs);\n\n    const forcedType = expression[0] === NODE.assignmentExpr\n      ? [lhsExpr.dataType as AnyData]\n      : [];\n\n    const converted = convertToCommonType(\n      ctx,\n      [lhsExpr, rhsExpr],\n      forcedType,\n    ) as\n      | [Snippet, Snippet]\n      | undefined;\n    const [convLhs, convRhs] = converted || [lhsExpr, rhsExpr];\n\n    const lhsStr = ctx.resolve(convLhs.value);\n    const rhsStr = ctx.resolve(convRhs.value);\n    const type = operatorToType(convLhs.dataType, op, convRhs.dataType);\n\n    return snip(\n      parenthesizedOps.includes(op)\n        ? `(${lhsStr} ${op} ${rhsStr})`\n        : `${lhsStr} ${op} ${rhsStr}`,\n      type,\n    );\n  }\n\n  if (expression[0] === NODE.postUpdate) {\n    // Post-Update Expression\n    const [_, op, arg] = expression;\n    const argExpr = generateExpression(ctx, arg);\n    const argStr = ctx.resolve(argExpr.value);\n\n    return snip(`${argStr}${op}`, argExpr.dataType);\n  }\n\n  if (expression[0] === NODE.unaryExpr) {\n    // Unary Expression\n    const [_, op, arg] = expression;\n    const argExpr = generateExpression(ctx, arg);\n    const argStr = ctx.resolve(argExpr.value);\n\n    const type = operatorToType(argExpr.dataType, op);\n    return snip(`${op}${argStr}`, type);\n  }\n\n  if (expression[0] === NODE.memberAccess) {\n    // Member Access\n    const [_, targetNode, property] = expression;\n    const target = generateExpression(ctx, targetNode);\n\n    if (target.dataType.type === 'unknown') {\n      // No idea what the type is, so we act on the snippet's value and try to guess\n\n      // biome-ignore lint/suspicious/noExplicitAny: we're inspecting the value, and it could be any value\n      const propValue = (target.value as any)[property];\n\n      // We try to extract any type information based on the prop's value\n      return coerceToSnippet(propValue);\n    }\n\n    if (wgsl.isPtr(target.dataType)) {\n      return snip(\n        `(*${ctx.resolve(target.value)}).${property}`,\n        getTypeForPropAccess(target.dataType.inner as AnyData, property),\n      );\n    }\n\n    if (wgsl.isWgslArray(target.dataType) && property === 'length') {\n      if (target.dataType.elementCount === 0) {\n        // Dynamically-sized array\n        return snip(`arrayLength(&${ctx.resolve(target.value)})`, d.u32);\n      }\n\n      return snip(String(target.dataType.elementCount), abstractInt);\n    }\n\n    if (wgsl.isMat(target.dataType) && property === 'columns') {\n      return snip(target.value, target.dataType);\n    }\n\n    if (\n      wgsl.isVec(target.dataType) && wgsl.isVecInstance(target.value)\n    ) {\n      // We're operating on a vector that's known at resolution time\n      // biome-ignore lint/suspicious/noExplicitAny: it's probably a swizzle\n      return coerceToSnippet((target.value as any)[property]);\n    }\n\n    return snip(\n      `${ctx.resolve(target.value)}.${property}`,\n      getTypeForPropAccess(target.dataType, property),\n    );\n  }\n\n  if (expression[0] === NODE.indexAccess) {\n    // Index Access\n    const [_, targetNode, propertyNode] = expression;\n    const target = generateExpression(ctx, targetNode);\n    const property = generateExpression(ctx, propertyNode);\n    const targetStr = ctx.resolve(target.value);\n    const propertyStr = ctx.resolve(property.value);\n\n    if (target.dataType.type === 'unknown') {\n      // No idea what the type is, so we act on the snippet's value and try to guess\n\n      if (\n        Array.isArray(propertyNode) && propertyNode[0] === NODE.numericLiteral\n      ) {\n        return coerceToSnippet(\n          // biome-ignore lint/suspicious/noExplicitAny: we're inspecting the value, and it could be any value\n          (target.value as any)[propertyNode[1] as number],\n        );\n      }\n\n      throw new Error(\n        `Cannot index value ${targetStr} of unknown type with index ${propertyStr}`,\n      );\n    }\n\n    if (wgsl.isPtr(target.dataType)) {\n      return snip(\n        `(*${targetStr})[${propertyStr}]`,\n        getTypeForIndexAccess(target.dataType.inner as AnyData),\n      );\n    }\n\n    return snip(\n      `${targetStr}[${propertyStr}]`,\n      isData(target.dataType)\n        ? getTypeForIndexAccess(target.dataType)\n        : UnknownData,\n    );\n  }\n\n  if (expression[0] === NODE.numericLiteral) {\n    // Numeric Literal\n    const type = numericLiteralToSnippet(expression[1]);\n    if (!type) {\n      throw new Error(`Invalid numeric literal ${expression[1]}`);\n    }\n    return type;\n  }\n\n  if (expression[0] === NODE.call) {\n    // Function Call\n    const [_, callee, args] = expression;\n    const id = generateExpression(ctx, callee);\n\n    ctx.callStack.push(id.value);\n\n    const argSnippets = args.map((arg) => generateExpression(ctx, arg));\n    const resolvedSnippets = argSnippets.map((res) =>\n      snip(ctx.resolve(res.value), res.dataType)\n    );\n    const argValues = resolvedSnippets.map((res) => res.value);\n\n    ctx.callStack.pop();\n\n    resolvedSnippets.forEach((sn, idx) => {\n      if (sn.dataType === UnknownData) {\n        throw new Error(\n          `Tried to pass '${sn.value}' of unknown type as argument #${idx} to '${\n            typeof id.value === 'string'\n              ? id.value\n              : getName(id.value) ?? '<unnamed>'\n          }()'`,\n        );\n      }\n    });\n\n    if (typeof id.value === 'string') {\n      return snip(`${id.value}(${argValues.join(', ')})`, id.dataType);\n    }\n\n    if (wgsl.isWgslStruct(id.value)) {\n      const resolvedId = ctx.resolve(id.value);\n\n      return snip(\n        `${resolvedId}(${argValues.join(', ')})`,\n        // Unintuitive, but the type of the return value is the struct itself\n        id.value,\n      );\n    }\n\n    if (!isMarkedInternal(id.value)) {\n      throw new Error(\n        `Function ${String(id.value)} ${\n          getName(id.value)\n        } has not been created using TypeGPU APIs. Did you mean to wrap the function with tgpu.fn(args, return)(...) ?`,\n      );\n    }\n\n    const argTypes = id.value[$internal]?.argTypes as\n      | FnArgsConversionHint\n      | undefined;\n    let convertedResources: Snippet[];\n    try {\n      if (!argTypes || argTypes === 'keep') {\n        convertedResources = resolvedSnippets;\n      } else if (argTypes === 'coerce') {\n        convertedResources = convertToCommonType(ctx, resolvedSnippets) ??\n          resolvedSnippets;\n      } else {\n        const pairs =\n          (Array.isArray(argTypes) ? argTypes : (argTypes(...resolvedSnippets)))\n            .map((type, i) => [type, resolvedSnippets[i] as Snippet] as const);\n\n        convertedResources = pairs.map(([type, sn]) => {\n          if (sn.dataType.type === 'unknown') {\n            console.warn(\n              `Internal error: unknown type when generating expression: ${expression}`,\n            );\n            return sn;\n          }\n\n          const conv = convertToCommonType(ctx, [sn], [type])?.[0];\n          if (!conv) {\n            throw new ResolutionError(\n              `Cannot convert argument of type '${sn.dataType.type}' to '${type.type}' for function ${\n                getName(id.value)\n              }`,\n              [{\n                function: id.value,\n                callStack: ctx.callStack,\n                error:\n                  `Cannot convert argument of type '${sn.dataType.type}' to '${type.type}'`,\n                toString: () => getName(id.value),\n              }],\n            );\n          }\n          return conv;\n        });\n      }\n\n      // Assuming that `id` is callable\n      const fnRes = (id.value as unknown as (...args: unknown[]) => unknown)(\n        ...convertedResources,\n      ) as Snippet;\n      return snip(ctx.resolve(fnRes.value), fnRes.dataType);\n    } catch (error) {\n      throw new ResolutionError(error, [{\n        toString: () => getName(id.value),\n      }]);\n    }\n  }\n\n  if (expression[0] === NODE.objectExpr) {\n    // Object Literal\n    const obj = expression[1];\n    const callee = ctx.callStack[ctx.callStack.length - 1];\n\n    if (wgsl.isWgslStruct(callee)) {\n      const propKeys = Object.keys(callee.propTypes);\n      const entries = Object.fromEntries(\n        propKeys.map((key) => {\n          const val = obj[key];\n          if (val === undefined) {\n            throw new Error(\n              `Missing property ${key} in object literal for struct ${callee}`,\n            );\n          }\n          return [key, generateExpression(ctx, val)];\n        }),\n      );\n\n      const convertedValues = convertStructValues(ctx, callee, entries);\n\n      return snip(\n        convertedValues.map((v) => ctx.resolve(v.value)).join(', '),\n        callee,\n      );\n    }\n\n    if (isMarkedInternal(callee)) {\n      const argTypes = callee[$internal]?.argTypes;\n\n      if (typeof argTypes === 'object' && argTypes !== null) {\n        const propKeys = Object.keys(argTypes);\n        const snippets: Record<string, Snippet> = {};\n\n        for (const key of propKeys) {\n          const val = obj[key];\n          if (val === undefined) {\n            throw new Error(\n              `Missing property ${key} in object literal for function ${callee}`,\n            );\n          }\n          const expr = generateExpression(ctx, val);\n          const targetType = argTypes[key as keyof typeof argTypes];\n          const converted = convertToCommonType(ctx, [expr], [targetType]);\n          snippets[key] = converted?.[0] ?? expr;\n        }\n\n        return snip(snippets, UnknownData);\n      }\n    }\n\n    throw new Error(\n      'Object expressions are only allowed as return values of functions or as arguments to structs.',\n    );\n  }\n\n  if (expression[0] === NODE.arrayExpr) {\n    const [_, valuesRaw] = expression;\n    // Array Expression\n    const values = valuesRaw.map((value) =>\n      generateExpression(ctx, value as tinyest.Expression)\n    );\n    if (values.length === 0) {\n      throw new Error('Cannot create empty array literal.');\n    }\n\n    const convertedValues = convertToCommonType(ctx, values);\n    if (!convertedValues) {\n      throw new Error(\n        'The given values cannot be automatically converted to a common type. Consider explicitly casting them.',\n      );\n    }\n\n    const targetType = convertedValues[0]?.dataType as AnyData;\n    const type = targetType.type === 'abstractFloat'\n      ? d.f32\n      : targetType.type === 'abstractInt'\n      ? d.i32\n      : targetType;\n\n    const typeId = ctx.resolve(type);\n\n    const arrayType = `array<${typeId}, ${values.length}>`;\n    const arrayValues = convertedValues.map((sn) => ctx.resolve(sn.value));\n\n    return snip(\n      `${arrayType}( ${arrayValues.join(', ')} )`,\n      arrayOf(\n        type as wgsl.AnyWgslData,\n        values.length,\n      ) as wgsl.AnyWgslData,\n    );\n  }\n\n  if (expression[0] === NODE.stringLiteral) {\n    throw new Error('Cannot use string literals in TGSL.');\n  }\n\n  if (expression[0] === NODE.preUpdate) {\n    throw new Error('Cannot use pre-updates in TGSL.');\n  }\n\n  assertExhaustive(expression);\n}\n\nfunction blockifySingleStatement(statement: tinyest.Statement): tinyest.Block {\n  return typeof statement !== 'object' ||\n      statement[0] !== NODE.block\n    ? [NODE.block, [statement]]\n    : statement;\n}\n\nexport function generateStatement(\n  ctx: GenerationCtx,\n  statement: tinyest.Statement,\n): string {\n  if (typeof statement === 'string') {\n    return `${ctx.pre}${\n      ctx.resolve(generateIdentifier(ctx, statement).value)\n    };`;\n  }\n\n  if (typeof statement === 'boolean') {\n    return `${ctx.pre}${statement ? 'true' : 'false'};`;\n  }\n\n  if (statement[0] === NODE.return) {\n    const returnNode = statement[1];\n    const returnValue = returnNode !== undefined\n      ? ctx.resolve(generateExpression(ctx, returnNode).value)\n      : undefined;\n\n    // check if the thing at the top of the call stack is a struct and the statement is a plain JS object\n    // if so wrap the value returned in a constructor of the struct (its resolved name)\n    if (\n      wgsl.isWgslStruct(ctx.callStack[ctx.callStack.length - 1]) &&\n      typeof returnNode === 'object' &&\n      returnNode[0] === NODE.objectExpr\n    ) {\n      const resolvedStruct = ctx.resolve(\n        ctx.callStack[ctx.callStack.length - 1],\n      );\n      return `${ctx.pre}return ${resolvedStruct}(${returnValue});`;\n    }\n\n    return returnValue\n      ? `${ctx.pre}return ${returnValue};`\n      : `${ctx.pre}return;`;\n  }\n\n  if (statement[0] === NODE.if) {\n    const [_, cond, cons, alt] = statement;\n    const condExpr = generateExpression(ctx, cond);\n    let condSnippet = condExpr;\n    const converted = convertToCommonType(ctx, [condExpr], [d.bool]);\n    if (converted?.[0]) {\n      [condSnippet] = converted;\n    }\n    const condition = ctx.resolve(condSnippet.value);\n\n    ctx.indent(); // {\n    const consequent = generateStatement(ctx, blockifySingleStatement(cons));\n    ctx.dedent(); // }\n\n    ctx.indent(); // {\n    const alternate = alt\n      ? generateStatement(ctx, blockifySingleStatement(alt))\n      : undefined;\n    ctx.dedent(); // }\n\n    if (!alternate) {\n      return `\\\n${ctx.pre}if (${condition})\n${consequent}`;\n    }\n\n    return `\\\n${ctx.pre}if (${condition})\n${consequent}\n${ctx.pre}else\n${alternate}`;\n  }\n\n  if (statement[0] === NODE.let || statement[0] === NODE.const) {\n    const [_, rawId, rawValue] = statement;\n    const eq = rawValue !== undefined\n      ? generateExpression(ctx, rawValue)\n      : undefined;\n\n    if (!eq) {\n      throw new Error(\n        `Cannot create variable '${rawId}' without an initial value.`,\n      );\n    }\n\n    if (isLooseData(eq.dataType)) {\n      throw new Error(\n        `Cannot create variable '${rawId}' with loose data type.`,\n      );\n    }\n\n    registerBlockVariable(\n      ctx,\n      rawId,\n      concretize(eq.dataType as wgsl.AnyWgslData),\n    );\n    const id = ctx.resolve(generateIdentifier(ctx, rawId).value);\n\n    // If the value is a plain JS object it has to be an output struct\n    if (\n      typeof rawValue === 'object' &&\n      rawValue[0] === NODE.objectExpr &&\n      wgsl.isWgslStruct(ctx.callStack[ctx.callStack.length - 1])\n    ) {\n      const structType = ctx.callStack[\n        ctx.callStack.length - 1\n      ] as wgsl.WgslStruct;\n      const obj = rawValue[1];\n\n      const entries: Record<string, Snippet> = {};\n      for (const [key, value] of Object.entries(obj)) {\n        if (!value) {\n          throw new Error(`Missing property ${key} in object literal`);\n        }\n        entries[key] = generateExpression(ctx, value);\n      }\n\n      const convertedValues = convertStructValues(ctx, structType, entries);\n      const resolvedStruct = ctx.resolve(structType);\n      return `${ctx.pre}var ${id} = ${resolvedStruct}(${\n        convertedValues.map((sn) => ctx.resolve(sn.value)).join(', ')\n      });`;\n    }\n\n    return `${ctx.pre}var ${id} = ${ctx.resolve(eq.value)};`;\n  }\n\n  if (statement[0] === NODE.block) {\n    return generateBlock(ctx, statement);\n  }\n\n  if (statement[0] === NODE.for) {\n    const [_, init, condition, update, body] = statement;\n\n    const initStatement = init ? generateStatement(ctx, init) : undefined;\n    const initStr = initStatement ? initStatement.slice(0, -1) : '';\n\n    const conditionExpr = condition\n      ? generateExpression(ctx, condition)\n      : undefined;\n    let condSnippet = conditionExpr;\n    if (conditionExpr) {\n      const converted = convertToCommonType(ctx, [conditionExpr], [d.bool]);\n      if (converted?.[0]) {\n        [condSnippet] = converted;\n      }\n    }\n    const conditionStr = condSnippet ? ctx.resolve(condSnippet.value) : '';\n\n    const updateStatement = update ? generateStatement(ctx, update) : undefined;\n    const updateStr = updateStatement ? updateStatement.slice(0, -1) : '';\n\n    ctx.indent();\n    const bodyStr = generateStatement(ctx, blockifySingleStatement(body));\n    ctx.dedent();\n\n    return `\\\n${ctx.pre}for (${initStr}; ${conditionStr}; ${updateStr})\n${bodyStr}`;\n  }\n\n  if (statement[0] === NODE.while) {\n    const [_, condition, body] = statement;\n    const condExpr = generateExpression(ctx, condition);\n    let condSnippet = condExpr;\n    if (condExpr) {\n      const converted = convertToCommonType(ctx, [condExpr], [d.bool]);\n      if (converted?.[0]) {\n        [condSnippet] = converted;\n      }\n    }\n    const conditionStr = ctx.resolve(condSnippet.value);\n\n    ctx.indent();\n    const bodyStr = generateStatement(ctx, blockifySingleStatement(body));\n    ctx.dedent();\n\n    return `\\\n${ctx.pre}while (${conditionStr})\n${bodyStr}`;\n  }\n\n  if (statement[0] === NODE.continue) {\n    return `${ctx.pre}continue;`;\n  }\n\n  if (statement[0] === NODE.break) {\n    return `${ctx.pre}break;`;\n  }\n\n  return `${ctx.pre}${ctx.resolve(generateExpression(ctx, statement).value)};`;\n}\n\nexport function generateFunction(\n  ctx: GenerationCtx,\n  body: tinyest.Block,\n): string {\n  return generateBlock(ctx, body);\n}\n","import { resolveData } from './core/resolve/resolveData.ts';\nimport {\n  type Eventual,\n  isDerived,\n  isProviding,\n  isSlot,\n  type SlotValuePair,\n  type TgpuDerived,\n  type TgpuSlot,\n} from './core/slot/slotTypes.ts';\nimport { getAttributesString } from './data/attributes.ts';\nimport {\n  type AnyData,\n  isData,\n  snip,\n  type Snippet,\n  type UnknownData,\n} from './data/dataTypes.ts';\nimport { type BaseData, isWgslArray, isWgslStruct } from './data/wgslTypes.ts';\nimport { MissingSlotValueError, ResolutionError } from './errors.ts';\nimport { popMode, provideCtx, pushMode, RuntimeMode } from './gpuMode.ts';\nimport type { NameRegistry } from './nameRegistry.ts';\nimport { naturalsExcept } from './shared/generators.ts';\nimport type { Infer } from './shared/repr.ts';\nimport { $internal, $providing } from './shared/symbols.ts';\nimport {\n  bindGroupLayout,\n  type TgpuBindGroup,\n  TgpuBindGroupImpl,\n  type TgpuBindGroupLayout,\n  type TgpuLayoutEntry,\n} from './tgpuBindGroupLayout.ts';\nimport { coerceToSnippet } from './tgsl/generationHelpers.ts';\nimport { generateFunction } from './tgsl/wgslGenerator.ts';\nimport type {\n  FnToWgslOptions,\n  ItemLayer,\n  ItemStateStack,\n  ResolutionCtx,\n  Wgsl,\n} from './types.ts';\nimport { isSelfResolvable, isWgsl } from './types.ts';\n\n/**\n * Inserted into bind group entry definitions that belong\n * to the automatically generated catch-all bind group.\n *\n * A non-occupied group index can only be determined after\n * every resource has been resolved, so this acts as a placeholder\n * to be replaced with an actual numeric index at the very end\n * of the resolution process.\n */\nconst CATCHALL_BIND_GROUP_IDX_MARKER = '#CATCHALL#';\n\nexport type ResolutionCtxImplOptions = {\n  readonly names: NameRegistry;\n};\n\ntype SlotToValueMap = Map<TgpuSlot<unknown>, unknown>;\n\ntype SlotBindingLayer = {\n  type: 'slotBinding';\n  bindingMap: WeakMap<TgpuSlot<unknown>, unknown>;\n};\n\ntype FunctionScopeLayer = {\n  type: 'functionScope';\n  args: Snippet[];\n  argAliases: Record<string, Snippet>;\n  externalMap: Record<string, unknown>;\n  returnType: AnyData;\n};\n\ntype BlockScopeLayer = {\n  type: 'blockScope';\n  declarations: Map<string, AnyData | UnknownData>;\n};\n\nclass ItemStateStackImpl implements ItemStateStack {\n  private _stack: (\n    | ItemLayer\n    | SlotBindingLayer\n    | FunctionScopeLayer\n    | BlockScopeLayer\n  )[] = [];\n  private _itemDepth = 0;\n\n  get itemDepth(): number {\n    return this._itemDepth;\n  }\n\n  get topItem(): ItemLayer {\n    const state = this._stack[this._stack.length - 1];\n    if (!state || state.type !== 'item') {\n      throw new Error('Internal error, expected item layer to be on top.');\n    }\n    return state;\n  }\n\n  pushItem() {\n    this._itemDepth++;\n    this._stack.push({\n      type: 'item',\n      usedSlots: new Set(),\n    });\n  }\n\n  popItem() {\n    this.pop('item');\n  }\n\n  pushSlotBindings(pairs: SlotValuePair<unknown>[]) {\n    this._stack.push({\n      type: 'slotBinding',\n      bindingMap: new WeakMap(pairs),\n    });\n  }\n\n  popSlotBindings() {\n    this.pop('slotBinding');\n  }\n\n  pushFunctionScope(\n    args: Snippet[],\n    argAliases: Record<string, Snippet>,\n    returnType: AnyData,\n    externalMap: Record<string, unknown>,\n  ) {\n    this._stack.push({\n      type: 'functionScope',\n      args,\n      argAliases,\n      returnType,\n      externalMap,\n    });\n  }\n\n  popFunctionScope() {\n    this.pop('functionScope');\n  }\n\n  pushBlockScope() {\n    this._stack.push({\n      type: 'blockScope',\n      declarations: new Map<string, AnyData | UnknownData>(),\n    });\n  }\n\n  popBlockScope() {\n    this.pop('blockScope');\n  }\n\n  pop(type?: (typeof this._stack)[number]['type']) {\n    const layer = this._stack[this._stack.length - 1];\n    if (!layer || (type && layer.type !== type)) {\n      throw new Error(`Internal error, expected a ${type} layer to be on top.`);\n    }\n\n    this._stack.pop();\n    if (type === 'item') {\n      this._itemDepth--;\n    }\n  }\n\n  readSlot<T>(slot: TgpuSlot<T>): T | undefined {\n    for (let i = this._stack.length - 1; i >= 0; --i) {\n      const layer = this._stack[i];\n      if (layer?.type === 'item') {\n        // Binding not available yet, so this layer is dependent on the slot's value.\n        layer.usedSlots.add(slot);\n      } else if (layer?.type === 'slotBinding') {\n        const boundValue = layer.bindingMap.get(slot);\n\n        if (boundValue !== undefined) {\n          return boundValue as T;\n        }\n      } else if (\n        layer?.type === 'functionScope' ||\n        layer?.type === 'blockScope'\n      ) {\n        // Skip\n      } else {\n        throw new Error('Unknown layer type.');\n      }\n    }\n\n    return slot.defaultValue;\n  }\n\n  getSnippetById(id: string): Snippet | undefined {\n    for (let i = this._stack.length - 1; i >= 0; --i) {\n      const layer = this._stack[i];\n\n      if (layer?.type === 'functionScope') {\n        const arg = layer.args.find((a) => a.value === id);\n        if (arg !== undefined) {\n          return arg;\n        }\n\n        if (layer.argAliases[id]) {\n          return layer.argAliases[id];\n        }\n\n        const external = layer.externalMap[id];\n\n        if (external !== undefined && external !== null) {\n          return coerceToSnippet(external);\n        }\n\n        // Since functions cannot access resources from the calling scope, we\n        // return early here.\n        return undefined;\n      }\n\n      if (layer?.type === 'blockScope') {\n        const declarationType = layer.declarations.get(id);\n        if (declarationType !== undefined) {\n          return snip(id, declarationType);\n        }\n      } else {\n        // Skip\n      }\n    }\n\n    return undefined;\n  }\n\n  defineBlockVariable(id: string, type: AnyData | UnknownData): Snippet {\n    if (type.type === 'unknown') {\n      throw Error(`Tried to define variable '${id}' of unknown type`);\n    }\n\n    for (let i = this._stack.length - 1; i >= 0; --i) {\n      const layer = this._stack[i];\n\n      if (layer?.type === 'blockScope') {\n        layer.declarations.set(id, type);\n\n        return snip(id, type);\n      }\n    }\n\n    throw new Error('No block scope found to define a variable in.');\n  }\n}\n\nconst INDENT = [\n  '', // 0\n  '  ', // 1\n  '    ', // 2\n  '      ', // 3\n  '        ', // 4\n  '          ', // 5\n  '            ', // 6\n  '              ', // 7\n  '                ', // 8\n];\n\nconst N = INDENT.length - 1;\n\nexport class IndentController {\n  private identLevel = 0;\n\n  get pre(): string {\n    return (\n      INDENT[this.identLevel] ??\n        (INDENT[N] as string).repeat(this.identLevel / N) +\n          INDENT[this.identLevel % N]\n    );\n  }\n\n  indent(): string {\n    const str = this.pre;\n    this.identLevel++;\n    return str;\n  }\n\n  dedent(): string {\n    this.identLevel--;\n    return this.pre;\n  }\n}\n\ninterface FixedBindingConfig {\n  layoutEntry: TgpuLayoutEntry;\n  resource: object;\n}\n\nexport class ResolutionCtxImpl implements ResolutionCtx {\n  private readonly _memoizedResolves = new WeakMap<\n    // WeakMap because if the item does not exist anymore,\n    // apart from this map, there is no way to access the cached value anyway.\n    object,\n    { slotToValueMap: SlotToValueMap; result: string }[]\n  >();\n  private readonly _memoizedDerived = new WeakMap<\n    // WeakMap because if the \"derived\" does not exist anymore,\n    // apart from this map, there is no way to access the cached value anyway.\n    TgpuDerived<unknown>,\n    { slotToValueMap: SlotToValueMap; result: unknown }[]\n  >();\n\n  private readonly _indentController = new IndentController();\n  private readonly _itemStateStack = new ItemStateStackImpl();\n  private readonly _declarations: string[] = [];\n  private _varyingLocations: Record<string, number> | undefined;\n\n  get varyingLocations() {\n    return this._varyingLocations;\n  }\n\n  readonly [$internal] = {\n    itemStateStack: this._itemStateStack,\n  };\n\n  // -- Bindings\n  /**\n   * A map from registered bind group layouts to random strings put in\n   * place of their group index. The whole tree has to be traversed to\n   * collect every use of a typed bind group layout, since they can be\n   * explicitly imposed group indices, and they cannot collide.\n   */\n  public readonly bindGroupLayoutsToPlaceholderMap = new Map<\n    TgpuBindGroupLayout,\n    string\n  >();\n  private _nextFreeLayoutPlaceholderIdx = 0;\n  public readonly fixedBindings: FixedBindingConfig[] = [];\n  // --\n\n  public readonly callStack: unknown[] = [];\n  public readonly names: NameRegistry;\n\n  constructor(opts: ResolutionCtxImplOptions) {\n    this.names = opts.names;\n  }\n\n  get pre(): string {\n    return this._indentController.pre;\n  }\n\n  indent(): string {\n    return this._indentController.indent();\n  }\n\n  dedent(): string {\n    return this._indentController.dedent();\n  }\n\n  getById(id: string): Snippet | null {\n    const item = this._itemStateStack.getSnippetById(id);\n\n    if (item === undefined) {\n      return null;\n    }\n\n    return item;\n  }\n\n  defineVariable(id: string, dataType: AnyData | UnknownData): Snippet {\n    return this._itemStateStack.defineBlockVariable(id, dataType);\n  }\n\n  pushBlockScope() {\n    this._itemStateStack.pushBlockScope();\n  }\n\n  popBlockScope() {\n    this._itemStateStack.popBlockScope();\n  }\n\n  fnToWgsl(options: FnToWgslOptions): { head: Wgsl; body: Wgsl } {\n    this._itemStateStack.pushFunctionScope(\n      options.args,\n      options.argAliases,\n      options.returnType,\n      options.externalMap,\n    );\n\n    try {\n      return {\n        head: resolveFunctionHeader(this, options.args, options.returnType),\n        body: generateFunction(this, options.body),\n      };\n    } finally {\n      this._itemStateStack.popFunctionScope();\n    }\n  }\n\n  addDeclaration(declaration: string): void {\n    this._declarations.push(declaration);\n  }\n\n  allocateLayoutEntry(layout: TgpuBindGroupLayout): string {\n    const memoMap = this.bindGroupLayoutsToPlaceholderMap;\n    let placeholderKey = memoMap.get(layout);\n\n    if (!placeholderKey) {\n      placeholderKey = `#BIND_GROUP_LAYOUT_${this\n        ._nextFreeLayoutPlaceholderIdx++}#`;\n      memoMap.set(layout, placeholderKey);\n    }\n\n    return placeholderKey;\n  }\n\n  allocateFixedEntry(\n    layoutEntry: TgpuLayoutEntry,\n    resource: object,\n  ): { group: string; binding: number } {\n    const binding = this.fixedBindings.length;\n    this.fixedBindings.push({ layoutEntry, resource });\n\n    return {\n      group: CATCHALL_BIND_GROUP_IDX_MARKER,\n      binding,\n    };\n  }\n\n  readSlot<T>(slot: TgpuSlot<T>): T {\n    const value = this._itemStateStack.readSlot(slot);\n\n    if (value === undefined) {\n      throw new MissingSlotValueError(slot);\n    }\n\n    return value;\n  }\n\n  withSlots<T>(pairs: SlotValuePair<unknown>[], callback: () => T): T {\n    this._itemStateStack.pushSlotBindings(pairs);\n\n    try {\n      return callback();\n    } finally {\n      this._itemStateStack.popSlotBindings();\n    }\n  }\n\n  withVaryingLocations<T>(\n    locations: Record<string, number>,\n    callback: () => T,\n  ): T {\n    this._varyingLocations = locations;\n\n    try {\n      return callback();\n    } finally {\n      this._varyingLocations = undefined;\n    }\n  }\n\n  unwrap<T>(eventual: Eventual<T>): T {\n    if (isProviding(eventual)) {\n      return this.withSlots(\n        eventual[$providing].pairs,\n        () => this.unwrap(eventual[$providing].inner) as T,\n      );\n    }\n\n    let maybeEventual = eventual;\n\n    // Unwrapping all layers of slots.\n    while (true) {\n      if (isSlot(maybeEventual)) {\n        maybeEventual = this.readSlot(maybeEventual);\n      } else if (isDerived(maybeEventual)) {\n        maybeEventual = this._getOrCompute(maybeEventual);\n      } else {\n        break;\n      }\n    }\n\n    return maybeEventual;\n  }\n\n  _getOrCompute<T>(derived: TgpuDerived<T>): T {\n    // All memoized versions of `derived`\n    const instances = this._memoizedDerived.get(derived) ?? [];\n\n    this._itemStateStack.pushItem();\n\n    try {\n      for (const instance of instances) {\n        const slotValuePairs = [...instance.slotToValueMap.entries()];\n\n        if (\n          slotValuePairs.every(([slot, expectedValue]) =>\n            slot.areEqual(this._itemStateStack.readSlot(slot), expectedValue)\n          )\n        ) {\n          return instance.result as T;\n        }\n      }\n\n      // If we got here, no item with the given slot-to-value combo exists in cache yet\n      // Derived computations are always done on the CPU\n      pushMode(RuntimeMode.CPU);\n\n      let result: T;\n      try {\n        result = derived['~compute']();\n      } finally {\n        popMode(RuntimeMode.CPU);\n      }\n\n      // We know which slots the item used while resolving\n      const slotToValueMap = new Map<TgpuSlot<unknown>, unknown>();\n      for (const usedSlot of this._itemStateStack.topItem.usedSlots) {\n        slotToValueMap.set(usedSlot, this._itemStateStack.readSlot(usedSlot));\n      }\n\n      instances.push({ slotToValueMap, result });\n      this._memoizedDerived.set(derived, instances);\n      return result;\n    } catch (err) {\n      if (err instanceof ResolutionError) {\n        throw err.appendToTrace(derived);\n      }\n\n      throw new ResolutionError(err, [derived]);\n    } finally {\n      this._itemStateStack.popItem();\n    }\n  }\n\n  /**\n   * @param item The item whose resolution should be either retrieved from the cache (if there is a cache hit), or resolved.\n   */\n  _getOrInstantiate(item: object): string {\n    // All memoized versions of `item`\n    const instances = this._memoizedResolves.get(item) ?? [];\n\n    this._itemStateStack.pushItem();\n\n    try {\n      for (const instance of instances) {\n        const slotValuePairs = [...instance.slotToValueMap.entries()];\n\n        if (\n          slotValuePairs.every(([slot, expectedValue]) =>\n            slot.areEqual(this._itemStateStack.readSlot(slot), expectedValue)\n          )\n        ) {\n          return instance.result;\n        }\n      }\n\n      // If we got here, no item with the given slot-to-value combo exists in cache yet\n      let result: string;\n      if (isData(item)) {\n        result = resolveData(this, item);\n      } else if (isDerived(item) || isSlot(item)) {\n        result = this.resolve(this.unwrap(item));\n      } else if (isSelfResolvable(item)) {\n        result = item['~resolve'](this);\n      } else {\n        result = this.resolveValue(item);\n      }\n\n      // We know which slots the item used while resolving\n      const slotToValueMap = new Map<TgpuSlot<unknown>, unknown>();\n      for (const usedSlot of this._itemStateStack.topItem.usedSlots) {\n        slotToValueMap.set(usedSlot, this._itemStateStack.readSlot(usedSlot));\n      }\n\n      instances.push({ slotToValueMap, result });\n      this._memoizedResolves.set(item, instances);\n\n      return result;\n    } catch (err) {\n      if (err instanceof ResolutionError) {\n        throw err.appendToTrace(item);\n      }\n\n      throw new ResolutionError(err, [item]);\n    } finally {\n      this._itemStateStack.popItem();\n    }\n  }\n\n  resolve(item: unknown): string {\n    if (isProviding(item)) {\n      return this.withSlots(\n        item[$providing].pairs,\n        () => this.resolve(item[$providing].inner),\n      );\n    }\n\n    if ((item && typeof item === 'object') || typeof item === 'function') {\n      if (this._itemStateStack.itemDepth === 0) {\n        try {\n          pushMode(RuntimeMode.GPU);\n          const result = provideCtx(this, () => this._getOrInstantiate(item));\n          return `${[...this._declarations].join('\\n\\n')}${result}`;\n        } finally {\n          popMode(RuntimeMode.GPU);\n        }\n      }\n\n      return this._getOrInstantiate(item);\n    }\n\n    return String(item);\n  }\n\n  resolveValue<T extends BaseData>(\n    value: Infer<T>,\n    schema?: T | undefined,\n  ): string {\n    if (isWgsl(value)) {\n      return this.resolve(value);\n    }\n\n    if (schema && isWgslArray(schema)) {\n      return `array(${\n        (value as unknown[]).map((element) =>\n          this.resolveValue(element, schema.elementType)\n        )\n      })`;\n    }\n\n    if (Array.isArray(value)) {\n      return `array(${value.map((element) => this.resolveValue(element))})`;\n    }\n\n    if (schema && isWgslStruct(schema)) {\n      return `${this.resolve(schema)}(${\n        Object.entries(schema.propTypes).map(([key, type_]) =>\n          this.resolveValue((value as Infer<typeof schema>)[key], type_)\n        )\n      })`;\n    }\n\n    throw new Error(\n      `Value ${value} (as json: ${\n        JSON.stringify(value)\n      }) of schema ${schema} is not resolvable to WGSL`,\n    );\n  }\n}\n\n/**\n * The results of a WGSL resolution.\n *\n * @param code - The resolved code.\n * @param usedBindGroupLayouts - List of used `tgpu.bindGroupLayout`s.\n * @param catchall - Automatically constructed bind group for buffer usages and buffer shorthands, preceded by its index.\n */\nexport interface ResolutionResult {\n  code: string;\n  usedBindGroupLayouts: TgpuBindGroupLayout[];\n  catchall: [number, TgpuBindGroup] | undefined;\n}\n\nexport function resolve(\n  item: Wgsl,\n  options: ResolutionCtxImplOptions,\n): ResolutionResult {\n  const ctx = new ResolutionCtxImpl(options);\n  let code = ctx.resolve(item);\n\n  const memoMap = ctx.bindGroupLayoutsToPlaceholderMap;\n  const usedBindGroupLayouts: TgpuBindGroupLayout[] = [];\n  const takenIndices = new Set<number>(\n    [...memoMap.keys()]\n      .map((layout) => layout.index)\n      .filter((v): v is number => v !== undefined),\n  );\n\n  const automaticIds = naturalsExcept(takenIndices);\n\n  const layoutEntries = ctx.fixedBindings.map(\n    (binding, idx) =>\n      [String(idx), binding.layoutEntry] as [string, TgpuLayoutEntry],\n  );\n\n  const createCatchallGroup = () => {\n    const catchallIdx = automaticIds.next().value;\n    const catchallLayout = bindGroupLayout(Object.fromEntries(layoutEntries));\n    usedBindGroupLayouts[catchallIdx] = catchallLayout;\n    code = code.replaceAll(CATCHALL_BIND_GROUP_IDX_MARKER, String(catchallIdx));\n\n    return [\n      catchallIdx,\n      new TgpuBindGroupImpl(\n        catchallLayout,\n        Object.fromEntries(\n          ctx.fixedBindings.map(\n            (binding, idx) =>\n              // biome-ignore lint/suspicious/noExplicitAny: <it's fine>\n              [String(idx), binding.resource] as [string, any],\n          ),\n        ),\n      ),\n    ] as [number, TgpuBindGroup];\n  };\n\n  // Retrieving the catch-all binding index first, because it's inherently\n  // the least swapped bind group (fixed and cannot be swapped).\n  const catchall = layoutEntries.length > 0 ? createCatchallGroup() : undefined;\n\n  for (const [layout, placeholder] of memoMap.entries()) {\n    const idx = layout.index ?? automaticIds.next().value;\n    usedBindGroupLayouts[idx] = layout;\n    code = code.replaceAll(placeholder, String(idx));\n  }\n\n  return {\n    code,\n    usedBindGroupLayouts,\n    catchall,\n  };\n}\n\nexport function resolveFunctionHeader(\n  ctx: ResolutionCtx,\n  args: Snippet[],\n  returnType: AnyData,\n) {\n  const argList = args\n    .map((arg) => `${arg.value}: ${ctx.resolve(arg.dataType as AnyData)}`)\n    .join(', ');\n\n  return returnType.type !== 'void'\n    ? `(${argList}) -> ${getAttributesString(returnType)} ${\n      ctx.resolve(returnType)\n    }`\n    : `(${argList})`;\n}\n","import { RandomNameRegistry, StrictNameRegistry } from '../../nameRegistry.ts';\nimport {\n  type ResolutionResult,\n  resolve as resolveImpl,\n} from '../../resolutionCtx.ts';\nimport type { SelfResolvable, Wgsl } from '../../types.ts';\nimport { applyExternals, replaceExternalsInWgsl } from './externals.ts';\n\nexport interface TgpuResolveOptions {\n  /**\n   * Map of external names to their resolvable values.\n   */\n  externals: Record<string, Wgsl | object>;\n  /**\n   * The code template to use for the resolution. All external names will be replaced with their resolved values.\n   * @default ''\n   */\n  template?: string | undefined;\n  /**\n   * The naming strategy used for generating identifiers for resolved externals and their dependencies.\n   * @default 'random'\n   */\n  names?: 'strict' | 'random' | undefined;\n}\n\n/**\n * Resolves a template with external values. Each external will get resolved to a code string and replaced in the template.\n * Any dependencies of the externals will also be resolved and included in the output.\n * @param options - The options for the resolution.\n *\n * @returns {ResolutionResult}\n *\n * @example\n * ```ts\n * const Gradient = d.struct({\n *   from: d.vec3f,\n *   to: d.vec3f,\n * });\n *\n * const { code, usedBindGroupLayouts, catchall } = tgpu.resolveWithContext({\n *   template: `\n *     fn getGradientAngle(gradient: Gradient) -> f32 {\n *       return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n *     }\n *   `,\n *   externals: {\n *     Gradient,\n *   },\n * });\n *\n * console.log(code);\n * // struct Gradient_0 {\n * //   from: vec3f,\n * //   to: vec3f,\n * // }\n * // fn getGradientAngle(gradient: Gradient_0) -> f32 {\n * //   return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n * // }\n * ```\n */\nexport function resolveWithContext(\n  options: TgpuResolveOptions,\n): ResolutionResult {\n  const {\n    externals,\n    template,\n    names,\n  } = options;\n\n  const dependencies = {} as Record<string, Wgsl>;\n  applyExternals(dependencies, externals ?? {});\n\n  const resolutionObj: SelfResolvable = {\n    '~resolve'(ctx) {\n      return replaceExternalsInWgsl(ctx, dependencies, template ?? '');\n    },\n\n    toString: () => '<root>',\n  };\n\n  return resolveImpl(resolutionObj, {\n    names: names === 'strict'\n      ? new StrictNameRegistry()\n      : new RandomNameRegistry(),\n  });\n}\n\n/**\n * Resolves a template with external values. Each external will get resolved to a code string and replaced in the template.\n * Any dependencies of the externals will also be resolved and included in the output.\n * @param options - The options for the resolution.\n *\n * @returns The resolved code.\n *\n * @example\n * ```ts\n * const Gradient = d.struct({\n *   from: d.vec3f,\n *   to: d.vec3f,\n * });\n *\n * const resolved = tgpu.resolve({\n *   template: `\n *     fn getGradientAngle(gradient: Gradient) -> f32 {\n *       return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n *     }\n *   `,\n *   externals: {\n *     Gradient,\n *   },\n * });\n *\n * console.log(resolved);\n * // struct Gradient_0 {\n * //   from: vec3f,\n * //   to: vec3f,\n * // }\n * // fn getGradientAngle(gradient: Gradient_0) -> f32 {\n * //   return atan(gradient.to.y - gradient.from.y, gradient.to.x - gradient.from.x);\n * // }\n * ```\n */\nexport function resolve(options: TgpuResolveOptions): string {\n  return resolveWithContext(options).code;\n}\n","import { setName, type TgpuNamable } from '../../shared/meta.ts';\nimport type { ExperimentalTgpuRoot } from '../../core/root/rootTypes.ts';\nimport { $internal } from '../../shared/symbols.ts';\n\nexport interface TgpuQuerySet<T extends GPUQueryType> extends TgpuNamable {\n  readonly resourceType: 'query-set';\n  readonly type: T;\n  readonly count: number;\n\n  readonly querySet: GPUQuerySet;\n  readonly destroyed: boolean;\n  readonly available: boolean;\n\n  readonly [$internal]: {\n    readonly readBuffer: GPUBuffer;\n    readonly resolveBuffer: GPUBuffer;\n  };\n\n  resolve(): void;\n  read(): Promise<bigint[]>;\n  destroy(): void;\n}\n\nexport function INTERNAL_createQuerySet<T extends GPUQueryType>(\n  group: ExperimentalTgpuRoot,\n  type: T,\n  count: number,\n  rawQuerySet?: GPUQuerySet,\n): TgpuQuerySet<T> {\n  return new TgpuQuerySetImpl(group, type, count, rawQuerySet);\n}\n\nexport function isQuerySet<T extends GPUQueryType>(\n  value: unknown,\n): value is TgpuQuerySet<T> {\n  const maybe = value as TgpuQuerySet<T>;\n  return maybe?.resourceType === 'query-set' && !!maybe[$internal];\n}\n\nclass TgpuQuerySetImpl<T extends GPUQueryType> implements TgpuQuerySet<T> {\n  public readonly resourceType = 'query-set' as const;\n  private _querySet: GPUQuerySet | null = null;\n  private readonly _ownQuerySet: boolean;\n  private _destroyed = false;\n  private _available = true;\n  private _readBuffer: GPUBuffer | null = null;\n  private _resolveBuffer: GPUBuffer | null = null;\n\n  constructor(\n    private readonly _group: ExperimentalTgpuRoot,\n    public readonly type: T,\n    public readonly count: number,\n    private readonly rawQuerySet?: GPUQuerySet,\n  ) {\n    this._ownQuerySet = !rawQuerySet;\n    this._querySet = rawQuerySet || null;\n  }\n\n  get querySet(): GPUQuerySet {\n    if (this._destroyed) {\n      throw new Error('This QuerySet has been destroyed.');\n    }\n    if (this.rawQuerySet) {\n      return this.rawQuerySet;\n    }\n    if (this._querySet) {\n      return this._querySet;\n    }\n\n    this._querySet = this._group.device.createQuerySet({\n      type: this.type,\n      count: this.count,\n    });\n    return this._querySet;\n  }\n\n  get destroyed(): boolean {\n    return this._destroyed;\n  }\n\n  get available(): boolean {\n    return this._available;\n  }\n\n  get [$internal]() {\n    const self = this;\n    return {\n      get readBuffer(): GPUBuffer {\n        if (!self._readBuffer) {\n          self._readBuffer = self._group.device.createBuffer({\n            size: self.count * BigUint64Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,\n          });\n        }\n        return self._readBuffer;\n      },\n      get resolveBuffer(): GPUBuffer {\n        if (!self._resolveBuffer) {\n          self._resolveBuffer = self._group.device.createBuffer({\n            size: self.count * BigUint64Array.BYTES_PER_ELEMENT,\n            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n          });\n        }\n        return self._resolveBuffer;\n      },\n    };\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    if (this._querySet) {\n      this._querySet.label = label;\n    }\n    return this;\n  }\n\n  resolve(): void {\n    if (this._destroyed) {\n      throw new Error('This QuerySet has been destroyed.');\n    }\n    if (!this._available) {\n      throw new Error('This QuerySet is busy resolving or reading.');\n    }\n\n    const commandEncoder = this._group.device.createCommandEncoder();\n    commandEncoder.resolveQuerySet(\n      this.querySet,\n      0,\n      this.count,\n      this[$internal].resolveBuffer,\n      0,\n    );\n    this._group.device.queue.submit([commandEncoder.finish()]);\n  }\n\n  async read(): Promise<bigint[]> {\n    this._group.flush();\n    if (!this._resolveBuffer) {\n      throw new Error('QuerySet must be resolved before reading.');\n    }\n\n    this._available = false;\n    try {\n      const commandEncoder = this._group.device.createCommandEncoder();\n      commandEncoder.copyBufferToBuffer(\n        this[$internal].resolveBuffer,\n        0,\n        this[$internal].readBuffer,\n        0,\n        this.count * BigUint64Array.BYTES_PER_ELEMENT,\n      );\n      this._group.device.queue.submit([commandEncoder.finish()]);\n      await this._group.device.queue.onSubmittedWorkDone();\n\n      const readBuffer = this[$internal].readBuffer;\n      await readBuffer.mapAsync(GPUMapMode.READ);\n      const data = new BigUint64Array(readBuffer.getMappedRange().slice());\n      readBuffer.unmap();\n      return Array.from(data);\n    } finally {\n      this._available = true;\n    }\n  }\n\n  destroy(): void {\n    if (this._destroyed) {\n      return;\n    }\n    this._destroyed = true;\n\n    if (this._querySet && this._ownQuerySet) {\n      this._querySet.destroy();\n    }\n    this._readBuffer?.destroy();\n    this._resolveBuffer?.destroy();\n    this._readBuffer = this._resolveBuffer = null;\n  }\n}\n","/**\n * Caches results of the function passed in as\n * the argument to the constructor.\n *\n * If the key can be garbage collected, it will be.\n */\nexport class WeakMemo<TKey extends object, TValue, TArgs extends unknown[]> {\n  private readonly _map = new WeakMap<TKey, TValue>();\n\n  constructor(private readonly _make: (key: TKey, ...args: TArgs) => TValue) {}\n\n  getOrMake(key: TKey, ...args: TArgs): TValue {\n    if (this._map.has(key)) {\n      return this._map.get(key) as TValue;\n    }\n\n    const value = this._make(key, ...args);\n    this._map.set(key, value);\n    return value;\n  }\n}\n","import { isQuerySet, type TgpuQuerySet } from '../querySet/querySet.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport { $internal } from '../../shared/symbols.ts';\n\nexport interface Timeable {\n  withPerformanceCallback(\n    callback: (start: bigint, end: bigint) => void | Promise<void>,\n  ): this;\n\n  withTimestampWrites(options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  }): this;\n}\n\nexport type TimestampWritesPriors = {\n  readonly timestampWrites?: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  };\n  readonly performanceCallback?: (\n    start: bigint,\n    end: bigint,\n  ) => void | Promise<void>;\n  readonly hasAutoQuerySet?: boolean;\n};\n\nexport function createWithPerformanceCallback<T extends TimestampWritesPriors>(\n  currentPriors: T,\n  callback: (start: bigint, end: bigint) => void | Promise<void>,\n  root: ExperimentalTgpuRoot,\n): T {\n  if (!root.enabledFeatures.has('timestamp-query')) {\n    throw new Error(\n      'Performance callback requires the \"timestamp-query\" feature to be enabled on GPU device.',\n    );\n  }\n\n  if (!currentPriors.timestampWrites) {\n    return {\n      ...currentPriors,\n      performanceCallback: callback,\n      hasAutoQuerySet: true,\n      timestampWrites: {\n        querySet: root.createQuerySet('timestamp', 2),\n        beginningOfPassWriteIndex: 0,\n        endOfPassWriteIndex: 1,\n      },\n    };\n  }\n\n  return {\n    ...currentPriors,\n    performanceCallback: callback,\n  };\n}\n\nexport function createWithTimestampWrites<T extends TimestampWritesPriors>(\n  currentPriors: T,\n  options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  },\n  root: ExperimentalTgpuRoot,\n): T {\n  if (!root.enabledFeatures.has('timestamp-query')) {\n    throw new Error(\n      'Timestamp writes require the \"timestamp-query\" feature to be enabled on GPU device.',\n    );\n  }\n\n  if (currentPriors.hasAutoQuerySet && currentPriors.timestampWrites) {\n    currentPriors.timestampWrites.querySet.destroy();\n  }\n\n  const timestampWrites: TimestampWritesPriors['timestampWrites'] = {\n    querySet: options.querySet,\n  };\n\n  if (options.beginningOfPassWriteIndex !== undefined) {\n    timestampWrites.beginningOfPassWriteIndex =\n      options.beginningOfPassWriteIndex;\n  }\n  if (options.endOfPassWriteIndex !== undefined) {\n    timestampWrites.endOfPassWriteIndex = options.endOfPassWriteIndex;\n  }\n\n  return {\n    ...currentPriors,\n    hasAutoQuerySet: false,\n    timestampWrites,\n  };\n}\n\nexport function setupTimestampWrites(\n  priors: TimestampWritesPriors,\n  root: ExperimentalTgpuRoot,\n): {\n  timestampWrites?:\n    | GPUComputePassTimestampWrites\n    | GPURenderPassTimestampWrites;\n} {\n  if (!priors.timestampWrites) {\n    return {};\n  }\n\n  const { querySet, beginningOfPassWriteIndex, endOfPassWriteIndex } =\n    priors.timestampWrites;\n\n  const timestampWrites:\n    | GPUComputePassTimestampWrites\n    | GPURenderPassTimestampWrites = {\n      querySet: isQuerySet(querySet) ? root.unwrap(querySet) : querySet,\n    };\n\n  if (beginningOfPassWriteIndex !== undefined) {\n    timestampWrites.beginningOfPassWriteIndex = beginningOfPassWriteIndex;\n  }\n  if (endOfPassWriteIndex !== undefined) {\n    timestampWrites.endOfPassWriteIndex = endOfPassWriteIndex;\n  }\n\n  return { timestampWrites };\n}\n\nexport function triggerPerformanceCallback({\n  root,\n  priors,\n}: {\n  root: ExperimentalTgpuRoot;\n  priors: TimestampWritesPriors;\n}): void | Promise<void> {\n  const querySet = priors.timestampWrites?.querySet;\n  const callback = priors.performanceCallback as (\n    start: bigint,\n    end: bigint,\n  ) => void | Promise<void>;\n\n  if (!querySet) {\n    throw new Error(\n      'Cannot dispatch workgroups with performance callback without a query set.',\n    );\n  }\n\n  if (!isQuerySet(querySet)) {\n    throw new Error(\n      'Performance callback with raw GPUQuerySet is not supported. Use TgpuQuerySet instead.',\n    );\n  }\n\n  root.commandEncoder.resolveQuerySet(\n    root.unwrap(querySet),\n    0,\n    querySet.count,\n    querySet[$internal].resolveBuffer,\n    0,\n  );\n\n  root.flush();\n  root.device.queue.onSubmittedWorkDone().then(async () => {\n    if (!querySet.available) {\n      return;\n    }\n    const result = await querySet.read();\n    const start =\n      result[priors.timestampWrites?.beginningOfPassWriteIndex ?? 0];\n    const end = result[priors.timestampWrites?.endOfPassWriteIndex ?? 1];\n\n    if (start === undefined || end === undefined) {\n      throw new Error('QuerySet did not return valid timestamps.');\n    }\n\n    await callback(start, end);\n  });\n}\n","import type { TgpuQuerySet } from '../../core/querySet/querySet.ts';\nimport { MissingBindGroupsError } from '../../errors.ts';\nimport { type ResolutionResult, resolve } from '../../resolutionCtx.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type {\n  TgpuBindGroup,\n  TgpuBindGroupLayout,\n} from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { TgpuComputeFn } from '../function/tgpuComputeFn.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport type { TgpuSlot } from '../slot/slotTypes.ts';\nimport {\n  createWithPerformanceCallback,\n  createWithTimestampWrites,\n  setupTimestampWrites,\n  type Timeable,\n  type TimestampWritesPriors,\n  triggerPerformanceCallback,\n} from './timeable.ts';\nimport { PERF } from '../../shared/meta.ts';\n\ninterface ComputePipelineInternals {\n  readonly rawPipeline: GPUComputePipeline;\n  readonly priors: TgpuComputePipelinePriors & TimestampWritesPriors;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuComputePipeline\n  extends TgpuNamable, SelfResolvable, Timeable {\n  readonly [$internal]: ComputePipelineInternals;\n  readonly resourceType: 'compute-pipeline';\n\n  with(\n    bindGroupLayout: TgpuBindGroupLayout,\n    bindGroup: TgpuBindGroup,\n  ): TgpuComputePipeline;\n\n  dispatchWorkgroups(\n    x: number,\n    y?: number | undefined,\n    z?: number | undefined,\n  ): void;\n}\n\nexport function INTERNAL_createComputePipeline(\n  branch: ExperimentalTgpuRoot,\n  slotBindings: [TgpuSlot<unknown>, unknown][],\n  entryFn: TgpuComputeFn,\n) {\n  return new TgpuComputePipelineImpl(\n    new ComputePipelineCore(branch, slotBindings, entryFn),\n    {},\n  );\n}\n\nexport function isComputePipeline(\n  value: unknown,\n): value is TgpuComputePipeline {\n  const maybe = value as TgpuComputePipeline | undefined;\n  return maybe?.resourceType === 'compute-pipeline' && !!maybe[$internal];\n}\n\n// --------------\n// Implementation\n// --------------\n\ntype TgpuComputePipelinePriors = {\n  readonly bindGroupLayoutMap?: Map<TgpuBindGroupLayout, TgpuBindGroup>;\n} & TimestampWritesPriors;\n\ntype Memo = {\n  pipeline: GPUComputePipeline;\n  usedBindGroupLayouts: TgpuBindGroupLayout[];\n  catchall: [number, TgpuBindGroup] | undefined;\n};\n\nclass TgpuComputePipelineImpl implements TgpuComputePipeline {\n  public readonly [$internal]: ComputePipelineInternals;\n  public readonly resourceType = 'compute-pipeline';\n  readonly [$getNameForward]: ComputePipelineCore;\n\n  constructor(\n    private readonly _core: ComputePipelineCore,\n    private readonly _priors: TgpuComputePipelinePriors,\n  ) {\n    this[$internal] = {\n      get rawPipeline() {\n        return _core.unwrap().pipeline;\n      },\n      get priors() {\n        return _priors;\n      },\n    };\n    this[$getNameForward] = _core;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    return ctx.resolve(this._core);\n  }\n\n  toString(): string {\n    return `computePipeline:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  get rawPipeline(): GPUComputePipeline {\n    return this._core.unwrap().pipeline;\n  }\n\n  with(\n    bindGroupLayout: TgpuBindGroupLayout,\n    bindGroup: TgpuBindGroup,\n  ): TgpuComputePipeline {\n    return new TgpuComputePipelineImpl(this._core, {\n      ...this._priors,\n      bindGroupLayoutMap: new Map([\n        ...(this._priors.bindGroupLayoutMap ?? []),\n        [bindGroupLayout, bindGroup],\n      ]),\n    });\n  }\n\n  withPerformanceCallback(\n    callback: (start: bigint, end: bigint) => void | Promise<void>,\n  ): this {\n    const newPriors = createWithPerformanceCallback(\n      this._priors,\n      callback,\n      this._core.branch,\n    );\n    return new TgpuComputePipelineImpl(this._core, newPriors) as this;\n  }\n\n  withTimestampWrites(options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  }): this {\n    const newPriors = createWithTimestampWrites(\n      this._priors,\n      options,\n      this._core.branch,\n    );\n    return new TgpuComputePipelineImpl(this._core, newPriors) as this;\n  }\n\n  dispatchWorkgroups(\n    x: number,\n    y?: number | undefined,\n    z?: number | undefined,\n  ): void {\n    const memo = this._core.unwrap();\n    const { branch } = this._core;\n\n    const passDescriptor: GPUComputePassDescriptor = {\n      label: getName(this._core) ?? '<unnamed>',\n      ...setupTimestampWrites(this._priors, branch),\n    };\n\n    const pass = branch.commandEncoder.beginComputePass(passDescriptor);\n\n    pass.setPipeline(memo.pipeline);\n\n    const missingBindGroups = new Set(memo.usedBindGroupLayouts);\n\n    memo.usedBindGroupLayouts.forEach((layout, idx) => {\n      if (memo.catchall && idx === memo.catchall[0]) {\n        // Catch-all\n        pass.setBindGroup(idx, branch.unwrap(memo.catchall[1]));\n        missingBindGroups.delete(layout);\n      } else {\n        const bindGroup = this._priors.bindGroupLayoutMap?.get(layout);\n        if (bindGroup !== undefined) {\n          missingBindGroups.delete(layout);\n          pass.setBindGroup(idx, branch.unwrap(bindGroup));\n        }\n      }\n    });\n\n    if (missingBindGroups.size > 0) {\n      throw new MissingBindGroupsError(missingBindGroups);\n    }\n\n    pass.dispatchWorkgroups(x, y, z);\n    pass.end();\n\n    if (this._priors.performanceCallback) {\n      triggerPerformanceCallback({\n        root: branch,\n        priors: this._priors,\n      });\n    }\n  }\n\n  $name(label: string): this {\n    setName(this._core, label);\n    return this;\n  }\n}\n\nclass ComputePipelineCore implements SelfResolvable {\n  private _memo: Memo | undefined;\n\n  constructor(\n    public readonly branch: ExperimentalTgpuRoot,\n    private readonly _slotBindings: [TgpuSlot<unknown>, unknown][],\n    private readonly _entryFn: TgpuComputeFn,\n  ) {}\n\n  '~resolve'(ctx: ResolutionCtx) {\n    return ctx.withSlots(this._slotBindings, () => {\n      ctx.resolve(this._entryFn);\n      return '';\n    });\n  }\n\n  toString() {\n    return 'computePipelineCore';\n  }\n\n  public unwrap(): Memo {\n    if (this._memo === undefined) {\n      const device = this.branch.device;\n\n      // Resolving code\n      let resolutionResult: ResolutionResult;\n\n      let resolveMeasure: PerformanceMeasure | undefined;\n      if (PERF?.enabled) {\n        const resolveStart = performance.mark('typegpu:resolution:start');\n        resolutionResult = resolve(this, {\n          names: this.branch.nameRegistry,\n        });\n        resolveMeasure = performance.measure('typegpu:resolution', {\n          start: resolveStart.name,\n        });\n      } else {\n        resolutionResult = resolve(this, {\n          names: this.branch.nameRegistry,\n        });\n      }\n\n      const { code, usedBindGroupLayouts, catchall } = resolutionResult;\n\n      if (catchall !== undefined) {\n        usedBindGroupLayouts[catchall[0]]?.$name(\n          `${getName(this) ?? '<unnamed>'} - Automatic Bind Group & Layout`,\n        );\n      }\n\n      const module = device.createShaderModule({\n        label: `${getName(this) ?? '<unnamed>'} - Shader`,\n        code,\n      });\n\n      this._memo = {\n        pipeline: device.createComputePipeline({\n          label: getName(this) ?? '<unnamed>',\n          layout: device.createPipelineLayout({\n            label: `${getName(this) ?? '<unnamed>'} - Pipeline Layout`,\n            bindGroupLayouts: usedBindGroupLayouts.map((l) =>\n              this.branch.unwrap(l)\n            ),\n          }),\n          compute: { module },\n        }),\n        usedBindGroupLayouts,\n        catchall,\n      };\n\n      if (PERF?.enabled) {\n        (async () => {\n          const start = performance.mark('typegpu:compile-start');\n          await device.queue.onSubmittedWorkDone();\n          const compileMeasure = performance.measure('typegpu:compiled', {\n            start: start.name,\n          });\n\n          PERF?.record('resolution', {\n            resolveDuration: resolveMeasure?.duration,\n            compileDuration: compileMeasure.duration,\n            wgslSize: code.length,\n          });\n        })();\n      }\n    }\n\n    return this._memo;\n  }\n}\n","import { alignmentOf, customAlignmentOf } from '../../data/alignmentOf.ts';\nimport type { Disarray } from '../../data/dataTypes.ts';\nimport {\n  getCustomLocation,\n  isLooseDecorated,\n  isUnstruct,\n} from '../../data/dataTypes.ts';\nimport { sizeOf } from '../../data/sizeOf.ts';\nimport type { BaseData, WgslArray } from '../../data/wgslTypes.ts';\nimport { isDecorated, isWgslStruct } from '../../data/wgslTypes.ts';\nimport { roundUp } from '../../mathUtils.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { setName } from '../../shared/meta.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport {\n  kindToDefaultFormatMap,\n  type TgpuVertexAttrib,\n  type VertexFormat,\n  vertexFormats,\n} from '../../shared/vertexFormat.ts';\nimport type {\n  ArrayToContainedAttribs,\n  DataToContainedAttribs,\n} from './vertexAttribute.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport interface TgpuVertexLayout<\n  TData extends WgslArray | Disarray = WgslArray | Disarray,\n> extends TgpuNamable {\n  readonly [$internal]: true;\n  readonly resourceType: 'vertex-layout';\n  readonly stride: number;\n  readonly stepMode: 'vertex' | 'instance';\n  readonly attrib: ArrayToContainedAttribs<TData>;\n  readonly vertexLayout: GPUVertexBufferLayout;\n  schemaForCount(n: number): TData;\n}\n\nexport interface INTERNAL_TgpuVertexAttrib {\n  readonly _layout: TgpuVertexLayout;\n}\n\nexport function vertexLayout<TData extends WgslArray | Disarray>(\n  schemaForCount: (count: number) => TData,\n  stepMode: 'vertex' | 'instance' = 'vertex',\n): TgpuVertexLayout<TData> {\n  return new TgpuVertexLayoutImpl(schemaForCount, stepMode);\n}\n\nexport function isVertexLayout<T extends TgpuVertexLayout>(\n  value: unknown | T,\n): value is T {\n  return (value as T)?.resourceType === 'vertex-layout';\n}\n\n// --------------\n// Implementation\n// --------------\n\nconst defaultAttribEntry = Symbol('defaultAttribEntry');\n\nfunction dataToContainedAttribs<\n  TLayoutData extends WgslArray | Disarray,\n  TData extends BaseData,\n>(\n  layout: TgpuVertexLayout<TLayoutData>,\n  data: TData,\n  offset: number,\n  customLocationMap: Record<string | symbol, number>,\n  key?: string,\n): DataToContainedAttribs<TData> {\n  if (isDecorated(data) || isLooseDecorated(data)) {\n    const customLocation = getCustomLocation(data);\n    if (customLocation !== undefined) {\n      customLocationMap[key ?? defaultAttribEntry] = customLocation;\n    }\n\n    return dataToContainedAttribs(\n      layout,\n      data.inner,\n      roundUp(offset, customAlignmentOf(data)),\n      customLocationMap,\n    );\n  }\n\n  if (isWgslStruct(data)) {\n    let memberOffset = offset;\n\n    return Object.fromEntries(\n      Object.entries(data.propTypes).map(([key, value]) => {\n        memberOffset = roundUp(memberOffset, alignmentOf(value));\n        const attrib = [\n          key,\n          dataToContainedAttribs(\n            layout,\n            value,\n            memberOffset,\n            customLocationMap,\n            key,\n          ),\n        ];\n        memberOffset += sizeOf(value);\n        return attrib;\n      }),\n    ) as DataToContainedAttribs<TData>;\n  }\n\n  if (isUnstruct(data)) {\n    let memberOffset = offset;\n\n    return Object.fromEntries(\n      Object.entries(data.propTypes).map(([key, value]) => {\n        memberOffset = roundUp(memberOffset, customAlignmentOf(value));\n        const attrib = [\n          key,\n          dataToContainedAttribs(\n            layout,\n            value,\n            memberOffset,\n            customLocationMap,\n            key,\n          ),\n        ];\n        memberOffset += sizeOf(value);\n        return attrib;\n      }),\n    ) as DataToContainedAttribs<TData>;\n  }\n\n  if ('type' in data && typeof data.type === 'string') {\n    if (vertexFormats.includes(data.type as VertexFormat)) {\n      return {\n        _layout: layout, // hidden property, used to determine which buffers to apply when executing the pipeline\n        format: data.type as VertexFormat,\n        offset,\n        // biome-ignore lint/suspicious/noExplicitAny: <too many type shenanigans>\n      } satisfies TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib as any;\n    }\n\n    const format = (kindToDefaultFormatMap as Record<string, VertexFormat>)[\n      data.type\n    ];\n\n    if (format) {\n      return {\n        _layout: layout, // hidden property, used to determine which buffers to apply when executing the pipeline\n        format,\n        offset,\n        // biome-ignore lint/suspicious/noExplicitAny: <too many type shenanigans>\n      } satisfies TgpuVertexAttrib & INTERNAL_TgpuVertexAttrib as any;\n    }\n  }\n\n  throw new Error(`Unsupported data used in vertex layout: ${String(data)}`);\n}\n\nclass TgpuVertexLayoutImpl<TData extends WgslArray | Disarray>\n  implements TgpuVertexLayout<TData> {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'vertex-layout';\n  public readonly stride: number;\n  public readonly attrib: ArrayToContainedAttribs<TData>;\n  private readonly _customLocationMap = {} as Record<string | symbol, number>;\n\n  constructor(\n    public readonly schemaForCount: (count: number) => TData,\n    public readonly stepMode: 'vertex' | 'instance',\n  ) {\n    // `0` signals that the data-type is runtime-sized, and should not be used to create buffers.\n    const arraySchema = schemaForCount(0);\n\n    this.stride = roundUp(\n      sizeOf(arraySchema.elementType),\n      alignmentOf(arraySchema),\n    );\n    this.attrib = dataToContainedAttribs(\n      this,\n      arraySchema.elementType,\n      0,\n      this._customLocationMap,\n    );\n  }\n\n  get vertexLayout(): GPUVertexBufferLayout {\n    // If defaultAttribEntry is in the custom location map,\n    // it means that the vertex layout is based on a single attribute\n    if (this._customLocationMap[defaultAttribEntry] !== undefined) {\n      if (\n        typeof this.attrib.format !== 'string' ||\n        typeof this.attrib.offset !== 'number'\n      ) {\n        throw new Error(\n          'Single attribute vertex layouts must have a format and offset.',\n        );\n      }\n\n      return {\n        arrayStride: this.stride,\n        stepMode: this.stepMode,\n        attributes: [\n          {\n            format: this.attrib.format,\n            offset: this.attrib.offset,\n            shaderLocation: this._customLocationMap[defaultAttribEntry],\n          },\n        ],\n      };\n    }\n\n    // check if all attributes have custom locations\n    const allAttributesHaveCustomLocations = Object.keys(this.attrib).every(\n      (key) => this._customLocationMap[key] !== undefined,\n    );\n\n    if (!allAttributesHaveCustomLocations) {\n      throw new Error(\n        'All attributes must have custom locations in order to unwrap a vertex layout.',\n      );\n    }\n\n    return {\n      arrayStride: this.stride,\n      stepMode: this.stepMode,\n      attributes: [\n        ...Object.entries(this.attrib).map(([key, attrib]) => ({\n          format: attrib.format,\n          offset: attrib.offset,\n          shaderLocation: this._customLocationMap[key],\n        })),\n      ] as GPUVertexAttribute[],\n    };\n  }\n\n  $name(label: string): this {\n    setName(this, label);\n    return this;\n  }\n}\n","import { isData } from '../../data/dataTypes.ts';\nimport type { FragmentOutConstrained } from '../function/tgpuFragmentFn.ts';\nimport type {\n  AnyFragmentColorAttachment,\n  ColorAttachment,\n} from './renderPipeline.ts';\n\nfunction isColorAttachment(\n  value: unknown | ColorAttachment,\n): value is ColorAttachment {\n  return typeof (value as ColorAttachment)?.loadOp === 'string';\n}\n\nexport function connectAttachmentToShader(\n  shaderOutputLayout: FragmentOutConstrained,\n  attachment: AnyFragmentColorAttachment,\n): ColorAttachment[] {\n  if (isData(shaderOutputLayout)) {\n    if (!isColorAttachment(attachment)) {\n      throw new Error('Expected a single color attachment, not a record.');\n    }\n\n    return [attachment];\n  }\n\n  const result: ColorAttachment[] = [];\n  for (const key of Object.keys(shaderOutputLayout)) {\n    const matching = (attachment as Record<string, ColorAttachment>)[key];\n\n    if (!matching) {\n      throw new Error(\n        `A color attachment by the name of '${key}' was not provided to the shader.`,\n      );\n    }\n\n    result.push(matching);\n  }\n\n  return result;\n}\n","import { isVoid } from '../../data/wgslTypes.ts';\nimport { isData } from '../../data/dataTypes.ts';\nimport type { FragmentOutConstrained } from '../function/tgpuFragmentFn.ts';\nimport type { AnyFragmentTargets } from './renderPipeline.ts';\n\nfunction isColorTargetState(\n  value: unknown | GPUColorTargetState,\n): value is GPUColorTargetState {\n  return typeof (value as GPUColorTargetState)?.format === 'string';\n}\n\nexport function connectTargetsToShader(\n  shaderOutputLayout: FragmentOutConstrained,\n  targets: AnyFragmentTargets,\n): GPUColorTargetState[] {\n  if (isData(shaderOutputLayout)) {\n    if (isVoid(shaderOutputLayout)) {\n      return [];\n    }\n\n    if (!isColorTargetState(targets)) {\n      throw new Error(\n        'Expected a single color target configuration, not a record.',\n      );\n    }\n\n    return [targets];\n  }\n\n  const result: GPUColorTargetState[] = [];\n  for (const key of Object.keys(shaderOutputLayout)) {\n    const matchingTarget = (targets as Record<string, GPUColorTargetState>)[\n      key\n    ];\n\n    if (!matchingTarget) {\n      throw new Error(\n        `A color target by the name of '${key}' was not provided to the shader.`,\n      );\n    }\n\n    result.push(matchingTarget);\n  }\n\n  return result;\n}\n","import type {\n  IndexFlag,\n  TgpuBuffer,\n  VertexFlag,\n} from '../../core/buffer/buffer.ts';\n\nimport type { TgpuQuerySet } from '../../core/querySet/querySet.ts';\nimport { isBuiltin } from '../../data/attributes.ts';\nimport { type Disarray, getCustomLocation } from '../../data/dataTypes.ts';\nimport {\n  type AnyWgslData,\n  isWgslData,\n  type U16,\n  type U32,\n  type WgslArray,\n} from '../../data/wgslTypes.ts';\nimport {\n  MissingBindGroupsError,\n  MissingVertexBuffersError,\n} from '../../errors.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport { type ResolutionResult, resolve } from '../../resolutionCtx.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { AnyVertexAttribs } from '../../shared/vertexFormat.ts';\nimport {\n  isBindGroupLayout,\n  type TgpuBindGroup,\n  type TgpuBindGroupLayout,\n  type TgpuLayoutEntry,\n} from '../../tgpuBindGroupLayout.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { IOData, IOLayout, IORecord } from '../function/fnTypes.ts';\nimport type { TgpuFragmentFn } from '../function/tgpuFragmentFn.ts';\nimport type { TgpuVertexFn } from '../function/tgpuVertexFn.ts';\nimport type { ExperimentalTgpuRoot } from '../root/rootTypes.ts';\nimport type { TgpuSlot } from '../slot/slotTypes.ts';\nimport { isTexture, type TgpuTexture } from '../texture/texture.ts';\nimport type { Render } from '../texture/usageExtension.ts';\nimport { connectAttributesToShader } from '../vertexLayout/connectAttributesToShader.ts';\nimport {\n  isVertexLayout,\n  type TgpuVertexLayout,\n} from '../vertexLayout/vertexLayout.ts';\nimport { connectAttachmentToShader } from './connectAttachmentToShader.ts';\nimport { connectTargetsToShader } from './connectTargetsToShader.ts';\nimport { isGPUBuffer } from '../../types.ts';\nimport { sizeOf } from '../../data/index.ts';\nimport {\n  createWithPerformanceCallback,\n  createWithTimestampWrites,\n  setupTimestampWrites,\n  type Timeable,\n  type TimestampWritesPriors,\n  triggerPerformanceCallback,\n} from './timeable.ts';\nimport { PERF } from '../../shared/meta.ts';\n\ninterface RenderPipelineInternals {\n  readonly core: RenderPipelineCore;\n  readonly priors: TgpuRenderPipelinePriors & TimestampWritesPriors;\n}\n\n// ----------\n// Public API\n// ----------\n\nexport interface HasIndexBuffer {\n  readonly hasIndexBuffer: true;\n\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): void;\n}\n\nexport interface TgpuRenderPipeline<Output extends IOLayout = IOLayout>\n  extends TgpuNamable, SelfResolvable, Timeable {\n  readonly [$internal]: RenderPipelineInternals;\n  readonly resourceType: 'render-pipeline';\n  readonly hasIndexBuffer: boolean;\n\n  with<TData extends WgslArray | Disarray>(\n    vertexLayout: TgpuVertexLayout<TData>,\n    buffer: TgpuBuffer<TData> & VertexFlag,\n  ): this;\n  with<Entries extends Record<string, TgpuLayoutEntry | null>>(\n    bindGroupLayout: TgpuBindGroupLayout<Entries>,\n    bindGroup: TgpuBindGroup<Entries>,\n  ): this;\n\n  withColorAttachment(\n    attachment: FragmentOutToColorAttachment<Output>,\n  ): this;\n\n  withDepthStencilAttachment(\n    attachment: DepthStencilAttachment,\n  ): this;\n\n  withIndexBuffer(\n    buffer: TgpuBuffer<AnyWgslData> & IndexFlag,\n    offsetElements?: number,\n    sizeElements?: number,\n  ): this & HasIndexBuffer;\n  withIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offsetBytes?: number,\n    sizeBytes?: number,\n  ): this & HasIndexBuffer;\n\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): void;\n}\n\nexport type FragmentOutToTargets<T extends IOLayout> = T extends IOData\n  ? GPUColorTargetState\n  : T extends Record<string, unknown>\n    ? { [Key in keyof T]: GPUColorTargetState }\n  : T extends { type: 'void' } ? Record<string, never>\n  : never;\n\nexport type FragmentOutToColorAttachment<T extends IOLayout> = T extends IOData\n  ? ColorAttachment\n  : T extends Record<string, unknown> ? { [Key in keyof T]: ColorAttachment }\n  : never;\n\nexport type AnyFragmentTargets =\n  | GPUColorTargetState\n  | Record<string, GPUColorTargetState>;\n\nexport interface ColorAttachment {\n  /**\n   * A {@link GPUTextureView} describing the texture subresource that will be output to for this\n   * color attachment.\n   */\n  view: (TgpuTexture & Render) | GPUTextureView;\n  /**\n   * Indicates the depth slice index of {@link GPUTextureViewDimension#\"3d\"} {@link GPURenderPassColorAttachment#view}\n   * that will be output to for this color attachment.\n   */\n  depthSlice?: GPUIntegerCoordinate;\n  /**\n   * A {@link GPUTextureView} describing the texture subresource that will receive the resolved\n   * output for this color attachment if {@link GPURenderPassColorAttachment#view} is\n   * multisampled.\n   */\n  resolveTarget?: GPUTextureView;\n  /**\n   * Indicates the value to clear {@link GPURenderPassColorAttachment#view} to prior to executing the\n   * render pass. If not map/exist|provided, defaults to `{r: 0, g: 0, b: 0, a: 0}`. Ignored\n   * if {@link GPURenderPassColorAttachment#loadOp} is not {@link GPULoadOp#\"clear\"}.\n   * The components of {@link GPURenderPassColorAttachment#clearValue} are all double values.\n   * They are converted to a texel value of texture format matching the render attachment.\n   * If conversion fails, a validation error is generated.\n   */\n  clearValue?: GPUColor;\n  /**\n   * Indicates the load operation to perform on {@link GPURenderPassColorAttachment#view} prior to\n   * executing the render pass.\n   * Note: It is recommended to prefer clearing; see {@link GPULoadOp#\"clear\"} for details.\n   */\n  loadOp: GPULoadOp;\n  /**\n   * The store operation to perform on {@link GPURenderPassColorAttachment#view}\n   * after executing the render pass.\n   */\n  storeOp: GPUStoreOp;\n}\n\nexport interface DepthStencilAttachment {\n  /**\n   * A {@link GPUTextureView} | ({@link TgpuTexture} & {@link Render}) describing the texture subresource that will be output to\n   * and read from for this depth/stencil attachment.\n   */\n  view: (TgpuTexture & Render) | GPUTextureView;\n  /**\n   * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s depth component\n   * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#depthLoadOp}\n   * is not {@link GPULoadOp#\"clear\"}. Must be between 0.0 and 1.0, inclusive (unless unrestricted depth is enabled).\n   */\n  depthClearValue?: number;\n  /**\n   * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * depth component prior to executing the render pass.\n   * Note: It is recommended to prefer clearing; see {@link GPULoadOp#\"clear\"} for details.\n   */\n  depthLoadOp?: GPULoadOp;\n  /**\n   * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * depth component after executing the render pass.\n   */\n  depthStoreOp?: GPUStoreOp;\n  /**\n   * Indicates that the depth component of {@link GPURenderPassDepthStencilAttachment#view}\n   * is read only.\n   */\n  depthReadOnly?: boolean;\n  /**\n   * Indicates the value to clear {@link GPURenderPassDepthStencilAttachment#view}'s stencil component\n   * to prior to executing the render pass. Ignored if {@link GPURenderPassDepthStencilAttachment#stencilLoadOp}\n   * is not {@link GPULoadOp#\"clear\"}.\n   * The value will be converted to the type of the stencil aspect of `view` by taking the same\n   * number of LSBs as the number of bits in the stencil aspect of one texel block|texel of `view`.\n   */\n  stencilClearValue?: GPUStencilValue;\n  /**\n   * Indicates the load operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * stencil component prior to executing the render pass.\n   * Note: It is recommended to prefer clearing; see {@link GPULoadOp#\"clear\"} for details.\n   */\n  stencilLoadOp?: GPULoadOp;\n  /**\n   * The store operation to perform on {@link GPURenderPassDepthStencilAttachment#view}'s\n   * stencil component after executing the render pass.\n   */\n  stencilStoreOp?: GPUStoreOp;\n  /**\n   * Indicates that the stencil component of {@link GPURenderPassDepthStencilAttachment#view}\n   * is read only.\n   */\n  stencilReadOnly?: boolean;\n}\n\nexport type AnyFragmentColorAttachment =\n  | ColorAttachment\n  | Record<string, ColorAttachment>;\n\nexport type RenderPipelineCoreOptions = {\n  branch: ExperimentalTgpuRoot;\n  slotBindings: [TgpuSlot<unknown>, unknown][];\n  vertexAttribs: AnyVertexAttribs;\n  vertexFn: TgpuVertexFn;\n  fragmentFn: TgpuFragmentFn;\n  primitiveState:\n    | GPUPrimitiveState\n    | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {\n      stripIndexFormat?: U32 | U16;\n    }\n    | undefined;\n  depthStencilState: GPUDepthStencilState | undefined;\n  targets: AnyFragmentTargets;\n  multisampleState: GPUMultisampleState | undefined;\n};\n\nexport function INTERNAL_createRenderPipeline(\n  options: RenderPipelineCoreOptions,\n) {\n  return new TgpuRenderPipelineImpl(new RenderPipelineCore(options), {});\n}\n\nexport function isRenderPipeline(value: unknown): value is TgpuRenderPipeline {\n  const maybe = value as TgpuRenderPipeline | undefined;\n  return maybe?.resourceType === 'render-pipeline' && !!maybe[$internal];\n}\n\n// --------------\n// Implementation\n// --------------\n\ntype TgpuRenderPipelinePriors = {\n  readonly vertexLayoutMap?:\n    | Map<TgpuVertexLayout, TgpuBuffer<AnyWgslData> & VertexFlag>\n    | undefined;\n  readonly bindGroupLayoutMap?:\n    | Map<TgpuBindGroupLayout, TgpuBindGroup>\n    | undefined;\n  readonly colorAttachment?: AnyFragmentColorAttachment | undefined;\n  readonly depthStencilAttachment?: DepthStencilAttachment | undefined;\n  readonly indexBuffer?:\n    | {\n      buffer: TgpuBuffer<AnyWgslData> & IndexFlag | GPUBuffer;\n      indexFormat: GPUIndexFormat;\n      offsetBytes?: number | undefined;\n      sizeBytes?: number | undefined;\n    }\n    | undefined;\n} & TimestampWritesPriors;\n\ntype Memo = {\n  pipeline: GPURenderPipeline;\n  usedBindGroupLayouts: TgpuBindGroupLayout[];\n  catchall: [number, TgpuBindGroup] | undefined;\n};\n\nclass TgpuRenderPipelineImpl implements TgpuRenderPipeline {\n  public readonly [$internal]: RenderPipelineInternals;\n  public readonly resourceType = 'render-pipeline';\n  [$getNameForward]: RenderPipelineCore;\n  public readonly hasIndexBuffer: boolean = false;\n\n  constructor(core: RenderPipelineCore, priors: TgpuRenderPipelinePriors) {\n    this[$internal] = {\n      core,\n      priors,\n    };\n    this[$getNameForward] = core;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    return ctx.resolve(this[$internal].core);\n  }\n\n  toString(): string {\n    return `renderPipeline:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  $name(label: string): this {\n    setName(this[$internal].core, label);\n    return this;\n  }\n\n  with<TData extends WgslArray<AnyWgslData>>(\n    vertexLayout: TgpuVertexLayout<TData>,\n    buffer: TgpuBuffer<TData> & VertexFlag,\n  ): this;\n  with(\n    bindGroupLayout: TgpuBindGroupLayout,\n    bindGroup: TgpuBindGroup,\n  ): this;\n  with(\n    definition: TgpuVertexLayout | TgpuBindGroupLayout,\n    resource: (TgpuBuffer<AnyWgslData> & VertexFlag) | TgpuBindGroup,\n  ): this {\n    const internals = this[$internal];\n\n    if (isBindGroupLayout(definition)) {\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        bindGroupLayoutMap: new Map([\n          ...(internals.priors.bindGroupLayoutMap ?? []),\n          [definition, resource as TgpuBindGroup],\n        ]),\n      }) as this;\n    }\n\n    if (isVertexLayout(definition)) {\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        vertexLayoutMap: new Map([\n          ...(internals.priors.vertexLayoutMap ?? []),\n          [definition, resource as TgpuBuffer<AnyWgslData> & VertexFlag],\n        ]),\n      }) as this;\n    }\n\n    throw new Error('Unsupported value passed into .with()');\n  }\n\n  withPerformanceCallback(\n    callback: (start: bigint, end: bigint) => void | Promise<void>,\n  ): this {\n    const internals = this[$internal];\n    const newPriors = createWithPerformanceCallback(\n      internals.priors,\n      callback,\n      internals.core.options.branch,\n    );\n    return new TgpuRenderPipelineImpl(internals.core, newPriors) as this;\n  }\n\n  withTimestampWrites(options: {\n    querySet: TgpuQuerySet<'timestamp'> | GPUQuerySet;\n    beginningOfPassWriteIndex?: number;\n    endOfPassWriteIndex?: number;\n  }): this {\n    const internals = this[$internal];\n    const newPriors = createWithTimestampWrites(\n      internals.priors,\n      options,\n      internals.core.options.branch,\n    );\n    return new TgpuRenderPipelineImpl(internals.core, newPriors) as this;\n  }\n\n  withColorAttachment(\n    attachment: AnyFragmentColorAttachment,\n  ): this {\n    const internals = this[$internal];\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      colorAttachment: attachment,\n    }) as this;\n  }\n\n  withDepthStencilAttachment(\n    attachment: DepthStencilAttachment,\n  ): this {\n    const internals = this[$internal];\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      depthStencilAttachment: attachment,\n    }) as this;\n  }\n\n  withIndexBuffer(\n    buffer: TgpuBuffer<AnyWgslData> & IndexFlag,\n    offsetElements?: number,\n    sizeElements?: number,\n  ): this & HasIndexBuffer;\n  withIndexBuffer(\n    buffer: GPUBuffer,\n    indexFormat: GPUIndexFormat,\n    offsetBytes?: number,\n    sizeBytes?: number,\n  ): this & HasIndexBuffer;\n  withIndexBuffer(\n    buffer: TgpuBuffer<AnyWgslData> & IndexFlag | GPUBuffer,\n    indexFormatOrOffset?: GPUIndexFormat | number,\n    offsetElementsOrSizeBytes?: number,\n    sizeElementsOrUndefined?: number,\n  ): this & HasIndexBuffer {\n    const internals = this[$internal];\n\n    if (isGPUBuffer(buffer)) {\n      if (typeof indexFormatOrOffset !== 'string') {\n        throw new Error(\n          'If a GPUBuffer is passed, indexFormat must be provided.',\n        );\n      }\n\n      return new TgpuRenderPipelineImpl(internals.core, {\n        ...internals.priors,\n        indexBuffer: {\n          buffer,\n          indexFormat: indexFormatOrOffset,\n          offsetBytes: offsetElementsOrSizeBytes,\n          sizeBytes: sizeElementsOrUndefined,\n        },\n      }) as unknown as this & HasIndexBuffer;\n    }\n\n    const dataTypeToIndexFormat = {\n      'u32': 'uint32',\n      'u16': 'uint16',\n    } as const;\n\n    const elementType = (buffer.dataType as WgslArray<U32 | U16>).elementType;\n\n    return new TgpuRenderPipelineImpl(internals.core, {\n      ...internals.priors,\n      indexBuffer: {\n        buffer,\n        indexFormat: dataTypeToIndexFormat[elementType.type],\n        offsetBytes: indexFormatOrOffset !== undefined\n          ? (indexFormatOrOffset as number) * sizeOf(elementType)\n          : undefined,\n        sizeBytes: sizeElementsOrUndefined !== undefined\n          ? sizeElementsOrUndefined * sizeOf(elementType)\n          : undefined,\n      },\n    }) as unknown as this & HasIndexBuffer;\n  }\n\n  private setupRenderPass(): GPURenderPassEncoder {\n    const internals = this[$internal];\n    const memo = internals.core.unwrap();\n    const { branch, fragmentFn } = internals.core.options;\n\n    const colorAttachments = connectAttachmentToShader(\n      fragmentFn.shell.out,\n      internals.priors.colorAttachment ?? {},\n    ).map((attachment) => {\n      if (isTexture(attachment.view)) {\n        return {\n          ...attachment,\n          view: branch.unwrap(attachment.view).createView(),\n        };\n      }\n\n      return attachment;\n    }) as GPURenderPassColorAttachment[];\n\n    const renderPassDescriptor: GPURenderPassDescriptor = {\n      label: getName(internals.core) ?? '<unnamed>',\n      colorAttachments,\n      ...setupTimestampWrites(\n        internals.priors,\n        branch,\n      ),\n    };\n\n    if (internals.priors.depthStencilAttachment !== undefined) {\n      const attachment = internals.priors.depthStencilAttachment;\n      if (isTexture(attachment.view)) {\n        renderPassDescriptor.depthStencilAttachment = {\n          ...attachment,\n          view: branch.unwrap(attachment.view).createView(),\n        };\n      } else {\n        renderPassDescriptor.depthStencilAttachment =\n          attachment as GPURenderPassDepthStencilAttachment;\n      }\n    }\n\n    const pass = branch.commandEncoder.beginRenderPass(renderPassDescriptor);\n\n    pass.setPipeline(memo.pipeline);\n\n    const missingBindGroups = new Set(memo.usedBindGroupLayouts);\n\n    memo.usedBindGroupLayouts.forEach((layout, idx) => {\n      if (memo.catchall && idx === memo.catchall[0]) {\n        // Catch-all\n        pass.setBindGroup(idx, branch.unwrap(memo.catchall[1]));\n        missingBindGroups.delete(layout);\n      } else {\n        const bindGroup = internals.priors.bindGroupLayoutMap?.get(layout);\n        if (bindGroup !== undefined) {\n          missingBindGroups.delete(layout);\n          pass.setBindGroup(idx, branch.unwrap(bindGroup));\n        }\n      }\n    });\n\n    const missingVertexLayouts = new Set(internals.core.usedVertexLayouts);\n\n    const usedVertexLayouts = internals.core.usedVertexLayouts;\n    usedVertexLayouts.forEach((vertexLayout, idx) => {\n      const buffer = internals.priors.vertexLayoutMap?.get(vertexLayout);\n      if (buffer) {\n        missingVertexLayouts.delete(vertexLayout);\n        pass.setVertexBuffer(idx, branch.unwrap(buffer));\n      }\n    });\n\n    if (missingBindGroups.size > 0) {\n      throw new MissingBindGroupsError(missingBindGroups);\n    }\n\n    if (missingVertexLayouts.size > 0) {\n      throw new MissingVertexBuffersError(missingVertexLayouts);\n    }\n\n    return pass;\n  }\n\n  draw(\n    vertexCount: number,\n    instanceCount?: number,\n    firstVertex?: number,\n    firstInstance?: number,\n  ): void {\n    const internals = this[$internal];\n    const pass = this.setupRenderPass();\n    const { branch } = internals.core.options;\n\n    pass.draw(vertexCount, instanceCount, firstVertex, firstInstance);\n\n    pass.end();\n\n    internals.priors.performanceCallback\n      ? triggerPerformanceCallback({\n        root: branch,\n        priors: internals.priors,\n      })\n      : branch.flush();\n  }\n\n  drawIndexed(\n    indexCount: number,\n    instanceCount?: number,\n    firstIndex?: number,\n    baseVertex?: number,\n    firstInstance?: number,\n  ): void {\n    const internals = this[$internal];\n\n    if (!internals.priors.indexBuffer) {\n      throw new Error('No index buffer set for this render pipeline.');\n    }\n\n    const { buffer, indexFormat, offsetBytes, sizeBytes } =\n      internals.priors.indexBuffer;\n\n    const pass = this.setupRenderPass();\n    const { branch } = internals.core.options;\n\n    if (isGPUBuffer(buffer)) {\n      pass.setIndexBuffer(buffer, indexFormat, offsetBytes, sizeBytes);\n    } else {\n      pass.setIndexBuffer(\n        branch.unwrap(buffer),\n        indexFormat,\n        offsetBytes,\n        sizeBytes,\n      );\n    }\n\n    pass.drawIndexed(\n      indexCount,\n      instanceCount,\n      firstIndex,\n      baseVertex,\n      firstInstance,\n    );\n\n    pass.end();\n\n    internals.priors.performanceCallback\n      ? triggerPerformanceCallback({\n        root: branch,\n        priors: internals.priors,\n      })\n      : branch.flush();\n  }\n}\n\nclass RenderPipelineCore implements SelfResolvable {\n  public readonly usedVertexLayouts: TgpuVertexLayout[];\n\n  private _memo: Memo | undefined;\n  private readonly _vertexBufferLayouts: GPUVertexBufferLayout[];\n  private readonly _targets: GPUColorTargetState[];\n\n  constructor(public readonly options: RenderPipelineCoreOptions) {\n    const connectedAttribs = connectAttributesToShader(\n      options.vertexFn.shell.in ?? {},\n      options.vertexAttribs,\n    );\n\n    this._vertexBufferLayouts = connectedAttribs.bufferDefinitions;\n    this.usedVertexLayouts = connectedAttribs.usedVertexLayouts;\n\n    this._targets = connectTargetsToShader(\n      options.fragmentFn.shell.out,\n      options.targets,\n    );\n  }\n\n  '~resolve'(ctx: ResolutionCtx) {\n    const {\n      vertexFn,\n      fragmentFn,\n      slotBindings,\n    } = this.options;\n\n    const locations = matchUpVaryingLocations(\n      vertexFn.shell.out,\n      fragmentFn.shell.in,\n      getName(vertexFn) ?? '<unnamed>',\n      getName(fragmentFn) ?? '<unnamed>',\n    );\n\n    return ctx.withVaryingLocations(\n      locations,\n      () =>\n        ctx.withSlots(slotBindings, () => {\n          ctx.resolve(vertexFn);\n          ctx.resolve(fragmentFn);\n          return '';\n        }),\n    );\n  }\n\n  toString() {\n    return 'renderPipelineCore';\n  }\n\n  public unwrap(): Memo {\n    if (this._memo === undefined) {\n      const {\n        branch,\n        primitiveState,\n        depthStencilState,\n        multisampleState,\n      } = this.options;\n      const device = branch.device;\n\n      // Resolving code\n      let resolutionResult: ResolutionResult;\n\n      let resolveMeasure: PerformanceMeasure | undefined;\n      if (PERF?.enabled) {\n        const resolveStart = performance.mark('typegpu:resolution:start');\n        resolutionResult = resolve(this, {\n          names: branch.nameRegistry,\n        });\n        resolveMeasure = performance.measure('typegpu:resolution', {\n          start: resolveStart.name,\n        });\n      } else {\n        resolutionResult = resolve(this, {\n          names: branch.nameRegistry,\n        });\n      }\n\n      const { code, usedBindGroupLayouts, catchall } = resolutionResult;\n\n      if (catchall !== undefined) {\n        usedBindGroupLayouts[catchall[0]]?.$name(\n          `${getName(this) ?? '<unnamed>'} - Automatic Bind Group & Layout`,\n        );\n      }\n\n      const module = device.createShaderModule({\n        label: `${getName(this) ?? '<unnamed>'} - Shader`,\n        code,\n      });\n\n      const descriptor: GPURenderPipelineDescriptor = {\n        layout: device.createPipelineLayout({\n          label: `${getName(this) ?? '<unnamed>'} - Pipeline Layout`,\n          bindGroupLayouts: usedBindGroupLayouts.map((l) => branch.unwrap(l)),\n        }),\n        vertex: {\n          module,\n          buffers: this._vertexBufferLayouts,\n        },\n        fragment: {\n          module,\n          targets: this._targets,\n        },\n      };\n\n      const label = getName(this);\n      if (label !== undefined) {\n        descriptor.label = label;\n      }\n\n      if (primitiveState) {\n        if (isWgslData(primitiveState.stripIndexFormat)) {\n          descriptor.primitive = {\n            ...primitiveState,\n            stripIndexFormat: {\n              'u32': 'uint32',\n              'u16': 'uint16',\n            }[primitiveState.stripIndexFormat.type] as GPUIndexFormat,\n          };\n        } else {\n          descriptor.primitive = primitiveState as GPUPrimitiveState;\n        }\n      }\n\n      if (depthStencilState) {\n        descriptor.depthStencil = depthStencilState;\n      }\n\n      if (multisampleState) {\n        descriptor.multisample = multisampleState;\n      }\n\n      this._memo = {\n        pipeline: device.createRenderPipeline(descriptor),\n        usedBindGroupLayouts,\n        catchall,\n      };\n\n      if (PERF?.enabled) {\n        (async () => {\n          const start = performance.mark('typegpu:compile-start');\n          await device.queue.onSubmittedWorkDone();\n          const compileMeasure = performance.measure('typegpu:compiled', {\n            start: start.name,\n          });\n\n          PERF?.record('resolution', {\n            resolveDuration: resolveMeasure?.duration,\n            compileDuration: compileMeasure.duration,\n            wgslSize: code.length,\n          });\n        })();\n      }\n    }\n\n    return this._memo;\n  }\n}\n\n/**\n * Assumes vertexOut and fragmentIn are matching when it comes to the keys, that is fragmentIn's keyset is a subset of vertexOut's\n * Logs a warning, when they don't match in terms of custom locations\n */\nexport function matchUpVaryingLocations(\n  vertexOut: IORecord,\n  fragmentIn: IORecord | undefined,\n  vertexFnName: string,\n  fragmentFnName: string,\n) {\n  const locations: Record<\n    string,\n    number\n  > = {};\n  const usedLocations = new Set<number>();\n\n  function saveLocation(key: string, location: number) {\n    locations[key] = location;\n    usedLocations.add(location);\n  }\n\n  // respect custom locations and pair up vertex and fragment varying with the same key\n  for (const [key, value] of Object.entries(vertexOut)) {\n    const customLocation = getCustomLocation(value);\n    if (customLocation !== undefined) {\n      saveLocation(key, customLocation);\n    }\n  }\n\n  for (const [key, value] of Object.entries(fragmentIn ?? {})) {\n    const customLocation = getCustomLocation(value);\n    if (customLocation === undefined) {\n      continue;\n    }\n\n    if (locations[key] === undefined) {\n      saveLocation(key, customLocation);\n    } else if (locations[key] !== customLocation) {\n      console.warn(\n        `Mismatched location between vertexFn (${vertexFnName}) output (${\n          locations[key]\n        }) and fragmentFn (${fragmentFnName}) input (${customLocation}) for the key \"${key}\", using the location set on vertex output.`,\n      );\n    }\n  }\n\n  // automatically assign remaining locations to the rest\n  let nextLocation = 0;\n  for (const key of Object.keys(vertexOut ?? {})) {\n    if (isBuiltin(vertexOut[key]) || locations[key] !== undefined) {\n      continue;\n    }\n\n    while (usedLocations.has(nextLocation)) {\n      nextLocation++;\n    }\n\n    saveLocation(key, nextLocation);\n  }\n\n  return locations;\n}\n","import type { BaseData } from '../../data/wgslTypes.ts';\nimport type { StorageFlag } from '../../extension.ts';\nimport { setName, type TgpuNamable } from '../../shared/meta.ts';\nimport type { Infer, InferGPU, InferPartial } from '../../shared/repr.ts';\nimport { $getNameForward, $internal } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport type { TgpuBuffer, UniformFlag } from './buffer.ts';\nimport type { TgpuBufferUsage } from './bufferUsage.ts';\n\n// ----------\n// Public API\n// ----------\n\ninterface TgpuBufferShorthandBase<TData extends BaseData> extends TgpuNamable {\n  readonly [$internal]: true;\n\n  // Accessible on the CPU\n  write(data: Infer<TData>): void;\n  writePartial(data: InferPartial<TData>): void;\n  read(): Promise<Infer<TData>>;\n  // ---\n}\n\nexport interface TgpuMutable<TData extends BaseData>\n  extends TgpuBufferShorthandBase<TData> {\n  readonly resourceType: 'mutable';\n  readonly buffer: TgpuBuffer<TData> & StorageFlag;\n\n  // Accessible on the GPU\n  value: InferGPU<TData>;\n  $: InferGPU<TData>;\n  // ---\n}\n\nexport interface TgpuReadonly<TData extends BaseData>\n  extends TgpuBufferShorthandBase<TData> {\n  readonly resourceType: 'readonly';\n  readonly buffer: TgpuBuffer<TData> & StorageFlag;\n\n  // Accessible on the GPU\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n  // ---\n}\n\nexport interface TgpuUniform<TData extends BaseData>\n  extends TgpuBufferShorthandBase<TData> {\n  readonly resourceType: 'uniform';\n  readonly buffer: TgpuBuffer<TData> & UniformFlag;\n\n  // Accessible on the GPU\n  readonly value: InferGPU<TData>;\n  readonly $: InferGPU<TData>;\n  // ---\n}\n\nexport type TgpuBufferShorthand<TData extends BaseData> =\n  | TgpuMutable<TData>\n  | TgpuReadonly<TData>\n  | TgpuUniform<TData>;\n\nexport function isBufferShorthand<TData extends BaseData>(\n  value: unknown | TgpuBufferShorthand<TData>,\n): value is TgpuBufferShorthand<TData> {\n  return value instanceof TgpuBufferShorthandImpl;\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuBufferShorthandImpl<\n  TType extends 'mutable' | 'readonly' | 'uniform',\n  TData extends BaseData,\n> implements SelfResolvable {\n  readonly [$internal] = true;\n  readonly [$getNameForward]: object;\n  readonly #usage: TgpuBufferUsage<TData, TType>;\n\n  constructor(\n    public readonly resourceType: TType,\n    public readonly buffer:\n      & TgpuBuffer<TData>\n      & (TType extends 'mutable' | 'readonly' ? StorageFlag : UniformFlag),\n  ) {\n    this[$getNameForward] = buffer;\n    // biome-ignore lint/suspicious/noExplicitAny: too complex a type\n    this.#usage = (this.buffer as any).as(this.resourceType);\n  }\n\n  $name(label: string): this {\n    setName(this[$getNameForward], label);\n    return this;\n  }\n\n  write(data: Infer<TData>): void {\n    this.buffer.write(data);\n  }\n\n  writePartial(data: InferPartial<TData>): void {\n    this.buffer.writePartial(data);\n  }\n\n  read(): Promise<Infer<TData>> {\n    return this.buffer.read();\n  }\n\n  get value(): InferGPU<TData> {\n    return this.#usage.value;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    return ctx.resolve(this.#usage);\n  }\n\n  get $(): InferGPU<TData> {\n    return this.value;\n  }\n}\n","import {\n  INTERNAL_createQuerySet,\n  isQuerySet,\n  type TgpuQuerySet,\n} from '../../core/querySet/querySet.ts';\nimport type { AnyComputeBuiltin, OmitBuiltins } from '../../builtin.ts';\nimport type { AnyData, Disarray } from '../../data/dataTypes.ts';\nimport type {\n  AnyWgslData,\n  BaseData,\n  U16,\n  U32,\n  WgslArray,\n} from '../../data/wgslTypes.ts';\nimport {\n  invariant,\n  MissingBindGroupsError,\n  MissingVertexBuffersError,\n} from '../../errors.ts';\nimport { WeakMemo } from '../../memo.ts';\nimport {\n  type NameRegistry,\n  RandomNameRegistry,\n  StrictNameRegistry,\n} from '../../nameRegistry.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport { $internal } from '../../shared/symbols.ts';\nimport type { AnyVertexAttribs } from '../../shared/vertexFormat.ts';\nimport type {\n  ExtractBindGroupInputFromLayout,\n  TgpuBindGroup,\n  TgpuBindGroupLayout,\n  TgpuLayoutEntry,\n} from '../../tgpuBindGroupLayout.ts';\nimport {\n  isBindGroup,\n  isBindGroupLayout,\n  TgpuBindGroupImpl,\n} from '../../tgpuBindGroupLayout.ts';\nimport {\n  INTERNAL_createBuffer,\n  isBuffer,\n  type TgpuBuffer,\n  type VertexFlag,\n} from '../buffer/buffer.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport type { IOLayout } from '../function/fnTypes.ts';\nimport type { TgpuComputeFn } from '../function/tgpuComputeFn.ts';\nimport type { TgpuFn } from '../function/tgpuFn.ts';\nimport type { TgpuFragmentFn } from '../function/tgpuFragmentFn.ts';\nimport type { TgpuVertexFn } from '../function/tgpuVertexFn.ts';\nimport {\n  INTERNAL_createComputePipeline,\n  isComputePipeline,\n  type TgpuComputePipeline,\n} from '../pipeline/computePipeline.ts';\nimport {\n  type AnyFragmentTargets,\n  INTERNAL_createRenderPipeline,\n  isRenderPipeline,\n  type RenderPipelineCoreOptions,\n  type TgpuRenderPipeline,\n} from '../pipeline/renderPipeline.ts';\nimport {\n  isComparisonSampler,\n  isSampler,\n  type TgpuComparisonSampler,\n  type TgpuSampler,\n} from '../sampler/sampler.ts';\nimport {\n  isAccessor,\n  type TgpuAccessor,\n  type TgpuSlot,\n} from '../slot/slotTypes.ts';\nimport {\n  INTERNAL_createTexture,\n  isSampledTextureView,\n  isStorageTextureView,\n  isTexture,\n  type TgpuMutableTexture,\n  type TgpuReadonlyTexture,\n  type TgpuSampledTexture,\n  type TgpuTexture,\n  type TgpuWriteonlyTexture,\n} from '../texture/texture.ts';\nimport type { LayoutToAllowedAttribs } from '../vertexLayout/vertexAttribute.ts';\nimport {\n  isVertexLayout,\n  type TgpuVertexLayout,\n} from '../vertexLayout/vertexLayout.ts';\nimport type {\n  Configurable,\n  CreateTextureOptions,\n  CreateTextureResult,\n  ExperimentalTgpuRoot,\n  RenderPass,\n  TgpuRoot,\n  WithBinding,\n  WithCompute,\n  WithFragment,\n  WithVertex,\n} from './rootTypes.ts';\nimport {\n  TgpuBufferShorthandImpl,\n  type TgpuMutable,\n  type TgpuReadonly,\n  type TgpuUniform,\n} from '../buffer/bufferShorthand.ts';\n\nclass ConfigurableImpl implements Configurable {\n  constructor(readonly bindings: [TgpuSlot<unknown>, unknown][]) {}\n\n  with<T extends AnyWgslData>(\n    slot: TgpuSlot<T> | TgpuAccessor<T>,\n    value: T | TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n  ): Configurable {\n    return new ConfigurableImpl([\n      ...this.bindings,\n      [isAccessor(slot) ? slot.slot : slot, value],\n    ]);\n  }\n\n  pipe(transform: (cfg: Configurable) => Configurable): Configurable {\n    const newCfg = transform(this);\n    return new ConfigurableImpl([\n      ...this.bindings,\n      ...newCfg.bindings,\n    ]);\n  }\n}\n\nclass WithBindingImpl implements WithBinding {\n  constructor(\n    private readonly _getRoot: () => ExperimentalTgpuRoot,\n    private readonly _slotBindings: [TgpuSlot<unknown>, unknown][],\n  ) {}\n\n  with<T extends AnyWgslData>(\n    slot: TgpuSlot<T> | TgpuAccessor<T>,\n    value: T | TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n  ): WithBinding {\n    return new WithBindingImpl(this._getRoot, [\n      ...this._slotBindings,\n      [isAccessor(slot) ? slot.slot : slot, value],\n    ]);\n  }\n\n  withCompute<ComputeIn extends Record<string, AnyComputeBuiltin>>(\n    entryFn: TgpuComputeFn<ComputeIn>,\n  ): WithCompute {\n    return new WithComputeImpl(this._getRoot(), this._slotBindings, entryFn);\n  }\n\n  withVertex<VertexIn extends IOLayout>(\n    vertexFn: TgpuVertexFn,\n    attribs: LayoutToAllowedAttribs<OmitBuiltins<VertexIn>>,\n  ): WithVertex {\n    return new WithVertexImpl({\n      branch: this._getRoot(),\n      primitiveState: undefined,\n      depthStencilState: undefined,\n      slotBindings: this._slotBindings,\n      vertexFn,\n      vertexAttribs: attribs as AnyVertexAttribs,\n      multisampleState: undefined,\n    });\n  }\n\n  pipe(transform: (cfg: Configurable) => Configurable): WithBinding {\n    const newCfg = transform(new ConfigurableImpl([]));\n    return new WithBindingImpl(this._getRoot, [\n      ...this._slotBindings,\n      ...newCfg.bindings,\n    ]);\n  }\n}\n\nclass WithComputeImpl implements WithCompute {\n  constructor(\n    private readonly _root: ExperimentalTgpuRoot,\n    private readonly _slotBindings: [TgpuSlot<unknown>, unknown][],\n    private readonly _entryFn: TgpuComputeFn,\n  ) {}\n\n  createPipeline(): TgpuComputePipeline {\n    return INTERNAL_createComputePipeline(\n      this._root,\n      this._slotBindings,\n      this._entryFn,\n    );\n  }\n}\n\nclass WithVertexImpl implements WithVertex {\n  constructor(\n    private readonly _options: Omit<\n      RenderPipelineCoreOptions,\n      'fragmentFn' | 'targets'\n    >,\n  ) {}\n\n  withFragment(\n    fragmentFn: TgpuFragmentFn | 'n/a',\n    targets: AnyFragmentTargets | 'n/a',\n    _mismatch?: unknown,\n  ): WithFragment {\n    invariant(typeof fragmentFn !== 'string', 'Just type mismatch validation');\n    invariant(typeof targets !== 'string', 'Just type mismatch validation');\n\n    return new WithFragmentImpl({\n      ...this._options,\n      fragmentFn,\n      targets,\n    });\n  }\n}\n\nclass WithFragmentImpl implements WithFragment {\n  constructor(private readonly _options: RenderPipelineCoreOptions) {}\n\n  withPrimitive(\n    primitiveState:\n      | GPUPrimitiveState\n      | Omit<GPUPrimitiveState, 'stripIndexFormat'> & {\n        stripIndexFormat?: U32 | U16;\n      }\n      | undefined,\n  ): WithFragment {\n    return new WithFragmentImpl({ ...this._options, primitiveState });\n  }\n\n  withDepthStencil(\n    depthStencilState: GPUDepthStencilState | undefined,\n  ): WithFragment {\n    return new WithFragmentImpl({ ...this._options, depthStencilState });\n  }\n\n  withMultisample(\n    multisampleState: GPUMultisampleState | undefined,\n  ): WithFragment {\n    return new WithFragmentImpl({ ...this._options, multisampleState });\n  }\n\n  createPipeline(): TgpuRenderPipeline {\n    return INTERNAL_createRenderPipeline(this._options);\n  }\n}\n\ninterface Disposable {\n  destroy(): void;\n}\n\n/**\n * Holds all data that is necessary to facilitate CPU and GPU communication.\n * Programs that share a root can interact via GPU buffers.\n */\nclass TgpuRootImpl extends WithBindingImpl\n  implements TgpuRoot, ExperimentalTgpuRoot {\n  '~unstable': Omit<ExperimentalTgpuRoot, keyof TgpuRoot>;\n\n  private _disposables: Disposable[] = [];\n\n  private _unwrappedBindGroupLayouts = new WeakMemo(\n    (key: TgpuBindGroupLayout) => key.unwrap(this),\n  );\n  private _unwrappedBindGroups = new WeakMemo((key: TgpuBindGroup) =>\n    key.unwrap(this)\n  );\n\n  private _commandEncoder: GPUCommandEncoder | null = null;\n\n  constructor(\n    public readonly device: GPUDevice,\n    public readonly nameRegistry: NameRegistry,\n    private readonly _ownDevice: boolean,\n  ) {\n    super(() => this, []);\n\n    this['~unstable'] = this;\n  }\n\n  get commandEncoder() {\n    if (!this._commandEncoder) {\n      this._commandEncoder = this.device.createCommandEncoder();\n    }\n\n    return this._commandEncoder;\n  }\n\n  get enabledFeatures() {\n    return new Set(this.device.features) as ReadonlySet<GPUFeatureName>;\n  }\n\n  createBuffer<TData extends AnyData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuBuffer<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer);\n    this._disposables.push(buffer);\n    return buffer;\n  }\n\n  createUniform<TData extends AnyWgslData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuUniform<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer)\n      // biome-ignore lint/suspicious/noExplicitAny: i'm sure it's fine\n      .$usage('uniform' as any);\n    this._disposables.push(buffer);\n\n    return new TgpuBufferShorthandImpl('uniform', buffer);\n  }\n\n  createMutable<TData extends AnyWgslData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuMutable<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer)\n      // biome-ignore lint/suspicious/noExplicitAny: i'm sure it's fine\n      .$usage('storage' as any);\n    this._disposables.push(buffer);\n\n    return new TgpuBufferShorthandImpl('mutable', buffer);\n  }\n\n  createReadonly<TData extends AnyWgslData>(\n    typeSchema: TData,\n    initialOrBuffer?: Infer<TData> | GPUBuffer,\n  ): TgpuReadonly<TData> {\n    const buffer = INTERNAL_createBuffer(this, typeSchema, initialOrBuffer)\n      // biome-ignore lint/suspicious/noExplicitAny: i'm sure it's fine\n      .$usage('storage' as any);\n    this._disposables.push(buffer);\n\n    return new TgpuBufferShorthandImpl('readonly', buffer);\n  }\n\n  createQuerySet<T extends GPUQueryType>(\n    type: T,\n    count: number,\n    rawQuerySet?: GPUQuerySet,\n  ): TgpuQuerySet<T> {\n    return INTERNAL_createQuerySet(this, type, count, rawQuerySet);\n  }\n\n  createBindGroup<\n    Entries extends Record<string, TgpuLayoutEntry | null> = Record<\n      string,\n      TgpuLayoutEntry | null\n    >,\n  >(\n    layout: TgpuBindGroupLayout<Entries>,\n    entries: ExtractBindGroupInputFromLayout<Entries>,\n  ) {\n    return new TgpuBindGroupImpl(layout, entries);\n  }\n\n  destroy() {\n    for (const disposable of this._disposables) {\n      disposable.destroy();\n    }\n\n    if (this._ownDevice) {\n      this.device.destroy();\n    }\n  }\n\n  createTexture<\n    TWidth extends number,\n    THeight extends number,\n    TDepth extends number,\n    TSize extends\n      | readonly [TWidth]\n      | readonly [TWidth, THeight]\n      | readonly [TWidth, THeight, TDepth],\n    TFormat extends GPUTextureFormat,\n    TMipLevelCount extends number,\n    TSampleCount extends number,\n    TViewFormat extends GPUTextureFormat,\n    TDimension extends GPUTextureDimension,\n  >(\n    props: CreateTextureOptions<\n      TSize,\n      TFormat,\n      TMipLevelCount,\n      TSampleCount,\n      TViewFormat,\n      TDimension\n    >,\n  ): TgpuTexture<\n    CreateTextureResult<\n      TSize,\n      TFormat,\n      TMipLevelCount,\n      TSampleCount,\n      TViewFormat,\n      TDimension\n    >\n  > {\n    const texture = INTERNAL_createTexture(props, this);\n    this._disposables.push(texture);\n    // biome-ignore lint/suspicious/noExplicitAny: <too much type wrangling>\n    return texture as any;\n  }\n\n  unwrap(resource: TgpuComputePipeline): GPUComputePipeline;\n  unwrap(resource: TgpuRenderPipeline): GPURenderPipeline;\n  unwrap(resource: TgpuBindGroupLayout): GPUBindGroupLayout;\n  unwrap(resource: TgpuBindGroup): GPUBindGroup;\n  unwrap(resource: TgpuBuffer<AnyData>): GPUBuffer;\n  unwrap(resource: TgpuTexture): GPUTexture;\n  unwrap(\n    resource:\n      | TgpuReadonlyTexture\n      | TgpuWriteonlyTexture\n      | TgpuMutableTexture\n      | TgpuSampledTexture,\n  ): GPUTextureView;\n  unwrap(resource: TgpuVertexLayout): GPUVertexBufferLayout;\n  unwrap(resource: TgpuSampler): GPUSampler;\n  unwrap(resource: TgpuComparisonSampler): GPUSampler;\n  unwrap(resource: TgpuQuerySet<GPUQueryType>): GPUQuerySet;\n  unwrap(\n    resource:\n      | TgpuComputePipeline\n      | TgpuRenderPipeline\n      | TgpuBindGroupLayout\n      | TgpuBindGroup\n      | TgpuBuffer<AnyData>\n      | TgpuTexture\n      | TgpuReadonlyTexture\n      | TgpuWriteonlyTexture\n      | TgpuMutableTexture\n      | TgpuSampledTexture\n      | TgpuVertexLayout\n      | TgpuSampler\n      | TgpuComparisonSampler\n      | TgpuQuerySet<GPUQueryType>,\n  ):\n    | GPUComputePipeline\n    | GPURenderPipeline\n    | GPUBindGroupLayout\n    | GPUBindGroup\n    | GPUBuffer\n    | GPUTexture\n    | GPUTextureView\n    | GPUVertexBufferLayout\n    | GPUSampler\n    | GPUQuerySet {\n    if (isComputePipeline(resource)) {\n      return resource[$internal].rawPipeline;\n    }\n\n    if (isRenderPipeline(resource)) {\n      return resource[$internal].core.unwrap().pipeline;\n    }\n\n    if (isBindGroupLayout(resource)) {\n      return this._unwrappedBindGroupLayouts.getOrMake(resource);\n    }\n\n    if (isBindGroup(resource)) {\n      return this._unwrappedBindGroups.getOrMake(resource);\n    }\n\n    if (isBuffer(resource)) {\n      return resource.buffer;\n    }\n\n    if (isTexture(resource)) {\n      return resource[$internal].unwrap();\n    }\n\n    if (isStorageTextureView(resource)) {\n      if (resource[$internal].unwrap) {\n        return resource[$internal].unwrap();\n      }\n      throw new Error('Cannot unwrap laid-out texture view.');\n    }\n\n    if (isSampledTextureView(resource)) {\n      if (resource[$internal].unwrap) {\n        return resource[$internal].unwrap();\n      }\n      throw new Error('Cannot unwrap laid-out texture view.');\n    }\n\n    if (isVertexLayout(resource)) {\n      return resource.vertexLayout;\n    }\n\n    if (isSampler(resource)) {\n      if (resource[$internal].unwrap) {\n        return resource[$internal].unwrap(this);\n      }\n      throw new Error('Cannot unwrap laid-out sampler.');\n    }\n\n    if (isComparisonSampler(resource)) {\n      if (resource[$internal].unwrap) {\n        return resource[$internal].unwrap(this);\n      }\n      throw new Error('Cannot unwrap laid-out comparison sampler.');\n    }\n\n    if (isQuerySet(resource)) {\n      return resource.querySet;\n    }\n\n    throw new Error(`Unknown resource type: ${resource}`);\n  }\n\n  beginRenderPass(\n    descriptor: GPURenderPassDescriptor,\n    callback: (pass: RenderPass) => void,\n  ): void {\n    const pass = this.commandEncoder.beginRenderPass(descriptor);\n\n    const bindGroups = new Map<\n      TgpuBindGroupLayout,\n      TgpuBindGroup | GPUBindGroup\n    >();\n    const vertexBuffers = new Map<\n      TgpuVertexLayout,\n      {\n        buffer:\n          | (TgpuBuffer<WgslArray<BaseData> | Disarray<BaseData>> & VertexFlag)\n          | GPUBuffer;\n        offset?: number | undefined;\n        size?: number | undefined;\n      }\n    >();\n\n    let currentPipeline: TgpuRenderPipeline | undefined;\n\n    const setupPassBeforeDraw = () => {\n      if (!currentPipeline) {\n        throw new Error('Cannot draw without a call to pass.setPipeline');\n      }\n\n      const { core, priors } = currentPipeline[$internal];\n      const memo = core.unwrap();\n\n      pass.setPipeline(memo.pipeline);\n\n      const missingBindGroups = new Set(memo.usedBindGroupLayouts);\n      memo.usedBindGroupLayouts.forEach((layout, idx) => {\n        if (memo.catchall && idx === memo.catchall[0]) {\n          // Catch-all\n          pass.setBindGroup(idx, this.unwrap(memo.catchall[1]));\n          missingBindGroups.delete(layout);\n        } else {\n          const bindGroup = priors.bindGroupLayoutMap?.get(layout) ??\n            bindGroups.get(layout);\n          if (bindGroup !== undefined) {\n            missingBindGroups.delete(layout);\n            if (isBindGroup(bindGroup)) {\n              pass.setBindGroup(idx, this.unwrap(bindGroup));\n            } else {\n              pass.setBindGroup(idx, bindGroup);\n            }\n          }\n        }\n      });\n\n      const missingVertexLayouts = new Set<TgpuVertexLayout>();\n      core.usedVertexLayouts.forEach((vertexLayout, idx) => {\n        const priorBuffer = priors.vertexLayoutMap?.get(vertexLayout);\n        const opts = priorBuffer\n          ? {\n            buffer: priorBuffer,\n            offset: undefined,\n            size: undefined,\n          }\n          : vertexBuffers.get(vertexLayout);\n\n        if (!opts || !opts.buffer) {\n          missingVertexLayouts.add(vertexLayout);\n        } else if (isBuffer(opts.buffer)) {\n          pass.setVertexBuffer(\n            idx,\n            this.unwrap(opts.buffer),\n            opts.offset,\n            opts.size,\n          );\n        } else {\n          pass.setVertexBuffer(idx, opts.buffer, opts.offset, opts.size);\n        }\n      });\n\n      if (missingBindGroups.size > 0) {\n        throw new MissingBindGroupsError(missingBindGroups);\n      }\n\n      if (missingVertexLayouts.size > 0) {\n        throw new MissingVertexBuffersError(missingVertexLayouts);\n      }\n    };\n\n    callback({\n      setViewport(...args) {\n        pass.setViewport(...args);\n      },\n      setScissorRect(...args) {\n        pass.setScissorRect(...args);\n      },\n      setBlendConstant(...args) {\n        pass.setBlendConstant(...args);\n      },\n      setStencilReference(...args) {\n        pass.setStencilReference(...args);\n      },\n      beginOcclusionQuery(...args) {\n        pass.beginOcclusionQuery(...args);\n      },\n      endOcclusionQuery(...args) {\n        pass.endOcclusionQuery(...args);\n      },\n      executeBundles(...args) {\n        pass.executeBundles(...args);\n      },\n      setPipeline(pipeline) {\n        currentPipeline = pipeline;\n      },\n\n      setIndexBuffer: (buffer, indexFormat, offset, size) => {\n        if (isBuffer(buffer)) {\n          pass.setIndexBuffer(this.unwrap(buffer), indexFormat, offset, size);\n        } else {\n          pass.setIndexBuffer(buffer, indexFormat, offset, size);\n        }\n      },\n\n      setVertexBuffer(vertexLayout, buffer, offset, size) {\n        vertexBuffers.set(vertexLayout, { buffer, offset, size });\n      },\n\n      setBindGroup(bindGroupLayout, bindGroup) {\n        bindGroups.set(bindGroupLayout, bindGroup);\n      },\n\n      draw(vertexCount, instanceCount, firstVertex, firstInstance) {\n        setupPassBeforeDraw();\n        pass.draw(vertexCount, instanceCount, firstVertex, firstInstance);\n      },\n\n      drawIndexed(...args) {\n        setupPassBeforeDraw();\n        pass.drawIndexed(...args);\n      },\n\n      drawIndirect(...args) {\n        setupPassBeforeDraw();\n        pass.drawIndirect(...args);\n      },\n\n      drawIndexedIndirect(...args) {\n        setupPassBeforeDraw();\n        pass.drawIndexedIndirect(...args);\n      },\n    });\n\n    pass.end();\n  }\n\n  flush() {\n    if (!this._commandEncoder) {\n      return;\n    }\n\n    this.device.queue.submit([this._commandEncoder.finish()]);\n    this._commandEncoder = null;\n  }\n}\n\n/**\n * Options passed into {@link init}.\n */\nexport type InitOptions = {\n  adapter?: GPURequestAdapterOptions | undefined;\n  device?:\n    | GPUDeviceDescriptor & { optionalFeatures?: Iterable<GPUFeatureName> }\n    | undefined;\n  /** @default 'random' */\n  unstable_names?: 'random' | 'strict' | undefined;\n};\n\n/**\n * Options passed into {@link initFromDevice}.\n */\nexport type InitFromDeviceOptions = {\n  device: GPUDevice;\n  /** @default 'random' */\n  unstable_names?: 'random' | 'strict' | undefined;\n};\n\n/**\n * Requests a new GPU device and creates a root around it.\n * If a specific device should be used instead, use @see initFromDevice.\n *\n * @example\n * When given no options, the function will ask the browser for a suitable GPU device.\n * ```ts\n * const root = await tgpu.init();\n * ```\n *\n * @example\n * If there are specific options that should be used when requesting a device, you can pass those in.\n * ```ts\n * const adapterOptions: GPURequestAdapterOptions = ...;\n * const deviceDescriptor: GPUDeviceDescriptor = ...;\n * const root = await tgpu.init({ adapter: adapterOptions, device: deviceDescriptor });\n * ```\n */\nexport async function init(options?: InitOptions): Promise<TgpuRoot> {\n  const {\n    adapter: adapterOpt,\n    device: deviceOpt,\n    unstable_names: names = 'random',\n  } = options ?? {};\n\n  if (!navigator.gpu) {\n    throw new Error('WebGPU is not supported by this browser.');\n  }\n\n  const adapter = await navigator.gpu.requestAdapter(adapterOpt);\n\n  if (!adapter) {\n    throw new Error('Could not find a compatible GPU');\n  }\n\n  const availableFeatures: GPUFeatureName[] = [];\n  for (const feature of deviceOpt?.requiredFeatures ?? []) {\n    if (!adapter.features.has(feature)) {\n      throw new Error(\n        `Requested feature \"${feature}\" is not supported by the adapter.`,\n      );\n    }\n    availableFeatures.push(feature);\n  }\n  for (const feature of deviceOpt?.optionalFeatures ?? []) {\n    if (adapter.features.has(feature)) {\n      availableFeatures.push(feature);\n    } else {\n      console.warn(\n        `Optional feature \"${feature}\" is not supported by the adapter.`,\n      );\n    }\n  }\n\n  return new TgpuRootImpl(\n    await adapter.requestDevice({\n      ...deviceOpt,\n      requiredFeatures: availableFeatures,\n    }),\n    names === 'random' ? new RandomNameRegistry() : new StrictNameRegistry(),\n    true,\n  );\n}\n\n/**\n * Creates a root from the given device, instead of requesting it like @see init.\n *\n * @example\n * ```ts\n * const device: GPUDevice = ...;\n * const root = tgpu.initFromDevice({ device });\n * ```\n */\nexport function initFromDevice(options: InitFromDeviceOptions): TgpuRoot {\n  const {\n    device,\n    unstable_names: names = 'random',\n  } = options ?? {};\n\n  return new TgpuRootImpl(\n    device,\n    names === 'random' ? new RandomNameRegistry() : new StrictNameRegistry(),\n    false,\n  );\n}\n","import { getResolutionCtx } from '../../gpuMode.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $gpuRepr,\n  $gpuValueOf,\n  $internal,\n  $repr,\n} from '../../shared/symbols.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport { getGpuValueRecursively } from '../valueProxyUtils.ts';\nimport type { TgpuSlot } from './slotTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport function slot<T>(defaultValue?: T): TgpuSlot<T> {\n  return new TgpuSlotImpl(defaultValue);\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuSlotImpl<T> implements TgpuSlot<T> {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'slot';\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<T>;\n  declare readonly [$gpuRepr]: InferGPU<T>;\n  // ---\n\n  constructor(public defaultValue: T | undefined = undefined) {}\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  areEqual(a: T, b: T): boolean {\n    return Object.is(a, b);\n  }\n\n  toString(): string {\n    return `slot:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](ctx: ResolutionCtx): InferGPU<T> {\n    return getGpuValueRecursively(ctx, ctx.unwrap(this));\n  }\n\n  get value(): InferGPU<T> {\n    const ctx = getResolutionCtx();\n    if (!ctx) {\n      throw new Error(`Cannot access tgpu.slot's value outside of resolution.`);\n    }\n\n    return this[$gpuValueOf](ctx);\n  }\n\n  get $(): InferGPU<T> {\n    return this.value;\n  }\n}\n","import type { AnyWgslData } from '../../data/wgslTypes.ts';\nimport { inGPUMode } from '../../gpuMode.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $getNameForward,\n  $gpuRepr,\n  $gpuValueOf,\n  $internal,\n  $repr,\n  $wgslDataType,\n} from '../../shared/symbols.ts';\nimport {\n  isBufferUsage,\n  type ResolutionCtx,\n  type SelfResolvable,\n} from '../../types.ts';\nimport { isBufferShorthand } from '../buffer/bufferShorthand.ts';\nimport type { TgpuBufferUsage } from '../buffer/bufferUsage.ts';\nimport { isTgpuFn, type TgpuFn } from '../function/tgpuFn.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\nimport { slot } from './slot.ts';\nimport type { TgpuAccessor, TgpuSlot } from './slotTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport function accessor<T extends AnyWgslData>(\n  schema: T,\n  defaultValue?: TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>,\n): TgpuAccessor<T> {\n  return new TgpuAccessorImpl(schema, defaultValue);\n}\n\n// --------------\n// Implementation\n// --------------\n\nexport class TgpuAccessorImpl<T extends AnyWgslData>\n  implements TgpuAccessor<T>, SelfResolvable {\n  public readonly [$internal] = true;\n  public readonly resourceType = 'accessor';\n  public readonly slot: TgpuSlot<\n    TgpuFn<() => T> | TgpuBufferUsage<T> | Infer<T>\n  >;\n\n  // Type-tokens, not available at runtime\n  declare readonly [$repr]: Infer<T>;\n  declare readonly [$gpuRepr]: InferGPU<T>;\n  declare readonly [$getNameForward]: unknown;\n  // ---\n\n  constructor(\n    public readonly schema: T,\n    public readonly defaultValue:\n      | TgpuFn<() => T>\n      | TgpuBufferUsage<T>\n      | Infer<T>\n      | undefined = undefined,\n  ) {\n    this.slot = slot(defaultValue);\n    this[$getNameForward] = this.slot;\n  }\n\n  $name(label: string) {\n    this.slot.$name(label);\n    return this;\n  }\n\n  toString(): string {\n    return `accessor:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): InferGPU<T> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this.schema,\n      },\n      valueProxyHandler,\n    ) as InferGPU<T>;\n  }\n\n  get value(): InferGPU<T> {\n    if (!inGPUMode()) {\n      throw new Error('`tgpu.accessor` values are only accessible on the GPU');\n    }\n\n    return this[$gpuValueOf]();\n  }\n\n  get $(): InferGPU<T> {\n    return this.value;\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const value = ctx.unwrap(this.slot);\n\n    if (isBufferUsage(value) || isBufferShorthand(value)) {\n      return ctx.resolve(value);\n    }\n\n    if (isTgpuFn(value)) {\n      return `${ctx.resolve(value)}()`;\n    }\n\n    return ctx.resolveValue(value as Infer<T>, this.schema);\n  }\n}\n","import { getResolutionCtx } from '../../gpuMode.ts';\nimport { getName } from '../../shared/meta.ts';\nimport type { Infer, InferGPU } from '../../shared/repr.ts';\nimport {\n  $gpuRepr,\n  $gpuValueOf,\n  $providing,\n  $repr,\n} from '../../shared/symbols.ts';\nimport type { ResolutionCtx } from '../../types.ts';\nimport { getGpuValueRecursively } from '../valueProxyUtils.ts';\nimport type {\n  Eventual,\n  SlotValuePair,\n  TgpuDerived,\n  TgpuSlot,\n} from './slotTypes.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport function derived<T>(compute: () => T): TgpuDerived<T> {\n  return createDerived(compute);\n}\n\n// --------------\n// Implementation\n// --------------\n\nfunction stringifyPair([slot, value]: SlotValuePair): string {\n  return `${getName(slot) ?? '<unnamed>'}=${value}`;\n}\n\nfunction createDerived<T>(compute: () => T): TgpuDerived<T> {\n  if (getResolutionCtx()) {\n    throw new Error(\n      'Cannot create tgpu.derived objects at the resolution stage.',\n    );\n  }\n\n  const result = {\n    resourceType: 'derived' as const,\n    '~compute': compute,\n    [$repr]: undefined as Infer<T>,\n    [$gpuRepr]: undefined as InferGPU<T>,\n\n    [$gpuValueOf](ctx: ResolutionCtx): InferGPU<T> {\n      return getGpuValueRecursively(ctx, ctx.unwrap(this));\n    },\n\n    get value(): InferGPU<T> {\n      const ctx = getResolutionCtx();\n      if (!ctx) {\n        throw new Error(\n          `Cannot access tgpu.derived's value outside of resolution.`,\n        );\n      }\n\n      return this[$gpuValueOf](ctx);\n    },\n\n    get $(): InferGPU<T> {\n      return this.value;\n    },\n\n    with<TValue>(\n      slot: TgpuSlot<TValue>,\n      value: Eventual<TValue>,\n    ): TgpuDerived<T> {\n      return createBoundDerived(this, [[slot, value]]);\n    },\n\n    toString(): string {\n      return 'derived';\n    },\n  };\n\n  return result;\n}\n\nfunction createBoundDerived<T>(\n  innerDerived: TgpuDerived<T>,\n  pairs: SlotValuePair[],\n): TgpuDerived<T> {\n  const result = {\n    resourceType: 'derived' as const,\n    [$repr]: undefined as Infer<T>,\n    [$gpuRepr]: undefined as InferGPU<T>,\n\n    '~compute'() {\n      throw new Error(\n        `'~compute' should never be read on bound derived items.`,\n      );\n    },\n    [$providing]: {\n      inner: innerDerived,\n      pairs,\n    },\n\n    [$gpuValueOf](ctx: ResolutionCtx): InferGPU<T> {\n      return getGpuValueRecursively(ctx, ctx.unwrap(this));\n    },\n\n    get value(): InferGPU<T> {\n      const ctx = getResolutionCtx();\n      if (!ctx) {\n        throw new Error(\n          `Cannot access tgpu.derived's value outside of resolution.`,\n        );\n      }\n\n      return this[$gpuValueOf](ctx);\n    },\n\n    get $(): InferGPU<T> {\n      return this.value;\n    },\n\n    with<TValue>(\n      slot: TgpuSlot<TValue>,\n      value: Eventual<TValue>,\n    ): TgpuDerived<T> {\n      return createBoundDerived(innerDerived, [...pairs, [slot, value]]);\n    },\n\n    toString(): string {\n      return `derived[${pairs.map(stringifyPair).join(', ')}]`;\n    },\n  };\n\n  return result;\n}\n","import type { AnyData } from '../../data/dataTypes.ts';\nimport { inGPUMode } from '../../gpuMode.ts';\nimport type { TgpuNamable } from '../../shared/meta.ts';\nimport { getName, setName } from '../../shared/meta.ts';\nimport type { Infer } from '../../shared/repr.ts';\nimport { $gpuValueOf, $internal, $wgslDataType } from '../../shared/symbols.ts';\nimport type { ResolutionCtx, SelfResolvable } from '../../types.ts';\nimport { valueProxyHandler } from '../valueProxyUtils.ts';\n\n// ----------\n// Public API\n// ----------\n\nexport type VariableScope = 'private' | 'workgroup';\n\nexport interface TgpuVar<\n  TScope extends VariableScope = VariableScope,\n  TDataType extends AnyData = AnyData,\n> extends TgpuNamable {\n  value: Infer<TDataType>;\n\n  readonly [$internal]: {\n    readonly scope: TScope;\n  };\n}\n\n/**\n * Defines a variable scoped to each entry function (private).\n *\n * @param dataType The schema of the held data's type\n * @param initialValue If not provided, the variable will be initialized to the dataType's \"zero-value\".\n */\nexport function privateVar<TDataType extends AnyData>(\n  dataType: TDataType,\n  initialValue?: Infer<TDataType>,\n): TgpuVar<'private', TDataType> {\n  return new TgpuVarImpl('private', dataType, initialValue);\n}\n\n/**\n * Defines a variable scoped to the whole workgroup, shared between entry functions\n * of the same invocation.\n *\n * @param dataType The schema of the held data's type\n */\nexport function workgroupVar<TDataType extends AnyData>(\n  dataType: TDataType,\n): TgpuVar<'workgroup', TDataType> {\n  return new TgpuVarImpl('workgroup', dataType);\n}\n\nexport function isVariable<T extends TgpuVar>(\n  value: T | unknown,\n): value is T {\n  return value instanceof TgpuVarImpl;\n}\n\n// --------------\n// Implementation\n// --------------\n\nclass TgpuVarImpl<TScope extends VariableScope, TDataType extends AnyData>\n  implements TgpuVar<TScope, TDataType>, SelfResolvable {\n  declare readonly [$internal]: {\n    readonly scope: TScope;\n  };\n\n  constructor(\n    readonly scope: TScope,\n    private readonly _dataType: TDataType,\n    private readonly _initialValue?: Infer<TDataType> | undefined,\n  ) {\n    this[$internal] = { scope };\n  }\n\n  '~resolve'(ctx: ResolutionCtx): string {\n    const id = ctx.names.makeUnique(getName(this));\n\n    if (this._initialValue) {\n      ctx.addDeclaration(\n        `var<${this.scope}> ${id}: ${ctx.resolve(this._dataType)} = ${\n          ctx.resolveValue(this._initialValue, this._dataType)\n        };`,\n      );\n    } else {\n      ctx.addDeclaration(\n        `var<${this.scope}> ${id}: ${ctx.resolve(this._dataType)};`,\n      );\n    }\n\n    return id;\n  }\n\n  $name(label: string) {\n    setName(this, label);\n    return this;\n  }\n\n  toString() {\n    return `var:${getName(this) ?? '<unnamed>'}`;\n  }\n\n  [$gpuValueOf](): Infer<TDataType> {\n    return new Proxy(\n      {\n        '~resolve': (ctx: ResolutionCtx) => ctx.resolve(this),\n        toString: () => `.value:${getName(this) ?? '<unnamed>'}`,\n        [$wgslDataType]: this._dataType,\n      },\n      valueProxyHandler,\n    ) as Infer<TDataType>;\n  }\n\n  get value(): Infer<TDataType> {\n    if (!inGPUMode()) {\n      throw new Error('`tgpu.var` values are only accessible on the GPU');\n    }\n\n    return this[$gpuValueOf]();\n  }\n}\n","/**\n * @module typegpu\n */\n\nimport { constant } from './core/constant/tgpuConstant.ts';\nimport { declare } from './core/declare/tgpuDeclare.ts';\nimport { computeFn } from './core/function/tgpuComputeFn.ts';\nimport { fn } from './core/function/tgpuFn.ts';\nimport { fragmentFn } from './core/function/tgpuFragmentFn.ts';\nimport { vertexFn } from './core/function/tgpuVertexFn.ts';\nimport { resolve, resolveWithContext } from './core/resolve/tgpuResolve.ts';\nimport { init, initFromDevice } from './core/root/init.ts';\nimport { comparisonSampler, sampler } from './core/sampler/sampler.ts';\nimport { accessor } from './core/slot/accessor.ts';\nimport { derived } from './core/slot/derived.ts';\nimport { slot } from './core/slot/slot.ts';\nimport { privateVar, workgroupVar } from './core/variable/tgpuVariable.ts';\nimport { vertexLayout } from './core/vertexLayout/vertexLayout.ts';\nimport { bindGroupLayout } from './tgpuBindGroupLayout.ts';\n\nexport const tgpu = {\n  fn,\n  bindGroupLayout,\n  vertexLayout,\n  slot,\n\n  init,\n  initFromDevice,\n\n  resolve,\n  resolveWithContext,\n\n  '~unstable': {\n    /**\n     * @deprecated This feature is now stable, use tgpu.fn.\n     */\n    fn,\n    fragmentFn,\n    vertexFn,\n    computeFn,\n    /**\n     * @deprecated This feature is now stable, use tgpu.vertexLayout.\n     */\n    vertexLayout,\n    derived,\n    /**\n     * @deprecated This feature is now stable, use tgpu.slot.\n     */\n    slot,\n    accessor,\n    privateVar,\n    workgroupVar,\n    const: constant,\n    declare,\n    sampler,\n    comparisonSampler,\n  },\n};\nexport default tgpu;\n\nexport {\n  MissingBindGroupsError,\n  MissingLinksError,\n  MissingSlotValueError,\n  MissingVertexBuffersError,\n  NotUniformError,\n  ResolutionError,\n} from './errors.ts';\nexport { RandomNameRegistry, StrictNameRegistry } from './nameRegistry.ts';\nexport { isBuffer, isUsableAsVertex } from './core/buffer/buffer.ts';\nexport { isDerived, isSlot } from './core/slot/slotTypes.ts';\nexport { isComparisonSampler, isSampler } from './core/sampler/sampler.ts';\nexport {\n  isSampledTextureView,\n  isStorageTextureView,\n  isTexture,\n} from './core/texture/texture.ts';\nexport {\n  isUsableAsRender,\n  isUsableAsSampled,\n} from './core/texture/usageExtension.ts';\nexport { isUsableAsStorage } from './extension.ts';\nexport {\n  asMutable as unstable_asMutable,\n  asReadonly as unstable_asReadonly,\n  asUniform as unstable_asUniform,\n  isUsableAsUniform,\n} from './core/buffer/bufferUsage.ts';\nexport { isBufferShorthand } from './core/buffer/bufferShorthand.ts';\nexport { isTgpuFn } from './core/function/tgpuFn.ts';\n\n// types\n\nexport type {\n  Configurable,\n  TgpuRoot,\n  WithBinding,\n  WithCompute,\n  WithFragment,\n  WithVertex,\n} from './core/root/rootTypes.ts';\nexport type { Storage, StorageFlag } from './extension.ts';\nexport type { TgpuVertexLayout } from './core/vertexLayout/vertexLayout.ts';\nexport type { TgpuRenderPipeline } from './core/pipeline/renderPipeline.ts';\nexport type { TgpuComputePipeline } from './core/pipeline/computePipeline.ts';\nexport type {\n  IndexFlag,\n  TgpuBuffer,\n  Uniform,\n  UniformFlag,\n  Vertex,\n  VertexFlag,\n} from './core/buffer/buffer.ts';\nexport type {\n  TgpuBufferMutable,\n  TgpuBufferReadonly,\n  TgpuBufferUniform,\n} from './core/buffer/bufferUsage.ts';\nexport type {\n  TgpuMutable,\n  TgpuReadonly,\n  TgpuUniform,\n} from './core/buffer/bufferShorthand.ts';\nexport type {\n  Eventual,\n  TgpuAccessor,\n  TgpuDerived,\n  TgpuSlot,\n} from './core/slot/slotTypes.ts';\nexport type {\n  TgpuAnyTextureView,\n  TgpuMutableTexture,\n  TgpuReadonlyTexture,\n  TgpuSampledTexture,\n  TgpuTexture,\n  TgpuWriteonlyTexture,\n} from './core/texture/texture.ts';\nexport type { TextureProps } from './core/texture/textureProps.ts';\nexport type { Render, Sampled } from './core/texture/usageExtension.ts';\nexport type { InitFromDeviceOptions, InitOptions } from './core/root/init.ts';\nexport type { TgpuConst } from './core/constant/tgpuConstant.ts';\nexport type { TgpuVar, VariableScope } from './core/variable/tgpuVariable.ts';\nexport type { TgpuSampler } from './core/sampler/sampler.ts';\nexport type {\n  BindLayoutEntry,\n  ExtractBindGroupInputFromLayout,\n  LayoutEntryToInput,\n  TgpuBindGroup,\n  TgpuBindGroupLayout,\n  TgpuLayoutComparisonSampler,\n  TgpuLayoutEntry,\n  TgpuLayoutExternalTexture,\n  TgpuLayoutSampler,\n  TgpuLayoutStorage,\n  TgpuLayoutStorageTexture,\n  TgpuLayoutTexture,\n  TgpuLayoutUniform,\n} from './tgpuBindGroupLayout.ts';\nexport type { TgpuFn, TgpuFnShell } from './core/function/tgpuFn.ts';\nexport type {\n  TgpuVertexFn,\n  TgpuVertexFnShell,\n} from './core/function/tgpuVertexFn.ts';\nexport type {\n  TgpuFragmentFn,\n  TgpuFragmentFnShell,\n} from './core/function/tgpuFragmentFn.ts';\nexport type {\n  TgpuComputeFn,\n  TgpuComputeFnShell,\n} from './core/function/tgpuComputeFn.ts';\nexport type { TgpuDeclare } from './core/declare/tgpuDeclare.ts';\n// Exported for being able to track use of these global extensions easier,\n// and to establish a solid contract between tooling using them.\nexport type { INTERNAL_GlobalExt } from './shared/meta.ts';\n"],"mappings":"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","names":["extractGpuValueGetter","object","$gpuValueOf","assertExhaustive","x","location","swizzleLenToType","f32","vec2f","vec3f","vec4f","f16","vec2h","vec3h","vec4h","i32","vec2i","vec3i","vec4i","u32","vec2u","vec3u","vec4u","bool","vec2b","vec3b","vec4b","kindToSchema","mat2x2f","mat3x3f","mat4x4f","indexableTypeToResult","getTypeForPropAccess","targetType","propName","isWgslStruct","isUnstruct","UnknownData","isNumericSchema","propLength","isVec","swizzleTypeChar","swizzleType","getTypeForIndexAccess","dataType","isWgslArray","isDisarray","numericLiteralToSnippet","value","snip","abstractInt","abstractFloat","INFINITE_RANK","unwrapDecorated","data","getVectorComponent","type","vecTypeToPrimitive","getAutoConversionRank","src","dest","trueSrc","trueDst","compSrc","compDest","isMat","getImplicitConversionRank","primitivePreference","srcType","destType","srcPref","getConversionRank","allowImplicit","autoRank","findBestType","types","uniqueTypes","bestType","minSum","conversionDetails","currentSum","currentDetails","possible","sourceType","conversion","actions","detail","index","hasCasts","action","concretize","getBestConversion","targetTypes","uniqueTargetTypes","explicitResult","implicitResult","applyActionToSnippet","ctx","value","action","targetType","snip","resolvedValue","assertExhaustive","convertToCommonType","values","restrictTo","types","type","UnknownData","conversion","getBestConversion","v","index","invariant","convertStructValues","structType","key","val","coerceToSnippet","isSnippet","hasInternalDataType","$wgslDataType","isVecInstance","isMatInstance","kindToSchema","coerced","context","getResolutionCtx","converted","commonType","arrayOf","concretize","numericLiteralToSnippet","bool","valueProxyHandler","target","prop","$providing","ctx","getName","$wgslDataType","getTypeForPropAccess","getGpuValueRecursively","value","unwrapped","valueGetter","extractGpuValueGetter","constant","dataType","value","TgpuConstImpl","_value","$internal","label","setName","ctx","id","getName","resolvedValue","resolvedDataType","$gpuValueOf","$wgslDataType","valueProxyHandler","inGPUMode","isSlot","value","isDerived","isProviding","$providing","isAccessor","isSelfResolvable","value","isWgsl","isWgslData","isSlot","isDerived","isProviding","isGPUBuffer","isBufferUsage","isMarkedInternal","$internal","applyExternals","existing","newExternals","key","value","isNamable","getName","addArgTypesToExternals","implementation","argTypes","argTypeNames","found","argType","i","argTypeName","isWgslStruct","addReturnTypeToExternals","returnType","matched","outputName","identifierRegex","name","replaceExternalsInWgsl","ctx","externalMap","wgsl","acc","externalName","external","isWgsl","isLooseData","innerAcc","prop","declare","declaration","TgpuDeclareImpl","dependencyMap","ctx","externalMap","externals","applyExternals","replacedDeclaration","replaceExternalsInWgsl","FuncParameterType","extractArgs","rawCode","strippedCode","range","strip","code","ParsableString","args","attributes","closingParenthesis","parentheses","identifierEndSymbols","identifier","maybeType","typeEndSymbols","angleBrackets","maybeRet","argsStart","blankSpaces","lineBreaks","openingCommentBlock","commentBlocks","str","#pos","#parseStartPos","substr","i","elem","toFind","brackets","openedBrackets","steps","createFnCore","implementation","fnAttribute","externalsToApply","core","newExternals","ctx","argTypes","returnType","externalMap","externals","applyExternals","id","getName","replacedImpl","replaceExternalsInWgsl","header","body","input","isWgslStruct","attributes","isWgslData","getAttributesString","output","Void","providedArgs","extractArgs","argInfo","i","checkAndReturnType","pluginData","getMetaData","missing","name","ast","missingExternals","MissingLinksError","head","arg","snip","FuncParameterType","param","alias","maybeName","setName","wgslType","jsType","resolvedJsType","resolvedWgslType","withLocations","members","locations","nextLocation","usedCustomLocations","key","member","customLocation","getCustomLocation","isBuiltin","location","createIoSchema","layout","isData","isVoid","struct","stripTemplate","arg","values","isTemplateStringsArray","templateLiteralIdentity","value","item","strings","acc","elem","index","computeFn","options","shell","createIoSchema","Void","call","arg","values","createComputeFn","stripTemplate","workgroupSize","implementation","core","createFnCore","inputType","newExternals","$internal","$getNameForward","newLabel","setName","isNamable","ctx","getName","fn","argTypes","returnType","shell","$internal","Void","arg","values","createFn","stripTemplate","isTgpuFn","value","stringifyPair","slot","getName","implementation","core","createFnCore","fnBase","newExternals","$getNameForward","label","setName","createBoundFunction","isAccessor","ctx","addArgTypesToExternals","addReturnTypeToExternals","generationCtx","call","createDualImpl","args","castAndCopiedArgs","index","schemaCallWrapper","snip","FnCall","UnknownData","innerFn","pairs","$providing","_fn","_params","param","fragmentFn","options","shell","createIoSchema","call","arg","values","createFragmentFn","stripTemplate","implementation","core","createFnCore","outputType","addReturnTypeToExternals","externals","newExternals","$internal","$getNameForward","newLabel","setName","isNamable","ctx","inputWithLocation","getName","generationCtx","vertexFn","options","shell","createIoSchema","call","arg","values","createVertexFn","stripTemplate","implementation","core","createFnCore","inputType","newExternals","$internal","$getNameForward","newLabel","setName","isNamable","ctx","outputWithLocation","getName","generationCtx","RandomNameRegistry","primer","label","StrictNameRegistry","index","unusedName","isAttribute","value","connectAttributesToShader","shaderInputLayout","attributes","usedVertexLayouts","isData","getCustomLocation","bufferDefinitions","layoutToAttribListMap","nextShaderLocation","key","member","isBuiltin","matchingAttribute","layout","attribList","identityTypes","isIdentityType","data","resolveStructProperty","ctx","key","property","getAttributesString","resolveStruct","struct","id","getName","prop","resolveUnstruct","unstruct","isAttribute","formatToWGSLType","resolveArray","array","element","resolveDisarray","disarray","resolveData","isLooseData","assertExhaustive","BufferReader","BufferWriter","getSystemEndianness","Measurer","alignIO","io","baseAlignment","currentPos","bitMask","offset","alignIO_default","cachedOffsets","offsetsForProps","struct","cached","measurer","Measurer","offsets","lastEntry","key","prop","beforeAlignment","alignIO_default","isUnstruct","customAlignmentOf","alignmentOf","propSize","sizeOf","roundUp","EVAL_ALLOWED_IN_ENV","compiledWriters","typeToPrimitive","primitiveToWriteFunction","buildWriter","node","offsetExpr","valueExpr","isAtomic","isDecorated","isWgslStruct","isUnstruct","propOffsets","offsetsForProps","sortedProps","a","b","code","key","propOffset","subSchema","isWgslArray","isDisarray","arrSchema","elementSize","roundUp","sizeOf","alignmentOf","isVec","primitive","writeFunc","components","count","isVec2","isVec3","i","isMat","matSize","isMat2x2f","isMat3x3f","elementCount","rowStride","colIndex","rowIndex","byteOffset","getCompiledWriterForSchema","schema","body","fn","dataWriters","output","_schema","value","_","i","schema","alignment","alignmentOf","alignIO_default","key","property","writeData","beginning","sizeOf","customAlignmentOf","packed","writer","dataReaders","input","vec2f","vec3f","vec4f","vec2h","vec3h","vec4h","vec2i","vec3i","vec4i","vec2u","vec3u","vec4u","mat2x2f","skipOneAfter","mat3x3f","mat4x4f","result","readData","elements","elementType","g","b","a","r","reader","BufferWriter","getWriteInstructions","schema","data","totalSize","sizeOf","bigBuffer","writer","BufferWriter","segments","gatherAndWrite","node","partialValue","offset","padding","isWgslStruct","isUnstruct","propOffsets","offsetsForProps","key","propOffset","subSchema","childValue","isWgslArray","isDisarray","arrSchema","elementSize","roundUp","alignmentOf","arrayPartialValue","a","b","idx","value","leafSize","writeData","instructions","current","i","next","isUsableAsStorage","value","NotStorageError","_NotStorageError","getName","isUsableAsUniform","buffer","usageToVarTemplateMap","TgpuFixedBufferImpl","usage","$internal","$getNameForward","label","ctx","id","getName","group","binding","$gpuValueOf","$wgslDataType","valueProxyHandler","inGPUMode","TgpuLaidOutBufferImpl","dataType","_membership","setName","mutableUsageMap","asMutable","isUsableAsStorage","readonlyUsageMap","asReadonly","uniformUsageMap","asUniform","usageToUsageConstructor","asUniform","asMutable","asReadonly","INTERNAL_createBuffer","group","typeSchema","initialOrBuffer","isWgslData","TgpuBufferImpl","isBuffer","value","isUsableAsVertex","buffer","endianness","getSystemEndianness","TgpuBufferImpl","_group","dataType","initialOrBuffer","_disallowedUsages","isGPUBuffer","$internal","device","sizeOf","getName","writer","BufferWriter","writeData","label","setName","usages","usage","flags","EVAL_ALLOWED_IN_ENV","getCompiledWriterForSchema","data","gpuBuffer","mapped","size","instructions","getWriteInstructions","mappedRange","mappedView","instruction","srcBuffer","readData","BufferReader","res","stagingBuffer","commandEncoder","usageToUsageConstructor","sampler","props","TgpuFixedSamplerImpl","comparisonSampler","TgpuFixedComparisonSamplerImpl","isSampler","resource","maybe","$internal","isComparisonSampler","TgpuLaidOutSamplerImpl","_membership","$wgslDataType","setName","ctx","id","getName","group","TgpuLaidOutComparisonSamplerImpl","_props","branch","label","binding","TgpuExternalTextureImpl","_membership","setName","ctx","id","getName","group","texelFormatToChannelType","f32","u32","i32","texelFormatToDataType","vec4f","vec4u","vec4i","channelKindToFormat","channelFormatToSchema","INTERNAL_createTexture","props","branch","TgpuTextureImpl","isTexture","value","$internal","isStorageTextureView","isSampledTextureView","accessMap","_branch","getName","label","setName","usages","hasStorage","hasSampled","hasRender","access","params","storageParams","format","type","texelFormatToDataType","invariant","TgpuFixedStorageTextureImpl","TgpuFixedSampledTextureImpl","dimensionToCodeMap","_texture","$wgslDataType","$getNameForward","ctx","id","group","binding","TgpuLaidOutStorageTextureImpl","_format","dimension","_membership","_props","texelFormatToChannelType","multisampled","channelKindToFormat","TgpuLaidOutSampledTextureImpl","sampleType","_multisampled","channelFormatToSchema","isUsableAsSampled","value","isUsableAsRender","NotSampledError","_NotSampledError","getName","bindGroupLayout","entries","TgpuBindGroupLayoutImpl","isBindGroupLayout","value","isBindGroup","MissingBindingError","_MissingBindingError","groupLabel","key","DEFAULT_MUTABLE_VISIBILITY","DEFAULT_READONLY_VISIBILITY","idx","entry","membership","TgpuLaidOutBufferImpl","dataType","TgpuLaidOutSampledTextureImpl","TgpuLaidOutStorageTextureImpl","TgpuExternalTextureImpl","TgpuLaidOutComparisonSamplerImpl","TgpuLaidOutSamplerImpl","$internal","getName","label","setName","index","unwrapper","visibility","binding","access","v","TgpuBindGroupImpl","layout","resource","isBuffer","isUsableAsUniform","NotUniformError","isUsableAsStorage","NotStorageError","isTexture","isUsableAsSampled","NotSampledError","isSampledTextureView","isStorageTextureView","isSampler","isComparisonSampler","tinyest","NODE","tinyest","parenthesizedOps","binaryLogicalOps","operatorToType","lhs","op","rhs","bool","assertExhaustive","value","generateBlock","ctx","_","statements","statement","generateStatement","registerBlockVariable","id","dataType","generateIdentifier","res","generateExpression","expression","snip","lhsExpr","rhsExpr","forcedType","converted","convertToCommonType","convLhs","convRhs","lhsStr","rhsStr","type","arg","argExpr","argStr","targetNode","property","target","propValue","coerceToSnippet","isPtr","getTypeForPropAccess","isWgslArray","u32","abstractInt","isMat","isVec","isVecInstance","propertyNode","targetStr","propertyStr","getTypeForIndexAccess","isData","UnknownData","numericLiteralToSnippet","callee","args","resolvedSnippets","argValues","sn","idx","getName","isWgslStruct","resolvedId","isMarkedInternal","argTypes","$internal","convertedResources","i","conv","ResolutionError","fnRes","error","obj","propKeys","entries","key","val","convertedValues","convertStructValues","v","snippets","expr","targetType","valuesRaw","values","f32","i32","arrayType","arrayValues","arrayOf","blockifySingleStatement","returnNode","returnValue","resolvedStruct","cond","cons","alt","condExpr","condSnippet","condition","consequent","alternate","rawId","rawValue","eq","isLooseData","concretize","structType","init","update","body","initStatement","initStr","conditionExpr","conditionStr","updateStatement","updateStr","bodyStr","generateFunction","CATCHALL_BIND_GROUP_IDX_MARKER","ItemStateStackImpl","state","pairs","args","argAliases","returnType","externalMap","type","layer","slot","i","boundValue","id","arg","a","external","coerceToSnippet","declarationType","snip","INDENT","N","IndentController","str","ResolutionCtxImpl","$internal","opts","item","dataType","options","resolveFunctionHeader","generateFunction","declaration","layout","memoMap","placeholderKey","layoutEntry","resource","binding","value","MissingSlotValueError","callback","locations","eventual","isProviding","$providing","maybeEventual","isSlot","isDerived","derived","instances","instance","expectedValue","pushMode","RuntimeMode","result","popMode","slotToValueMap","usedSlot","err","ResolutionError","isData","resolveData","isSelfResolvable","provideCtx","schema","isWgsl","isWgslArray","element","isWgslStruct","key","type_","resolve","ctx","code","usedBindGroupLayouts","takenIndices","v","automaticIds","naturalsExcept","layoutEntries","idx","createCatchallGroup","catchallIdx","catchallLayout","bindGroupLayout","TgpuBindGroupImpl","catchall","placeholder","argList","getAttributesString","resolveWithContext","options","externals","template","names","dependencies","applyExternals","resolve","ctx","replaceExternalsInWgsl","StrictNameRegistry","RandomNameRegistry","INTERNAL_createQuerySet","group","type","count","rawQuerySet","TgpuQuerySetImpl","isQuerySet","value","maybe","$internal","_group","self","label","setName","commandEncoder","readBuffer","data","WeakMemo","_make","key","args","value","createWithPerformanceCallback","currentPriors","callback","root","createWithTimestampWrites","options","timestampWrites","setupTimestampWrites","priors","querySet","beginningOfPassWriteIndex","endOfPassWriteIndex","isQuerySet","triggerPerformanceCallback","$internal","result","start","end","INTERNAL_createComputePipeline","branch","slotBindings","entryFn","TgpuComputePipelineImpl","ComputePipelineCore","isComputePipeline","value","maybe","$internal","_TgpuComputePipelineImpl","_core","_priors","$getNameForward","ctx","getName","bindGroupLayout","bindGroup","callback","newPriors","createWithPerformanceCallback","options","createWithTimestampWrites","x","y","z","memo","passDescriptor","setupTimestampWrites","pass","missingBindGroups","layout","idx","MissingBindGroupsError","triggerPerformanceCallback","label","setName","_slotBindings","_entryFn","device","resolutionResult","resolveMeasure","PERF","resolveStart","resolve","code","usedBindGroupLayouts","catchall","module","l","start","compileMeasure","vertexLayout","schemaForCount","stepMode","TgpuVertexLayoutImpl","isVertexLayout","value","defaultAttribEntry","dataToContainedAttribs","layout","data","offset","customLocationMap","key","isDecorated","isLooseDecorated","customLocation","getCustomLocation","roundUp","customAlignmentOf","isWgslStruct","memberOffset","alignmentOf","attrib","sizeOf","isUnstruct","vertexFormats","format","kindToDefaultFormatMap","arraySchema","$internal","label","setName","isColorAttachment","value","connectAttachmentToShader","shaderOutputLayout","attachment","isData","result","key","matching","isColorTargetState","value","connectTargetsToShader","shaderOutputLayout","targets","isData","isVoid","result","key","matchingTarget","INTERNAL_createRenderPipeline","options","TgpuRenderPipelineImpl","RenderPipelineCore","isRenderPipeline","value","maybe","$internal","_TgpuRenderPipelineImpl","$getNameForward","core","priors","ctx","getName","label","setName","definition","resource","internals","isBindGroupLayout","isVertexLayout","callback","newPriors","createWithPerformanceCallback","createWithTimestampWrites","attachment","buffer","indexFormatOrOffset","offsetElementsOrSizeBytes","sizeElementsOrUndefined","isGPUBuffer","dataTypeToIndexFormat","elementType","PUBLIC_sizeOf","memo","branch","fragmentFn","colorAttachments","connectAttachmentToShader","isTexture","renderPassDescriptor","setupTimestampWrites","pass","missingBindGroups","layout","idx","bindGroup","missingVertexLayouts","vertexLayout","MissingBindGroupsError","MissingVertexBuffersError","vertexCount","instanceCount","firstVertex","firstInstance","triggerPerformanceCallback","indexCount","firstIndex","baseVertex","indexFormat","offsetBytes","sizeBytes","connectedAttribs","connectAttributesToShader","connectTargetsToShader","vertexFn","slotBindings","locations","matchUpVaryingLocations","primitiveState","depthStencilState","multisampleState","device","resolutionResult","resolveMeasure","PERF","resolveStart","resolve","code","usedBindGroupLayouts","catchall","module","descriptor","l","isWgslData","start","compileMeasure","vertexOut","fragmentIn","vertexFnName","fragmentFnName","usedLocations","saveLocation","key","location","customLocation","getCustomLocation","nextLocation","isBuiltin","isBufferShorthand","value","TgpuBufferShorthandImpl","resourceType","buffer","$getNameForward","#usage","$internal","label","setName","data","ctx","ConfigurableImpl","_ConfigurableImpl","bindings","slot","value","isAccessor","transform","newCfg","WithBindingImpl","_WithBindingImpl","_getRoot","_slotBindings","entryFn","WithComputeImpl","vertexFn","attribs","WithVertexImpl","_root","_entryFn","INTERNAL_createComputePipeline","_options","fragmentFn","targets","_mismatch","invariant","WithFragmentImpl","_WithFragmentImpl","primitiveState","depthStencilState","multisampleState","INTERNAL_createRenderPipeline","TgpuRootImpl","device","nameRegistry","_ownDevice","WeakMemo","key","typeSchema","initialOrBuffer","buffer","INTERNAL_createBuffer","TgpuBufferShorthandImpl","type","count","rawQuerySet","INTERNAL_createQuerySet","layout","entries","TgpuBindGroupImpl","disposable","props","texture","INTERNAL_createTexture","resource","isComputePipeline","$internal","isRenderPipeline","isBindGroupLayout","isBindGroup","isBuffer","isTexture","isStorageTextureView","isSampledTextureView","isVertexLayout","isSampler","isComparisonSampler","isQuerySet","descriptor","callback","pass","bindGroups","vertexBuffers","currentPipeline","setupPassBeforeDraw","core","priors","memo","missingBindGroups","idx","bindGroup","missingVertexLayouts","vertexLayout","priorBuffer","opts","MissingBindGroupsError","MissingVertexBuffersError","args","pipeline","indexFormat","offset","size","bindGroupLayout","vertexCount","instanceCount","firstVertex","firstInstance","init","options","adapterOpt","deviceOpt","names","adapter","availableFeatures","feature","RandomNameRegistry","StrictNameRegistry","initFromDevice","slot","defaultValue","TgpuSlotImpl","$internal","label","setName","a","b","getName","$gpuValueOf","ctx","getGpuValueRecursively","getResolutionCtx","accessor","schema","defaultValue","TgpuAccessorImpl","slot","$getNameForward","$internal","label","getName","$gpuValueOf","ctx","$wgslDataType","valueProxyHandler","inGPUMode","value","isBufferUsage","isBufferShorthand","isTgpuFn","derived","compute","createDerived","stringifyPair","slot","value","getName","getResolutionCtx","$repr","$gpuRepr","$gpuValueOf","ctx","getGpuValueRecursively","createBoundDerived","innerDerived","pairs","$providing","privateVar","dataType","initialValue","TgpuVarImpl","workgroupVar","TgpuVarImpl","scope","_dataType","_initialValue","$internal","ctx","id","getName","label","setName","$gpuValueOf","$wgslDataType","valueProxyHandler","inGPUMode","tgpu","fn","bindGroupLayout","vertexLayout","slot","init","initFromDevice","resolve","resolveWithContext","fragmentFn","vertexFn","computeFn","derived","accessor","privateVar","workgroupVar","constant","declare","sampler","comparisonSampler","index_default"]}